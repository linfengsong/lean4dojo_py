<TracedFile path="src/lean/Init/Data/List/Erase.lean" md5="207e66d49d1cead5878b63d61f708401">
  <FileNode start="(1, 1)" end="(656, 9)">
    <ModuleHeaderNode start="(7, 1)" end="(11, 27)">
      <NullNode start="(7, 1)" end="(7, 7)">
        <OtherNode start="(7, 1)" end="(7, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(7, 1)" end="(7, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(9, 8)">
        <ModulePreludeNode start="(9, 1)" end="(9, 8)">
          <AtomNode start="(9, 1)" end="(9, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(10, 1)" end="(11, 27)">
        <ModuleImportNode start="(10, 1)" end="(10, 31)" module="Init.Data.List.Pairwise" path="src/lean/Init/Data/List/Pairwise.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 31)" leading="" trailing="&#10;" raw_val="Init.Data.List.Pairwise" val="Init.Data.List.Pairwise"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 27)" module="Init.Data.List.Find" path="src/lean/Init/Data/List/Find.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 27)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Find" val="Init.Data.List.Find"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(13, 1)" end="(15, 3)" comment="# Lemmas about `List.eraseP`, `List.erase`, and `List.eraseIdx`.&#10;-/">
      <AtomNode start="(13, 1)" end="(13, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(14, 1)" end="(15, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `List.eraseP`, `List.erase`, and `List.eraseIdx`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(17, 1)" end="(17, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(17, 33)" end="(17, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(18, 1)" end="(18, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(18, 1)" end="(18, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(18, 12)" end="(18, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(18, 34)" end="(18, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(20, 1)" end="(20, 15)" name="List">
      <AtomNode start="(20, 1)" end="(20, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(20, 11)" end="(20, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(22, 1)" end="(22, 9)">
      <AtomNode start="(22, 1)" end="(22, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(22, 6)" end="(22, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(22, 6)" end="(22, 9)">
          <IdentNode start="(22, 6)" end="(22, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(24, 1)" end="(24, 18)" comment="### eraseP -/">
      <AtomNode start="(24, 1)" end="(24, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(24, 5)" end="(24, 18)" leading="" trailing="&#10;&#10;" val="### eraseP -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(26, 1)" end="(26, 53)" name="eraseP_nil" full_name="List.eraseP_nil">
      <CommandDeclmodifiersNode start="(26, 1)" end="(26, 8)">
        <NullNode/>
        <NullNode start="(26, 1)" end="(26, 8)">
          <OtherNode start="(26, 1)" end="(26, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(26, 1)" end="(26, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(26, 3)" end="(26, 7)">
              <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(26, 3)" end="(26, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(26, 3)" end="(26, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(26, 7)" end="(26, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(26, 9)" end="(26, 53)" name="eraseP_nil" full_name="List.eraseP_nil" _is_private_decl="False">
        <AtomNode start="(26, 9)" end="(26, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(26, 17)" end="(26, 27)">
          <IdentNode start="(26, 17)" end="(26, 27)" leading="" trailing=" " raw_val="eraseP_nil" val="eraseP_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(26, 28)" end="(26, 46)">
          <NullNode/>
          <TermTypespecNode start="(26, 28)" end="(26, 46)">
            <AtomNode start="(26, 28)" end="(26, 29)" leading="" trailing=" " val=":"/>
            <OtherNode start="(26, 30)" end="(26, 46)" kind="«term_=_»">
              <OtherNode start="(26, 30)" end="(26, 41)" kind="Lean.Parser.Term.app">
                <OtherNode start="(26, 30)" end="(26, 39)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(26, 30)" end="(26, 32)" kind="«term[_]»">
                    <AtomNode start="(26, 30)" end="(26, 31)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(26, 31)" end="(26, 32)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(26, 32)" end="(26, 33)" leading="" trailing="" val="."/>
                  <IdentNode start="(26, 33)" end="(26, 39)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(26, 40)" end="(26, 41)">
                  <IdentNode start="(26, 40)" end="(26, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(26, 42)" end="(26, 43)" leading="" trailing=" " val="="/>
              <OtherNode start="(26, 44)" end="(26, 46)" kind="«term[_]»">
                <AtomNode start="(26, 44)" end="(26, 45)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(26, 45)" end="(26, 46)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(26, 47)" end="(26, 53)">
          <AtomNode start="(26, 47)" end="(26, 49)" leading="" trailing=" " val=":="/>
          <IdentNode start="(26, 50)" end="(26, 53)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(28, 1)" end="(29, 67)" name="eraseP_cons" full_name="List.eraseP_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(28, 1)" end="(29, 67)" name="eraseP_cons" full_name="List.eraseP_cons" _is_private_decl="False">
        <AtomNode start="(28, 1)" end="(28, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(28, 9)" end="(28, 20)">
          <IdentNode start="(28, 9)" end="(28, 20)" leading="" trailing=" " raw_val="eraseP_cons" val="eraseP_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(28, 21)" end="(29, 60)">
          <NullNode start="(28, 21)" end="(28, 41)">
            <OtherNode start="(28, 21)" end="(28, 28)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(28, 21)" end="(28, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(28, 22)" end="(28, 23)">
                <IdentNode start="(28, 22)" end="(28, 23)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(28, 24)" end="(28, 27)">
                <AtomNode start="(28, 24)" end="(28, 25)" leading="" trailing=" " val=":"/>
                <IdentNode start="(28, 26)" end="(28, 27)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(28, 27)" end="(28, 28)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(28, 29)" end="(28, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(28, 29)" end="(28, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(28, 30)" end="(28, 31)">
                <IdentNode start="(28, 30)" end="(28, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(28, 32)" end="(28, 40)">
                <AtomNode start="(28, 32)" end="(28, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(28, 34)" end="(28, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(28, 34)" end="(28, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(28, 39)" end="(28, 40)">
                    <IdentNode start="(28, 39)" end="(28, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(28, 40)" end="(28, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(28, 42)" end="(29, 60)">
            <AtomNode start="(28, 42)" end="(28, 43)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(29, 5)" end="(29, 60)" kind="«term_=_»">
              <OtherNode start="(29, 5)" end="(29, 22)" kind="Lean.Parser.Term.app">
                <OtherNode start="(29, 5)" end="(29, 20)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(29, 5)" end="(29, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(29, 5)" end="(29, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(29, 6)" end="(29, 12)" kind="«term_::_»">
                      <IdentNode start="(29, 6)" end="(29, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(29, 8)" end="(29, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(29, 11)" end="(29, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(29, 12)" end="(29, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(29, 13)" end="(29, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(29, 14)" end="(29, 20)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(29, 21)" end="(29, 22)">
                  <IdentNode start="(29, 21)" end="(29, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(29, 23)" end="(29, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(29, 25)" end="(29, 60)" kind="boolIfThenElse">
                <AtomNode start="(29, 25)" end="(29, 28)" leading="" trailing=" " val="bif"/>
                <OtherNode start="(29, 29)" end="(29, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(29, 29)" end="(29, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(29, 31)" end="(29, 32)">
                    <IdentNode start="(29, 31)" end="(29, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(29, 33)" end="(29, 37)" leading="" trailing=" " val="then"/>
                <IdentNode start="(29, 38)" end="(29, 39)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(29, 40)" end="(29, 44)" leading="" trailing=" " val="else"/>
                <OtherNode start="(29, 45)" end="(29, 60)" kind="«term_::_»">
                  <IdentNode start="(29, 45)" end="(29, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(29, 47)" end="(29, 49)" leading="" trailing=" " val="::"/>
                  <OtherNode start="(29, 50)" end="(29, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(29, 50)" end="(29, 58)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                    <NullNode start="(29, 59)" end="(29, 60)">
                      <IdentNode start="(29, 59)" end="(29, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(29, 61)" end="(29, 67)">
          <AtomNode start="(29, 61)" end="(29, 63)" leading="" trailing=" " val=":="/>
          <IdentNode start="(29, 64)" end="(29, 67)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(31, 1)" end="(32, 24)" name="eraseP_cons_of_pos" full_name="List.eraseP_cons_of_pos">
      <CommandDeclmodifiersNode start="(31, 1)" end="(31, 8)">
        <NullNode/>
        <NullNode start="(31, 1)" end="(31, 8)">
          <OtherNode start="(31, 1)" end="(31, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(31, 1)" end="(31, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(31, 3)" end="(31, 7)">
              <OtherNode start="(31, 3)" end="(31, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(31, 3)" end="(31, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(31, 3)" end="(31, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(31, 7)" end="(31, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(31, 9)" end="(32, 24)" name="eraseP_cons_of_pos" full_name="List.eraseP_cons_of_pos" _is_private_decl="False">
        <AtomNode start="(31, 9)" end="(31, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(31, 17)" end="(31, 35)">
          <IdentNode start="(31, 17)" end="(31, 35)" leading="" trailing=" " raw_val="eraseP_cons_of_pos" val="eraseP_cons_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(31, 36)" end="(31, 86)">
          <NullNode start="(31, 36)" end="(31, 62)">
            <OtherNode start="(31, 36)" end="(31, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(31, 36)" end="(31, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(31, 37)" end="(31, 38)">
                <IdentNode start="(31, 37)" end="(31, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(31, 39)" end="(31, 47)">
                <AtomNode start="(31, 39)" end="(31, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(31, 41)" end="(31, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(31, 41)" end="(31, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(31, 46)" end="(31, 47)">
                    <IdentNode start="(31, 46)" end="(31, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(31, 47)" end="(31, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(31, 49)" end="(31, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(31, 49)" end="(31, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(31, 50)" end="(31, 51)">
                <IdentNode start="(31, 50)" end="(31, 51)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(31, 51)" end="(31, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(31, 53)" end="(31, 62)">
              <AtomNode start="(31, 53)" end="(31, 54)" leading="" trailing="" val="("/>
              <NullNode start="(31, 54)" end="(31, 55)">
                <IdentNode start="(31, 54)" end="(31, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(31, 56)" end="(31, 61)">
                <AtomNode start="(31, 56)" end="(31, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(31, 58)" end="(31, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(31, 58)" end="(31, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(31, 60)" end="(31, 61)">
                    <IdentNode start="(31, 60)" end="(31, 61)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(31, 61)" end="(31, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(31, 63)" end="(31, 86)">
            <AtomNode start="(31, 63)" end="(31, 64)" leading="" trailing=" " val=":"/>
            <OtherNode start="(31, 65)" end="(31, 86)" kind="«term_=_»">
              <OtherNode start="(31, 65)" end="(31, 82)" kind="Lean.Parser.Term.app">
                <OtherNode start="(31, 65)" end="(31, 80)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(31, 65)" end="(31, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(31, 65)" end="(31, 66)" leading="" trailing="" val="("/>
                    <OtherNode start="(31, 66)" end="(31, 72)" kind="«term_::_»">
                      <IdentNode start="(31, 66)" end="(31, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(31, 68)" end="(31, 70)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(31, 71)" end="(31, 72)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(31, 72)" end="(31, 73)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(31, 73)" end="(31, 74)" leading="" trailing="" val="."/>
                  <IdentNode start="(31, 74)" end="(31, 80)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(31, 81)" end="(31, 82)">
                  <IdentNode start="(31, 81)" end="(31, 82)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(31, 83)" end="(31, 84)" leading="" trailing=" " val="="/>
              <IdentNode start="(31, 85)" end="(31, 86)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(31, 87)" end="(32, 24)">
          <AtomNode start="(31, 87)" end="(31, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(31, 90)" end="(32, 24)">
            <AtomNode start="(31, 90)" end="(31, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(32, 3)" end="(32, 24)">
              <TacticTacticseq1IndentedNode start="(32, 3)" end="(32, 24)">
                <NullNode start="(32, 3)" end="(32, 24)">
                  <OtherNode start="(32, 3)" end="(32, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;p : α → Bool&#10;h : p a = true&#10;⊢ eraseP p (a :: l) = l" state_after="no goals" tactic="simp [eraseP_cons, h]">
                    <AtomNode start="(32, 3)" end="(32, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(32, 8)" end="(32, 24)">
                      <AtomNode start="(32, 8)" end="(32, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(32, 9)" end="(32, 23)">
                        <OtherNode start="(32, 9)" end="(32, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(32, 9)" end="(32, 20)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                        </OtherNode>
                        <AtomNode start="(32, 20)" end="(32, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(32, 22)" end="(32, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(32, 22)" end="(32, 23)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(32, 23)" end="(32, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(34, 1)" end="(35, 68)" name="eraseP_cons_of_neg" full_name="List.eraseP_cons_of_neg">
      <CommandDeclmodifiersNode start="(34, 1)" end="(34, 8)">
        <NullNode/>
        <NullNode start="(34, 1)" end="(34, 8)">
          <OtherNode start="(34, 1)" end="(34, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(34, 1)" end="(34, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(34, 3)" end="(34, 7)">
              <OtherNode start="(34, 3)" end="(34, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(34, 3)" end="(34, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(34, 3)" end="(34, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(34, 7)" end="(34, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(34, 9)" end="(35, 68)" name="eraseP_cons_of_neg" full_name="List.eraseP_cons_of_neg" _is_private_decl="False">
        <AtomNode start="(34, 9)" end="(34, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(34, 17)" end="(34, 35)">
          <IdentNode start="(34, 17)" end="(34, 35)" leading="" trailing=" " raw_val="eraseP_cons_of_neg" val="eraseP_cons_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 36)" end="(35, 40)">
          <NullNode start="(34, 36)" end="(34, 63)">
            <OtherNode start="(34, 36)" end="(34, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 36)" end="(34, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 37)" end="(34, 38)">
                <IdentNode start="(34, 37)" end="(34, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(34, 39)" end="(34, 47)">
                <AtomNode start="(34, 39)" end="(34, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 41)" end="(34, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(34, 41)" end="(34, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(34, 46)" end="(34, 47)">
                    <IdentNode start="(34, 46)" end="(34, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(34, 47)" end="(34, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(34, 49)" end="(34, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 49)" end="(34, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 50)" end="(34, 51)">
                <IdentNode start="(34, 50)" end="(34, 51)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(34, 51)" end="(34, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(34, 53)" end="(34, 63)">
              <AtomNode start="(34, 53)" end="(34, 54)" leading="" trailing="" val="("/>
              <NullNode start="(34, 54)" end="(34, 55)">
                <IdentNode start="(34, 54)" end="(34, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(34, 56)" end="(34, 62)">
                <AtomNode start="(34, 56)" end="(34, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 58)" end="(34, 62)" kind="«term¬_»">
                  <AtomNode start="(34, 58)" end="(34, 59)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(34, 59)" end="(34, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(34, 59)" end="(34, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(34, 61)" end="(34, 62)">
                      <IdentNode start="(34, 61)" end="(34, 62)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(34, 62)" end="(34, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(34, 64)" end="(35, 40)">
            <AtomNode start="(34, 64)" end="(34, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(35, 5)" end="(35, 40)" kind="«term_=_»">
              <OtherNode start="(35, 5)" end="(35, 22)" kind="Lean.Parser.Term.app">
                <OtherNode start="(35, 5)" end="(35, 20)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(35, 5)" end="(35, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(35, 5)" end="(35, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(35, 6)" end="(35, 12)" kind="«term_::_»">
                      <IdentNode start="(35, 6)" end="(35, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(35, 8)" end="(35, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(35, 11)" end="(35, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(35, 12)" end="(35, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(35, 13)" end="(35, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(35, 14)" end="(35, 20)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(35, 21)" end="(35, 22)">
                  <IdentNode start="(35, 21)" end="(35, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(35, 23)" end="(35, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(35, 25)" end="(35, 40)" kind="«term_::_»">
                <IdentNode start="(35, 25)" end="(35, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(35, 27)" end="(35, 29)" leading="" trailing=" " val="::"/>
                <OtherNode start="(35, 30)" end="(35, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(35, 30)" end="(35, 38)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(35, 39)" end="(35, 40)">
                    <IdentNode start="(35, 39)" end="(35, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(35, 41)" end="(35, 68)">
          <AtomNode start="(35, 41)" end="(35, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(35, 44)" end="(35, 68)">
            <AtomNode start="(35, 44)" end="(35, 46)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(35, 47)" end="(35, 68)">
              <TacticTacticseq1IndentedNode start="(35, 47)" end="(35, 68)">
                <NullNode start="(35, 47)" end="(35, 68)">
                  <OtherNode start="(35, 47)" end="(35, 68)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;p : α → Bool&#10;h : ¬p a = true&#10;⊢ eraseP p (a :: l) = a :: eraseP p l" state_after="no goals" tactic="simp [eraseP_cons, h]">
                    <AtomNode start="(35, 47)" end="(35, 51)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(35, 52)" end="(35, 68)">
                      <AtomNode start="(35, 52)" end="(35, 53)" leading="" trailing="" val="["/>
                      <NullNode start="(35, 53)" end="(35, 67)">
                        <OtherNode start="(35, 53)" end="(35, 64)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(35, 53)" end="(35, 64)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                        </OtherNode>
                        <AtomNode start="(35, 64)" end="(35, 65)" leading="" trailing=" " val=","/>
                        <OtherNode start="(35, 66)" end="(35, 67)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(35, 66)" end="(35, 67)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(35, 67)" end="(35, 68)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(37, 1)" end="(40, 69)" name="eraseP_of_forall_not" full_name="List.eraseP_of_forall_not">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(37, 1)" end="(40, 69)" name="eraseP_of_forall_not" full_name="List.eraseP_of_forall_not" _is_private_decl="False">
        <AtomNode start="(37, 1)" end="(37, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(37, 9)" end="(37, 29)">
          <IdentNode start="(37, 9)" end="(37, 29)" leading="" trailing=" " raw_val="eraseP_of_forall_not" val="eraseP_of_forall_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(37, 30)" end="(37, 83)">
          <NullNode start="(37, 30)" end="(37, 66)">
            <OtherNode start="(37, 30)" end="(37, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(37, 30)" end="(37, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(37, 31)" end="(37, 32)">
                <IdentNode start="(37, 31)" end="(37, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(37, 33)" end="(37, 41)">
                <AtomNode start="(37, 33)" end="(37, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 35)" end="(37, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(37, 35)" end="(37, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(37, 40)" end="(37, 41)">
                    <IdentNode start="(37, 40)" end="(37, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(37, 41)" end="(37, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(37, 43)" end="(37, 66)">
              <AtomNode start="(37, 43)" end="(37, 44)" leading="" trailing="" val="("/>
              <NullNode start="(37, 44)" end="(37, 45)">
                <IdentNode start="(37, 44)" end="(37, 45)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(37, 46)" end="(37, 65)">
                <AtomNode start="(37, 46)" end="(37, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 48)" end="(37, 65)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(37, 48)" end="(37, 49)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(37, 50)" end="(37, 51)">
                    <IdentNode start="(37, 50)" end="(37, 51)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(37, 51)" end="(37, 52)" leading="" trailing=" " val=","/>
                  <OtherNode start="(37, 53)" end="(37, 65)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(37, 53)" end="(37, 58)" kind="«term_∈_»">
                      <IdentNode start="(37, 53)" end="(37, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(37, 55)" end="(37, 56)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(37, 57)" end="(37, 58)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(37, 59)" end="(37, 60)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(37, 61)" end="(37, 65)" kind="«term¬_»">
                      <AtomNode start="(37, 61)" end="(37, 62)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(37, 62)" end="(37, 65)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(37, 62)" end="(37, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(37, 64)" end="(37, 65)">
                          <IdentNode start="(37, 64)" end="(37, 65)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(37, 65)" end="(37, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(37, 67)" end="(37, 83)">
            <AtomNode start="(37, 67)" end="(37, 68)" leading="" trailing=" " val=":"/>
            <OtherNode start="(37, 69)" end="(37, 83)" kind="«term_=_»">
              <OtherNode start="(37, 69)" end="(37, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(37, 69)" end="(37, 77)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                <NullNode start="(37, 78)" end="(37, 79)">
                  <IdentNode start="(37, 78)" end="(37, 79)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(37, 80)" end="(37, 81)" leading="" trailing=" " val="="/>
              <IdentNode start="(37, 82)" end="(37, 83)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(37, 84)" end="(40, 69)">
          <AtomNode start="(37, 84)" end="(37, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(37, 87)" end="(40, 69)">
            <AtomNode start="(37, 87)" end="(37, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(38, 3)" end="(40, 69)">
              <TacticTacticseq1IndentedNode start="(38, 3)" end="(40, 69)">
                <NullNode start="(38, 3)" end="(40, 69)">
                  <OtherNode start="(38, 3)" end="(40, 69)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∀ (a : α), a ∈ l → ¬p a = true&#10;⊢ eraseP p l = l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; rfl&#10;| cons _ _ ih =&amp;gt; simp [h _ (.head ..), ih (forall_mem_cons.1 h).2]">
                    <AtomNode start="(38, 3)" end="(38, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(38, 13)" end="(38, 14)">
                      <OtherNode start="(38, 13)" end="(38, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(38, 13)" end="(38, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(38, 15)" end="(40, 69)">
                      <OtherNode start="(38, 15)" end="(40, 69)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(38, 15)" end="(38, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(39, 3)" end="(40, 69)">
                          <OtherNode start="(39, 3)" end="(39, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(39, 3)" end="(39, 8)">
                              <OtherNode start="(39, 3)" end="(39, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(39, 3)" end="(39, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(39, 5)" end="(39, 8)">
                                  <NullNode/>
                                  <IdentNode start="(39, 5)" end="(39, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(39, 9)" end="(39, 15)">
                              <AtomNode start="(39, 9)" end="(39, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(39, 12)" end="(39, 15)">
                                <TacticTacticseq1IndentedNode start="(39, 12)" end="(39, 15)">
                                  <NullNode start="(39, 12)" end="(39, 15)">
                                    <OtherNode start="(39, 12)" end="(39, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;h : ∀ (a : α), a ∈ [] → ¬p a = true&#10;⊢ eraseP p [] = []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(39, 12)" end="(39, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(40, 3)" end="(40, 69)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(40, 3)" end="(40, 16)">
                              <OtherNode start="(40, 3)" end="(40, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(40, 3)" end="(40, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(40, 5)" end="(40, 9)">
                                  <NullNode/>
                                  <IdentNode start="(40, 5)" end="(40, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(40, 10)" end="(40, 16)">
                                  <TermHoleNode start="(40, 10)" end="(40, 11)">
                                    <AtomNode start="(40, 10)" end="(40, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(40, 12)" end="(40, 13)">
                                    <AtomNode start="(40, 12)" end="(40, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(40, 14)" end="(40, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(40, 17)" end="(40, 69)">
                              <AtomNode start="(40, 17)" end="(40, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(40, 20)" end="(40, 69)">
                                <TacticTacticseq1IndentedNode start="(40, 20)" end="(40, 69)">
                                  <NullNode start="(40, 20)" end="(40, 69)">
                                    <OtherNode start="(40, 20)" end="(40, 69)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;ih : (∀ (a : α), a ∈ tail✝ → ¬p a = true) → eraseP p tail✝ = tail✝&#10;h : ∀ (a : α), a ∈ head✝ :: tail✝ → ¬p a = true&#10;⊢ eraseP p (head✝ :: tail✝) = head✝ :: tail✝" state_after="no goals" tactic="simp [h _ (.head ..), ih (forall_mem_cons.1 h).2]">
                                      <AtomNode start="(40, 20)" end="(40, 24)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(40, 25)" end="(40, 69)">
                                        <AtomNode start="(40, 25)" end="(40, 26)" leading="" trailing="" val="["/>
                                        <NullNode start="(40, 26)" end="(40, 68)">
                                          <OtherNode start="(40, 26)" end="(40, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(40, 26)" end="(40, 40)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(40, 26)" end="(40, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                                              <NullNode start="(40, 28)" end="(40, 40)">
                                                <TermHoleNode start="(40, 28)" end="(40, 29)">
                                                  <AtomNode start="(40, 28)" end="(40, 29)" leading="" trailing=" " val="_"/>
                                                </TermHoleNode>
                                                <OtherNode start="(40, 30)" end="(40, 40)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(40, 30)" end="(40, 31)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(40, 31)" end="(40, 39)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(40, 31)" end="(40, 36)" kind="Lean.Parser.Term.dotIdent">
                                                      <AtomNode start="(40, 31)" end="(40, 32)" leading="" trailing="" val="."/>
                                                      <IdentNode start="(40, 32)" end="(40, 36)" leading="" trailing=" " raw_val="head" val="head"/>
                                                    </OtherNode>
                                                    <NullNode start="(40, 37)" end="(40, 39)">
                                                      <OtherNode start="(40, 37)" end="(40, 39)" kind="Lean.Parser.Term.ellipsis">
                                                        <AtomNode start="(40, 37)" end="(40, 39)" leading="" trailing="" val=".."/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(40, 39)" end="(40, 40)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(40, 40)" end="(40, 41)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(40, 42)" end="(40, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(40, 42)" end="(40, 68)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(40, 42)" end="(40, 44)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                              <NullNode start="(40, 45)" end="(40, 68)">
                                                <OtherNode start="(40, 45)" end="(40, 68)" kind="Lean.Parser.Term.proj">
                                                  <OtherNode start="(40, 45)" end="(40, 66)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(40, 45)" end="(40, 46)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(40, 46)" end="(40, 65)" kind="Lean.Parser.Term.app">
                                                      <OtherNode start="(40, 46)" end="(40, 63)" kind="Lean.Parser.Term.proj">
                                                        <IdentNode start="(40, 46)" end="(40, 61)" leading="" trailing="" raw_val="forall_mem_cons" val="forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                        <AtomNode start="(40, 61)" end="(40, 62)" leading="" trailing="" val="."/>
                                                        <OtherNode start="(40, 62)" end="(40, 63)" kind="fieldIdx">
                                                          <AtomNode start="(40, 62)" end="(40, 63)" leading="" trailing=" " val="1"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode start="(40, 64)" end="(40, 65)">
                                                        <IdentNode start="(40, 64)" end="(40, 65)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(40, 65)" end="(40, 66)" leading="" trailing="" val=")"/>
                                                  </OtherNode>
                                                  <AtomNode start="(40, 66)" end="(40, 67)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(40, 67)" end="(40, 68)" kind="fieldIdx">
                                                    <AtomNode start="(40, 67)" end="(40, 68)" leading="" trailing="" val="2"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(40, 68)" end="(40, 69)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(42, 1)" end="(56, 15)" name="eraseP_eq_nil_iff" full_name="List.eraseP_eq_nil_iff">
      <CommandDeclmodifiersNode start="(42, 1)" end="(42, 8)">
        <NullNode/>
        <NullNode start="(42, 1)" end="(42, 8)">
          <OtherNode start="(42, 1)" end="(42, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(42, 1)" end="(42, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(42, 3)" end="(42, 7)">
              <OtherNode start="(42, 3)" end="(42, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(42, 3)" end="(42, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(42, 3)" end="(42, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(42, 7)" end="(42, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(42, 9)" end="(56, 15)" name="eraseP_eq_nil_iff" full_name="List.eraseP_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(42, 9)" end="(42, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(42, 17)" end="(42, 34)">
          <IdentNode start="(42, 17)" end="(42, 34)" leading="" trailing=" " raw_val="eraseP_eq_nil_iff" val="eraseP_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(42, 35)" end="(42, 114)">
          <NullNode start="(42, 35)" end="(42, 63)">
            <OtherNode start="(42, 35)" end="(42, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(42, 35)" end="(42, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(42, 36)" end="(42, 38)">
                <IdentNode start="(42, 36)" end="(42, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(42, 39)" end="(42, 47)">
                <AtomNode start="(42, 39)" end="(42, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 41)" end="(42, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(42, 41)" end="(42, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(42, 46)" end="(42, 47)">
                    <IdentNode start="(42, 46)" end="(42, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(42, 47)" end="(42, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(42, 49)" end="(42, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(42, 49)" end="(42, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(42, 50)" end="(42, 51)">
                <IdentNode start="(42, 50)" end="(42, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(42, 52)" end="(42, 62)">
                <AtomNode start="(42, 52)" end="(42, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(42, 54)" end="(42, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(42, 54)" end="(42, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(42, 56)" end="(42, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(42, 58)" end="(42, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(42, 62)" end="(42, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(42, 64)" end="(42, 114)">
            <AtomNode start="(42, 64)" end="(42, 65)" leading="" trailing=" " val=":"/>
            <OtherNode start="(42, 66)" end="(42, 114)" kind="«term_↔_»">
              <OtherNode start="(42, 66)" end="(42, 82)" kind="«term_=_»">
                <OtherNode start="(42, 66)" end="(42, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(42, 66)" end="(42, 75)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(42, 76)" end="(42, 77)">
                    <IdentNode start="(42, 76)" end="(42, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(42, 78)" end="(42, 79)" leading="" trailing=" " val="="/>
                <OtherNode start="(42, 80)" end="(42, 82)" kind="«term[_]»">
                  <AtomNode start="(42, 80)" end="(42, 81)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(42, 81)" end="(42, 82)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(42, 83)" end="(42, 84)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(42, 85)" end="(42, 114)" kind="«term_∨_»">
                <OtherNode start="(42, 85)" end="(42, 92)" kind="«term_=_»">
                  <IdentNode start="(42, 85)" end="(42, 87)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(42, 88)" end="(42, 89)" leading="" trailing=" " val="="/>
                  <OtherNode start="(42, 90)" end="(42, 92)" kind="«term[_]»">
                    <AtomNode start="(42, 90)" end="(42, 91)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(42, 91)" end="(42, 92)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(42, 93)" end="(42, 94)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(42, 95)" end="(42, 114)" kind="«term∃_,_»">
                  <AtomNode start="(42, 95)" end="(42, 96)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(42, 97)" end="(42, 98)" kind="Lean.explicitBinders">
                    <OtherNode start="(42, 97)" end="(42, 98)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(42, 97)" end="(42, 98)">
                        <LeanBinderidentNode start="(42, 97)" end="(42, 98)">
                          <IdentNode start="(42, 97)" end="(42, 98)" leading="" trailing="" raw_val="x" val="x"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(42, 98)" end="(42, 99)" leading="" trailing=" " val=","/>
                  <OtherNode start="(42, 100)" end="(42, 114)" kind="«term_∧_»">
                    <OtherNode start="(42, 100)" end="(42, 103)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(42, 100)" end="(42, 101)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(42, 102)" end="(42, 103)">
                        <IdentNode start="(42, 102)" end="(42, 103)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(42, 104)" end="(42, 105)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(42, 106)" end="(42, 114)" kind="«term_=_»">
                      <IdentNode start="(42, 106)" end="(42, 108)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(42, 109)" end="(42, 110)" leading="" trailing=" " val="="/>
                      <OtherNode start="(42, 111)" end="(42, 114)" kind="«term[_]»">
                        <AtomNode start="(42, 111)" end="(42, 112)" leading="" trailing="" val="["/>
                        <NullNode start="(42, 112)" end="(42, 113)">
                          <IdentNode start="(42, 112)" end="(42, 113)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                        <AtomNode start="(42, 113)" end="(42, 114)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(42, 115)" end="(56, 15)">
          <AtomNode start="(42, 115)" end="(42, 117)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(42, 118)" end="(56, 15)">
            <AtomNode start="(42, 118)" end="(42, 120)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(43, 3)" end="(56, 15)">
              <TacticTacticseq1IndentedNode start="(43, 3)" end="(56, 15)">
                <NullNode start="(43, 3)" end="(56, 15)">
                  <OtherNode start="(43, 3)" end="(56, 15)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [eraseP_cons, cond_eq_if]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · simp only [reduceCtorEq, cons.injEq, false_or]&#10;    constructor&#10;    · rintro rfl&#10;      simpa&#10;    · rintro ⟨_, _, rfl, rfl⟩&#10;      rfl&#10;  · simp only [reduceCtorEq, cons.injEq, false_or, false_iff, not_exists, not_and]&#10;    rintro x h' rfl&#10;    simp_all">
                    <AtomNode start="(43, 3)" end="(43, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(43, 13)" end="(43, 15)">
                      <OtherNode start="(43, 13)" end="(43, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(43, 13)" end="(43, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(43, 16)" end="(56, 15)">
                      <OtherNode start="(43, 16)" end="(56, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(43, 16)" end="(43, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(44, 3)" end="(56, 15)">
                          <OtherNode start="(44, 3)" end="(44, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(44, 3)" end="(44, 8)">
                              <OtherNode start="(44, 3)" end="(44, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(44, 3)" end="(44, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(44, 5)" end="(44, 8)">
                                  <NullNode/>
                                  <IdentNode start="(44, 5)" end="(44, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(44, 9)" end="(44, 16)">
                              <AtomNode start="(44, 9)" end="(44, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(44, 12)" end="(44, 16)">
                                <TacticTacticseq1IndentedNode start="(44, 12)" end="(44, 16)">
                                  <NullNode start="(44, 12)" end="(44, 16)">
                                    <OtherNode start="(44, 12)" end="(44, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ eraseP p [] = [] ↔ [] = [] ∨ ∃ x, p x = true ∧ [] = [x]" state_after="no goals" tactic="simp">
                                      <AtomNode start="(44, 12)" end="(44, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(45, 3)" end="(56, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(45, 3)" end="(45, 17)">
                              <OtherNode start="(45, 3)" end="(45, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(45, 3)" end="(45, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(45, 5)" end="(45, 9)">
                                  <NullNode/>
                                  <IdentNode start="(45, 5)" end="(45, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(45, 10)" end="(45, 17)">
                                  <IdentNode start="(45, 10)" end="(45, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(45, 12)" end="(45, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(45, 15)" end="(45, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(45, 18)" end="(56, 15)">
                              <AtomNode start="(45, 18)" end="(45, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(46, 5)" end="(56, 15)">
                                <TacticTacticseq1IndentedNode start="(46, 5)" end="(56, 15)">
                                  <NullNode start="(46, 5)" end="(56, 15)">
                                    <OtherNode start="(46, 5)" end="(46, 40)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;⊢ eraseP p (x :: xs) = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;⊢ (if p x = true then xs else x :: eraseP p xs) = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" tactic="simp only [eraseP_cons, cond_eq_if]">
                                      <AtomNode start="(46, 5)" end="(46, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(46, 10)" end="(46, 14)">
                                        <AtomNode start="(46, 10)" end="(46, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(46, 15)" end="(46, 40)">
                                        <AtomNode start="(46, 15)" end="(46, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(46, 16)" end="(46, 39)">
                                          <OtherNode start="(46, 16)" end="(46, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(46, 16)" end="(46, 27)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                          </OtherNode>
                                          <AtomNode start="(46, 27)" end="(46, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(46, 29)" end="(46, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(46, 29)" end="(46, 39)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(46, 39)" end="(46, 40)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(47, 5)" end="(47, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;⊢ (if p x = true then xs else x :: eraseP p xs) = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ x :: eraseP p xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                      <OtherNode start="(47, 5)" end="(47, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(47, 5)" end="(47, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(47, 11)" end="(47, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(47, 15)" end="(47, 25)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(47, 15)" end="(47, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(47, 24)" end="(47, 25)">
                                          <LeanBinderidentNode start="(47, 24)" end="(47, 25)">
                                            <IdentNode start="(47, 24)" end="(47, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(48, 5)" end="(53, 12)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ x :: eraseP p xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ x :: eraseP p xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" tactic="· simp only [reduceCtorEq, cons.injEq, false_or]&#10;  constructor&#10;  · rintro rfl&#10;    simpa&#10;  · rintro ⟨_, _, rfl, rfl⟩&#10;    rfl">
                                      <OtherNode start="(48, 5)" end="(48, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(48, 5)" end="(48, 6)" kind="patternIgnore">
                                          <OtherNode start="(48, 5)" end="(48, 6)" kind="token.«· »">
                                            <AtomNode start="(48, 5)" end="(48, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(48, 7)" end="(53, 12)">
                                        <TacticTacticseq1IndentedNode start="(48, 7)" end="(53, 12)">
                                          <NullNode start="(48, 7)" end="(53, 12)">
                                            <OtherNode start="(48, 7)" end="(48, 53)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] ↔ ∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []" tactic="simp only [reduceCtorEq, cons.injEq, false_or]">
                                              <AtomNode start="(48, 7)" end="(48, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(48, 12)" end="(48, 16)">
                                                <AtomNode start="(48, 12)" end="(48, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(48, 17)" end="(48, 53)">
                                                <AtomNode start="(48, 17)" end="(48, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(48, 18)" end="(48, 52)">
                                                  <OtherNode start="(48, 18)" end="(48, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 18)" end="(48, 30)" leading="" trailing="" raw_val="reduceCtorEq" val="reduceCtorEq"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 30)" end="(48, 31)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 32)" end="(48, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 32)" end="(48, 42)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(48, 42)" end="(48, 43)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(48, 44)" end="(48, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(48, 44)" end="(48, 52)" leading="" trailing="" raw_val="false_or" val="false_or" full_name="false_or" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(48, 52)" end="(48, 53)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(49, 7)" end="(49, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] ↔ ∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []" state_after="case cons.isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] → ∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []&#10;&#10;case cons.isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ (∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []) → xs = []" tactic="constructor">
                                              <AtomNode start="(49, 7)" end="(49, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(50, 7)" end="(51, 14)" kind="Lean.cdot" state_before="case cons.isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] → ∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []&#10;&#10;case cons.isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ (∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []) → xs = []" state_after="case cons.isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ (∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []) → xs = []" tactic="· rintro rfl&#10;  simpa">
                                              <OtherNode start="(50, 7)" end="(50, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(50, 7)" end="(50, 8)" kind="patternIgnore">
                                                  <OtherNode start="(50, 7)" end="(50, 8)" kind="token.«· »">
                                                    <AtomNode start="(50, 7)" end="(50, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(50, 9)" end="(51, 14)">
                                                <TacticTacticseq1IndentedNode start="(50, 9)" end="(51, 14)">
                                                  <NullNode start="(50, 9)" end="(51, 14)">
                                                    <OtherNode start="(50, 9)" end="(50, 19)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ xs = [] → ∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []" state_after="case cons.isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;h : p x = true&#10;ih : eraseP p [] = [] ↔ [] = [] ∨ ∃ x, p x = true ∧ [] = [x]&#10;⊢ ∃ x_1, p x_1 = true ∧ x = x_1 ∧ [] = []" tactic="rintro rfl">
                                                      <AtomNode start="(50, 9)" end="(50, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(50, 16)" end="(50, 19)">
                                                        <OtherNode start="(50, 16)" end="(50, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(50, 16)" end="(50, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(50, 16)" end="(50, 19)" leading="" trailing="&#10;        " raw_val="rfl" val="rfl"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(51, 9)" end="(51, 14)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;h : p x = true&#10;ih : eraseP p [] = [] ↔ [] = [] ∨ ∃ x, p x = true ∧ [] = [x]&#10;⊢ ∃ x_1, p x_1 = true ∧ x = x_1 ∧ [] = []" state_after="no goals" tactic="simpa">
                                                      <AtomNode start="(51, 9)" end="(51, 14)" leading="" trailing="&#10;      " val="simpa"/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(52, 7)" end="(53, 12)" kind="Lean.cdot" state_before="case cons.isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ (∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []) → xs = []" state_after="no goals" tactic="· rintro ⟨_, _, rfl, rfl⟩&#10;  rfl">
                                              <OtherNode start="(52, 7)" end="(52, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(52, 7)" end="(52, 8)" kind="patternIgnore">
                                                  <OtherNode start="(52, 7)" end="(52, 8)" kind="token.«· »">
                                                    <AtomNode start="(52, 7)" end="(52, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(52, 9)" end="(53, 12)">
                                                <TacticTacticseq1IndentedNode start="(52, 9)" end="(53, 12)">
                                                  <NullNode start="(52, 9)" end="(53, 12)">
                                                    <OtherNode start="(52, 9)" end="(52, 32)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : p x = true&#10;⊢ (∃ x_1, p x_1 = true ∧ x = x_1 ∧ xs = []) → xs = []" state_after="case cons.isTrue.mpr.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;h left✝ : p x = true&#10;ih : eraseP p [] = [] ↔ [] = [] ∨ ∃ x, p x = true ∧ [] = [x]&#10;⊢ [] = []" tactic="rintro ⟨_, _, rfl, rfl⟩">
                                                      <AtomNode start="(52, 9)" end="(52, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(52, 16)" end="(52, 32)">
                                                        <OtherNode start="(52, 16)" end="(52, 32)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(52, 16)" end="(52, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(52, 16)" end="(52, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(52, 17)" end="(52, 31)">
                                                            <OtherNode start="(52, 17)" end="(52, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(52, 17)" end="(52, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(52, 17)" end="(52, 18)">
                                                            <OtherNode start="(52, 17)" end="(52, 18)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(52, 17)" end="(52, 18)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(52, 18)" end="(52, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(52, 20)" end="(52, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(52, 20)" end="(52, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(52, 20)" end="(52, 21)">
                                                            <OtherNode start="(52, 20)" end="(52, 21)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                                            <AtomNode start="(52, 20)" end="(52, 21)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(52, 21)" end="(52, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(52, 23)" end="(52, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(52, 23)" end="(52, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(52, 23)" end="(52, 26)">
                                                            <OtherNode start="(52, 23)" end="(52, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(52, 23)" end="(52, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(52, 26)" end="(52, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(52, 28)" end="(52, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(52, 28)" end="(52, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(52, 28)" end="(52, 31)">
                                                            <OtherNode start="(52, 28)" end="(52, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(52, 28)" end="(52, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(52, 31)" end="(52, 32)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(53, 9)" end="(53, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.isTrue.mpr.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;h left✝ : p x = true&#10;ih : eraseP p [] = [] ↔ [] = [] ∨ ∃ x, p x = true ∧ [] = [x]&#10;⊢ [] = []" state_after="no goals" tactic="rfl">
                                                      <AtomNode start="(53, 9)" end="(53, 12)" leading="" trailing="&#10;    " val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(54, 5)" end="(56, 15)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ x :: eraseP p xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" state_after="no goals" tactic="· simp only [reduceCtorEq, cons.injEq, false_or, false_iff, not_exists, not_and]&#10;  rintro x h' rfl&#10;  simp_all">
                                      <OtherNode start="(54, 5)" end="(54, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(54, 5)" end="(54, 6)" kind="patternIgnore">
                                          <OtherNode start="(54, 5)" end="(54, 6)" kind="token.«· »">
                                            <AtomNode start="(54, 5)" end="(54, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(54, 7)" end="(56, 15)">
                                        <TacticTacticseq1IndentedNode start="(54, 7)" end="(56, 15)">
                                          <NullNode start="(54, 7)" end="(56, 15)">
                                            <OtherNode start="(54, 7)" end="(54, 85)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ x :: eraseP p xs = [] ↔ x :: xs = [] ∨ ∃ x_1, p x_1 = true ∧ x :: xs = [x_1]" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ ∀ (x_1 : α), p x_1 = true → x = x_1 → ¬xs = []" tactic="simp only [reduceCtorEq, cons.injEq, false_or, false_iff, not_exists, not_and]">
                                              <AtomNode start="(54, 7)" end="(54, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(54, 12)" end="(54, 16)">
                                                <AtomNode start="(54, 12)" end="(54, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(54, 17)" end="(54, 85)">
                                                <AtomNode start="(54, 17)" end="(54, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(54, 18)" end="(54, 84)">
                                                  <OtherNode start="(54, 18)" end="(54, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(54, 18)" end="(54, 30)" leading="" trailing="" raw_val="reduceCtorEq" val="reduceCtorEq"/>
                                                  </OtherNode>
                                                  <AtomNode start="(54, 30)" end="(54, 31)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(54, 32)" end="(54, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(54, 32)" end="(54, 42)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(54, 42)" end="(54, 43)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(54, 44)" end="(54, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(54, 44)" end="(54, 52)" leading="" trailing="" raw_val="false_or" val="false_or" full_name="false_or" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(54, 52)" end="(54, 53)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(54, 54)" end="(54, 63)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(54, 54)" end="(54, 63)" leading="" trailing="" raw_val="false_iff" val="false_iff" full_name="false_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(54, 63)" end="(54, 64)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(54, 65)" end="(54, 75)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(54, 65)" end="(54, 75)" leading="" trailing="" raw_val="not_exists" val="not_exists" full_name="not_exists" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(54, 75)" end="(54, 76)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(54, 77)" end="(54, 84)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(54, 77)" end="(54, 84)" leading="" trailing="" raw_val="not_and" val="not_and" full_name="not_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(54, 84)" end="(54, 85)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(55, 7)" end="(55, 22)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;⊢ ∀ (x_1 : α), p x_1 = true → x = x_1 → ¬xs = []" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;h' : p x = true&#10;⊢ ¬xs = []" tactic="rintro x h' rfl">
                                              <AtomNode start="(55, 7)" end="(55, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(55, 14)" end="(55, 22)">
                                                <OtherNode start="(55, 14)" end="(55, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(55, 14)" end="(55, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(55, 14)" end="(55, 15)" leading="" trailing=" " raw_val="x" val="x"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <OtherNode start="(55, 16)" end="(55, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(55, 16)" end="(55, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(55, 16)" end="(55, 18)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <OtherNode start="(55, 19)" end="(55, 22)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(55, 19)" end="(55, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(55, 19)" end="(55, 22)" leading="" trailing="&#10;      " raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(56, 7)" end="(56, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : eraseP p xs = [] ↔ xs = [] ∨ ∃ x, p x = true ∧ xs = [x]&#10;h : ¬p x = true&#10;h' : p x = true&#10;⊢ ¬xs = []" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(56, 7)" end="(56, 15)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(58, 1)" end="(59, 43)" name="eraseP_eq_nil" full_name="List.eraseP_eq_nil">
      <CommandDeclmodifiersNode start="(58, 1)" end="(58, 56)">
        <NullNode/>
        <NullNode start="(58, 1)" end="(58, 56)">
          <OtherNode start="(58, 1)" end="(58, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(58, 1)" end="(58, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(58, 3)" end="(58, 55)">
              <OtherNode start="(58, 3)" end="(58, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(58, 3)" end="(58, 55)" kind="Lean.deprecated">
                  <AtomNode start="(58, 3)" end="(58, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(58, 14)" end="(58, 31)">
                    <IdentNode start="(58, 14)" end="(58, 31)" leading="" trailing=" " raw_val="eraseP_eq_nil_iff" val="eraseP_eq_nil_iff" full_name="List.eraseP_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(42, 17)" def_end="(42, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(58, 32)" end="(58, 55)">
                    <AtomNode start="(58, 32)" end="(58, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(58, 33)" end="(58, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(58, 39)" end="(58, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(58, 42)" end="(58, 54)" kind="str">
                      <AtomNode start="(58, 42)" end="(58, 54)" leading="" trailing="" val="&amp;quot;2025-01-30&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(58, 54)" end="(58, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(58, 55)" end="(58, 56)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(59, 1)" end="(59, 43)" name="eraseP_eq_nil">
        <AtomNode start="(59, 1)" end="(59, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(59, 8)" end="(59, 21)">
          <IdentNode start="(59, 8)" end="(59, 21)" leading="" trailing=" " raw_val="eraseP_eq_nil" val="eraseP_eq_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(59, 22)" end="(59, 43)">
          <AtomNode start="(59, 22)" end="(59, 24)" leading="" trailing=" " val=":="/>
          <OtherNode start="(59, 25)" end="(59, 43)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(59, 25)" end="(59, 26)" leading="" trailing="" val="@"/>
            <IdentNode start="(59, 26)" end="(59, 43)" leading="" trailing="&#10;&#10;" raw_val="eraseP_eq_nil_iff" val="eraseP_eq_nil_iff" full_name="List.eraseP_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(42, 17)" def_end="(42, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(61, 1)" end="(62, 7)" name="eraseP_ne_nil_iff" full_name="List.eraseP_ne_nil_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(61, 1)" end="(62, 7)" name="eraseP_ne_nil_iff" full_name="List.eraseP_ne_nil_iff" _is_private_decl="False">
        <AtomNode start="(61, 1)" end="(61, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(61, 9)" end="(61, 26)">
          <IdentNode start="(61, 9)" end="(61, 26)" leading="" trailing=" " raw_val="eraseP_ne_nil_iff" val="eraseP_ne_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(61, 27)" end="(61, 106)">
          <NullNode start="(61, 27)" end="(61, 55)">
            <OtherNode start="(61, 27)" end="(61, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 27)" end="(61, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 28)" end="(61, 30)">
                <IdentNode start="(61, 28)" end="(61, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(61, 31)" end="(61, 39)">
                <AtomNode start="(61, 31)" end="(61, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 33)" end="(61, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 33)" end="(61, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(61, 38)" end="(61, 39)">
                    <IdentNode start="(61, 38)" end="(61, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 39)" end="(61, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(61, 41)" end="(61, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(61, 41)" end="(61, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(61, 42)" end="(61, 43)">
                <IdentNode start="(61, 42)" end="(61, 43)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(61, 44)" end="(61, 54)">
                <AtomNode start="(61, 44)" end="(61, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(61, 46)" end="(61, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(61, 46)" end="(61, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(61, 48)" end="(61, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(61, 50)" end="(61, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(61, 54)" end="(61, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(61, 56)" end="(61, 106)">
            <AtomNode start="(61, 56)" end="(61, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(61, 58)" end="(61, 106)" kind="«term_↔_»">
              <OtherNode start="(61, 58)" end="(61, 74)" kind="«term_≠_»">
                <OtherNode start="(61, 58)" end="(61, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 58)" end="(61, 67)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                  <NullNode start="(61, 68)" end="(61, 69)">
                    <IdentNode start="(61, 68)" end="(61, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(61, 70)" end="(61, 71)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(61, 72)" end="(61, 74)" kind="«term[_]»">
                  <AtomNode start="(61, 72)" end="(61, 73)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(61, 73)" end="(61, 74)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(61, 75)" end="(61, 76)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(61, 77)" end="(61, 106)" kind="«term_∧_»">
                <OtherNode start="(61, 77)" end="(61, 84)" kind="«term_≠_»">
                  <IdentNode start="(61, 77)" end="(61, 79)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(61, 80)" end="(61, 81)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(61, 82)" end="(61, 84)" kind="«term[_]»">
                    <AtomNode start="(61, 82)" end="(61, 83)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(61, 83)" end="(61, 84)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(61, 85)" end="(61, 86)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(61, 87)" end="(61, 106)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(61, 87)" end="(61, 88)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(61, 89)" end="(61, 90)">
                    <IdentNode start="(61, 89)" end="(61, 90)" leading="" trailing="" raw_val="x" val="x"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(61, 90)" end="(61, 91)" leading="" trailing=" " val=","/>
                  <OtherNode start="(61, 92)" end="(61, 106)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(61, 92)" end="(61, 95)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(61, 92)" end="(61, 93)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(61, 94)" end="(61, 95)">
                        <IdentNode start="(61, 94)" end="(61, 95)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(61, 96)" end="(61, 97)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(61, 98)" end="(61, 106)" kind="«term_≠_»">
                      <IdentNode start="(61, 98)" end="(61, 100)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(61, 101)" end="(61, 102)" leading="" trailing=" " val="≠"/>
                      <OtherNode start="(61, 103)" end="(61, 106)" kind="«term[_]»">
                        <AtomNode start="(61, 103)" end="(61, 104)" leading="" trailing="" val="["/>
                        <NullNode start="(61, 104)" end="(61, 105)">
                          <IdentNode start="(61, 104)" end="(61, 105)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                        <AtomNode start="(61, 105)" end="(61, 106)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 107)" end="(62, 7)">
          <AtomNode start="(61, 107)" end="(61, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 110)" end="(62, 7)">
            <AtomNode start="(61, 110)" end="(61, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(62, 7)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(62, 7)">
                <NullNode start="(62, 3)" end="(62, 7)">
                  <OtherNode start="(62, 3)" end="(62, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ eraseP p xs ≠ [] ↔ xs ≠ [] ∧ ∀ (x : α), p x = true → xs ≠ [x]" state_after="no goals" tactic="simp">
                    <AtomNode start="(62, 3)" end="(62, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(64, 1)" end="(65, 43)" name="eraseP_ne_nil" full_name="List.eraseP_ne_nil">
      <CommandDeclmodifiersNode start="(64, 1)" end="(64, 56)">
        <NullNode/>
        <NullNode start="(64, 1)" end="(64, 56)">
          <OtherNode start="(64, 1)" end="(64, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(64, 1)" end="(64, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(64, 3)" end="(64, 55)">
              <OtherNode start="(64, 3)" end="(64, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(64, 3)" end="(64, 55)" kind="Lean.deprecated">
                  <AtomNode start="(64, 3)" end="(64, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(64, 14)" end="(64, 31)">
                    <IdentNode start="(64, 14)" end="(64, 31)" leading="" trailing=" " raw_val="eraseP_ne_nil_iff" val="eraseP_ne_nil_iff" full_name="List.eraseP_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(61, 9)" def_end="(61, 26)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(64, 32)" end="(64, 55)">
                    <AtomNode start="(64, 32)" end="(64, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(64, 33)" end="(64, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(64, 39)" end="(64, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(64, 42)" end="(64, 54)" kind="str">
                      <AtomNode start="(64, 42)" end="(64, 54)" leading="" trailing="" val="&amp;quot;2025-01-30&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(64, 54)" end="(64, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(64, 55)" end="(64, 56)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(65, 1)" end="(65, 43)" name="eraseP_ne_nil">
        <AtomNode start="(65, 1)" end="(65, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(65, 8)" end="(65, 21)">
          <IdentNode start="(65, 8)" end="(65, 21)" leading="" trailing=" " raw_val="eraseP_ne_nil" val="eraseP_ne_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(65, 22)" end="(65, 43)">
          <AtomNode start="(65, 22)" end="(65, 24)" leading="" trailing=" " val=":="/>
          <OtherNode start="(65, 25)" end="(65, 43)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(65, 25)" end="(65, 26)" leading="" trailing="" val="@"/>
            <IdentNode start="(65, 26)" end="(65, 43)" leading="" trailing="&#10;&#10;" raw_val="eraseP_ne_nil_iff" val="eraseP_ne_nil_iff" full_name="List.eraseP_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(61, 9)" def_end="(61, 26)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(67, 1)" end="(78, 57)" name="exists_of_eraseP" full_name="List.exists_of_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(67, 1)" end="(78, 57)" name="exists_of_eraseP" full_name="List.exists_of_eraseP" _is_private_decl="False">
        <AtomNode start="(67, 1)" end="(67, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(67, 9)" end="(67, 25)">
          <IdentNode start="(67, 9)" end="(67, 25)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(67, 26)" end="(68, 82)">
          <NullNode/>
          <TermTypespecNode start="(67, 26)" end="(68, 82)">
            <AtomNode start="(67, 26)" end="(67, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(67, 28)" end="(68, 82)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(67, 28)" end="(67, 29)" leading="" trailing=" " val="∀"/>
              <NullNode start="(67, 30)" end="(67, 68)">
                <OtherNode start="(67, 30)" end="(67, 42)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(67, 30)" end="(67, 31)" leading="" trailing="" val="{"/>
                  <NullNode start="(67, 31)" end="(67, 32)">
                    <IdentNode start="(67, 31)" end="(67, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(67, 33)" end="(67, 41)">
                    <AtomNode start="(67, 33)" end="(67, 34)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(67, 35)" end="(67, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(67, 35)" end="(67, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(67, 40)" end="(67, 41)">
                        <IdentNode start="(67, 40)" end="(67, 41)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(67, 41)" end="(67, 42)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(67, 43)" end="(67, 46)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(67, 43)" end="(67, 44)" leading="" trailing="" val="{"/>
                  <NullNode start="(67, 44)" end="(67, 45)">
                    <IdentNode start="(67, 44)" end="(67, 45)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(67, 45)" end="(67, 46)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <TermExplicitbinderNode start="(67, 47)" end="(67, 58)">
                  <AtomNode start="(67, 47)" end="(67, 48)" leading="" trailing="" val="("/>
                  <NullNode start="(67, 48)" end="(67, 49)">
                    <TermHoleNode start="(67, 48)" end="(67, 49)">
                      <AtomNode start="(67, 48)" end="(67, 49)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(67, 50)" end="(67, 57)">
                    <AtomNode start="(67, 50)" end="(67, 51)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(67, 52)" end="(67, 57)" kind="«term_∈_»">
                      <IdentNode start="(67, 52)" end="(67, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(67, 54)" end="(67, 55)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(67, 56)" end="(67, 57)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(67, 57)" end="(67, 58)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(67, 59)" end="(67, 68)">
                  <AtomNode start="(67, 59)" end="(67, 60)" leading="" trailing="" val="("/>
                  <NullNode start="(67, 60)" end="(67, 61)">
                    <TermHoleNode start="(67, 60)" end="(67, 61)">
                      <AtomNode start="(67, 60)" end="(67, 61)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(67, 62)" end="(67, 67)">
                    <AtomNode start="(67, 62)" end="(67, 63)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(67, 64)" end="(67, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(67, 64)" end="(67, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(67, 66)" end="(67, 67)">
                        <IdentNode start="(67, 66)" end="(67, 67)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(67, 67)" end="(67, 68)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(67, 68)" end="(67, 69)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(68, 5)" end="(68, 82)" kind="«term∃_,_»">
                <AtomNode start="(68, 5)" end="(68, 6)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(68, 7)" end="(68, 14)" kind="Lean.explicitBinders">
                  <OtherNode start="(68, 7)" end="(68, 14)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(68, 7)" end="(68, 14)">
                      <LeanBinderidentNode start="(68, 7)" end="(68, 8)">
                        <IdentNode start="(68, 7)" end="(68, 8)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(68, 9)" end="(68, 11)">
                        <IdentNode start="(68, 9)" end="(68, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(68, 12)" end="(68, 14)">
                        <IdentNode start="(68, 12)" end="(68, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(68, 14)" end="(68, 15)" leading="" trailing=" " val=","/>
                <OtherNode start="(68, 16)" end="(68, 82)" kind="«term_∧_»">
                  <OtherNode start="(68, 16)" end="(68, 32)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(68, 16)" end="(68, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(68, 17)" end="(68, 31)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(68, 17)" end="(68, 18)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(68, 19)" end="(68, 20)">
                        <IdentNode start="(68, 19)" end="(68, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(68, 21)" end="(68, 25)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(68, 21)" end="(68, 22)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(68, 23)" end="(68, 25)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(68, 25)" end="(68, 26)" leading="" trailing=" " val=","/>
                      <OtherNode start="(68, 27)" end="(68, 31)" kind="«term¬_»">
                        <AtomNode start="(68, 27)" end="(68, 28)" leading="" trailing="" val="¬"/>
                        <OtherNode start="(68, 28)" end="(68, 31)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(68, 28)" end="(68, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(68, 30)" end="(68, 31)">
                            <IdentNode start="(68, 30)" end="(68, 31)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(68, 31)" end="(68, 32)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(68, 33)" end="(68, 34)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(68, 35)" end="(68, 82)" kind="«term_∧_»">
                    <OtherNode start="(68, 35)" end="(68, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(68, 35)" end="(68, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(68, 37)" end="(68, 38)">
                        <IdentNode start="(68, 37)" end="(68, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(68, 39)" end="(68, 40)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(68, 41)" end="(68, 82)" kind="«term_∧_»">
                      <OtherNode start="(68, 41)" end="(68, 58)" kind="«term_=_»">
                        <IdentNode start="(68, 41)" end="(68, 42)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(68, 43)" end="(68, 44)" leading="" trailing=" " val="="/>
                        <OtherNode start="(68, 45)" end="(68, 58)" kind="«term_++_»">
                          <IdentNode start="(68, 45)" end="(68, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <AtomNode start="(68, 48)" end="(68, 50)" leading="" trailing=" " val="++"/>
                          <OtherNode start="(68, 51)" end="(68, 58)" kind="«term_::_»">
                            <IdentNode start="(68, 51)" end="(68, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                            <AtomNode start="(68, 53)" end="(68, 55)" leading="" trailing=" " val="::"/>
                            <IdentNode start="(68, 56)" end="(68, 58)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(68, 59)" end="(68, 60)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(68, 61)" end="(68, 82)" kind="«term_=_»">
                        <OtherNode start="(68, 61)" end="(68, 71)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(68, 61)" end="(68, 69)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                          <NullNode start="(68, 70)" end="(68, 71)">
                            <IdentNode start="(68, 70)" end="(68, 71)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(68, 72)" end="(68, 73)" leading="" trailing=" " val="="/>
                        <OtherNode start="(68, 74)" end="(68, 82)" kind="«term_++_»">
                          <IdentNode start="(68, 74)" end="(68, 76)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <AtomNode start="(68, 77)" end="(68, 79)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(68, 80)" end="(68, 82)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(69, 3)" end="(78, 57)">
          <OtherNode start="(69, 3)" end="(78, 57)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(69, 3)" end="(78, 57)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(69, 3)" end="(78, 57)">
                <OtherNode start="(69, 3)" end="(78, 57)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(69, 3)" end="(69, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(69, 5)" end="(69, 22)">
                    <NullNode start="(69, 5)" end="(69, 22)">
                      <OtherNode start="(69, 5)" end="(69, 11)" kind="«term_::_»">
                        <IdentNode start="(69, 5)" end="(69, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(69, 7)" end="(69, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(69, 10)" end="(69, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(69, 11)" end="(69, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(69, 13)" end="(69, 14)">
                        <AtomNode start="(69, 13)" end="(69, 14)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(69, 14)" end="(69, 15)" leading="" trailing=" " val=","/>
                      <IdentNode start="(69, 16)" end="(69, 18)" leading="" trailing="" raw_val="al" val="al"/>
                      <AtomNode start="(69, 18)" end="(69, 19)" leading="" trailing=" " val=","/>
                      <IdentNode start="(69, 20)" end="(69, 22)" leading="" trailing=" " raw_val="pa" val="pa"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(69, 23)" end="(69, 25)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(70, 5)" end="(78, 57)" kind="termDepIfThenElse">
                    <AtomNode start="(70, 5)" end="(70, 7)" leading="" trailing=" " val="if"/>
                    <LeanBinderidentNode start="(70, 8)" end="(70, 10)">
                      <IdentNode start="(70, 8)" end="(70, 10)" leading="" trailing=" " raw_val="pb" val="pb"/>
                    </LeanBinderidentNode>
                    <AtomNode start="(70, 11)" end="(70, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(70, 13)" end="(70, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(70, 13)" end="(70, 14)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(70, 15)" end="(70, 16)">
                        <IdentNode start="(70, 15)" end="(70, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(70, 17)" end="(70, 21)" leading="" trailing="&#10;      " val="then"/>
                    <OtherNode start="(71, 7)" end="(71, 53)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(71, 7)" end="(71, 8)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(71, 8)" end="(71, 52)">
                        <IdentNode start="(71, 8)" end="(71, 9)" leading="" trailing="" raw_val="b" val="b"/>
                        <AtomNode start="(71, 9)" end="(71, 10)" leading="" trailing=" " val=","/>
                        <OtherNode start="(71, 11)" end="(71, 13)" kind="«term[_]»">
                          <AtomNode start="(71, 11)" end="(71, 12)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(71, 12)" end="(71, 13)" leading="" trailing="" val="]"/>
                        </OtherNode>
                        <AtomNode start="(71, 13)" end="(71, 14)" leading="" trailing=" " val=","/>
                        <IdentNode start="(71, 15)" end="(71, 16)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(71, 16)" end="(71, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(71, 18)" end="(71, 34)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(71, 18)" end="(71, 32)" leading="" trailing=" " raw_val="forall_mem_nil" val="forall_mem_nil" full_name="List.forall_mem_nil" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                          <NullNode start="(71, 33)" end="(71, 34)">
                            <TermHoleNode start="(71, 33)" end="(71, 34)">
                              <AtomNode start="(71, 33)" end="(71, 34)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(71, 34)" end="(71, 35)" leading="" trailing=" " val=","/>
                        <IdentNode start="(71, 36)" end="(71, 38)" leading="" trailing="" raw_val="pb" val="pb"/>
                        <AtomNode start="(71, 38)" end="(71, 39)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(71, 40)" end="(71, 52)">
                          <AtomNode start="(71, 40)" end="(71, 42)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(71, 43)" end="(71, 52)">
                            <TacticTacticseq1IndentedNode start="(71, 43)" end="(71, 52)">
                              <NullNode start="(71, 43)" end="(71, 52)">
                                <OtherNode start="(71, 43)" end="(71, 52)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;l : List α&#10;x✝ : α&#10;al : x✝ ∈ b :: l&#10;pa : p x✝ = true&#10;pb : p b = true&#10;⊢ b :: l = [] ++ b :: l ∧ eraseP p (b :: l) = [] ++ l" state_after="no goals" tactic="simp [pb]">
                                  <AtomNode start="(71, 43)" end="(71, 47)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(71, 48)" end="(71, 52)">
                                    <AtomNode start="(71, 48)" end="(71, 49)" leading="" trailing="" val="["/>
                                    <NullNode start="(71, 49)" end="(71, 51)">
                                      <OtherNode start="(71, 49)" end="(71, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(71, 49)" end="(71, 51)" leading="" trailing="" raw_val="pb" val="pb"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(71, 51)" end="(71, 52)" leading="" trailing="" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(71, 52)" end="(71, 53)" leading="" trailing="&#10;    " val="⟩"/>
                    </OtherNode>
                    <AtomNode start="(72, 5)" end="(72, 9)" leading="" trailing="&#10;      " val="else"/>
                    <OtherNode start="(73, 7)" end="(78, 57)" kind="Lean.Parser.Term.match">
                      <AtomNode start="(73, 7)" end="(73, 12)" leading="" trailing=" " val="match"/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(73, 13)" end="(73, 15)">
                        <OtherNode start="(73, 13)" end="(73, 15)" kind="Lean.Parser.Term.matchDiscr">
                          <NullNode/>
                          <IdentNode start="(73, 13)" end="(73, 15)" leading="" trailing=" " raw_val="al" val="al"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(73, 16)" end="(73, 20)" leading="" trailing="&#10;      " val="with"/>
                      <OtherNode start="(74, 7)" end="(78, 57)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(74, 7)" end="(78, 57)">
                          <OtherNode start="(74, 7)" end="(74, 34)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(74, 7)" end="(74, 8)" leading="" trailing=" " val="|"/>
                            <NullNode start="(74, 9)" end="(74, 17)">
                              <NullNode start="(74, 9)" end="(74, 17)">
                                <OtherNode start="(74, 9)" end="(74, 17)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(74, 9)" end="(74, 14)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(74, 9)" end="(74, 10)" leading="" trailing="" val="."/>
                                    <IdentNode start="(74, 10)" end="(74, 14)" leading="" trailing=" " raw_val="head" val="head"/>
                                  </OtherNode>
                                  <NullNode start="(74, 15)" end="(74, 17)">
                                    <OtherNode start="(74, 15)" end="(74, 17)" kind="Lean.Parser.Term.ellipsis">
                                      <AtomNode start="(74, 15)" end="(74, 17)" leading="" trailing=" " val=".."/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(74, 18)" end="(74, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(74, 21)" end="(74, 34)" kind="Lean.Parser.Term.nomatch">
                              <AtomNode start="(74, 21)" end="(74, 28)" leading="" trailing=" " val="nomatch"/>
                              <NullNode start="(74, 29)" end="(74, 34)">
                                <OtherNode start="(74, 29)" end="(74, 34)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(74, 29)" end="(74, 31)" leading="" trailing=" " raw_val="pb" val="pb"/>
                                  <NullNode start="(74, 32)" end="(74, 34)">
                                    <IdentNode start="(74, 32)" end="(74, 34)" leading="" trailing="&#10;      " raw_val="pa" val="pa"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(75, 7)" end="(78, 57)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(75, 7)" end="(75, 8)" leading="" trailing=" " val="|"/>
                            <NullNode start="(75, 9)" end="(75, 19)">
                              <NullNode start="(75, 9)" end="(75, 19)">
                                <OtherNode start="(75, 9)" end="(75, 19)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(75, 9)" end="(75, 14)" kind="Lean.Parser.Term.dotIdent">
                                    <AtomNode start="(75, 9)" end="(75, 10)" leading="" trailing="" val="."/>
                                    <IdentNode start="(75, 10)" end="(75, 14)" leading="" trailing=" " raw_val="tail" val="tail"/>
                                  </OtherNode>
                                  <NullNode start="(75, 15)" end="(75, 19)">
                                    <TermHoleNode start="(75, 15)" end="(75, 16)">
                                      <AtomNode start="(75, 15)" end="(75, 16)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <IdentNode start="(75, 17)" end="(75, 19)" leading="" trailing=" " raw_val="al" val="al"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(75, 20)" end="(75, 22)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                            <OtherNode start="(76, 9)" end="(78, 57)" kind="Lean.Parser.Term.let">
                              <AtomNode start="(76, 9)" end="(76, 12)" leading="" trailing=" " val="let"/>
                              <OtherNode start="(76, 13)" end="(76, 66)" kind="Lean.Parser.Term.letDecl">
                                <OtherNode start="(76, 13)" end="(76, 66)" kind="Lean.Parser.Term.letPatDecl">
                                  <OtherNode start="(76, 13)" end="(76, 40)" kind="Lean.Parser.Term.anonymousCtor">
                                    <AtomNode start="(76, 13)" end="(76, 14)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(76, 14)" end="(76, 39)">
                                      <IdentNode start="(76, 14)" end="(76, 15)" leading="" trailing="" raw_val="c" val="c"/>
                                      <AtomNode start="(76, 15)" end="(76, 16)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(76, 17)" end="(76, 19)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                      <AtomNode start="(76, 19)" end="(76, 20)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(76, 21)" end="(76, 23)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                      <AtomNode start="(76, 23)" end="(76, 24)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(76, 25)" end="(76, 27)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                      <AtomNode start="(76, 27)" end="(76, 28)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(76, 29)" end="(76, 31)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      <AtomNode start="(76, 31)" end="(76, 32)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(76, 33)" end="(76, 35)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                      <AtomNode start="(76, 35)" end="(76, 36)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(76, 37)" end="(76, 39)" leading="" trailing="" raw_val="h₄" val="h₄"/>
                                    </NullNode>
                                    <AtomNode start="(76, 39)" end="(76, 40)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(76, 41)" end="(76, 43)" leading="" trailing=" " val=":="/>
                                  <OtherNode start="(76, 44)" end="(76, 66)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(76, 44)" end="(76, 60)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP"/>
                                    <NullNode start="(76, 61)" end="(76, 66)">
                                      <IdentNode start="(76, 61)" end="(76, 63)" leading="" trailing=" " raw_val="al" val="al"/>
                                      <IdentNode start="(76, 64)" end="(76, 66)" leading="" trailing="&#10;        " raw_val="pa" val="pa"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(77, 9)" end="(78, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(77, 9)" end="(77, 10)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(77, 10)" end="(78, 56)">
                                  <IdentNode start="(77, 10)" end="(77, 11)" leading="" trailing="" raw_val="c" val="c"/>
                                  <AtomNode start="(77, 11)" end="(77, 12)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(77, 13)" end="(77, 18)" kind="«term_::_»">
                                    <IdentNode start="(77, 13)" end="(77, 14)" leading="" trailing="" raw_val="b" val="b"/>
                                    <AtomNode start="(77, 14)" end="(77, 16)" leading="" trailing="" val="::"/>
                                    <IdentNode start="(77, 16)" end="(77, 18)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                  </OtherNode>
                                  <AtomNode start="(77, 18)" end="(77, 19)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(77, 20)" end="(77, 22)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                  <AtomNode start="(77, 22)" end="(77, 23)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(77, 24)" end="(77, 55)" kind="Lean.Parser.Term.app">
                                    <OtherNode start="(77, 24)" end="(77, 46)" kind="Lean.Parser.Term.proj">
                                      <OtherNode start="(77, 24)" end="(77, 44)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(77, 24)" end="(77, 25)" leading="" trailing="" val="("/>
                                        <OtherNode start="(77, 25)" end="(77, 43)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(77, 25)" end="(77, 40)" leading="" trailing=" " raw_val="forall_mem_cons" val="forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          <NullNode start="(77, 41)" end="(77, 43)">
                                            <OtherNode start="(77, 41)" end="(77, 43)" kind="Lean.Parser.Term.ellipsis">
                                              <AtomNode start="(77, 41)" end="(77, 43)" leading="" trailing="" val=".."/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(77, 43)" end="(77, 44)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(77, 44)" end="(77, 45)" leading="" trailing="" val="."/>
                                      <OtherNode start="(77, 45)" end="(77, 46)" kind="fieldIdx">
                                        <AtomNode start="(77, 45)" end="(77, 46)" leading="" trailing=" " val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode start="(77, 47)" end="(77, 55)">
                                      <OtherNode start="(77, 47)" end="(77, 55)" kind="Lean.Parser.Term.anonymousCtor">
                                        <AtomNode start="(77, 47)" end="(77, 48)" leading="" trailing="" val="⟨"/>
                                        <NullNode start="(77, 48)" end="(77, 54)">
                                          <IdentNode start="(77, 48)" end="(77, 50)" leading="" trailing="" raw_val="pb" val="pb"/>
                                          <AtomNode start="(77, 50)" end="(77, 51)" leading="" trailing=" " val=","/>
                                          <IdentNode start="(77, 52)" end="(77, 54)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                        </NullNode>
                                        <AtomNode start="(77, 54)" end="(77, 55)" leading="" trailing="" val="⟩"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(77, 55)" end="(77, 56)" leading="" trailing="&#10;          " val=","/>
                                  <IdentNode start="(78, 11)" end="(78, 13)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                  <AtomNode start="(78, 13)" end="(78, 14)" leading="" trailing=" " val=","/>
                                  <TermBytacticNode start="(78, 15)" end="(78, 38)">
                                    <AtomNode start="(78, 15)" end="(78, 17)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(78, 18)" end="(78, 38)">
                                      <TacticTacticseq1IndentedNode start="(78, 18)" end="(78, 38)">
                                        <NullNode start="(78, 18)" end="(78, 38)">
                                          <OtherNode start="(78, 18)" end="(78, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;b✝ : α&#10;l : List α&#10;x✝ : α&#10;al✝ : x✝ ∈ b✝ :: l&#10;pa : p x✝ = true&#10;b : α&#10;al : Mem x✝ l&#10;pb : ¬p b = true&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ b :: l = b :: l₁ ++ c :: l₂" state_after="no goals" tactic="rw [h₃, cons_append]">
                                            <AtomNode start="(78, 18)" end="(78, 20)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(78, 21)" end="(78, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(78, 21)" end="(78, 22)" leading="" trailing="" val="["/>
                                              <NullNode start="(78, 22)" end="(78, 37)">
                                                <OtherNode start="(78, 22)" end="(78, 24)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(78, 22)" end="(78, 24)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                </OtherNode>
                                                <AtomNode start="(78, 24)" end="(78, 25)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(78, 26)" end="(78, 37)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(78, 26)" end="(78, 37)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(78, 37)" end="(78, 38)" leading="" trailing="" val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(78, 38)" end="(78, 39)" leading="" trailing=" " val=","/>
                                  <TermBytacticNode start="(78, 40)" end="(78, 56)">
                                    <AtomNode start="(78, 40)" end="(78, 42)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(78, 43)" end="(78, 56)">
                                      <TacticTacticseq1IndentedNode start="(78, 43)" end="(78, 56)">
                                        <NullNode start="(78, 43)" end="(78, 56)">
                                          <OtherNode start="(78, 43)" end="(78, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;b✝ : α&#10;l : List α&#10;x✝ : α&#10;al✝ : x✝ ∈ b✝ :: l&#10;pa : p x✝ = true&#10;b : α&#10;al : Mem x✝ l&#10;pb : ¬p b = true&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ eraseP p (b :: l) = b :: l₁ ++ l₂" state_after="no goals" tactic="simp [pb, h₄]">
                                            <AtomNode start="(78, 43)" end="(78, 47)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(78, 48)" end="(78, 56)">
                                              <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing="" val="["/>
                                              <NullNode start="(78, 49)" end="(78, 55)">
                                                <OtherNode start="(78, 49)" end="(78, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(78, 49)" end="(78, 51)" leading="" trailing="" raw_val="pb" val="pb"/>
                                                </OtherNode>
                                                <AtomNode start="(78, 51)" end="(78, 52)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(78, 53)" end="(78, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(78, 53)" end="(78, 55)" leading="" trailing="" raw_val="h₄" val="h₄"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(78, 55)" end="(78, 56)" leading="" trailing="" val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                </NullNode>
                                <AtomNode start="(78, 56)" end="(78, 57)" leading="" trailing="&#10;&#10;-- The arguments are explicit here, so this lemma can be used as a case split.&#10;" val="⟩"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(81, 1)" end="(88, 46)" name="exists_or_eq_self_of_eraseP" full_name="List.exists_or_eq_self_of_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(81, 1)" end="(88, 46)" name="exists_or_eq_self_of_eraseP" full_name="List.exists_or_eq_self_of_eraseP" _is_private_decl="False">
        <AtomNode start="(81, 1)" end="(81, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(81, 9)" end="(81, 36)">
          <IdentNode start="(81, 9)" end="(81, 36)" leading="" trailing=" " raw_val="exists_or_eq_self_of_eraseP" val="exists_or_eq_self_of_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(81, 37)" end="(83, 82)">
          <NullNode start="(81, 37)" end="(81, 53)">
            <TermExplicitbinderNode start="(81, 37)" end="(81, 40)">
              <AtomNode start="(81, 37)" end="(81, 38)" leading="" trailing="" val="("/>
              <NullNode start="(81, 38)" end="(81, 39)">
                <IdentNode start="(81, 38)" end="(81, 39)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(81, 39)" end="(81, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(81, 41)" end="(81, 53)">
              <AtomNode start="(81, 41)" end="(81, 42)" leading="" trailing="" val="("/>
              <NullNode start="(81, 42)" end="(81, 43)">
                <IdentNode start="(81, 42)" end="(81, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(81, 44)" end="(81, 52)">
                <AtomNode start="(81, 44)" end="(81, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(81, 46)" end="(81, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(81, 46)" end="(81, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(81, 51)" end="(81, 52)">
                    <IdentNode start="(81, 51)" end="(81, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(81, 52)" end="(81, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(81, 54)" end="(83, 82)">
            <AtomNode start="(81, 54)" end="(81, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(82, 5)" end="(83, 82)" kind="«term_∨_»">
              <OtherNode start="(82, 5)" end="(82, 19)" kind="«term_=_»">
                <OtherNode start="(82, 5)" end="(82, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(82, 5)" end="(82, 13)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(82, 14)" end="(82, 15)">
                    <IdentNode start="(82, 14)" end="(82, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(82, 16)" end="(82, 17)" leading="" trailing=" " val="="/>
                <IdentNode start="(82, 18)" end="(82, 19)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
              <AtomNode start="(82, 20)" end="(82, 21)" leading="" trailing="&#10;    " val="∨"/>
              <OtherNode start="(83, 5)" end="(83, 82)" kind="«term∃_,_»">
                <AtomNode start="(83, 5)" end="(83, 6)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(83, 7)" end="(83, 14)" kind="Lean.explicitBinders">
                  <OtherNode start="(83, 7)" end="(83, 14)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(83, 7)" end="(83, 14)">
                      <LeanBinderidentNode start="(83, 7)" end="(83, 8)">
                        <IdentNode start="(83, 7)" end="(83, 8)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(83, 9)" end="(83, 11)">
                        <IdentNode start="(83, 9)" end="(83, 11)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(83, 12)" end="(83, 14)">
                        <IdentNode start="(83, 12)" end="(83, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(83, 14)" end="(83, 15)" leading="" trailing=" " val=","/>
                <OtherNode start="(83, 16)" end="(83, 82)" kind="«term_∧_»">
                  <OtherNode start="(83, 16)" end="(83, 32)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(83, 16)" end="(83, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(83, 17)" end="(83, 31)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(83, 17)" end="(83, 18)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(83, 19)" end="(83, 20)">
                        <IdentNode start="(83, 19)" end="(83, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(83, 21)" end="(83, 25)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(83, 21)" end="(83, 22)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(83, 23)" end="(83, 25)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(83, 25)" end="(83, 26)" leading="" trailing=" " val=","/>
                      <OtherNode start="(83, 27)" end="(83, 31)" kind="«term¬_»">
                        <AtomNode start="(83, 27)" end="(83, 28)" leading="" trailing="" val="¬"/>
                        <OtherNode start="(83, 28)" end="(83, 31)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(83, 28)" end="(83, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(83, 30)" end="(83, 31)">
                            <IdentNode start="(83, 30)" end="(83, 31)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(83, 31)" end="(83, 32)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(83, 33)" end="(83, 34)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(83, 35)" end="(83, 82)" kind="«term_∧_»">
                    <OtherNode start="(83, 35)" end="(83, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(83, 35)" end="(83, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(83, 37)" end="(83, 38)">
                        <IdentNode start="(83, 37)" end="(83, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(83, 39)" end="(83, 40)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(83, 41)" end="(83, 82)" kind="«term_∧_»">
                      <OtherNode start="(83, 41)" end="(83, 58)" kind="«term_=_»">
                        <IdentNode start="(83, 41)" end="(83, 42)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(83, 43)" end="(83, 44)" leading="" trailing=" " val="="/>
                        <OtherNode start="(83, 45)" end="(83, 58)" kind="«term_++_»">
                          <IdentNode start="(83, 45)" end="(83, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <AtomNode start="(83, 48)" end="(83, 50)" leading="" trailing=" " val="++"/>
                          <OtherNode start="(83, 51)" end="(83, 58)" kind="«term_::_»">
                            <IdentNode start="(83, 51)" end="(83, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                            <AtomNode start="(83, 53)" end="(83, 55)" leading="" trailing=" " val="::"/>
                            <IdentNode start="(83, 56)" end="(83, 58)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(83, 59)" end="(83, 60)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(83, 61)" end="(83, 82)" kind="«term_=_»">
                        <OtherNode start="(83, 61)" end="(83, 71)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(83, 61)" end="(83, 69)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                          <NullNode start="(83, 70)" end="(83, 71)">
                            <IdentNode start="(83, 70)" end="(83, 71)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(83, 72)" end="(83, 73)" leading="" trailing=" " val="="/>
                        <OtherNode start="(83, 74)" end="(83, 82)" kind="«term_++_»">
                          <IdentNode start="(83, 74)" end="(83, 76)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <AtomNode start="(83, 77)" end="(83, 79)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(83, 80)" end="(83, 82)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(83, 83)" end="(88, 46)">
          <AtomNode start="(83, 83)" end="(83, 85)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(84, 3)" end="(88, 46)" kind="termDepIfThenElse">
            <AtomNode start="(84, 3)" end="(84, 5)" leading="" trailing=" " val="if"/>
            <LeanBinderidentNode start="(84, 6)" end="(84, 7)">
              <IdentNode start="(84, 6)" end="(84, 7)" leading="" trailing=" " raw_val="h" val="h"/>
            </LeanBinderidentNode>
            <AtomNode start="(84, 8)" end="(84, 9)" leading="" trailing=" " val=":"/>
            <OtherNode start="(84, 10)" end="(84, 22)" kind="Lean.«term∃__,_»">
              <AtomNode start="(84, 10)" end="(84, 11)" leading="" trailing=" " val="∃"/>
              <LeanBinderidentNode start="(84, 12)" end="(84, 13)">
                <IdentNode start="(84, 12)" end="(84, 13)" leading="" trailing=" " raw_val="a" val="a"/>
              </LeanBinderidentNode>
              <OtherNode start="(84, 14)" end="(84, 17)" kind="Lean.«binderTerm∈_»">
                <AtomNode start="(84, 14)" end="(84, 15)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(84, 16)" end="(84, 17)" leading="" trailing="" raw_val="l" val="l"/>
              </OtherNode>
              <AtomNode start="(84, 17)" end="(84, 18)" leading="" trailing=" " val=","/>
              <OtherNode start="(84, 19)" end="(84, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(84, 19)" end="(84, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                <NullNode start="(84, 21)" end="(84, 22)">
                  <IdentNode start="(84, 21)" end="(84, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(84, 23)" end="(84, 27)" leading="" trailing="&#10;    " val="then"/>
            <OtherNode start="(85, 5)" end="(86, 34)" kind="Lean.Parser.Term.let">
              <AtomNode start="(85, 5)" end="(85, 8)" leading="" trailing=" " val="let"/>
              <OtherNode start="(85, 9)" end="(85, 25)" kind="Lean.Parser.Term.letDecl">
                <OtherNode start="(85, 9)" end="(85, 25)" kind="Lean.Parser.Term.letPatDecl">
                  <OtherNode start="(85, 9)" end="(85, 20)" kind="Lean.Parser.Term.anonymousCtor">
                    <AtomNode start="(85, 9)" end="(85, 10)" leading="" trailing="" val="⟨"/>
                    <NullNode start="(85, 10)" end="(85, 19)">
                      <TermHoleNode start="(85, 10)" end="(85, 11)">
                        <AtomNode start="(85, 10)" end="(85, 11)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(85, 11)" end="(85, 12)" leading="" trailing=" " val=","/>
                      <IdentNode start="(85, 13)" end="(85, 15)" leading="" trailing="" raw_val="ha" val="ha"/>
                      <AtomNode start="(85, 15)" end="(85, 16)" leading="" trailing=" " val=","/>
                      <IdentNode start="(85, 17)" end="(85, 19)" leading="" trailing="" raw_val="pa" val="pa"/>
                    </NullNode>
                    <AtomNode start="(85, 19)" end="(85, 20)" leading="" trailing=" " val="⟩"/>
                  </OtherNode>
                  <NullNode/>
                  <NullNode/>
                  <AtomNode start="(85, 21)" end="(85, 23)" leading="" trailing=" " val=":="/>
                  <IdentNode start="(85, 24)" end="(85, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                </OtherNode>
              </OtherNode>
              <NullNode/>
              <OtherNode start="(86, 5)" end="(86, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(86, 5)" end="(86, 9)" kind="Lean.Parser.Term.dotIdent">
                  <AtomNode start="(86, 5)" end="(86, 6)" leading="" trailing="" val="."/>
                  <IdentNode start="(86, 6)" end="(86, 9)" leading="" trailing=" " raw_val="inr" val="inr"/>
                </OtherNode>
                <NullNode start="(86, 10)" end="(86, 34)">
                  <OtherNode start="(86, 10)" end="(86, 34)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(86, 10)" end="(86, 11)" leading="" trailing="" val="("/>
                    <OtherNode start="(86, 11)" end="(86, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(86, 11)" end="(86, 27)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP" full_name="List.exists_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(67, 9)" def_end="(67, 25)"/>
                      <NullNode start="(86, 28)" end="(86, 33)">
                        <IdentNode start="(86, 28)" end="(86, 30)" leading="" trailing=" " raw_val="ha" val="ha"/>
                        <IdentNode start="(86, 31)" end="(86, 33)" leading="" trailing="" raw_val="pa" val="pa"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(86, 33)" end="(86, 34)" leading="" trailing="&#10;  " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(87, 3)" end="(87, 7)" leading="" trailing="&#10;    " val="else"/>
            <OtherNode start="(88, 5)" end="(88, 46)" kind="Lean.Parser.Term.app">
              <OtherNode start="(88, 5)" end="(88, 9)" kind="Lean.Parser.Term.dotIdent">
                <AtomNode start="(88, 5)" end="(88, 6)" leading="" trailing="" val="."/>
                <IdentNode start="(88, 6)" end="(88, 9)" leading="" trailing=" " raw_val="inl" val="inl"/>
              </OtherNode>
              <NullNode start="(88, 10)" end="(88, 46)">
                <OtherNode start="(88, 10)" end="(88, 46)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(88, 10)" end="(88, 11)" leading="" trailing="" val="("/>
                  <OtherNode start="(88, 11)" end="(88, 45)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(88, 11)" end="(88, 31)" leading="" trailing=" " raw_val="eraseP_of_forall_not" val="eraseP_of_forall_not" full_name="List.eraseP_of_forall_not" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(37, 9)" def_end="(37, 29)"/>
                    <NullNode start="(88, 32)" end="(88, 45)">
                      <OtherNode start="(88, 32)" end="(88, 45)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(88, 32)" end="(88, 33)" leading="" trailing="" val="("/>
                        <OtherNode start="(88, 33)" end="(88, 44)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(88, 33)" end="(88, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                          <NullNode start="(88, 35)" end="(88, 44)">
                            <OtherNode start="(88, 35)" end="(88, 44)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(88, 35)" end="(88, 36)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(88, 36)" end="(88, 43)">
                                <OtherNode start="(88, 36)" end="(88, 37)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(88, 36)" end="(88, 37)" leading="" trailing="" val="·"/>
                                </OtherNode>
                                <AtomNode start="(88, 37)" end="(88, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(88, 39)" end="(88, 40)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(88, 39)" end="(88, 40)" leading="" trailing="" val="·"/>
                                </OtherNode>
                                <AtomNode start="(88, 40)" end="(88, 41)" leading="" trailing=" " val=","/>
                                <OtherNode start="(88, 42)" end="(88, 43)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(88, 42)" end="(88, 43)" leading="" trailing="" val="·"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(88, 43)" end="(88, 44)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(88, 44)" end="(88, 45)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(88, 45)" end="(88, 46)" leading="" trailing="&#10;&#10;" val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(90, 1)" end="(93, 36)" name="length_eraseP_of_mem" full_name="List.length_eraseP_of_mem">
      <CommandDeclmodifiersNode start="(90, 1)" end="(90, 8)">
        <NullNode/>
        <NullNode start="(90, 1)" end="(90, 8)">
          <OtherNode start="(90, 1)" end="(90, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(90, 1)" end="(90, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(90, 3)" end="(90, 7)">
              <OtherNode start="(90, 3)" end="(90, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(90, 3)" end="(90, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(90, 3)" end="(90, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(90, 7)" end="(90, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(90, 9)" end="(93, 36)" name="length_eraseP_of_mem" full_name="List.length_eraseP_of_mem" _is_private_decl="False">
        <AtomNode start="(90, 9)" end="(90, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(90, 17)" end="(90, 37)">
          <IdentNode start="(90, 17)" end="(90, 37)" leading="" trailing=" " raw_val="length_eraseP_of_mem" val="length_eraseP_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(90, 38)" end="(91, 39)">
          <NullNode start="(90, 38)" end="(90, 61)">
            <TermExplicitbinderNode start="(90, 38)" end="(90, 50)">
              <AtomNode start="(90, 38)" end="(90, 39)" leading="" trailing="" val="("/>
              <NullNode start="(90, 39)" end="(90, 41)">
                <IdentNode start="(90, 39)" end="(90, 41)" leading="" trailing=" " raw_val="al" val="al"/>
              </NullNode>
              <NullNode start="(90, 42)" end="(90, 49)">
                <AtomNode start="(90, 42)" end="(90, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(90, 44)" end="(90, 49)" kind="«term_∈_»">
                  <IdentNode start="(90, 44)" end="(90, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(90, 46)" end="(90, 47)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(90, 48)" end="(90, 49)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(90, 49)" end="(90, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(90, 51)" end="(90, 61)">
              <AtomNode start="(90, 51)" end="(90, 52)" leading="" trailing="" val="("/>
              <NullNode start="(90, 52)" end="(90, 54)">
                <IdentNode start="(90, 52)" end="(90, 54)" leading="" trailing=" " raw_val="pa" val="pa"/>
              </NullNode>
              <NullNode start="(90, 55)" end="(90, 60)">
                <AtomNode start="(90, 55)" end="(90, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(90, 57)" end="(90, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(90, 57)" end="(90, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(90, 59)" end="(90, 60)">
                    <IdentNode start="(90, 59)" end="(90, 60)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(90, 60)" end="(90, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(90, 62)" end="(91, 39)">
            <AtomNode start="(90, 62)" end="(90, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(91, 5)" end="(91, 39)" kind="«term_=_»">
              <OtherNode start="(91, 5)" end="(91, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(91, 5)" end="(91, 11)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(91, 12)" end="(91, 24)">
                  <OtherNode start="(91, 12)" end="(91, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(91, 12)" end="(91, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(91, 13)" end="(91, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(91, 13)" end="(91, 21)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                      <NullNode start="(91, 22)" end="(91, 23)">
                        <IdentNode start="(91, 22)" end="(91, 23)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(91, 23)" end="(91, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(91, 25)" end="(91, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(91, 27)" end="(91, 39)" kind="«term_-_»">
                <OtherNode start="(91, 27)" end="(91, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(91, 27)" end="(91, 33)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(91, 34)" end="(91, 35)">
                    <IdentNode start="(91, 34)" end="(91, 35)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(91, 36)" end="(91, 37)" leading="" trailing=" " val="-"/>
                <OtherNode start="(91, 38)" end="(91, 39)" kind="num">
                  <AtomNode start="(91, 38)" end="(91, 39)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(91, 40)" end="(93, 36)">
          <AtomNode start="(91, 40)" end="(91, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(91, 43)" end="(93, 36)">
            <AtomNode start="(91, 43)" end="(91, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(92, 3)" end="(93, 36)">
              <TacticTacticseq1IndentedNode start="(92, 3)" end="(93, 36)">
                <NullNode start="(92, 3)" end="(93, 36)">
                  <OtherNode start="(92, 3)" end="(92, 58)" kind="Lean.Parser.Tactic.tacticLet_" state_before="α✝ : Type u_1&#10;l : List α✝&#10;a : α✝&#10;p : α✝ → Bool&#10;al : a ∈ l&#10;pa : p a = true&#10;⊢ (eraseP p l).length = l.length - 1" state_after="α✝ : Type u_1&#10;l : List α✝&#10;a : α✝&#10;p : α✝ → Bool&#10;al : a ∈ l&#10;pa : p a = true&#10;w✝ : α✝&#10;l₁ l₂ : List α✝&#10;left✝¹ : ∀ (b : α✝), b ∈ l₁ → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : l = l₁ ++ w✝ :: l₂&#10;e₂ : eraseP p l = l₁ ++ l₂&#10;⊢ (eraseP p l).length = l.length - 1" tactic="let ⟨_, l₁, l₂, _, _, e₁, e₂⟩ := exists_of_eraseP al pa">
                    <AtomNode start="(92, 3)" end="(92, 6)" leading="" trailing=" " val="let"/>
                    <OtherNode start="(92, 7)" end="(92, 58)" kind="Lean.Parser.Term.letDecl">
                      <OtherNode start="(92, 7)" end="(92, 58)" kind="Lean.Parser.Term.letPatDecl">
                        <OtherNode start="(92, 7)" end="(92, 32)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(92, 7)" end="(92, 8)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(92, 8)" end="(92, 31)">
                            <TermHoleNode start="(92, 8)" end="(92, 9)">
                              <AtomNode start="(92, 8)" end="(92, 9)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(92, 9)" end="(92, 10)" leading="" trailing=" " val=","/>
                            <IdentNode start="(92, 11)" end="(92, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                            <AtomNode start="(92, 13)" end="(92, 14)" leading="" trailing=" " val=","/>
                            <IdentNode start="(92, 15)" end="(92, 17)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                            <AtomNode start="(92, 17)" end="(92, 18)" leading="" trailing=" " val=","/>
                            <TermHoleNode start="(92, 19)" end="(92, 20)">
                              <AtomNode start="(92, 19)" end="(92, 20)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(92, 20)" end="(92, 21)" leading="" trailing=" " val=","/>
                            <TermHoleNode start="(92, 22)" end="(92, 23)">
                              <AtomNode start="(92, 22)" end="(92, 23)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(92, 23)" end="(92, 24)" leading="" trailing=" " val=","/>
                            <IdentNode start="(92, 25)" end="(92, 27)" leading="" trailing="" raw_val="e₁" val="e₁"/>
                            <AtomNode start="(92, 27)" end="(92, 28)" leading="" trailing=" " val=","/>
                            <IdentNode start="(92, 29)" end="(92, 31)" leading="" trailing="" raw_val="e₂" val="e₂"/>
                          </NullNode>
                          <AtomNode start="(92, 31)" end="(92, 32)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(92, 33)" end="(92, 35)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(92, 36)" end="(92, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(92, 36)" end="(92, 52)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP" full_name="List.exists_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(67, 9)" def_end="(67, 25)"/>
                          <NullNode start="(92, 53)" end="(92, 58)">
                            <IdentNode start="(92, 53)" end="(92, 55)" leading="" trailing=" " raw_val="al" val="al"/>
                            <IdentNode start="(92, 56)" end="(92, 58)" leading="" trailing="&#10;  " raw_val="pa" val="pa"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(93, 3)" end="(93, 10)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type u_1&#10;l : List α✝&#10;a : α✝&#10;p : α✝ → Bool&#10;al : a ∈ l&#10;pa : p a = true&#10;w✝ : α✝&#10;l₁ l₂ : List α✝&#10;left✝¹ : ∀ (b : α✝), b ∈ l₁ → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : l = l₁ ++ w✝ :: l₂&#10;e₂ : eraseP p l = l₁ ++ l₂&#10;⊢ (eraseP p l).length = l.length - 1" state_after="α✝ : Type u_1&#10;l : List α✝&#10;a : α✝&#10;p : α✝ → Bool&#10;al : a ∈ l&#10;pa : p a = true&#10;w✝ : α✝&#10;l₁ l₂ : List α✝&#10;left✝¹ : ∀ (b : α✝), b ∈ l₁ → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : l = l₁ ++ w✝ :: l₂&#10;e₂ : eraseP p l = l₁ ++ l₂&#10;⊢ (l₁ ++ l₂).length = l.length - 1" tactic="rw [e₂]">
                    <AtomNode start="(93, 3)" end="(93, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(93, 6)" end="(93, 10)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(93, 6)" end="(93, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(93, 7)" end="(93, 9)">
                        <OtherNode start="(93, 7)" end="(93, 9)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(93, 7)" end="(93, 9)" leading="" trailing="" raw_val="e₂" val="e₂"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(93, 9)" end="(93, 10)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(93, 10)" end="(93, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(93, 12)" end="(93, 36)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;l : List α✝&#10;a : α✝&#10;p : α✝ → Bool&#10;al : a ∈ l&#10;pa : p a = true&#10;w✝ : α✝&#10;l₁ l₂ : List α✝&#10;left✝¹ : ∀ (b : α✝), b ∈ l₁ → ¬p b = true&#10;left✝ : p w✝ = true&#10;e₁ : l = l₁ ++ w✝ :: l₂&#10;e₂ : eraseP p l = l₁ ++ l₂&#10;⊢ (l₁ ++ l₂).length = l.length - 1" state_after="no goals" tactic="simp [length_append, e₁]">
                    <AtomNode start="(93, 12)" end="(93, 16)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(93, 17)" end="(93, 36)">
                      <AtomNode start="(93, 17)" end="(93, 18)" leading="" trailing="" val="["/>
                      <NullNode start="(93, 18)" end="(93, 35)">
                        <OtherNode start="(93, 18)" end="(93, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(93, 18)" end="(93, 31)" leading="" trailing="" raw_val="length_append" val="length_append" full_name="List.length_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(93, 31)" end="(93, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(93, 33)" end="(93, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(93, 33)" end="(93, 35)" leading="" trailing="" raw_val="e₁" val="e₁"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(93, 35)" end="(93, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(95, 1)" end="(102, 13)" name="length_eraseP" full_name="List.length_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(95, 1)" end="(102, 13)" name="length_eraseP" full_name="List.length_eraseP" _is_private_decl="False">
        <AtomNode start="(95, 1)" end="(95, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(95, 9)" end="(95, 22)">
          <IdentNode start="(95, 9)" end="(95, 22)" leading="" trailing=" " raw_val="length_eraseP" val="length_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(95, 23)" end="(95, 102)">
          <NullNode start="(95, 23)" end="(95, 35)">
            <OtherNode start="(95, 23)" end="(95, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(95, 23)" end="(95, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(95, 24)" end="(95, 25)">
                <IdentNode start="(95, 24)" end="(95, 25)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(95, 26)" end="(95, 34)">
                <AtomNode start="(95, 26)" end="(95, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 28)" end="(95, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(95, 28)" end="(95, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(95, 33)" end="(95, 34)">
                    <IdentNode start="(95, 33)" end="(95, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(95, 34)" end="(95, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(95, 36)" end="(95, 102)">
            <AtomNode start="(95, 36)" end="(95, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(95, 38)" end="(95, 102)" kind="«term_=_»">
              <OtherNode start="(95, 38)" end="(95, 57)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(95, 38)" end="(95, 50)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(95, 38)" end="(95, 39)" leading="" trailing="" val="("/>
                  <OtherNode start="(95, 39)" end="(95, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(95, 39)" end="(95, 47)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                    <NullNode start="(95, 48)" end="(95, 49)">
                      <IdentNode start="(95, 48)" end="(95, 49)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(95, 49)" end="(95, 50)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(95, 50)" end="(95, 51)" leading="" trailing="" val="."/>
                <IdentNode start="(95, 51)" end="(95, 57)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(95, 58)" end="(95, 59)" leading="" trailing=" " val="="/>
              <OtherNode start="(95, 60)" end="(95, 102)" kind="termIfThenElse">
                <AtomNode start="(95, 60)" end="(95, 62)" leading="" trailing=" " val="if"/>
                <OtherNode start="(95, 63)" end="(95, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(95, 63)" end="(95, 68)" leading="" trailing=" " raw_val="l.any" val="l.any"/>
                  <NullNode start="(95, 69)" end="(95, 70)">
                    <IdentNode start="(95, 69)" end="(95, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(95, 71)" end="(95, 75)" leading="" trailing=" " val="then"/>
                <OtherNode start="(95, 76)" end="(95, 88)" kind="«term_-_»">
                  <IdentNode start="(95, 76)" end="(95, 84)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                  <AtomNode start="(95, 85)" end="(95, 86)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(95, 87)" end="(95, 88)" kind="num">
                    <AtomNode start="(95, 87)" end="(95, 88)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(95, 89)" end="(95, 93)" leading="" trailing=" " val="else"/>
                <IdentNode start="(95, 94)" end="(95, 102)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(95, 103)" end="(102, 13)">
          <AtomNode start="(95, 103)" end="(95, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(95, 106)" end="(102, 13)">
            <AtomNode start="(95, 106)" end="(95, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(96, 3)" end="(102, 13)">
              <TacticTacticseq1IndentedNode start="(96, 3)" end="(102, 13)">
                <NullNode start="(96, 3)" end="(102, 13)">
                  <OtherNode start="(96, 3)" end="(96, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (eraseP p l).length = if l.any p = true then l.length - 1 else l.length" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : l.any p = true&#10;⊢ (eraseP p l).length = l.length - 1&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ (eraseP p l).length = l.length" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(96, 3)" end="(96, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(96, 3)" end="(96, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(96, 9)" end="(96, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(96, 13)" end="(96, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(96, 13)" end="(96, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(96, 22)" end="(96, 23)">
                        <LeanBinderidentNode start="(96, 22)" end="(96, 23)">
                          <IdentNode start="(96, 22)" end="(96, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(97, 3)" end="(99, 36)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : l.any p = true&#10;⊢ (eraseP p l).length = l.length - 1&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ (eraseP p l).length = l.length" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ (eraseP p l).length = l.length" tactic="· simp only [any_eq_true] at h&#10;  obtain ⟨x, m, h⟩ := h&#10;  simp [length_eraseP_of_mem m h]">
                    <OtherNode start="(97, 3)" end="(97, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(97, 3)" end="(97, 4)" kind="patternIgnore">
                        <OtherNode start="(97, 3)" end="(97, 4)" kind="token.«· »">
                          <AtomNode start="(97, 3)" end="(97, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(97, 5)" end="(99, 36)">
                      <TacticTacticseq1IndentedNode start="(97, 5)" end="(99, 36)">
                        <NullNode start="(97, 5)" end="(99, 36)">
                          <OtherNode start="(97, 5)" end="(97, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : l.any p = true&#10;⊢ (eraseP p l).length = l.length - 1" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (eraseP p l).length = l.length - 1" tactic="simp only [any_eq_true] at h">
                            <AtomNode start="(97, 5)" end="(97, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(97, 10)" end="(97, 14)">
                              <AtomNode start="(97, 10)" end="(97, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(97, 15)" end="(97, 28)">
                              <AtomNode start="(97, 15)" end="(97, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(97, 16)" end="(97, 27)">
                                <OtherNode start="(97, 16)" end="(97, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(97, 16)" end="(97, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(97, 27)" end="(97, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(97, 29)" end="(97, 33)">
                              <OtherNode start="(97, 29)" end="(97, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(97, 29)" end="(97, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(97, 32)" end="(97, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(97, 32)" end="(97, 33)">
                                    <IdentNode start="(97, 32)" end="(97, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(98, 5)" end="(98, 26)" kind="Lean.Parser.Tactic.obtain" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (eraseP p l).length = l.length - 1" state_after="case isTrue.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;m : x ∈ l&#10;h : p x = true&#10;⊢ (eraseP p l).length = l.length - 1" tactic="obtain ⟨x, m, h⟩ := h">
                            <AtomNode start="(98, 5)" end="(98, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(98, 12)" end="(98, 21)">
                              <OtherNode start="(98, 12)" end="(98, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(98, 12)" end="(98, 21)">
                                  <OtherNode start="(98, 12)" end="(98, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(98, 12)" end="(98, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(98, 13)" end="(98, 20)">
                                      <OtherNode start="(98, 13)" end="(98, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(98, 13)" end="(98, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(98, 13)" end="(98, 14)">
                                            <OtherNode start="(98, 13)" end="(98, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(98, 13)" end="(98, 14)" leading="" trailing="" raw_val="x" val="x"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(98, 14)" end="(98, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(98, 16)" end="(98, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(98, 16)" end="(98, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(98, 16)" end="(98, 17)">
                                            <OtherNode start="(98, 16)" end="(98, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(98, 16)" end="(98, 17)" leading="" trailing="" raw_val="m" val="m"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(98, 17)" end="(98, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(98, 19)" end="(98, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(98, 19)" end="(98, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(98, 19)" end="(98, 20)">
                                            <OtherNode start="(98, 19)" end="(98, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(98, 19)" end="(98, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(98, 20)" end="(98, 21)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(98, 22)" end="(98, 26)">
                              <AtomNode start="(98, 22)" end="(98, 24)" leading="" trailing=" " val=":="/>
                              <NullNode start="(98, 25)" end="(98, 26)">
                                <IdentNode start="(98, 25)" end="(98, 26)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(99, 5)" end="(99, 36)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;m : x ∈ l&#10;h : p x = true&#10;⊢ (eraseP p l).length = l.length - 1" state_after="no goals" tactic="simp [length_eraseP_of_mem m h]">
                            <AtomNode start="(99, 5)" end="(99, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(99, 10)" end="(99, 36)">
                              <AtomNode start="(99, 10)" end="(99, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(99, 11)" end="(99, 35)">
                                <OtherNode start="(99, 11)" end="(99, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(99, 11)" end="(99, 35)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(99, 11)" end="(99, 31)" leading="" trailing=" " raw_val="length_eraseP_of_mem" val="length_eraseP_of_mem" full_name="List.length_eraseP_of_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(90, 17)" def_end="(90, 37)"/>
                                    <NullNode start="(99, 32)" end="(99, 35)">
                                      <IdentNode start="(99, 32)" end="(99, 33)" leading="" trailing=" " raw_val="m" val="m"/>
                                      <IdentNode start="(99, 34)" end="(99, 35)" leading="" trailing="" raw_val="h" val="h"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(99, 35)" end="(99, 36)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(100, 3)" end="(102, 13)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ (eraseP p l).length = l.length" state_after="no goals" tactic="· simp only [any_eq_true] at h&#10;  rw [eraseP_of_forall_not]&#10;  simp_all">
                    <OtherNode start="(100, 3)" end="(100, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(100, 3)" end="(100, 4)" kind="patternIgnore">
                        <OtherNode start="(100, 3)" end="(100, 4)" kind="token.«· »">
                          <AtomNode start="(100, 3)" end="(100, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(100, 5)" end="(102, 13)">
                      <TacticTacticseq1IndentedNode start="(100, 5)" end="(102, 13)">
                        <NullNode start="(100, 5)" end="(102, 13)">
                          <OtherNode start="(100, 5)" end="(100, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ (eraseP p l).length = l.length" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬∃ x, x ∈ l ∧ p x = true&#10;⊢ (eraseP p l).length = l.length" tactic="simp only [any_eq_true] at h">
                            <AtomNode start="(100, 5)" end="(100, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(100, 10)" end="(100, 14)">
                              <AtomNode start="(100, 10)" end="(100, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(100, 15)" end="(100, 28)">
                              <AtomNode start="(100, 15)" end="(100, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(100, 16)" end="(100, 27)">
                                <OtherNode start="(100, 16)" end="(100, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(100, 16)" end="(100, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(100, 27)" end="(100, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(100, 29)" end="(100, 33)">
                              <OtherNode start="(100, 29)" end="(100, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(100, 29)" end="(100, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(100, 32)" end="(100, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(100, 32)" end="(100, 33)">
                                    <IdentNode start="(100, 32)" end="(100, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(101, 5)" end="(101, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬∃ x, x ∈ l ∧ p x = true&#10;⊢ (eraseP p l).length = l.length" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬∃ x, x ∈ l ∧ p x = true&#10;⊢ ∀ (a : α), a ∈ l → ¬p a = true" tactic="rw [eraseP_of_forall_not]">
                            <AtomNode start="(101, 5)" end="(101, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(101, 8)" end="(101, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(101, 8)" end="(101, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(101, 9)" end="(101, 29)">
                                <OtherNode start="(101, 9)" end="(101, 29)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(101, 9)" end="(101, 29)" leading="" trailing="" raw_val="eraseP_of_forall_not" val="eraseP_of_forall_not" full_name="List.eraseP_of_forall_not" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(37, 9)" def_end="(37, 29)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(101, 29)" end="(101, 30)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(102, 5)" end="(102, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬∃ x, x ∈ l ∧ p x = true&#10;⊢ ∀ (a : α), a ∈ l → ¬p a = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(102, 5)" end="(102, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(104, 1)" end="(107, 56)" name="eraseP_sublist" full_name="List.eraseP_sublist">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(104, 1)" end="(107, 56)" name="eraseP_sublist" full_name="List.eraseP_sublist" _is_private_decl="False">
        <AtomNode start="(104, 1)" end="(104, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(104, 9)" end="(104, 23)">
          <IdentNode start="(104, 9)" end="(104, 23)" leading="" trailing=" " raw_val="eraseP_sublist" val="eraseP_sublist"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(104, 24)" end="(104, 54)">
          <NullNode start="(104, 24)" end="(104, 36)">
            <OtherNode start="(104, 24)" end="(104, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(104, 24)" end="(104, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(104, 25)" end="(104, 26)">
                <IdentNode start="(104, 25)" end="(104, 26)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(104, 27)" end="(104, 35)">
                <AtomNode start="(104, 27)" end="(104, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(104, 29)" end="(104, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(104, 29)" end="(104, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(104, 34)" end="(104, 35)">
                    <IdentNode start="(104, 34)" end="(104, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(104, 35)" end="(104, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(104, 37)" end="(104, 54)">
            <AtomNode start="(104, 37)" end="(104, 38)" leading="" trailing=" " val=":"/>
            <OtherNode start="(104, 39)" end="(104, 54)" kind="List.«term_&amp;lt;+_»">
              <OtherNode start="(104, 39)" end="(104, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(104, 39)" end="(104, 47)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                <NullNode start="(104, 48)" end="(104, 49)">
                  <IdentNode start="(104, 48)" end="(104, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(104, 50)" end="(104, 52)" leading="" trailing=" " val="&amp;lt;+"/>
              <IdentNode start="(104, 53)" end="(104, 54)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(104, 55)" end="(107, 56)">
          <AtomNode start="(104, 55)" end="(104, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(104, 58)" end="(107, 56)">
            <AtomNode start="(104, 58)" end="(104, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(105, 3)" end="(107, 56)">
              <TacticTacticseq1IndentedNode start="(105, 3)" end="(107, 56)">
                <NullNode start="(105, 3)" end="(107, 56)">
                  <OtherNode start="(105, 3)" end="(107, 56)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l &amp;lt;+ l" state_after="no goals" tactic="match exists_or_eq_self_of_eraseP p l with&#10;| .inl h =&amp;gt; rw [h]; apply Sublist.refl&#10;| .inr ⟨c, l₁, l₂, _, _, h₃, h₄⟩ =&amp;gt; rw [h₄, h₃]; simp">
                    <AtomNode start="(105, 3)" end="(105, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(105, 9)" end="(105, 40)">
                      <OtherNode start="(105, 9)" end="(105, 40)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <OtherNode start="(105, 9)" end="(105, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(105, 9)" end="(105, 36)" leading="" trailing=" " raw_val="exists_or_eq_self_of_eraseP" val="exists_or_eq_self_of_eraseP" full_name="List.exists_or_eq_self_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(81, 9)" def_end="(81, 36)"/>
                          <NullNode start="(105, 37)" end="(105, 40)">
                            <IdentNode start="(105, 37)" end="(105, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                            <IdentNode start="(105, 39)" end="(105, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(105, 41)" end="(105, 45)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(106, 3)" end="(107, 56)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(106, 3)" end="(107, 56)">
                        <OtherNode start="(106, 3)" end="(106, 41)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(106, 3)" end="(106, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(106, 5)" end="(106, 11)">
                            <NullNode start="(106, 5)" end="(106, 11)">
                              <OtherNode start="(106, 5)" end="(106, 11)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(106, 5)" end="(106, 9)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(106, 5)" end="(106, 6)" leading="" trailing="" val="."/>
                                  <IdentNode start="(106, 6)" end="(106, 9)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                </OtherNode>
                                <NullNode start="(106, 10)" end="(106, 11)">
                                  <IdentNode start="(106, 10)" end="(106, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(106, 12)" end="(106, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(106, 15)" end="(106, 41)">
                            <TacticTacticseq1IndentedNode start="(106, 15)" end="(106, 41)">
                              <NullNode start="(106, 15)" end="(106, 41)">
                                <OtherNode start="(106, 15)" end="(106, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l &amp;lt;+ l" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ l &amp;lt;+ l" tactic="rw [h]">
                                  <AtomNode start="(106, 15)" end="(106, 17)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(106, 18)" end="(106, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(106, 18)" end="(106, 19)" leading="" trailing="" val="["/>
                                    <NullNode start="(106, 19)" end="(106, 20)">
                                      <OtherNode start="(106, 19)" end="(106, 20)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(106, 19)" end="(106, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(106, 20)" end="(106, 21)" leading="" trailing="" val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(106, 21)" end="(106, 22)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(106, 23)" end="(106, 41)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ l &amp;lt;+ l" state_after="no goals" tactic="apply Sublist.refl">
                                  <AtomNode start="(106, 23)" end="(106, 28)" leading="" trailing=" " val="apply"/>
                                  <IdentNode start="(106, 29)" end="(106, 41)" leading="" trailing="&#10;  " raw_val="Sublist.refl" val="Sublist.refl" full_name="List.Sublist.refl" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(107, 3)" end="(107, 56)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(107, 3)" end="(107, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(107, 5)" end="(107, 35)">
                            <NullNode start="(107, 5)" end="(107, 35)">
                              <OtherNode start="(107, 5)" end="(107, 35)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(107, 5)" end="(107, 9)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(107, 5)" end="(107, 6)" leading="" trailing="" val="."/>
                                  <IdentNode start="(107, 6)" end="(107, 9)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                </OtherNode>
                                <NullNode start="(107, 10)" end="(107, 35)">
                                  <OtherNode start="(107, 10)" end="(107, 35)" kind="Lean.Parser.Term.anonymousCtor">
                                    <AtomNode start="(107, 10)" end="(107, 11)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(107, 11)" end="(107, 34)">
                                      <IdentNode start="(107, 11)" end="(107, 12)" leading="" trailing="" raw_val="c" val="c"/>
                                      <AtomNode start="(107, 12)" end="(107, 13)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(107, 14)" end="(107, 16)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                      <AtomNode start="(107, 16)" end="(107, 17)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(107, 18)" end="(107, 20)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                      <AtomNode start="(107, 20)" end="(107, 21)" leading="" trailing=" " val=","/>
                                      <TermHoleNode start="(107, 22)" end="(107, 23)">
                                        <AtomNode start="(107, 22)" end="(107, 23)" leading="" trailing="" val="_"/>
                                      </TermHoleNode>
                                      <AtomNode start="(107, 23)" end="(107, 24)" leading="" trailing=" " val=","/>
                                      <TermHoleNode start="(107, 25)" end="(107, 26)">
                                        <AtomNode start="(107, 25)" end="(107, 26)" leading="" trailing="" val="_"/>
                                      </TermHoleNode>
                                      <AtomNode start="(107, 26)" end="(107, 27)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(107, 28)" end="(107, 30)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                      <AtomNode start="(107, 30)" end="(107, 31)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(107, 32)" end="(107, 34)" leading="" trailing="" raw_val="h₄" val="h₄"/>
                                    </NullNode>
                                    <AtomNode start="(107, 34)" end="(107, 35)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(107, 36)" end="(107, 38)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(107, 39)" end="(107, 56)">
                            <TacticTacticseq1IndentedNode start="(107, 39)" end="(107, 56)">
                              <NullNode start="(107, 39)" end="(107, 56)">
                                <OtherNode start="(107, 39)" end="(107, 50)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;c : α&#10;l₁ l₂ : List α&#10;left✝¹ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;left✝ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ eraseP p l &amp;lt;+ l" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;c : α&#10;l₁ l₂ : List α&#10;left✝¹ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;left✝ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ &amp;lt;+ l₁ ++ c :: l₂" tactic="rw [h₄, h₃]">
                                  <AtomNode start="(107, 39)" end="(107, 41)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(107, 42)" end="(107, 50)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(107, 42)" end="(107, 43)" leading="" trailing="" val="["/>
                                    <NullNode start="(107, 43)" end="(107, 49)">
                                      <OtherNode start="(107, 43)" end="(107, 45)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(107, 43)" end="(107, 45)" leading="" trailing="" raw_val="h₄" val="h₄"/>
                                      </OtherNode>
                                      <AtomNode start="(107, 45)" end="(107, 46)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(107, 47)" end="(107, 49)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(107, 47)" end="(107, 49)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(107, 49)" end="(107, 50)" leading="" trailing="" val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(107, 50)" end="(107, 51)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(107, 52)" end="(107, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;c : α&#10;l₁ l₂ : List α&#10;left✝¹ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;left✝ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ &amp;lt;+ l₁ ++ c :: l₂" state_after="no goals" tactic="simp">
                                  <AtomNode start="(107, 52)" end="(107, 56)" leading="" trailing="&#10;&#10;" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(109, 1)" end="(109, 77)" name="eraseP_subset" full_name="List.eraseP_subset">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(109, 1)" end="(109, 77)" name="eraseP_subset" full_name="List.eraseP_subset" _is_private_decl="False">
        <AtomNode start="(109, 1)" end="(109, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(109, 9)" end="(109, 22)">
          <IdentNode start="(109, 9)" end="(109, 22)" leading="" trailing=" " raw_val="eraseP_subset" val="eraseP_subset"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(109, 23)" end="(109, 52)">
          <NullNode start="(109, 23)" end="(109, 35)">
            <OtherNode start="(109, 23)" end="(109, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(109, 23)" end="(109, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(109, 24)" end="(109, 25)">
                <IdentNode start="(109, 24)" end="(109, 25)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(109, 26)" end="(109, 34)">
                <AtomNode start="(109, 26)" end="(109, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(109, 28)" end="(109, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(109, 28)" end="(109, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(109, 33)" end="(109, 34)">
                    <IdentNode start="(109, 33)" end="(109, 34)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(109, 34)" end="(109, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(109, 36)" end="(109, 52)">
            <AtomNode start="(109, 36)" end="(109, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(109, 38)" end="(109, 52)" kind="«term_⊆_»">
              <OtherNode start="(109, 38)" end="(109, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(109, 38)" end="(109, 46)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                <NullNode start="(109, 47)" end="(109, 48)">
                  <IdentNode start="(109, 47)" end="(109, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(109, 49)" end="(109, 50)" leading="" trailing=" " val="⊆"/>
              <IdentNode start="(109, 51)" end="(109, 52)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(109, 53)" end="(109, 77)">
          <AtomNode start="(109, 53)" end="(109, 55)" leading="" trailing=" " val=":="/>
          <IdentNode start="(109, 56)" end="(109, 77)" leading="" trailing="&#10;&#10;" raw_val="eraseP_sublist.subset" val="eraseP_sublist.subset"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(111, 1)" end="(120, 31)" name="Sublist.eraseP" full_name="List.Sublist.eraseP">
      <CommandDeclmodifiersNode start="(111, 1)" end="(111, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(111, 1)" end="(111, 10)">
          <OtherNode start="(111, 1)" end="(111, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(111, 1)" end="(111, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(111, 11)" end="(120, 31)" name="Sublist.eraseP" full_name="List.Sublist.eraseP" _is_private_decl="False">
        <AtomNode start="(111, 11)" end="(111, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(111, 19)" end="(111, 33)">
          <IdentNode start="(111, 19)" end="(111, 33)" leading="" trailing=" " raw_val="Sublist.eraseP" val="Sublist.eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(111, 34)" end="(111, 73)">
          <NullNode/>
          <TermTypespecNode start="(111, 34)" end="(111, 73)">
            <AtomNode start="(111, 34)" end="(111, 35)" leading="" trailing=" " val=":"/>
            <OtherNode start="(111, 36)" end="(111, 73)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(111, 36)" end="(111, 44)" kind="List.«term_&amp;lt;+_»">
                <IdentNode start="(111, 36)" end="(111, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <AtomNode start="(111, 39)" end="(111, 41)" leading="" trailing=" " val="&amp;lt;+"/>
                <IdentNode start="(111, 42)" end="(111, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
              <AtomNode start="(111, 45)" end="(111, 46)" leading="" trailing=" " val="→"/>
              <OtherNode start="(111, 47)" end="(111, 73)" kind="List.«term_&amp;lt;+_»">
                <OtherNode start="(111, 47)" end="(111, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(111, 47)" end="(111, 56)" leading="" trailing=" " raw_val="l₁.eraseP" val="l₁.eraseP"/>
                  <NullNode start="(111, 57)" end="(111, 58)">
                    <IdentNode start="(111, 57)" end="(111, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(111, 59)" end="(111, 61)" leading="" trailing=" " val="&amp;lt;+"/>
                <OtherNode start="(111, 62)" end="(111, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(111, 62)" end="(111, 71)" leading="" trailing=" " raw_val="l₂.eraseP" val="l₂.eraseP"/>
                  <NullNode start="(111, 72)" end="(111, 73)">
                    <IdentNode start="(111, 72)" end="(111, 73)" leading="" trailing="&#10;  " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(112, 3)" end="(120, 31)">
          <OtherNode start="(112, 3)" end="(120, 31)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(112, 3)" end="(120, 31)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(112, 3)" end="(120, 31)">
                <OtherNode start="(112, 3)" end="(112, 29)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(112, 3)" end="(112, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(112, 5)" end="(112, 11)">
                    <NullNode start="(112, 5)" end="(112, 11)">
                      <OtherNode start="(112, 5)" end="(112, 11)" kind="Lean.Parser.Term.dotIdent">
                        <AtomNode start="(112, 5)" end="(112, 6)" leading="" trailing="" val="."/>
                        <IdentNode start="(112, 6)" end="(112, 11)" leading="" trailing=" " raw_val="slnil" val="slnil"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(112, 12)" end="(112, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(112, 15)" end="(112, 29)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(112, 15)" end="(112, 27)" leading="" trailing=" " raw_val="Sublist.refl" val="Sublist.refl" full_name="List.Sublist.refl" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                    <NullNode start="(112, 28)" end="(112, 29)">
                      <TermHoleNode start="(112, 28)" end="(112, 29)">
                        <AtomNode start="(112, 28)" end="(112, 29)" leading="" trailing="&#10;  " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(113, 3)" end="(116, 38)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(113, 3)" end="(113, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(113, 5)" end="(113, 14)">
                    <NullNode start="(113, 5)" end="(113, 14)">
                      <OtherNode start="(113, 5)" end="(113, 14)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(113, 5)" end="(113, 10)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(113, 5)" end="(113, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(113, 6)" end="(113, 10)" leading="" trailing=" " raw_val="cons" val="cons"/>
                        </OtherNode>
                        <NullNode start="(113, 11)" end="(113, 14)">
                          <IdentNode start="(113, 11)" end="(113, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(113, 13)" end="(113, 14)" leading="" trailing=" " raw_val="s" val="s"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(113, 15)" end="(113, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(113, 18)" end="(116, 38)">
                    <AtomNode start="(113, 18)" end="(113, 20)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(114, 5)" end="(116, 38)">
                      <TacticTacticseq1IndentedNode start="(114, 5)" end="(116, 38)">
                        <NullNode start="(114, 5)" end="(116, 38)">
                          <OtherNode start="(114, 5)" end="(114, 21)" kind="«tacticBy_cases_:_»" state_before="α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" state_after="case pos&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)&#10;&#10;case neg&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" tactic="by_cases h : p a">
                            <AtomNode start="(114, 5)" end="(114, 13)" leading="" trailing=" " val="by_cases"/>
                            <NullNode start="(114, 14)" end="(114, 17)">
                              <IdentNode start="(114, 14)" end="(114, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                              <AtomNode start="(114, 16)" end="(114, 17)" leading="" trailing=" " val=":"/>
                            </NullNode>
                            <OtherNode start="(114, 18)" end="(114, 21)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(114, 18)" end="(114, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(114, 20)" end="(114, 21)">
                                <IdentNode start="(114, 20)" end="(114, 21)" leading="" trailing="&#10;    " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(115, 5)" end="(115, 52)" kind="Lean.cdot" state_before="case pos&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)&#10;&#10;case neg&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" state_after="case neg&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" tactic="· simpa [h] using s.eraseP.trans eraseP_sublist">
                            <OtherNode start="(115, 5)" end="(115, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(115, 5)" end="(115, 6)" kind="patternIgnore">
                                <OtherNode start="(115, 5)" end="(115, 6)" kind="token.«· »">
                                  <AtomNode start="(115, 5)" end="(115, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(115, 7)" end="(115, 52)">
                              <TacticTacticseq1IndentedNode start="(115, 7)" end="(115, 52)">
                                <NullNode start="(115, 7)" end="(115, 52)">
                                  <OtherNode start="(115, 7)" end="(115, 52)" kind="Lean.Parser.Tactic.simpa" state_before="case pos&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" state_after="no goals" tactic="simpa [h] using s.eraseP.trans eraseP_sublist">
                                    <AtomNode start="(115, 7)" end="(115, 12)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(115, 13)" end="(115, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(115, 13)" end="(115, 16)">
                                        <OtherNode start="(115, 13)" end="(115, 16)" kind="Lean.Parser.Tactic.simpArgs">
                                          <AtomNode start="(115, 13)" end="(115, 14)" leading="" trailing="" val="["/>
                                          <NullNode start="(115, 14)" end="(115, 15)">
                                            <OtherNode start="(115, 14)" end="(115, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(115, 14)" end="(115, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(115, 15)" end="(115, 16)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(115, 17)" end="(115, 52)">
                                        <AtomNode start="(115, 17)" end="(115, 22)" leading="" trailing=" " val="using"/>
                                        <OtherNode start="(115, 23)" end="(115, 52)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(115, 23)" end="(115, 37)" leading="" trailing=" " raw_val="s.eraseP.trans" val="s.eraseP.trans"/>
                                          <NullNode start="(115, 38)" end="(115, 52)">
                                            <IdentNode start="(115, 38)" end="(115, 52)" leading="" trailing="&#10;    " raw_val="eraseP_sublist" val="eraseP_sublist" full_name="List.eraseP_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(104, 9)" def_end="(104, 23)"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(116, 5)" end="(116, 38)" kind="Lean.cdot" state_before="case neg&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" state_after="no goals" tactic="· simpa [h] using s.eraseP.cons _">
                            <OtherNode start="(116, 5)" end="(116, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(116, 5)" end="(116, 6)" kind="patternIgnore">
                                <OtherNode start="(116, 5)" end="(116, 6)" kind="token.«· »">
                                  <AtomNode start="(116, 5)" end="(116, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(116, 7)" end="(116, 38)">
                              <TacticTacticseq1IndentedNode start="(116, 7)" end="(116, 38)">
                                <NullNode start="(116, 7)" end="(116, 38)">
                                  <OtherNode start="(116, 7)" end="(116, 38)" kind="Lean.Parser.Tactic.simpa" state_before="case neg&#10;α✝ : Type u_1&#10;l₁✝ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p l₁ &amp;lt;+ eraseP p (a :: l₂✝)" state_after="no goals" tactic="simpa [h] using s.eraseP.cons _">
                                    <AtomNode start="(116, 7)" end="(116, 12)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(116, 13)" end="(116, 38)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(116, 13)" end="(116, 16)">
                                        <OtherNode start="(116, 13)" end="(116, 16)" kind="Lean.Parser.Tactic.simpArgs">
                                          <AtomNode start="(116, 13)" end="(116, 14)" leading="" trailing="" val="["/>
                                          <NullNode start="(116, 14)" end="(116, 15)">
                                            <OtherNode start="(116, 14)" end="(116, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(116, 14)" end="(116, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(116, 15)" end="(116, 16)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(116, 17)" end="(116, 38)">
                                        <AtomNode start="(116, 17)" end="(116, 22)" leading="" trailing=" " val="using"/>
                                        <OtherNode start="(116, 23)" end="(116, 38)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(116, 23)" end="(116, 36)" leading="" trailing=" " raw_val="s.eraseP.cons" val="s.eraseP.cons"/>
                                          <NullNode start="(116, 37)" end="(116, 38)">
                                            <TermHoleNode start="(116, 37)" end="(116, 38)">
                                              <AtomNode start="(116, 37)" end="(116, 38)" leading="" trailing="&#10;  " val="_"/>
                                            </TermHoleNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(117, 3)" end="(120, 31)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(117, 3)" end="(117, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(117, 5)" end="(117, 15)">
                    <NullNode start="(117, 5)" end="(117, 15)">
                      <OtherNode start="(117, 5)" end="(117, 15)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(117, 5)" end="(117, 11)" kind="Lean.Parser.Term.dotIdent">
                          <AtomNode start="(117, 5)" end="(117, 6)" leading="" trailing="" val="."/>
                          <IdentNode start="(117, 6)" end="(117, 11)" leading="" trailing=" " raw_val="cons₂" val="cons₂"/>
                        </OtherNode>
                        <NullNode start="(117, 12)" end="(117, 15)">
                          <IdentNode start="(117, 12)" end="(117, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(117, 14)" end="(117, 15)" leading="" trailing=" " raw_val="s" val="s"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(117, 16)" end="(117, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(117, 19)" end="(120, 31)">
                    <AtomNode start="(117, 19)" end="(117, 21)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(118, 5)" end="(120, 31)">
                      <TacticTacticseq1IndentedNode start="(118, 5)" end="(120, 31)">
                        <NullNode start="(118, 5)" end="(120, 31)">
                          <OtherNode start="(118, 5)" end="(118, 21)" kind="«tacticBy_cases_:_»" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" state_after="case pos&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)&#10;&#10;case neg&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" tactic="by_cases h : p a">
                            <AtomNode start="(118, 5)" end="(118, 13)" leading="" trailing=" " val="by_cases"/>
                            <NullNode start="(118, 14)" end="(118, 17)">
                              <IdentNode start="(118, 14)" end="(118, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                              <AtomNode start="(118, 16)" end="(118, 17)" leading="" trailing=" " val=":"/>
                            </NullNode>
                            <OtherNode start="(118, 18)" end="(118, 21)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(118, 18)" end="(118, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(118, 20)" end="(118, 21)">
                                <IdentNode start="(118, 20)" end="(118, 21)" leading="" trailing="&#10;    " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(119, 5)" end="(119, 24)" kind="Lean.cdot" state_before="case pos&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)&#10;&#10;case neg&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" state_after="case neg&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" tactic="· simpa [h] using s">
                            <OtherNode start="(119, 5)" end="(119, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(119, 5)" end="(119, 6)" kind="patternIgnore">
                                <OtherNode start="(119, 5)" end="(119, 6)" kind="token.«· »">
                                  <AtomNode start="(119, 5)" end="(119, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(119, 7)" end="(119, 24)">
                              <TacticTacticseq1IndentedNode start="(119, 7)" end="(119, 24)">
                                <NullNode start="(119, 7)" end="(119, 24)">
                                  <OtherNode start="(119, 7)" end="(119, 24)" kind="Lean.Parser.Tactic.simpa" state_before="case pos&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" state_after="no goals" tactic="simpa [h] using s">
                                    <AtomNode start="(119, 7)" end="(119, 12)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(119, 13)" end="(119, 24)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(119, 13)" end="(119, 16)">
                                        <OtherNode start="(119, 13)" end="(119, 16)" kind="Lean.Parser.Tactic.simpArgs">
                                          <AtomNode start="(119, 13)" end="(119, 14)" leading="" trailing="" val="["/>
                                          <NullNode start="(119, 14)" end="(119, 15)">
                                            <OtherNode start="(119, 14)" end="(119, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(119, 14)" end="(119, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(119, 15)" end="(119, 16)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(119, 17)" end="(119, 24)">
                                        <AtomNode start="(119, 17)" end="(119, 22)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(119, 23)" end="(119, 24)" leading="" trailing="&#10;    " raw_val="s" val="s"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(120, 5)" end="(120, 31)" kind="Lean.cdot" state_before="case neg&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" state_after="no goals" tactic="· simpa [h] using s.eraseP">
                            <OtherNode start="(120, 5)" end="(120, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(120, 5)" end="(120, 6)" kind="patternIgnore">
                                <OtherNode start="(120, 5)" end="(120, 6)" kind="token.«· »">
                                  <AtomNode start="(120, 5)" end="(120, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(120, 7)" end="(120, 31)">
                              <TacticTacticseq1IndentedNode start="(120, 7)" end="(120, 31)">
                                <NullNode start="(120, 7)" end="(120, 31)">
                                  <OtherNode start="(120, 7)" end="(120, 31)" kind="Lean.Parser.Tactic.simpa" state_before="case neg&#10;α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;l₁✝ l₂✝ : List α✝&#10;a : α✝&#10;s : l₁✝ &amp;lt;+ l₂✝&#10;h : ¬p a = true&#10;⊢ eraseP p (a :: l₁✝) &amp;lt;+ eraseP p (a :: l₂✝)" state_after="no goals" tactic="simpa [h] using s.eraseP">
                                    <AtomNode start="(120, 7)" end="(120, 12)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(120, 13)" end="(120, 31)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(120, 13)" end="(120, 16)">
                                        <OtherNode start="(120, 13)" end="(120, 16)" kind="Lean.Parser.Tactic.simpArgs">
                                          <AtomNode start="(120, 13)" end="(120, 14)" leading="" trailing="" val="["/>
                                          <NullNode start="(120, 14)" end="(120, 15)">
                                            <OtherNode start="(120, 14)" end="(120, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(120, 14)" end="(120, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(120, 15)" end="(120, 16)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode start="(120, 17)" end="(120, 31)">
                                        <AtomNode start="(120, 17)" end="(120, 22)" leading="" trailing=" " val="using"/>
                                        <IdentNode start="(120, 23)" end="(120, 31)" leading="" trailing="&#10;&#10;" raw_val="s.eraseP" val="s.eraseP"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(122, 1)" end="(123, 27)" name="length_eraseP_le" full_name="List.length_eraseP_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(122, 1)" end="(123, 27)" name="length_eraseP_le" full_name="List.length_eraseP_le" _is_private_decl="False">
        <AtomNode start="(122, 1)" end="(122, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(122, 9)" end="(122, 25)">
          <IdentNode start="(122, 9)" end="(122, 25)" leading="" trailing=" " raw_val="length_eraseP_le" val="length_eraseP_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(122, 26)" end="(122, 71)">
          <NullNode start="(122, 26)" end="(122, 38)">
            <OtherNode start="(122, 26)" end="(122, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(122, 26)" end="(122, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(122, 27)" end="(122, 28)">
                <IdentNode start="(122, 27)" end="(122, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(122, 29)" end="(122, 37)">
                <AtomNode start="(122, 29)" end="(122, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(122, 31)" end="(122, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(122, 31)" end="(122, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(122, 36)" end="(122, 37)">
                    <IdentNode start="(122, 36)" end="(122, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(122, 37)" end="(122, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(122, 39)" end="(122, 71)">
            <AtomNode start="(122, 39)" end="(122, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(122, 41)" end="(122, 71)" kind="«term_≤_»">
              <OtherNode start="(122, 41)" end="(122, 60)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(122, 41)" end="(122, 53)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(122, 41)" end="(122, 42)" leading="" trailing="" val="("/>
                  <OtherNode start="(122, 42)" end="(122, 52)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(122, 42)" end="(122, 50)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                    <NullNode start="(122, 51)" end="(122, 52)">
                      <IdentNode start="(122, 51)" end="(122, 52)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(122, 52)" end="(122, 53)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(122, 53)" end="(122, 54)" leading="" trailing="" val="."/>
                <IdentNode start="(122, 54)" end="(122, 60)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(122, 61)" end="(122, 62)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(122, 63)" end="(122, 71)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(122, 72)" end="(123, 27)">
          <AtomNode start="(122, 72)" end="(122, 74)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(123, 3)" end="(123, 27)" leading="" trailing="&#10;&#10;" raw_val="eraseP_sublist.length_le" val="eraseP_sublist.length_le"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(125, 1)" end="(127, 17)" name="le_length_eraseP" full_name="List.le_length_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(125, 1)" end="(127, 17)" name="le_length_eraseP" full_name="List.le_length_eraseP" _is_private_decl="False">
        <AtomNode start="(125, 1)" end="(125, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(125, 9)" end="(125, 25)">
          <IdentNode start="(125, 9)" end="(125, 25)" leading="" trailing=" " raw_val="le_length_eraseP" val="le_length_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(125, 26)" end="(125, 75)">
          <NullNode start="(125, 26)" end="(125, 38)">
            <OtherNode start="(125, 26)" end="(125, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 26)" end="(125, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 27)" end="(125, 28)">
                <IdentNode start="(125, 27)" end="(125, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(125, 29)" end="(125, 37)">
                <AtomNode start="(125, 29)" end="(125, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(125, 31)" end="(125, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(125, 31)" end="(125, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(125, 36)" end="(125, 37)">
                    <IdentNode start="(125, 36)" end="(125, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(125, 37)" end="(125, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(125, 39)" end="(125, 75)">
            <AtomNode start="(125, 39)" end="(125, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(125, 41)" end="(125, 75)" kind="«term_≤_»">
              <OtherNode start="(125, 41)" end="(125, 53)" kind="«term_-_»">
                <IdentNode start="(125, 41)" end="(125, 49)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                <AtomNode start="(125, 50)" end="(125, 51)" leading="" trailing=" " val="-"/>
                <OtherNode start="(125, 52)" end="(125, 53)" kind="num">
                  <AtomNode start="(125, 52)" end="(125, 53)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(125, 54)" end="(125, 55)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(125, 56)" end="(125, 75)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(125, 56)" end="(125, 68)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(125, 56)" end="(125, 57)" leading="" trailing="" val="("/>
                  <OtherNode start="(125, 57)" end="(125, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(125, 57)" end="(125, 65)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                    <NullNode start="(125, 66)" end="(125, 67)">
                      <IdentNode start="(125, 66)" end="(125, 67)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(125, 67)" end="(125, 68)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(125, 68)" end="(125, 69)" leading="" trailing="" val="."/>
                <IdentNode start="(125, 69)" end="(125, 75)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(125, 76)" end="(127, 17)">
          <AtomNode start="(125, 76)" end="(125, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(125, 79)" end="(127, 17)">
            <AtomNode start="(125, 79)" end="(125, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(126, 3)" end="(127, 17)">
              <TacticTacticseq1IndentedNode start="(126, 3)" end="(127, 17)">
                <NullNode start="(126, 3)" end="(127, 17)">
                  <OtherNode start="(126, 3)" end="(126, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ l.length - 1 ≤ (eraseP p l).length" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ l.length - 1 ≤ if l.any p = true then l.length - 1 else l.length" tactic="rw [length_eraseP]">
                    <AtomNode start="(126, 3)" end="(126, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(126, 6)" end="(126, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(126, 6)" end="(126, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(126, 7)" end="(126, 20)">
                        <OtherNode start="(126, 7)" end="(126, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(126, 7)" end="(126, 20)" leading="" trailing="" raw_val="length_eraseP" val="length_eraseP" full_name="List.length_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(126, 20)" end="(126, 21)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(127, 3)" end="(127, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ l.length - 1 ≤ if l.any p = true then l.length - 1 else l.length" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(127, 3)" end="(127, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(127, 3)" end="(127, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(127, 9)" end="(127, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(127, 13)" end="(127, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(127, 13)" end="(127, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(129, 1)" end="(129, 85)" name="mem_of_mem_eraseP" full_name="List.mem_of_mem_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(129, 1)" end="(129, 85)" name="mem_of_mem_eraseP" full_name="List.mem_of_mem_eraseP" _is_private_decl="False">
        <AtomNode start="(129, 1)" end="(129, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(129, 9)" end="(129, 26)">
          <IdentNode start="(129, 9)" end="(129, 26)" leading="" trailing=" " raw_val="mem_of_mem_eraseP" val="mem_of_mem_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(129, 27)" end="(129, 64)">
          <NullNode start="(129, 27)" end="(129, 39)">
            <OtherNode start="(129, 27)" end="(129, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(129, 27)" end="(129, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(129, 28)" end="(129, 29)">
                <IdentNode start="(129, 28)" end="(129, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(129, 30)" end="(129, 38)">
                <AtomNode start="(129, 30)" end="(129, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 32)" end="(129, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 32)" end="(129, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(129, 37)" end="(129, 38)">
                    <IdentNode start="(129, 37)" end="(129, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(129, 38)" end="(129, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(129, 40)" end="(129, 64)">
            <AtomNode start="(129, 40)" end="(129, 41)" leading="" trailing=" " val=":"/>
            <OtherNode start="(129, 42)" end="(129, 64)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(129, 42)" end="(129, 56)" kind="«term_∈_»">
                <IdentNode start="(129, 42)" end="(129, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(129, 44)" end="(129, 45)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(129, 46)" end="(129, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 46)" end="(129, 54)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(129, 55)" end="(129, 56)">
                    <IdentNode start="(129, 55)" end="(129, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(129, 57)" end="(129, 58)" leading="" trailing=" " val="→"/>
              <OtherNode start="(129, 59)" end="(129, 64)" kind="«term_∈_»">
                <IdentNode start="(129, 59)" end="(129, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(129, 61)" end="(129, 62)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(129, 63)" end="(129, 64)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(129, 65)" end="(129, 85)">
          <AtomNode start="(129, 65)" end="(129, 67)" leading="" trailing=" " val=":="/>
          <OtherNode start="(129, 68)" end="(129, 85)" kind="Lean.Parser.Term.paren">
            <AtomNode start="(129, 68)" end="(129, 69)" leading="" trailing="" val="("/>
            <OtherNode start="(129, 69)" end="(129, 84)" kind="Lean.Parser.Term.app">
              <IdentNode start="(129, 69)" end="(129, 82)" leading="" trailing=" " raw_val="eraseP_subset" val="eraseP_subset" full_name="List.eraseP_subset" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(109, 9)" def_end="(109, 22)"/>
              <NullNode start="(129, 83)" end="(129, 84)">
                <OtherNode start="(129, 83)" end="(129, 84)" kind="Lean.Parser.Term.cdot">
                  <AtomNode start="(129, 83)" end="(129, 84)" leading="" trailing="" val="·"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(129, 84)" end="(129, 85)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(131, 1)" end="(138, 33)" name="mem_eraseP_of_neg" full_name="List.mem_eraseP_of_neg">
      <CommandDeclmodifiersNode start="(131, 1)" end="(131, 8)">
        <NullNode/>
        <NullNode start="(131, 1)" end="(131, 8)">
          <OtherNode start="(131, 1)" end="(131, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(131, 1)" end="(131, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(131, 3)" end="(131, 7)">
              <OtherNode start="(131, 3)" end="(131, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(131, 3)" end="(131, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(131, 3)" end="(131, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(131, 7)" end="(131, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(131, 9)" end="(138, 33)" name="mem_eraseP_of_neg" full_name="List.mem_eraseP_of_neg" _is_private_decl="False">
        <AtomNode start="(131, 9)" end="(131, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(131, 17)" end="(131, 34)">
          <IdentNode start="(131, 17)" end="(131, 34)" leading="" trailing=" " raw_val="mem_eraseP_of_neg" val="mem_eraseP_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(131, 35)" end="(131, 84)">
          <NullNode start="(131, 35)" end="(131, 59)">
            <OtherNode start="(131, 35)" end="(131, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(131, 35)" end="(131, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(131, 36)" end="(131, 37)">
                <IdentNode start="(131, 36)" end="(131, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(131, 38)" end="(131, 46)">
                <AtomNode start="(131, 38)" end="(131, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(131, 40)" end="(131, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(131, 40)" end="(131, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(131, 45)" end="(131, 46)">
                    <IdentNode start="(131, 45)" end="(131, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(131, 46)" end="(131, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(131, 48)" end="(131, 59)">
              <AtomNode start="(131, 48)" end="(131, 49)" leading="" trailing="" val="("/>
              <NullNode start="(131, 49)" end="(131, 51)">
                <IdentNode start="(131, 49)" end="(131, 51)" leading="" trailing=" " raw_val="pa" val="pa"/>
              </NullNode>
              <NullNode start="(131, 52)" end="(131, 58)">
                <AtomNode start="(131, 52)" end="(131, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(131, 54)" end="(131, 58)" kind="«term¬_»">
                  <AtomNode start="(131, 54)" end="(131, 55)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(131, 55)" end="(131, 58)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(131, 55)" end="(131, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(131, 57)" end="(131, 58)">
                      <IdentNode start="(131, 57)" end="(131, 58)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(131, 58)" end="(131, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(131, 60)" end="(131, 84)">
            <AtomNode start="(131, 60)" end="(131, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(131, 62)" end="(131, 84)" kind="«term_↔_»">
              <OtherNode start="(131, 62)" end="(131, 76)" kind="«term_∈_»">
                <IdentNode start="(131, 62)" end="(131, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(131, 64)" end="(131, 65)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(131, 66)" end="(131, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(131, 66)" end="(131, 74)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(131, 75)" end="(131, 76)">
                    <IdentNode start="(131, 75)" end="(131, 76)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(131, 77)" end="(131, 78)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(131, 79)" end="(131, 84)" kind="«term_∈_»">
                <IdentNode start="(131, 79)" end="(131, 80)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(131, 81)" end="(131, 82)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(131, 83)" end="(131, 84)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(131, 85)" end="(138, 33)">
          <AtomNode start="(131, 85)" end="(131, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(131, 88)" end="(138, 33)">
            <AtomNode start="(131, 88)" end="(131, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(132, 3)" end="(138, 33)">
              <TacticTacticseq1IndentedNode start="(132, 3)" end="(138, 33)">
                <NullNode start="(132, 3)" end="(138, 33)">
                  <OtherNode start="(132, 3)" end="(132, 43)" kind="Lean.Parser.Tactic.refine" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;⊢ a ∈ eraseP p l ↔ a ∈ l" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;⊢ a ∈ eraseP p l" tactic="refine ⟨mem_of_mem_eraseP, fun al =&amp;gt; ?_⟩">
                    <AtomNode start="(132, 3)" end="(132, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(132, 10)" end="(132, 43)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(132, 10)" end="(132, 11)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(132, 11)" end="(132, 42)">
                        <IdentNode start="(132, 11)" end="(132, 28)" leading="" trailing="" raw_val="mem_of_mem_eraseP" val="mem_of_mem_eraseP" full_name="List.mem_of_mem_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(129, 9)" def_end="(129, 26)"/>
                        <AtomNode start="(132, 28)" end="(132, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(132, 30)" end="(132, 42)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(132, 30)" end="(132, 33)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(132, 34)" end="(132, 42)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(132, 34)" end="(132, 36)">
                              <IdentNode start="(132, 34)" end="(132, 36)" leading="" trailing=" " raw_val="al" val="al"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(132, 37)" end="(132, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(132, 40)" end="(132, 42)" kind="Lean.Parser.Term.syntheticHole">
                              <AtomNode start="(132, 40)" end="(132, 41)" leading="" trailing="" val="?"/>
                              <AtomNode start="(132, 41)" end="(132, 42)" leading="" trailing="" val="_"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(132, 42)" end="(132, 43)" leading="" trailing="&#10;  " val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(133, 3)" end="(138, 33)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;⊢ a ∈ eraseP p l" state_after="no goals" tactic="match exists_or_eq_self_of_eraseP p l with&#10;| .inl h =&amp;gt; rw [h]; assumption&#10;| .inr ⟨c, l₁, l₂, h₁, h₂, h₃, h₄⟩ =&amp;gt;&#10;  rw [h₄]; rw [h₃] at al&#10;  have : a ≠ c := fun h =&amp;gt; (h ▸ pa).elim h₂&#10;  simp [this] at al; simp [al]">
                    <AtomNode start="(133, 3)" end="(133, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(133, 9)" end="(133, 40)">
                      <OtherNode start="(133, 9)" end="(133, 40)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <OtherNode start="(133, 9)" end="(133, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(133, 9)" end="(133, 36)" leading="" trailing=" " raw_val="exists_or_eq_self_of_eraseP" val="exists_or_eq_self_of_eraseP" full_name="List.exists_or_eq_self_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(81, 9)" def_end="(81, 36)"/>
                          <NullNode start="(133, 37)" end="(133, 40)">
                            <IdentNode start="(133, 37)" end="(133, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                            <IdentNode start="(133, 39)" end="(133, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(133, 41)" end="(133, 45)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(134, 3)" end="(138, 33)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(134, 3)" end="(138, 33)">
                        <OtherNode start="(134, 3)" end="(134, 33)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(134, 3)" end="(134, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(134, 5)" end="(134, 11)">
                            <NullNode start="(134, 5)" end="(134, 11)">
                              <OtherNode start="(134, 5)" end="(134, 11)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(134, 5)" end="(134, 9)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(134, 5)" end="(134, 6)" leading="" trailing="" val="."/>
                                  <IdentNode start="(134, 6)" end="(134, 9)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                </OtherNode>
                                <NullNode start="(134, 10)" end="(134, 11)">
                                  <IdentNode start="(134, 10)" end="(134, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(134, 12)" end="(134, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(134, 15)" end="(134, 33)">
                            <TacticTacticseq1IndentedNode start="(134, 15)" end="(134, 33)">
                              <NullNode start="(134, 15)" end="(134, 33)">
                                <OtherNode start="(134, 15)" end="(134, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;h : eraseP p l = l&#10;⊢ a ∈ eraseP p l" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;h : eraseP p l = l&#10;⊢ a ∈ l" tactic="rw [h]">
                                  <AtomNode start="(134, 15)" end="(134, 17)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(134, 18)" end="(134, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(134, 18)" end="(134, 19)" leading="" trailing="" val="["/>
                                    <NullNode start="(134, 19)" end="(134, 20)">
                                      <OtherNode start="(134, 19)" end="(134, 20)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(134, 19)" end="(134, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(134, 20)" end="(134, 21)" leading="" trailing="" val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(134, 21)" end="(134, 22)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(134, 23)" end="(134, 33)" kind="Lean.Parser.Tactic.assumption" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;h : eraseP p l = l&#10;⊢ a ∈ l" state_after="no goals" tactic="assumption">
                                  <AtomNode start="(134, 23)" end="(134, 33)" leading="" trailing="&#10;  " val="assumption"/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(135, 3)" end="(138, 33)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(135, 3)" end="(135, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(135, 5)" end="(135, 37)">
                            <NullNode start="(135, 5)" end="(135, 37)">
                              <OtherNode start="(135, 5)" end="(135, 37)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(135, 5)" end="(135, 9)" kind="Lean.Parser.Term.dotIdent">
                                  <AtomNode start="(135, 5)" end="(135, 6)" leading="" trailing="" val="."/>
                                  <IdentNode start="(135, 6)" end="(135, 9)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                </OtherNode>
                                <NullNode start="(135, 10)" end="(135, 37)">
                                  <OtherNode start="(135, 10)" end="(135, 37)" kind="Lean.Parser.Term.anonymousCtor">
                                    <AtomNode start="(135, 10)" end="(135, 11)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(135, 11)" end="(135, 36)">
                                      <IdentNode start="(135, 11)" end="(135, 12)" leading="" trailing="" raw_val="c" val="c"/>
                                      <AtomNode start="(135, 12)" end="(135, 13)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(135, 14)" end="(135, 16)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                      <AtomNode start="(135, 16)" end="(135, 17)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(135, 18)" end="(135, 20)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                      <AtomNode start="(135, 20)" end="(135, 21)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(135, 22)" end="(135, 24)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                      <AtomNode start="(135, 24)" end="(135, 25)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(135, 26)" end="(135, 28)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      <AtomNode start="(135, 28)" end="(135, 29)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(135, 30)" end="(135, 32)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                      <AtomNode start="(135, 32)" end="(135, 33)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(135, 34)" end="(135, 36)" leading="" trailing="" raw_val="h₄" val="h₄"/>
                                    </NullNode>
                                    <AtomNode start="(135, 36)" end="(135, 37)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(135, 38)" end="(135, 40)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(136, 5)" end="(138, 33)">
                            <TacticTacticseq1IndentedNode start="(136, 5)" end="(138, 33)">
                              <NullNode start="(136, 5)" end="(138, 33)">
                                <OtherNode start="(136, 5)" end="(136, 12)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ a ∈ eraseP p l" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ a ∈ l₁ ++ l₂" tactic="rw [h₄]">
                                  <AtomNode start="(136, 5)" end="(136, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(136, 8)" end="(136, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(136, 8)" end="(136, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(136, 9)" end="(136, 11)">
                                      <OtherNode start="(136, 9)" end="(136, 11)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(136, 9)" end="(136, 11)" leading="" trailing="" raw_val="h₄" val="h₄"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(136, 11)" end="(136, 12)" leading="" trailing="" val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(136, 12)" end="(136, 13)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(136, 14)" end="(136, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;al : a ∈ l&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ a ∈ l₁ ++ l₂" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;c : α&#10;l₁ l₂ : List α&#10;al : a ∈ l₁ ++ c :: l₂&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ a ∈ l₁ ++ l₂" tactic="rw [h₃] at al">
                                  <AtomNode start="(136, 14)" end="(136, 16)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(136, 17)" end="(136, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(136, 17)" end="(136, 18)" leading="" trailing="" val="["/>
                                    <NullNode start="(136, 18)" end="(136, 20)">
                                      <OtherNode start="(136, 18)" end="(136, 20)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(136, 18)" end="(136, 20)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(136, 20)" end="(136, 21)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                  <NullNode start="(136, 22)" end="(136, 27)">
                                    <OtherNode start="(136, 22)" end="(136, 27)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(136, 22)" end="(136, 24)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(136, 25)" end="(136, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(136, 25)" end="(136, 27)">
                                          <IdentNode start="(136, 25)" end="(136, 27)" leading="" trailing="&#10;    " raw_val="al" val="al"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(137, 5)" end="(137, 46)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;c : α&#10;l₁ l₂ : List α&#10;al : a ∈ l₁ ++ c :: l₂&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;⊢ a ∈ l₁ ++ l₂" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;c : α&#10;l₁ l₂ : List α&#10;al : a ∈ l₁ ++ c :: l₂&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;this : a ≠ c&#10;⊢ a ∈ l₁ ++ l₂" tactic="have : a ≠ c := fun h =&amp;gt; (h ▸ pa).elim h₂">
                                  <AtomNode start="(137, 5)" end="(137, 9)" leading="" trailing=" " val="have"/>
                                  <OtherNode start="(137, 10)" end="(137, 46)" kind="Lean.Parser.Term.haveDecl">
                                    <OtherNode start="(137, 10)" end="(137, 46)" kind="Lean.Parser.Term.haveIdDecl">
                                      <OtherNode start="(137, 10)" end="(137, 10)" kind="Lean.Parser.Term.haveId">
                                        <OtherNode start="(137, 10)" end="(137, 10)" kind="hygieneInfo">
                                          <IdentNode start="(137, 10)" end="(137, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(137, 10)" end="(137, 17)">
                                        <TermTypespecNode start="(137, 10)" end="(137, 17)">
                                          <AtomNode start="(137, 10)" end="(137, 11)" leading="" trailing=" " val=":"/>
                                          <OtherNode start="(137, 12)" end="(137, 17)" kind="«term_≠_»">
                                            <IdentNode start="(137, 12)" end="(137, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                                            <AtomNode start="(137, 14)" end="(137, 15)" leading="" trailing=" " val="≠"/>
                                            <IdentNode start="(137, 16)" end="(137, 17)" leading="" trailing=" " raw_val="c" val="c"/>
                                          </OtherNode>
                                        </TermTypespecNode>
                                      </NullNode>
                                      <AtomNode start="(137, 18)" end="(137, 20)" leading="" trailing=" " val=":="/>
                                      <OtherNode start="(137, 21)" end="(137, 46)" kind="Lean.Parser.Term.fun">
                                        <AtomNode start="(137, 21)" end="(137, 24)" leading="" trailing=" " val="fun"/>
                                        <OtherNode start="(137, 25)" end="(137, 46)" kind="Lean.Parser.Term.basicFun">
                                          <NullNode start="(137, 25)" end="(137, 26)">
                                            <IdentNode start="(137, 25)" end="(137, 26)" leading="" trailing=" " raw_val="h" val="h"/>
                                          </NullNode>
                                          <NullNode/>
                                          <AtomNode start="(137, 27)" end="(137, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                                          <OtherNode start="(137, 30)" end="(137, 46)" kind="Lean.Parser.Term.app">
                                            <OtherNode start="(137, 30)" end="(137, 43)" kind="Lean.Parser.Term.proj">
                                              <OtherNode start="(137, 30)" end="(137, 38)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(137, 30)" end="(137, 31)" leading="" trailing="" val="("/>
                                                <OtherNode start="(137, 31)" end="(137, 37)" kind="Lean.Parser.Term.subst">
                                                  <IdentNode start="(137, 31)" end="(137, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                                                  <AtomNode start="(137, 33)" end="(137, 34)" leading="" trailing=" " val="▸"/>
                                                  <NullNode start="(137, 35)" end="(137, 37)">
                                                    <IdentNode start="(137, 35)" end="(137, 37)" leading="" trailing="" raw_val="pa" val="pa"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(137, 37)" end="(137, 38)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                              <AtomNode start="(137, 38)" end="(137, 39)" leading="" trailing="" val="."/>
                                              <IdentNode start="(137, 39)" end="(137, 43)" leading="" trailing=" " raw_val="elim" val="elim" full_name="Not.elim" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            </OtherNode>
                                            <NullNode start="(137, 44)" end="(137, 46)">
                                              <IdentNode start="(137, 44)" end="(137, 46)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(138, 5)" end="(138, 22)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;c : α&#10;l₁ l₂ : List α&#10;al : a ∈ l₁ ++ c :: l₂&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;this : a ≠ c&#10;⊢ a ∈ l₁ ++ l₂" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;this : a ≠ c&#10;al : a ∈ l₁ ∨ a ∈ l₂&#10;⊢ a ∈ l₁ ++ l₂" tactic="simp [this] at al">
                                  <AtomNode start="(138, 5)" end="(138, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(138, 10)" end="(138, 16)">
                                    <AtomNode start="(138, 10)" end="(138, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(138, 11)" end="(138, 15)">
                                      <OtherNode start="(138, 11)" end="(138, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(138, 11)" end="(138, 15)" leading="" trailing="" raw_val="this" val="this"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(138, 15)" end="(138, 16)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(138, 17)" end="(138, 22)">
                                    <OtherNode start="(138, 17)" end="(138, 22)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(138, 17)" end="(138, 19)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(138, 20)" end="(138, 22)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(138, 20)" end="(138, 22)">
                                          <IdentNode start="(138, 20)" end="(138, 22)" leading="" trailing="" raw_val="al" val="al"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(138, 22)" end="(138, 23)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(138, 24)" end="(138, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l : List α&#10;pa : ¬p a = true&#10;c : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p c = true&#10;h₃ : l = l₁ ++ c :: l₂&#10;h₄ : eraseP p l = l₁ ++ l₂&#10;this : a ≠ c&#10;al : a ∈ l₁ ∨ a ∈ l₂&#10;⊢ a ∈ l₁ ++ l₂" state_after="no goals" tactic="simp [al]">
                                  <AtomNode start="(138, 24)" end="(138, 28)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(138, 29)" end="(138, 33)">
                                    <AtomNode start="(138, 29)" end="(138, 30)" leading="" trailing="" val="["/>
                                    <NullNode start="(138, 30)" end="(138, 32)">
                                      <OtherNode start="(138, 30)" end="(138, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(138, 30)" end="(138, 32)" leading="" trailing="" raw_val="al" val="al"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(138, 32)" end="(138, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(140, 1)" end="(147, 13)" name="eraseP_eq_self_iff" full_name="List.eraseP_eq_self_iff">
      <CommandDeclmodifiersNode start="(140, 1)" end="(140, 8)">
        <NullNode/>
        <NullNode start="(140, 1)" end="(140, 8)">
          <OtherNode start="(140, 1)" end="(140, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(140, 1)" end="(140, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(140, 3)" end="(140, 7)">
              <OtherNode start="(140, 3)" end="(140, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(140, 3)" end="(140, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(140, 3)" end="(140, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(140, 7)" end="(140, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(140, 9)" end="(147, 13)" name="eraseP_eq_self_iff" full_name="List.eraseP_eq_self_iff" _is_private_decl="False">
        <AtomNode start="(140, 9)" end="(140, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(140, 17)" end="(140, 35)">
          <IdentNode start="(140, 17)" end="(140, 35)" leading="" trailing=" " raw_val="eraseP_eq_self_iff" val="eraseP_eq_self_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(140, 36)" end="(140, 86)">
          <NullNode start="(140, 36)" end="(140, 52)">
            <OtherNode start="(140, 36)" end="(140, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(140, 36)" end="(140, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(140, 37)" end="(140, 38)">
                <IdentNode start="(140, 37)" end="(140, 38)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(140, 38)" end="(140, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(140, 40)" end="(140, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(140, 40)" end="(140, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(140, 41)" end="(140, 42)">
                <IdentNode start="(140, 41)" end="(140, 42)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(140, 43)" end="(140, 51)">
                <AtomNode start="(140, 43)" end="(140, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(140, 45)" end="(140, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(140, 45)" end="(140, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(140, 50)" end="(140, 51)">
                    <IdentNode start="(140, 50)" end="(140, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(140, 51)" end="(140, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(140, 53)" end="(140, 86)">
            <AtomNode start="(140, 53)" end="(140, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(140, 55)" end="(140, 86)" kind="«term_↔_»">
              <OtherNode start="(140, 55)" end="(140, 69)" kind="«term_=_»">
                <OtherNode start="(140, 55)" end="(140, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(140, 55)" end="(140, 63)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(140, 64)" end="(140, 65)">
                    <IdentNode start="(140, 64)" end="(140, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(140, 66)" end="(140, 67)" leading="" trailing=" " val="="/>
                <IdentNode start="(140, 68)" end="(140, 69)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
              <AtomNode start="(140, 70)" end="(140, 71)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(140, 72)" end="(140, 86)" kind="Lean.«term∀__,_»">
                <AtomNode start="(140, 72)" end="(140, 73)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(140, 74)" end="(140, 75)">
                  <IdentNode start="(140, 74)" end="(140, 75)" leading="" trailing=" " raw_val="a" val="a"/>
                </LeanBinderidentNode>
                <OtherNode start="(140, 76)" end="(140, 79)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(140, 76)" end="(140, 77)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(140, 78)" end="(140, 79)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(140, 79)" end="(140, 80)" leading="" trailing=" " val=","/>
                <OtherNode start="(140, 81)" end="(140, 86)" kind="«term¬_»">
                  <AtomNode start="(140, 81)" end="(140, 82)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(140, 83)" end="(140, 86)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(140, 83)" end="(140, 84)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(140, 85)" end="(140, 86)">
                      <IdentNode start="(140, 85)" end="(140, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(140, 87)" end="(147, 13)">
          <AtomNode start="(140, 87)" end="(140, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(140, 90)" end="(147, 13)">
            <AtomNode start="(140, 90)" end="(140, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(141, 3)" end="(147, 13)">
              <TacticTacticseq1IndentedNode start="(141, 3)" end="(147, 13)">
                <NullNode start="(141, 3)" end="(147, 13)">
                  <OtherNode start="(141, 3)" end="(141, 57)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l = l ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (if l.any p = true then l.length - 1 else l.length) = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" tactic="rw [← Sublist.length_eq eraseP_sublist, length_eraseP]">
                    <AtomNode start="(141, 3)" end="(141, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(141, 6)" end="(141, 57)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(141, 6)" end="(141, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(141, 7)" end="(141, 56)">
                        <OtherNode start="(141, 7)" end="(141, 41)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(141, 7)" end="(141, 8)">
                            <OtherNode start="(141, 7)" end="(141, 8)" kind="patternIgnore">
                              <OtherNode start="(141, 7)" end="(141, 8)" kind="token.«← »">
                                <AtomNode start="(141, 7)" end="(141, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <OtherNode start="(141, 9)" end="(141, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(141, 9)" end="(141, 26)" leading="" trailing=" " raw_val="Sublist.length_eq" val="Sublist.length_eq" full_name="List.Sublist.length_eq" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                            <NullNode start="(141, 27)" end="(141, 41)">
                              <IdentNode start="(141, 27)" end="(141, 41)" leading="" trailing="" raw_val="eraseP_sublist" val="eraseP_sublist" full_name="List.eraseP_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(104, 9)" def_end="(104, 23)"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(141, 41)" end="(141, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(141, 43)" end="(141, 56)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(141, 43)" end="(141, 56)" leading="" trailing="" raw_val="length_eraseP" val="length_eraseP" full_name="List.length_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(141, 56)" end="(141, 57)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(142, 3)" end="(142, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (if l.any p = true then l.length - 1 else l.length) = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : l.any p = true&#10;⊢ l.length - 1 = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ l.length = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(142, 3)" end="(142, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(142, 3)" end="(142, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(142, 9)" end="(142, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(142, 13)" end="(142, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(142, 13)" end="(142, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(142, 22)" end="(142, 23)">
                        <LeanBinderidentNode start="(142, 22)" end="(142, 23)">
                          <IdentNode start="(142, 22)" end="(142, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(143, 3)" end="(146, 45)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : l.any p = true&#10;⊢ l.length - 1 = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ l.length = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ l.length = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" tactic="· simp only [any_eq_true, length_eq_zero_iff] at h&#10;  constructor&#10;  · intro; simp_all [Nat.sub_one_eq_self]&#10;  · intro; obtain ⟨x, m, h⟩ := h; simp_all">
                    <OtherNode start="(143, 3)" end="(143, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(143, 3)" end="(143, 4)" kind="patternIgnore">
                        <OtherNode start="(143, 3)" end="(143, 4)" kind="token.«· »">
                          <AtomNode start="(143, 3)" end="(143, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(143, 5)" end="(146, 45)">
                      <TacticTacticseq1IndentedNode start="(143, 5)" end="(146, 45)">
                        <NullNode start="(143, 5)" end="(146, 45)">
                          <OtherNode start="(143, 5)" end="(143, 53)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : l.any p = true&#10;⊢ l.length - 1 = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ l.length - 1 = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" tactic="simp only [any_eq_true, length_eq_zero_iff] at h">
                            <AtomNode start="(143, 5)" end="(143, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(143, 10)" end="(143, 14)">
                              <AtomNode start="(143, 10)" end="(143, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(143, 15)" end="(143, 48)">
                              <AtomNode start="(143, 15)" end="(143, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(143, 16)" end="(143, 47)">
                                <OtherNode start="(143, 16)" end="(143, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(143, 16)" end="(143, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(143, 27)" end="(143, 28)" leading="" trailing=" " val=","/>
                                <OtherNode start="(143, 29)" end="(143, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(143, 29)" end="(143, 47)" leading="" trailing="" raw_val="length_eq_zero_iff" val="length_eq_zero_iff" full_name="List.length_eq_zero_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(143, 47)" end="(143, 48)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(143, 49)" end="(143, 53)">
                              <OtherNode start="(143, 49)" end="(143, 53)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(143, 49)" end="(143, 51)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(143, 52)" end="(143, 53)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(143, 52)" end="(143, 53)">
                                    <IdentNode start="(143, 52)" end="(143, 53)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(144, 5)" end="(144, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ l.length - 1 = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="case isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ l.length - 1 = l.length → ∀ (a : α), a ∈ l → ¬p a = true&#10;&#10;case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) → l.length - 1 = l.length" tactic="constructor">
                            <AtomNode start="(144, 5)" end="(144, 16)" leading="" trailing="&#10;    " val="constructor"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(145, 5)" end="(145, 44)" kind="Lean.cdot" state_before="case isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ l.length - 1 = l.length → ∀ (a : α), a ∈ l → ¬p a = true&#10;&#10;case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) → l.length - 1 = l.length" state_after="case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) → l.length - 1 = l.length" tactic="· intro; simp_all [Nat.sub_one_eq_self]">
                            <OtherNode start="(145, 5)" end="(145, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(145, 5)" end="(145, 6)" kind="patternIgnore">
                                <OtherNode start="(145, 5)" end="(145, 6)" kind="token.«· »">
                                  <AtomNode start="(145, 5)" end="(145, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(145, 7)" end="(145, 44)">
                              <TacticTacticseq1IndentedNode start="(145, 7)" end="(145, 44)">
                                <NullNode start="(145, 7)" end="(145, 44)">
                                  <OtherNode start="(145, 7)" end="(145, 12)" kind="Lean.Parser.Tactic.intro" state_before="case isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ l.length - 1 = l.length → ∀ (a : α), a ∈ l → ¬p a = true" state_after="case isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;a✝ : l.length - 1 = l.length&#10;⊢ ∀ (a : α), a ∈ l → ¬p a = true" tactic="intro">
                                    <AtomNode start="(145, 7)" end="(145, 12)" leading="" trailing="" val="intro"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(145, 12)" end="(145, 13)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(145, 14)" end="(145, 44)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.mp&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;a✝ : l.length - 1 = l.length&#10;⊢ ∀ (a : α), a ∈ l → ¬p a = true" state_after="no goals" tactic="simp_all [Nat.sub_one_eq_self]">
                                    <AtomNode start="(145, 14)" end="(145, 22)" leading="" trailing=" " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(145, 23)" end="(145, 44)">
                                      <AtomNode start="(145, 23)" end="(145, 24)" leading="" trailing="" val="["/>
                                      <NullNode start="(145, 24)" end="(145, 43)">
                                        <OtherNode start="(145, 24)" end="(145, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(145, 24)" end="(145, 43)" leading="" trailing="" raw_val="Nat.sub_one_eq_self" val="Nat.sub_one_eq_self" full_name="Nat.sub_one_eq_self" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(145, 43)" end="(145, 44)" leading="" trailing="&#10;    " val="]"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(146, 5)" end="(146, 45)" kind="Lean.cdot" state_before="case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) → l.length - 1 = l.length" state_after="no goals" tactic="· intro; obtain ⟨x, m, h⟩ := h; simp_all">
                            <OtherNode start="(146, 5)" end="(146, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(146, 5)" end="(146, 6)" kind="patternIgnore">
                                <OtherNode start="(146, 5)" end="(146, 6)" kind="token.«· »">
                                  <AtomNode start="(146, 5)" end="(146, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(146, 7)" end="(146, 45)">
                              <TacticTacticseq1IndentedNode start="(146, 7)" end="(146, 45)">
                                <NullNode start="(146, 7)" end="(146, 45)">
                                  <OtherNode start="(146, 7)" end="(146, 12)" kind="Lean.Parser.Tactic.intro" state_before="case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) → l.length - 1 = l.length" state_after="case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;a✝ : ∀ (a : α), a ∈ l → ¬p a = true&#10;⊢ l.length - 1 = l.length" tactic="intro">
                                    <AtomNode start="(146, 7)" end="(146, 12)" leading="" trailing="" val="intro"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(146, 12)" end="(146, 13)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(146, 14)" end="(146, 35)" kind="Lean.Parser.Tactic.obtain" state_before="case isTrue.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ∃ x, x ∈ l ∧ p x = true&#10;a✝ : ∀ (a : α), a ∈ l → ¬p a = true&#10;⊢ l.length - 1 = l.length" state_after="case isTrue.mpr.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;a✝ : ∀ (a : α), a ∈ l → ¬p a = true&#10;x : α&#10;m : x ∈ l&#10;h : p x = true&#10;⊢ l.length - 1 = l.length" tactic="obtain ⟨x, m, h⟩ := h">
                                    <AtomNode start="(146, 14)" end="(146, 20)" leading="" trailing=" " val="obtain"/>
                                    <NullNode start="(146, 21)" end="(146, 30)">
                                      <OtherNode start="(146, 21)" end="(146, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(146, 21)" end="(146, 30)">
                                          <OtherNode start="(146, 21)" end="(146, 30)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(146, 21)" end="(146, 22)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(146, 22)" end="(146, 29)">
                                              <OtherNode start="(146, 22)" end="(146, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(146, 22)" end="(146, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(146, 22)" end="(146, 23)">
                                                    <OtherNode start="(146, 22)" end="(146, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(146, 22)" end="(146, 23)" leading="" trailing="" raw_val="x" val="x"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(146, 23)" end="(146, 24)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(146, 25)" end="(146, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(146, 25)" end="(146, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(146, 25)" end="(146, 26)">
                                                    <OtherNode start="(146, 25)" end="(146, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(146, 25)" end="(146, 26)" leading="" trailing="" raw_val="m" val="m"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(146, 26)" end="(146, 27)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(146, 28)" end="(146, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(146, 28)" end="(146, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(146, 28)" end="(146, 29)">
                                                    <OtherNode start="(146, 28)" end="(146, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(146, 28)" end="(146, 29)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(146, 29)" end="(146, 30)" leading="" trailing=" " val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(146, 31)" end="(146, 35)">
                                      <AtomNode start="(146, 31)" end="(146, 33)" leading="" trailing=" " val=":="/>
                                      <NullNode start="(146, 34)" end="(146, 35)">
                                        <IdentNode start="(146, 34)" end="(146, 35)" leading="" trailing="" raw_val="h" val="h"/>
                                      </NullNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(146, 35)" end="(146, 36)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(146, 37)" end="(146, 45)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.mpr.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;a✝ : ∀ (a : α), a ∈ l → ¬p a = true&#10;x : α&#10;m : x ∈ l&#10;h : p x = true&#10;⊢ l.length - 1 = l.length" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(146, 37)" end="(146, 45)" leading="" trailing="&#10;  " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(147, 3)" end="(147, 13)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ l.length = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="no goals" tactic="· simp_all">
                    <OtherNode start="(147, 3)" end="(147, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(147, 3)" end="(147, 4)" kind="patternIgnore">
                        <OtherNode start="(147, 3)" end="(147, 4)" kind="token.«· »">
                          <AtomNode start="(147, 3)" end="(147, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(147, 5)" end="(147, 13)">
                      <TacticTacticseq1IndentedNode start="(147, 5)" end="(147, 13)">
                        <NullNode start="(147, 5)" end="(147, 13)">
                          <OtherNode start="(147, 5)" end="(147, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : ¬l.any p = true&#10;⊢ l.length = l.length ↔ ∀ (a : α), a ∈ l → ¬p a = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(147, 5)" end="(147, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(149, 1)" end="(151, 81)" name="eraseP_map" full_name="List.eraseP_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(149, 1)" end="(151, 81)" name="eraseP_map" full_name="List.eraseP_map" _is_private_decl="False">
        <AtomNode start="(149, 1)" end="(149, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(149, 9)" end="(149, 19)">
          <IdentNode start="(149, 9)" end="(149, 19)" leading="" trailing=" " raw_val="eraseP_map" val="eraseP_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(149, 20)" end="(149, 95)">
          <NullNode start="(149, 20)" end="(149, 31)">
            <OtherNode start="(149, 20)" end="(149, 31)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(149, 20)" end="(149, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(149, 21)" end="(149, 22)">
                <IdentNode start="(149, 21)" end="(149, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(149, 23)" end="(149, 30)">
                <AtomNode start="(149, 23)" end="(149, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(149, 25)" end="(149, 30)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(149, 25)" end="(149, 26)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(149, 27)" end="(149, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(149, 29)" end="(149, 30)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(149, 30)" end="(149, 31)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(149, 32)" end="(149, 95)">
            <AtomNode start="(149, 32)" end="(149, 33)" leading="" trailing=" " val=":"/>
            <OtherNode start="(149, 34)" end="(149, 95)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(149, 34)" end="(149, 35)" leading="" trailing=" " val="∀"/>
              <NullNode start="(149, 36)" end="(149, 48)">
                <OtherNode start="(149, 36)" end="(149, 48)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(149, 36)" end="(149, 37)" leading="" trailing="" val="{"/>
                  <NullNode start="(149, 37)" end="(149, 38)">
                    <IdentNode start="(149, 37)" end="(149, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(149, 39)" end="(149, 47)">
                    <AtomNode start="(149, 39)" end="(149, 40)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(149, 41)" end="(149, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(149, 41)" end="(149, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(149, 46)" end="(149, 47)">
                        <IdentNode start="(149, 46)" end="(149, 47)" leading="" trailing="" raw_val="β" val="β"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(149, 47)" end="(149, 48)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(149, 48)" end="(149, 49)" leading="" trailing=" " val=","/>
              <OtherNode start="(149, 50)" end="(149, 95)" kind="«term_=_»">
                <OtherNode start="(149, 50)" end="(149, 68)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(149, 50)" end="(149, 66)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(149, 50)" end="(149, 59)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(149, 50)" end="(149, 51)" leading="" trailing="" val="("/>
                      <OtherNode start="(149, 51)" end="(149, 58)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(149, 51)" end="(149, 54)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(149, 55)" end="(149, 58)">
                          <IdentNode start="(149, 55)" end="(149, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                          <IdentNode start="(149, 57)" end="(149, 58)" leading="" trailing="" raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(149, 58)" end="(149, 59)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(149, 59)" end="(149, 60)" leading="" trailing="" val="."/>
                    <IdentNode start="(149, 60)" end="(149, 66)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(149, 67)" end="(149, 68)">
                    <IdentNode start="(149, 67)" end="(149, 68)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(149, 69)" end="(149, 70)" leading="" trailing=" " val="="/>
                <OtherNode start="(149, 71)" end="(149, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(149, 71)" end="(149, 74)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(149, 75)" end="(149, 95)">
                    <IdentNode start="(149, 75)" end="(149, 76)" leading="" trailing=" " raw_val="f" val="f"/>
                    <OtherNode start="(149, 77)" end="(149, 95)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(149, 77)" end="(149, 78)" leading="" trailing="" val="("/>
                      <OtherNode start="(149, 78)" end="(149, 94)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(149, 78)" end="(149, 86)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                        <NullNode start="(149, 87)" end="(149, 94)">
                          <OtherNode start="(149, 87)" end="(149, 94)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(149, 87)" end="(149, 88)" leading="" trailing="" val="("/>
                            <OtherNode start="(149, 88)" end="(149, 93)" kind="«term_∘_»">
                              <IdentNode start="(149, 88)" end="(149, 89)" leading="" trailing=" " raw_val="p" val="p"/>
                              <AtomNode start="(149, 90)" end="(149, 91)" leading="" trailing=" " val="∘"/>
                              <IdentNode start="(149, 92)" end="(149, 93)" leading="" trailing="" raw_val="f" val="f"/>
                            </OtherNode>
                            <AtomNode start="(149, 93)" end="(149, 94)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(149, 94)" end="(149, 95)" leading="" trailing="&#10;  " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(150, 3)" end="(151, 81)">
          <OtherNode start="(150, 3)" end="(151, 81)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(150, 3)" end="(151, 81)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(150, 3)" end="(151, 81)">
                <OtherNode start="(150, 3)" end="(150, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(150, 3)" end="(150, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(150, 5)" end="(150, 7)">
                    <NullNode start="(150, 5)" end="(150, 7)">
                      <OtherNode start="(150, 5)" end="(150, 7)" kind="«term[_]»">
                        <AtomNode start="(150, 5)" end="(150, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(150, 6)" end="(150, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(150, 8)" end="(150, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(150, 11)" end="(150, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(151, 3)" end="(151, 81)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(151, 3)" end="(151, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(151, 5)" end="(151, 9)">
                    <NullNode start="(151, 5)" end="(151, 9)">
                      <OtherNode start="(151, 5)" end="(151, 9)" kind="«term_::_»">
                        <IdentNode start="(151, 5)" end="(151, 6)" leading="" trailing="" raw_val="b" val="b"/>
                        <AtomNode start="(151, 6)" end="(151, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(151, 8)" end="(151, 9)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(151, 10)" end="(151, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(151, 13)" end="(151, 81)">
                    <AtomNode start="(151, 13)" end="(151, 15)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(151, 16)" end="(151, 81)">
                      <TacticTacticseq1IndentedNode start="(151, 16)" end="(151, 81)">
                        <NullNode start="(151, 16)" end="(151, 81)">
                          <OtherNode start="(151, 16)" end="(151, 81)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;b : β&#10;l : List β&#10;⊢ eraseP p (map f (b :: l)) = map f (eraseP (p ∘ f) (b :: l))" state_after="no goals" tactic="by_cases h : p (f b) &amp;lt;;&amp;gt; simp [h, eraseP_map, eraseP_cons_of_pos]">
                            <OtherNode start="(151, 16)" end="(151, 36)" kind="«tacticBy_cases_:_»">
                              <AtomNode start="(151, 16)" end="(151, 24)" leading="" trailing=" " val="by_cases"/>
                              <NullNode start="(151, 25)" end="(151, 28)">
                                <IdentNode start="(151, 25)" end="(151, 26)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(151, 27)" end="(151, 28)" leading="" trailing=" " val=":"/>
                              </NullNode>
                              <OtherNode start="(151, 29)" end="(151, 36)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(151, 29)" end="(151, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(151, 31)" end="(151, 36)">
                                  <OtherNode start="(151, 31)" end="(151, 36)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(151, 31)" end="(151, 32)" leading="" trailing="" val="("/>
                                    <OtherNode start="(151, 32)" end="(151, 35)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(151, 32)" end="(151, 33)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(151, 34)" end="(151, 35)">
                                        <IdentNode start="(151, 34)" end="(151, 35)" leading="" trailing="" raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(151, 35)" end="(151, 36)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(151, 37)" end="(151, 40)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(151, 41)" end="(151, 81)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(151, 41)" end="(151, 45)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(151, 46)" end="(151, 81)">
                                <AtomNode start="(151, 46)" end="(151, 47)" leading="" trailing="" val="["/>
                                <NullNode start="(151, 47)" end="(151, 80)">
                                  <OtherNode start="(151, 47)" end="(151, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(151, 47)" end="(151, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                  </OtherNode>
                                  <AtomNode start="(151, 48)" end="(151, 49)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(151, 50)" end="(151, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(151, 50)" end="(151, 60)" leading="" trailing="" raw_val="eraseP_map" val="eraseP_map"/>
                                  </OtherNode>
                                  <AtomNode start="(151, 60)" end="(151, 61)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(151, 62)" end="(151, 80)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(151, 62)" end="(151, 80)" leading="" trailing="" raw_val="eraseP_cons_of_pos" val="eraseP_cons_of_pos" full_name="List.eraseP_cons_of_pos" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(31, 17)" def_end="(31, 35)"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(151, 80)" end="(151, 81)" leading="" trailing="&#10;&#10;" val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(165, 53)" name="eraseP_filterMap" full_name="List.eraseP_filterMap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(153, 1)" end="(165, 53)" name="eraseP_filterMap" full_name="List.eraseP_filterMap" _is_private_decl="False">
        <AtomNode start="(153, 1)" end="(153, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(153, 9)" end="(153, 25)">
          <IdentNode start="(153, 9)" end="(153, 25)" leading="" trailing=" " raw_val="eraseP_filterMap" val="eraseP_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(153, 26)" end="(154, 112)">
          <NullNode start="(153, 26)" end="(153, 44)">
            <OtherNode start="(153, 26)" end="(153, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 26)" end="(153, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 27)" end="(153, 28)">
                <IdentNode start="(153, 27)" end="(153, 28)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(153, 29)" end="(153, 43)">
                <AtomNode start="(153, 29)" end="(153, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 31)" end="(153, 43)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(153, 31)" end="(153, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(153, 33)" end="(153, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(153, 35)" end="(153, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(153, 35)" end="(153, 41)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(153, 42)" end="(153, 43)">
                      <IdentNode start="(153, 42)" end="(153, 43)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(153, 43)" end="(153, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(153, 45)" end="(154, 112)">
            <AtomNode start="(153, 45)" end="(153, 46)" leading="" trailing=" " val=":"/>
            <OtherNode start="(153, 47)" end="(154, 112)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(153, 47)" end="(153, 48)" leading="" trailing=" " val="∀"/>
              <NullNode start="(153, 49)" end="(153, 61)">
                <OtherNode start="(153, 49)" end="(153, 61)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(153, 49)" end="(153, 50)" leading="" trailing="" val="{"/>
                  <NullNode start="(153, 50)" end="(153, 51)">
                    <IdentNode start="(153, 50)" end="(153, 51)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(153, 52)" end="(153, 60)">
                    <AtomNode start="(153, 52)" end="(153, 53)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(153, 54)" end="(153, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(153, 54)" end="(153, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(153, 59)" end="(153, 60)">
                        <IdentNode start="(153, 59)" end="(153, 60)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(153, 60)" end="(153, 61)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(153, 61)" end="(153, 62)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(154, 5)" end="(154, 112)" kind="«term_=_»">
                <OtherNode start="(154, 5)" end="(154, 29)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(154, 5)" end="(154, 27)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(154, 5)" end="(154, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(154, 5)" end="(154, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(154, 6)" end="(154, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(154, 6)" end="(154, 15)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(154, 16)" end="(154, 19)">
                          <IdentNode start="(154, 16)" end="(154, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                          <IdentNode start="(154, 18)" end="(154, 19)" leading="" trailing="" raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(154, 19)" end="(154, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(154, 20)" end="(154, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(154, 21)" end="(154, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(154, 28)" end="(154, 29)">
                    <IdentNode start="(154, 28)" end="(154, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(154, 30)" end="(154, 31)" leading="" trailing=" " val="="/>
                <OtherNode start="(154, 32)" end="(154, 112)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(154, 32)" end="(154, 41)" leading="" trailing=" " raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(154, 42)" end="(154, 112)">
                    <IdentNode start="(154, 42)" end="(154, 43)" leading="" trailing=" " raw_val="f" val="f"/>
                    <OtherNode start="(154, 44)" end="(154, 112)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(154, 44)" end="(154, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(154, 45)" end="(154, 111)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(154, 45)" end="(154, 53)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                        <NullNode start="(154, 54)" end="(154, 111)">
                          <OtherNode start="(154, 54)" end="(154, 111)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(154, 54)" end="(154, 55)" leading="" trailing="" val="("/>
                            <OtherNode start="(154, 55)" end="(154, 110)" kind="Lean.Parser.Term.fun">
                              <AtomNode start="(154, 55)" end="(154, 58)" leading="" trailing=" " val="fun"/>
                              <OtherNode start="(154, 59)" end="(154, 110)" kind="Lean.Parser.Term.basicFun">
                                <NullNode start="(154, 59)" end="(154, 60)">
                                  <IdentNode start="(154, 59)" end="(154, 60)" leading="" trailing=" " raw_val="x" val="x"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(154, 61)" end="(154, 63)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(154, 64)" end="(154, 110)" kind="Lean.Parser.Term.match">
                                  <AtomNode start="(154, 64)" end="(154, 69)" leading="" trailing=" " val="match"/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(154, 70)" end="(154, 73)">
                                    <OtherNode start="(154, 70)" end="(154, 73)" kind="Lean.Parser.Term.matchDiscr">
                                      <NullNode/>
                                      <OtherNode start="(154, 70)" end="(154, 73)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(154, 70)" end="(154, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                                        <NullNode start="(154, 72)" end="(154, 73)">
                                          <IdentNode start="(154, 72)" end="(154, 73)" leading="" trailing=" " raw_val="x" val="x"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(154, 74)" end="(154, 78)" leading="" trailing=" " val="with"/>
                                  <OtherNode start="(154, 79)" end="(154, 110)" kind="Lean.Parser.Term.matchAlts">
                                    <NullNode start="(154, 79)" end="(154, 110)">
                                      <OtherNode start="(154, 79)" end="(154, 94)" kind="Lean.Parser.Term.matchAlt">
                                        <AtomNode start="(154, 79)" end="(154, 80)" leading="" trailing=" " val="|"/>
                                        <NullNode start="(154, 81)" end="(154, 87)">
                                          <NullNode start="(154, 81)" end="(154, 87)">
                                            <OtherNode start="(154, 81)" end="(154, 87)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(154, 81)" end="(154, 85)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              <NullNode start="(154, 86)" end="(154, 87)">
                                                <IdentNode start="(154, 86)" end="(154, 87)" leading="" trailing=" " raw_val="y" val="y"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </NullNode>
                                        <AtomNode start="(154, 88)" end="(154, 90)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <OtherNode start="(154, 91)" end="(154, 94)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(154, 91)" end="(154, 92)" leading="" trailing=" " raw_val="p" val="p"/>
                                          <NullNode start="(154, 93)" end="(154, 94)">
                                            <IdentNode start="(154, 93)" end="(154, 94)" leading="" trailing=" " raw_val="y" val="y"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(154, 95)" end="(154, 110)" kind="Lean.Parser.Term.matchAlt">
                                        <AtomNode start="(154, 95)" end="(154, 96)" leading="" trailing=" " val="|"/>
                                        <NullNode start="(154, 97)" end="(154, 101)">
                                          <NullNode start="(154, 97)" end="(154, 101)">
                                            <IdentNode start="(154, 97)" end="(154, 101)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          </NullNode>
                                        </NullNode>
                                        <AtomNode start="(154, 102)" end="(154, 104)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <IdentNode start="(154, 105)" end="(154, 110)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(154, 110)" end="(154, 111)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(154, 111)" end="(154, 112)" leading="" trailing="&#10;  " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(155, 3)" end="(165, 53)">
          <OtherNode start="(155, 3)" end="(165, 53)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(155, 3)" end="(165, 53)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(155, 3)" end="(165, 53)">
                <OtherNode start="(155, 3)" end="(155, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(155, 3)" end="(155, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(155, 5)" end="(155, 7)">
                    <NullNode start="(155, 5)" end="(155, 7)">
                      <OtherNode start="(155, 5)" end="(155, 7)" kind="«term[_]»">
                        <AtomNode start="(155, 5)" end="(155, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(155, 6)" end="(155, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(155, 8)" end="(155, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(155, 11)" end="(155, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(156, 3)" end="(165, 53)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(156, 3)" end="(156, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(156, 5)" end="(156, 9)">
                    <NullNode start="(156, 5)" end="(156, 9)">
                      <OtherNode start="(156, 5)" end="(156, 9)" kind="«term_::_»">
                        <IdentNode start="(156, 5)" end="(156, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(156, 6)" end="(156, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(156, 8)" end="(156, 9)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(156, 10)" end="(156, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(156, 13)" end="(165, 53)">
                    <AtomNode start="(156, 13)" end="(156, 15)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(157, 5)" end="(165, 53)">
                      <TacticTacticseq1IndentedNode start="(157, 5)" end="(165, 53)">
                        <NullNode start="(157, 5)" end="(165, 53)">
                          <OtherNode start="(157, 5)" end="(157, 37)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;⊢ eraseP p (filterMap f (a :: l)) =&#10;    filterMap f&#10;      (eraseP&#10;        (fun x =&amp;gt;&#10;          match f x with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false)&#10;        (a :: l))" state_after="α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;⊢ eraseP p&#10;      (match f a with&#10;      | none =&amp;gt; filterMap f l&#10;      | some b =&amp;gt; b :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="rw [filterMap_cons, eraseP_cons]">
                            <AtomNode start="(157, 5)" end="(157, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(157, 8)" end="(157, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(157, 8)" end="(157, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(157, 9)" end="(157, 36)">
                                <OtherNode start="(157, 9)" end="(157, 23)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(157, 9)" end="(157, 23)" leading="" trailing="" raw_val="filterMap_cons" val="filterMap_cons" full_name="List.filterMap_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(157, 23)" end="(157, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(157, 25)" end="(157, 36)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(157, 25)" end="(157, 36)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(157, 36)" end="(157, 37)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(158, 5)" end="(158, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;⊢ eraseP p&#10;      (match f a with&#10;      | none =&amp;gt; filterMap f l&#10;      | some b =&amp;gt; b :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case h_1&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;h : f a = none&#10;⊢ eraseP p (filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)&#10;&#10;case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b✝ : β&#10;h : f a = some b✝&#10;⊢ eraseP p (b✝ :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="split &amp;lt;;&amp;gt; rename_i h">
                            <OtherNode start="(158, 5)" end="(158, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(158, 5)" end="(158, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(158, 11)" end="(158, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(158, 15)" end="(158, 25)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(158, 15)" end="(158, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(158, 24)" end="(158, 25)">
                                <LeanBinderidentNode start="(158, 24)" end="(158, 25)">
                                  <IdentNode start="(158, 24)" end="(158, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(159, 5)" end="(159, 33)" kind="Lean.cdot" state_before="case h_1&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;h : f a = none&#10;⊢ eraseP p (filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)&#10;&#10;case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b✝ : β&#10;h : f a = some b✝&#10;⊢ eraseP p (b✝ :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b✝ : β&#10;h : f a = some b✝&#10;⊢ eraseP p (b✝ :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="· simp [h, eraseP_filterMap]">
                            <OtherNode start="(159, 5)" end="(159, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(159, 5)" end="(159, 6)" kind="patternIgnore">
                                <OtherNode start="(159, 5)" end="(159, 6)" kind="token.«· »">
                                  <AtomNode start="(159, 5)" end="(159, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(159, 7)" end="(159, 33)">
                              <TacticTacticseq1IndentedNode start="(159, 7)" end="(159, 33)">
                                <NullNode start="(159, 7)" end="(159, 33)">
                                  <OtherNode start="(159, 7)" end="(159, 33)" kind="Lean.Parser.Tactic.simp" state_before="case h_1&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;h : f a = none&#10;⊢ eraseP p (filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="no goals" tactic="simp [h, eraseP_filterMap]">
                                    <AtomNode start="(159, 7)" end="(159, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(159, 12)" end="(159, 33)">
                                      <AtomNode start="(159, 12)" end="(159, 13)" leading="" trailing="" val="["/>
                                      <NullNode start="(159, 13)" end="(159, 32)">
                                        <OtherNode start="(159, 13)" end="(159, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(159, 13)" end="(159, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(159, 14)" end="(159, 15)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(159, 16)" end="(159, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(159, 16)" end="(159, 32)" leading="" trailing="" raw_val="eraseP_filterMap" val="eraseP_filterMap"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(159, 32)" end="(159, 33)" leading="" trailing="&#10;    " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(160, 5)" end="(165, 53)" kind="Lean.cdot" state_before="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b✝ : β&#10;h : f a = some b✝&#10;⊢ eraseP p (b✝ :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="no goals" tactic="· rename_i b&#10;  rw [h, eraseP_cons]&#10;  by_cases w : p b&#10;  · simp [w]&#10;  · simp only [w, cond_false]&#10;    rw [filterMap_cons_some h, eraseP_filterMap]">
                            <OtherNode start="(160, 5)" end="(160, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(160, 5)" end="(160, 6)" kind="patternIgnore">
                                <OtherNode start="(160, 5)" end="(160, 6)" kind="token.«· »">
                                  <AtomNode start="(160, 5)" end="(160, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(160, 7)" end="(165, 53)">
                              <TacticTacticseq1IndentedNode start="(160, 7)" end="(165, 53)">
                                <NullNode start="(160, 7)" end="(165, 53)">
                                  <OtherNode start="(160, 7)" end="(160, 17)" kind="Lean.Parser.Tactic.renameI" state_before="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b✝ : β&#10;h : f a = some b✝&#10;⊢ eraseP p (b✝ :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;⊢ eraseP p (b :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="rename_i b">
                                    <AtomNode start="(160, 7)" end="(160, 15)" leading="" trailing=" " val="rename_i"/>
                                    <NullNode start="(160, 16)" end="(160, 17)">
                                      <LeanBinderidentNode start="(160, 16)" end="(160, 17)">
                                        <IdentNode start="(160, 16)" end="(160, 17)" leading="" trailing="&#10;      " raw_val="b" val="b"/>
                                      </LeanBinderidentNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(161, 7)" end="(161, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;⊢ eraseP p (b :: filterMap f l) =&#10;    filterMap f&#10;      (bif&#10;          match f a with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="rw [h, eraseP_cons]">
                                    <AtomNode start="(161, 7)" end="(161, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(161, 10)" end="(161, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(161, 10)" end="(161, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(161, 11)" end="(161, 25)">
                                        <OtherNode start="(161, 11)" end="(161, 12)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(161, 11)" end="(161, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(161, 12)" end="(161, 13)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(161, 14)" end="(161, 25)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(161, 14)" end="(161, 25)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(161, 25)" end="(161, 26)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(162, 7)" end="(162, 23)" kind="«tacticBy_cases_:_»" state_before="case h_2&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)&#10;&#10;case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="by_cases w : p b">
                                    <AtomNode start="(162, 7)" end="(162, 15)" leading="" trailing=" " val="by_cases"/>
                                    <NullNode start="(162, 16)" end="(162, 19)">
                                      <IdentNode start="(162, 16)" end="(162, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                                      <AtomNode start="(162, 18)" end="(162, 19)" leading="" trailing=" " val=":"/>
                                    </NullNode>
                                    <OtherNode start="(162, 20)" end="(162, 23)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(162, 20)" end="(162, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                                      <NullNode start="(162, 22)" end="(162, 23)">
                                        <IdentNode start="(162, 22)" end="(162, 23)" leading="" trailing="&#10;      " raw_val="b" val="b"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(163, 7)" end="(163, 17)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)&#10;&#10;case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" tactic="· simp [w]">
                                    <OtherNode start="(163, 7)" end="(163, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(163, 7)" end="(163, 8)" kind="patternIgnore">
                                        <OtherNode start="(163, 7)" end="(163, 8)" kind="token.«· »">
                                          <AtomNode start="(163, 7)" end="(163, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(163, 9)" end="(163, 17)">
                                      <TacticTacticseq1IndentedNode start="(163, 9)" end="(163, 17)">
                                        <NullNode start="(163, 9)" end="(163, 17)">
                                          <OtherNode start="(163, 9)" end="(163, 17)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="no goals" tactic="simp [w]">
                                            <AtomNode start="(163, 9)" end="(163, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(163, 14)" end="(163, 17)">
                                              <AtomNode start="(163, 14)" end="(163, 15)" leading="" trailing="" val="["/>
                                              <NullNode start="(163, 15)" end="(163, 16)">
                                                <OtherNode start="(163, 15)" end="(163, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(163, 15)" end="(163, 16)" leading="" trailing="" raw_val="w" val="w"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(163, 16)" end="(163, 17)" leading="" trailing="&#10;      " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(164, 7)" end="(165, 53)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="no goals" tactic="· simp only [w, cond_false]&#10;  rw [filterMap_cons_some h, eraseP_filterMap]">
                                    <OtherNode start="(164, 7)" end="(164, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(164, 7)" end="(164, 8)" kind="patternIgnore">
                                        <OtherNode start="(164, 7)" end="(164, 8)" kind="token.«· »">
                                          <AtomNode start="(164, 7)" end="(164, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(164, 9)" end="(165, 53)">
                                      <TacticTacticseq1IndentedNode start="(164, 9)" end="(165, 53)">
                                        <NullNode start="(164, 9)" end="(165, 53)">
                                          <OtherNode start="(164, 9)" end="(164, 34)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ (bif p b then filterMap f l else b :: eraseP p (filterMap f l)) =&#10;    filterMap f&#10;      (bif&#10;          match some b with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false then&#10;        l&#10;      else&#10;        a ::&#10;          eraseP&#10;            (fun x =&amp;gt;&#10;              match f x with&#10;              | some y =&amp;gt; p y&#10;              | none =&amp;gt; false)&#10;            l)" state_after="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ b :: eraseP p (filterMap f l) =&#10;    filterMap f&#10;      (a ::&#10;        eraseP&#10;          (fun x =&amp;gt;&#10;            match f x with&#10;            | some y =&amp;gt; p y&#10;            | none =&amp;gt; false)&#10;          l)" tactic="simp only [w, cond_false]">
                                            <AtomNode start="(164, 9)" end="(164, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(164, 14)" end="(164, 18)">
                                              <AtomNode start="(164, 14)" end="(164, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(164, 19)" end="(164, 34)">
                                              <AtomNode start="(164, 19)" end="(164, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(164, 20)" end="(164, 33)">
                                                <OtherNode start="(164, 20)" end="(164, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(164, 20)" end="(164, 21)" leading="" trailing="" raw_val="w" val="w"/>
                                                </OtherNode>
                                                <AtomNode start="(164, 21)" end="(164, 22)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(164, 23)" end="(164, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(164, 23)" end="(164, 33)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(164, 33)" end="(164, 34)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(165, 9)" end="(165, 53)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;α : Type u_1&#10;β : Type u_2&#10;p : β → Bool&#10;f : α → Option β&#10;a : α&#10;l : List α&#10;x✝ : Option β&#10;b : β&#10;h : f a = some b&#10;w : ¬p b = true&#10;⊢ b :: eraseP p (filterMap f l) =&#10;    filterMap f&#10;      (a ::&#10;        eraseP&#10;          (fun x =&amp;gt;&#10;            match f x with&#10;            | some y =&amp;gt; p y&#10;            | none =&amp;gt; false)&#10;          l)" state_after="no goals" tactic="rw [filterMap_cons_some h, eraseP_filterMap]">
                                            <AtomNode start="(165, 9)" end="(165, 11)" leading="" trailing=" " val="rw"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <OtherNode start="(165, 12)" end="(165, 53)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                              <AtomNode start="(165, 12)" end="(165, 13)" leading="" trailing="" val="["/>
                                              <NullNode start="(165, 13)" end="(165, 52)">
                                                <OtherNode start="(165, 13)" end="(165, 34)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <OtherNode start="(165, 13)" end="(165, 34)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(165, 13)" end="(165, 32)" leading="" trailing=" " raw_val="filterMap_cons_some" val="filterMap_cons_some" full_name="List.filterMap_cons_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                    <NullNode start="(165, 33)" end="(165, 34)">
                                                      <IdentNode start="(165, 33)" end="(165, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(165, 34)" end="(165, 35)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(165, 36)" end="(165, 52)" kind="Lean.Parser.Tactic.rwRule">
                                                  <NullNode/>
                                                  <IdentNode start="(165, 36)" end="(165, 52)" leading="" trailing="" raw_val="eraseP_filterMap" val="eraseP_filterMap"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(165, 52)" end="(165, 53)" leading="" trailing="&#10;&#10;" val="]"/>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(167, 1)" end="(173, 36)" name="eraseP_filter" full_name="List.eraseP_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(167, 1)" end="(173, 36)" name="eraseP_filter" full_name="List.eraseP_filter" _is_private_decl="False">
        <AtomNode start="(167, 1)" end="(167, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(167, 9)" end="(167, 22)">
          <IdentNode start="(167, 9)" end="(167, 22)" leading="" trailing=" " raw_val="eraseP_filter" val="eraseP_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(167, 23)" end="(168, 70)">
          <NullNode start="(167, 23)" end="(167, 50)">
            <OtherNode start="(167, 23)" end="(167, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 23)" end="(167, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 24)" end="(167, 25)">
                <IdentNode start="(167, 24)" end="(167, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(167, 26)" end="(167, 36)">
                <AtomNode start="(167, 26)" end="(167, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 28)" end="(167, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(167, 28)" end="(167, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(167, 30)" end="(167, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(167, 32)" end="(167, 36)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(167, 36)" end="(167, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(167, 38)" end="(167, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 38)" end="(167, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 39)" end="(167, 40)">
                <IdentNode start="(167, 39)" end="(167, 40)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(167, 41)" end="(167, 49)">
                <AtomNode start="(167, 41)" end="(167, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 43)" end="(167, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(167, 43)" end="(167, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(167, 48)" end="(167, 49)">
                    <IdentNode start="(167, 48)" end="(167, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(167, 49)" end="(167, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(167, 51)" end="(168, 70)">
            <AtomNode start="(167, 51)" end="(167, 52)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(168, 5)" end="(168, 70)" kind="«term_=_»">
              <OtherNode start="(168, 5)" end="(168, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(168, 5)" end="(168, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(168, 5)" end="(168, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(168, 5)" end="(168, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(168, 6)" end="(168, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(168, 6)" end="(168, 12)" leading="" trailing=" " raw_val="filter" val="filter" full_name="List.filter" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(168, 13)" end="(168, 16)">
                        <IdentNode start="(168, 13)" end="(168, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(168, 15)" end="(168, 16)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(168, 16)" end="(168, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(168, 17)" end="(168, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(168, 18)" end="(168, 24)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(168, 25)" end="(168, 26)">
                  <IdentNode start="(168, 25)" end="(168, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(168, 27)" end="(168, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(168, 29)" end="(168, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(168, 29)" end="(168, 35)" leading="" trailing=" " raw_val="filter" val="filter" full_name="List.filter" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(168, 36)" end="(168, 70)">
                  <IdentNode start="(168, 36)" end="(168, 37)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(168, 38)" end="(168, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(168, 38)" end="(168, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(168, 39)" end="(168, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(168, 39)" end="(168, 47)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                      <NullNode start="(168, 48)" end="(168, 69)">
                        <OtherNode start="(168, 48)" end="(168, 69)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(168, 48)" end="(168, 49)" leading="" trailing="" val="("/>
                          <OtherNode start="(168, 49)" end="(168, 68)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(168, 49)" end="(168, 52)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(168, 53)" end="(168, 68)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(168, 53)" end="(168, 54)">
                                <IdentNode start="(168, 53)" end="(168, 54)" leading="" trailing=" " raw_val="x" val="x"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(168, 55)" end="(168, 57)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(168, 58)" end="(168, 68)" kind="«term_&amp;amp;&amp;amp;_»">
                                <OtherNode start="(168, 58)" end="(168, 61)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(168, 58)" end="(168, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <NullNode start="(168, 60)" end="(168, 61)">
                                    <IdentNode start="(168, 60)" end="(168, 61)" leading="" trailing=" " raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(168, 62)" end="(168, 64)" leading="" trailing=" " val="&amp;amp;&amp;amp;"/>
                                <OtherNode start="(168, 65)" end="(168, 68)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(168, 65)" end="(168, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <NullNode start="(168, 67)" end="(168, 68)">
                                    <IdentNode start="(168, 67)" end="(168, 68)" leading="" trailing="" raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(168, 68)" end="(168, 69)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(168, 69)" end="(168, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(168, 71)" end="(173, 36)">
          <AtomNode start="(168, 71)" end="(168, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(168, 74)" end="(173, 36)">
            <AtomNode start="(168, 74)" end="(168, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(169, 3)" end="(173, 36)">
              <TacticTacticseq1IndentedNode start="(169, 3)" end="(173, 36)">
                <NullNode start="(169, 3)" end="(173, 36)">
                  <OtherNode start="(169, 3)" end="(169, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;⊢ eraseP p (filter f l) = filter f (eraseP (fun x =&amp;gt; p x &amp;amp;&amp;amp; f x) l)" state_after="α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;⊢ filterMap (Option.guard fun x =&amp;gt; f x)&#10;      (eraseP&#10;        (fun x =&amp;gt;&#10;          match Option.guard (fun x =&amp;gt; f x) x with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false)&#10;        l) =&#10;    filterMap (Option.guard fun x =&amp;gt; f x) (eraseP (fun x =&amp;gt; p x &amp;amp;&amp;amp; f x) l)" tactic="rw [← filterMap_eq_filter, eraseP_filterMap]">
                    <AtomNode start="(169, 3)" end="(169, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(169, 6)" end="(169, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(169, 6)" end="(169, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(169, 7)" end="(169, 46)">
                        <OtherNode start="(169, 7)" end="(169, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(169, 7)" end="(169, 8)">
                            <OtherNode start="(169, 7)" end="(169, 8)" kind="patternIgnore">
                              <OtherNode start="(169, 7)" end="(169, 8)" kind="token.«← »">
                                <AtomNode start="(169, 7)" end="(169, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(169, 9)" end="(169, 28)" leading="" trailing="" raw_val="filterMap_eq_filter" val="filterMap_eq_filter" full_name="List.filterMap_eq_filter" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(169, 28)" end="(169, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(169, 30)" end="(169, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(169, 30)" end="(169, 46)" leading="" trailing="" raw_val="eraseP_filterMap" val="eraseP_filterMap" full_name="List.eraseP_filterMap" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(153, 9)" def_end="(153, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(169, 46)" end="(169, 47)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(170, 3)" end="(170, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;⊢ filterMap (Option.guard fun x =&amp;gt; f x)&#10;      (eraseP&#10;        (fun x =&amp;gt;&#10;          match Option.guard (fun x =&amp;gt; f x) x with&#10;          | some y =&amp;gt; p y&#10;          | none =&amp;gt; false)&#10;        l) =&#10;    filterMap (Option.guard fun x =&amp;gt; f x) (eraseP (fun x =&amp;gt; p x &amp;amp;&amp;amp; f x) l)" state_after="case e_a.e_p&#10;α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;⊢ (fun x =&amp;gt;&#10;      match Option.guard (fun x =&amp;gt; f x) x with&#10;      | some y =&amp;gt; p y&#10;      | none =&amp;gt; false) =&#10;    fun x =&amp;gt; p x &amp;amp;&amp;amp; f x" tactic="congr">
                    <AtomNode start="(170, 3)" end="(170, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(171, 3)" end="(171, 8)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case e_a.e_p&#10;α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;⊢ (fun x =&amp;gt;&#10;      match Option.guard (fun x =&amp;gt; f x) x with&#10;      | some y =&amp;gt; p y&#10;      | none =&amp;gt; false) =&#10;    fun x =&amp;gt; p x &amp;amp;&amp;amp; f x" state_after="case e_a.e_p.h&#10;α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;x : α&#10;⊢ (match Option.guard (fun x =&amp;gt; f x) x with&#10;    | some y =&amp;gt; p y&#10;    | none =&amp;gt; false) =&#10;    (p x &amp;amp;&amp;amp; f x)" tactic="ext x">
                    <AtomNode start="(171, 3)" end="(171, 6)" leading="" trailing=" " val="ext"/>
                    <NullNode start="(171, 7)" end="(171, 8)">
                      <OtherNode start="(171, 7)" end="(171, 8)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(171, 7)" end="(171, 8)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(171, 7)" end="(171, 8)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(172, 3)" end="(172, 27)" kind="Lean.Parser.Tactic.simp" state_before="case e_a.e_p.h&#10;α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;x : α&#10;⊢ (match Option.guard (fun x =&amp;gt; f x) x with&#10;    | some y =&amp;gt; p y&#10;    | none =&amp;gt; false) =&#10;    (p x &amp;amp;&amp;amp; f x)" state_after="case e_a.e_p.h&#10;α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;x : α&#10;⊢ (match if f x = true then some x else none with&#10;    | some y =&amp;gt; p y&#10;    | none =&amp;gt; false) =&#10;    (p x &amp;amp;&amp;amp; f x)" tactic="simp only [Option.guard]">
                    <AtomNode start="(172, 3)" end="(172, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(172, 8)" end="(172, 12)">
                      <AtomNode start="(172, 8)" end="(172, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(172, 13)" end="(172, 27)">
                      <AtomNode start="(172, 13)" end="(172, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(172, 14)" end="(172, 26)">
                        <OtherNode start="(172, 14)" end="(172, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(172, 14)" end="(172, 26)" leading="" trailing="" raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(172, 26)" end="(172, 27)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(173, 3)" end="(173, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case e_a.e_p.h&#10;α : Type u_1&#10;p f : α → Bool&#10;l : List α&#10;x : α&#10;⊢ (match if f x = true then some x else none with&#10;    | some y =&amp;gt; p y&#10;    | none =&amp;gt; false) =&#10;    (p x &amp;amp;&amp;amp; f x)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; split at * &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(173, 3)" end="(173, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(173, 3)" end="(173, 8)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(173, 3)" end="(173, 8)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(173, 9)" end="(173, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(173, 13)" end="(173, 23)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(173, 13)" end="(173, 18)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode start="(173, 19)" end="(173, 23)">
                          <OtherNode start="(173, 19)" end="(173, 23)" kind="Lean.Parser.Tactic.location">
                            <AtomNode start="(173, 19)" end="(173, 21)" leading="" trailing=" " val="at"/>
                            <OtherNode start="(173, 22)" end="(173, 23)" kind="Lean.Parser.Tactic.locationWildcard">
                              <AtomNode start="(173, 22)" end="(173, 23)" leading="" trailing=" " val="*"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(173, 24)" end="(173, 27)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(173, 28)" end="(173, 36)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(173, 28)" end="(173, 36)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(175, 1)" end="(180, 28)" name="eraseP_append_left" full_name="List.eraseP_append_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(175, 1)" end="(180, 28)" name="eraseP_append_left" full_name="List.eraseP_append_left" _is_private_decl="False">
        <AtomNode start="(175, 1)" end="(175, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(175, 9)" end="(175, 27)">
          <IdentNode start="(175, 9)" end="(175, 27)" leading="" trailing=" " raw_val="eraseP_append_left" val="eraseP_append_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(175, 28)" end="(176, 71)">
          <NullNode start="(175, 28)" end="(175, 46)">
            <OtherNode start="(175, 28)" end="(175, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(175, 28)" end="(175, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(175, 29)" end="(175, 30)">
                <IdentNode start="(175, 29)" end="(175, 30)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(175, 31)" end="(175, 34)">
                <AtomNode start="(175, 31)" end="(175, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(175, 33)" end="(175, 34)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(175, 34)" end="(175, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(175, 36)" end="(175, 46)">
              <AtomNode start="(175, 36)" end="(175, 37)" leading="" trailing="" val="("/>
              <NullNode start="(175, 37)" end="(175, 39)">
                <IdentNode start="(175, 37)" end="(175, 39)" leading="" trailing=" " raw_val="pa" val="pa"/>
              </NullNode>
              <NullNode start="(175, 40)" end="(175, 45)">
                <AtomNode start="(175, 40)" end="(175, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(175, 42)" end="(175, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(175, 42)" end="(175, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(175, 44)" end="(175, 45)">
                    <IdentNode start="(175, 44)" end="(175, 45)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(175, 45)" end="(175, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(175, 47)" end="(176, 71)">
            <AtomNode start="(175, 47)" end="(175, 48)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(176, 5)" end="(176, 71)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(176, 5)" end="(176, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(176, 7)" end="(176, 23)">
                <OtherNode start="(176, 7)" end="(176, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(176, 7)" end="(176, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(176, 8)" end="(176, 10)">
                    <IdentNode start="(176, 8)" end="(176, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(176, 11)" end="(176, 19)">
                    <AtomNode start="(176, 11)" end="(176, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(176, 13)" end="(176, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(176, 13)" end="(176, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(176, 18)" end="(176, 19)">
                        <IdentNode start="(176, 18)" end="(176, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(176, 19)" end="(176, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <IdentNode start="(176, 21)" end="(176, 23)" leading="" trailing="" raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(176, 23)" end="(176, 24)" leading="" trailing=" " val=","/>
              <OtherNode start="(176, 25)" end="(176, 71)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(176, 25)" end="(176, 31)" kind="«term_∈_»">
                  <IdentNode start="(176, 25)" end="(176, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(176, 27)" end="(176, 28)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(176, 29)" end="(176, 31)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </OtherNode>
                <AtomNode start="(176, 32)" end="(176, 33)" leading="" trailing=" " val="→"/>
                <OtherNode start="(176, 34)" end="(176, 71)" kind="«term_=_»">
                  <OtherNode start="(176, 34)" end="(176, 51)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(176, 34)" end="(176, 49)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(176, 34)" end="(176, 42)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(176, 34)" end="(176, 35)" leading="" trailing="" val="("/>
                        <OtherNode start="(176, 35)" end="(176, 41)" kind="«term_++_»">
                          <IdentNode start="(176, 35)" end="(176, 37)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          <AtomNode start="(176, 37)" end="(176, 39)" leading="" trailing="" val="++"/>
                          <IdentNode start="(176, 39)" end="(176, 41)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </OtherNode>
                        <AtomNode start="(176, 41)" end="(176, 42)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(176, 42)" end="(176, 43)" leading="" trailing="" val="."/>
                      <IdentNode start="(176, 43)" end="(176, 49)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </OtherNode>
                    <NullNode start="(176, 50)" end="(176, 51)">
                      <IdentNode start="(176, 50)" end="(176, 51)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(176, 52)" end="(176, 53)" leading="" trailing=" " val="="/>
                  <OtherNode start="(176, 54)" end="(176, 71)" kind="«term_++_»">
                    <OtherNode start="(176, 54)" end="(176, 65)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(176, 54)" end="(176, 63)" leading="" trailing=" " raw_val="l₁.eraseP" val="l₁.eraseP"/>
                      <NullNode start="(176, 64)" end="(176, 65)">
                        <IdentNode start="(176, 64)" end="(176, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(176, 66)" end="(176, 68)" leading="" trailing=" " val="++"/>
                    <IdentNode start="(176, 69)" end="(176, 71)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(177, 3)" end="(180, 28)">
          <OtherNode start="(177, 3)" end="(180, 28)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(177, 3)" end="(180, 28)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(177, 3)" end="(180, 28)">
                <OtherNode start="(177, 3)" end="(180, 28)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(177, 3)" end="(177, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(177, 5)" end="(177, 19)">
                    <NullNode start="(177, 5)" end="(177, 19)">
                      <OtherNode start="(177, 5)" end="(177, 12)" kind="«term_::_»">
                        <IdentNode start="(177, 5)" end="(177, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(177, 7)" end="(177, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(177, 10)" end="(177, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(177, 12)" end="(177, 13)" leading="" trailing=" " val=","/>
                      <IdentNode start="(177, 14)" end="(177, 16)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      <AtomNode start="(177, 16)" end="(177, 17)" leading="" trailing=" " val=","/>
                      <IdentNode start="(177, 18)" end="(177, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(177, 20)" end="(177, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(177, 23)" end="(180, 28)">
                    <AtomNode start="(177, 23)" end="(177, 25)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(178, 5)" end="(180, 28)">
                      <TacticTacticseq1IndentedNode start="(178, 5)" end="(180, 28)">
                        <NullNode start="(178, 5)" end="(180, 28)">
                          <OtherNode start="(178, 5)" end="(178, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;x : α&#10;xs l₂ : List α&#10;h : a ∈ x :: xs&#10;⊢ eraseP p (x :: xs ++ l₂) = eraseP p (x :: xs) ++ l₂" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;x : α&#10;xs l₂ : List α&#10;h : a ∈ x :: xs&#10;h' : ¬p x = true&#10;⊢ eraseP p (xs ++ l₂) = eraseP p xs ++ l₂" tactic="by_cases h' : p x &amp;lt;;&amp;gt; simp [h']">
                            <OtherNode start="(178, 5)" end="(178, 22)" kind="«tacticBy_cases_:_»">
                              <AtomNode start="(178, 5)" end="(178, 13)" leading="" trailing=" " val="by_cases"/>
                              <NullNode start="(178, 14)" end="(178, 18)">
                                <IdentNode start="(178, 14)" end="(178, 16)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                <AtomNode start="(178, 17)" end="(178, 18)" leading="" trailing=" " val=":"/>
                              </NullNode>
                              <OtherNode start="(178, 19)" end="(178, 22)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(178, 19)" end="(178, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(178, 21)" end="(178, 22)">
                                  <IdentNode start="(178, 21)" end="(178, 22)" leading="" trailing=" " raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(178, 23)" end="(178, 26)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(178, 27)" end="(178, 36)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(178, 27)" end="(178, 31)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(178, 32)" end="(178, 36)">
                                <AtomNode start="(178, 32)" end="(178, 33)" leading="" trailing="" val="["/>
                                <NullNode start="(178, 33)" end="(178, 35)">
                                  <OtherNode start="(178, 33)" end="(178, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(178, 33)" end="(178, 35)" leading="" trailing="" raw_val="h'" val="h'"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(178, 35)" end="(178, 36)" leading="" trailing="&#10;    " val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(179, 5)" end="(179, 74)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;x : α&#10;xs l₂ : List α&#10;h : a ∈ x :: xs&#10;h' : ¬p x = true&#10;⊢ eraseP p (xs ++ l₂) = eraseP p xs ++ l₂" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;x : α&#10;xs l₂ : List α&#10;h : a ∈ x :: xs&#10;h' : ¬p x = true&#10;⊢ a = x → p x = true" tactic="rw [eraseP_append_left pa l₂ ((mem_cons.1 h).resolve_left (mt _ h'))]">
                            <AtomNode start="(179, 5)" end="(179, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(179, 8)" end="(179, 74)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(179, 8)" end="(179, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(179, 9)" end="(179, 73)">
                                <OtherNode start="(179, 9)" end="(179, 73)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(179, 9)" end="(179, 73)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(179, 9)" end="(179, 27)" leading="" trailing=" " raw_val="eraseP_append_left" val="eraseP_append_left"/>
                                    <NullNode start="(179, 28)" end="(179, 73)">
                                      <IdentNode start="(179, 28)" end="(179, 30)" leading="" trailing=" " raw_val="pa" val="pa"/>
                                      <IdentNode start="(179, 31)" end="(179, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                      <OtherNode start="(179, 34)" end="(179, 73)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(179, 34)" end="(179, 35)" leading="" trailing="" val="("/>
                                        <OtherNode start="(179, 35)" end="(179, 72)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(179, 35)" end="(179, 62)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(179, 35)" end="(179, 49)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(179, 35)" end="(179, 36)" leading="" trailing="" val="("/>
                                              <OtherNode start="(179, 36)" end="(179, 48)" kind="Lean.Parser.Term.app">
                                                <OtherNode start="(179, 36)" end="(179, 46)" kind="Lean.Parser.Term.proj">
                                                  <IdentNode start="(179, 36)" end="(179, 44)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  <AtomNode start="(179, 44)" end="(179, 45)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(179, 45)" end="(179, 46)" kind="fieldIdx">
                                                    <AtomNode start="(179, 45)" end="(179, 46)" leading="" trailing=" " val="1"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode start="(179, 47)" end="(179, 48)">
                                                  <IdentNode start="(179, 47)" end="(179, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(179, 48)" end="(179, 49)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(179, 49)" end="(179, 50)" leading="" trailing="" val="."/>
                                            <IdentNode start="(179, 50)" end="(179, 62)" leading="" trailing=" " raw_val="resolve_left" val="resolve_left" full_name="Or.resolve_left" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          </OtherNode>
                                          <NullNode start="(179, 63)" end="(179, 72)">
                                            <OtherNode start="(179, 63)" end="(179, 72)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(179, 63)" end="(179, 64)" leading="" trailing="" val="("/>
                                              <OtherNode start="(179, 64)" end="(179, 71)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(179, 64)" end="(179, 66)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                <NullNode start="(179, 67)" end="(179, 71)">
                                                  <TermHoleNode start="(179, 67)" end="(179, 68)">
                                                    <AtomNode start="(179, 67)" end="(179, 68)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <IdentNode start="(179, 69)" end="(179, 71)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(179, 71)" end="(179, 72)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(179, 72)" end="(179, 73)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(179, 73)" end="(179, 74)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(180, 5)" end="(180, 28)" kind="Lean.Parser.Tactic.introMatch" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;x : α&#10;xs l₂ : List α&#10;h : a ∈ x :: xs&#10;h' : ¬p x = true&#10;⊢ a = x → p x = true" state_after="no goals" tactic="intro | rfl =&amp;gt; exact pa">
                            <AtomNode start="(180, 5)" end="(180, 10)" leading="" trailing=" " val="intro"/>
                            <OtherNode start="(180, 11)" end="(180, 28)" kind="Lean.Parser.Term.matchAlts">
                              <NullNode start="(180, 11)" end="(180, 28)">
                                <OtherNode start="(180, 11)" end="(180, 28)" kind="Lean.Parser.Term.matchAlt">
                                  <AtomNode start="(180, 11)" end="(180, 12)" leading="" trailing=" " val="|"/>
                                  <NullNode start="(180, 13)" end="(180, 16)">
                                    <NullNode start="(180, 13)" end="(180, 16)">
                                      <IdentNode start="(180, 13)" end="(180, 16)" leading="" trailing=" " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(180, 17)" end="(180, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <TacticTacticseqNode start="(180, 20)" end="(180, 28)">
                                    <TacticTacticseq1IndentedNode start="(180, 20)" end="(180, 28)">
                                      <NullNode start="(180, 20)" end="(180, 28)">
                                        <OtherNode start="(180, 20)" end="(180, 28)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;pa : p a = true&#10;x : α&#10;xs l₂ : List α&#10;x✝ : a = x&#10;h : a ∈ a :: xs&#10;h' : ¬p a = true&#10;⊢ p a = true" state_after="no goals" tactic="exact pa">
                                          <AtomNode start="(180, 20)" end="(180, 25)" leading="" trailing=" " val="exact"/>
                                          <IdentNode start="(180, 26)" end="(180, 28)" leading="" trailing="&#10;&#10;" raw_val="pa" val="pa"/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(182, 1)" end="(186, 82)" name="eraseP_append_right" full_name="List.eraseP_append_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(182, 1)" end="(186, 82)" name="eraseP_append_right" full_name="List.eraseP_append_right" _is_private_decl="False">
        <AtomNode start="(182, 1)" end="(182, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(182, 9)" end="(182, 28)">
          <IdentNode start="(182, 9)" end="(182, 28)" leading="" trailing=" " raw_val="eraseP_append_right" val="eraseP_append_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(182, 29)" end="(183, 81)">
          <NullNode/>
          <TermTypespecNode start="(182, 29)" end="(183, 81)">
            <AtomNode start="(182, 29)" end="(182, 30)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(183, 5)" end="(183, 81)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(183, 5)" end="(183, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(183, 7)" end="(183, 23)">
                <OtherNode start="(183, 7)" end="(183, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(183, 7)" end="(183, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(183, 8)" end="(183, 10)">
                    <IdentNode start="(183, 8)" end="(183, 10)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                  <NullNode start="(183, 11)" end="(183, 19)">
                    <AtomNode start="(183, 11)" end="(183, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(183, 13)" end="(183, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(183, 13)" end="(183, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(183, 18)" end="(183, 19)">
                        <IdentNode start="(183, 18)" end="(183, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(183, 19)" end="(183, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <IdentNode start="(183, 21)" end="(183, 23)" leading="" trailing="" raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(183, 23)" end="(183, 24)" leading="" trailing=" " val=","/>
              <OtherNode start="(183, 25)" end="(183, 81)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(183, 25)" end="(183, 41)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(183, 25)" end="(183, 26)" leading="" trailing="" val="("/>
                  <OtherNode start="(183, 26)" end="(183, 40)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(183, 26)" end="(183, 27)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(183, 28)" end="(183, 29)">
                      <IdentNode start="(183, 28)" end="(183, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(183, 30)" end="(183, 34)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(183, 30)" end="(183, 31)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(183, 32)" end="(183, 34)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                    </OtherNode>
                    <AtomNode start="(183, 34)" end="(183, 35)" leading="" trailing=" " val=","/>
                    <OtherNode start="(183, 36)" end="(183, 40)" kind="«term¬_»">
                      <AtomNode start="(183, 36)" end="(183, 37)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(183, 37)" end="(183, 40)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(183, 37)" end="(183, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(183, 39)" end="(183, 40)">
                          <IdentNode start="(183, 39)" end="(183, 40)" leading="" trailing="" raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(183, 40)" end="(183, 41)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(183, 42)" end="(183, 43)" leading="" trailing=" " val="→"/>
                <OtherNode start="(183, 44)" end="(183, 81)" kind="«term_=_»">
                  <OtherNode start="(183, 44)" end="(183, 61)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(183, 44)" end="(183, 50)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(183, 51)" end="(183, 61)">
                      <IdentNode start="(183, 51)" end="(183, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                      <OtherNode start="(183, 53)" end="(183, 61)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(183, 53)" end="(183, 54)" leading="" trailing="" val="("/>
                        <OtherNode start="(183, 54)" end="(183, 60)" kind="«term_++_»">
                          <IdentNode start="(183, 54)" end="(183, 56)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                          <AtomNode start="(183, 56)" end="(183, 58)" leading="" trailing="" val="++"/>
                          <IdentNode start="(183, 58)" end="(183, 60)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </OtherNode>
                        <AtomNode start="(183, 60)" end="(183, 61)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(183, 62)" end="(183, 63)" leading="" trailing=" " val="="/>
                  <OtherNode start="(183, 64)" end="(183, 81)" kind="«term_++_»">
                    <IdentNode start="(183, 64)" end="(183, 66)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(183, 67)" end="(183, 69)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(183, 70)" end="(183, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(183, 70)" end="(183, 79)" leading="" trailing=" " raw_val="l₂.eraseP" val="l₂.eraseP"/>
                      <NullNode start="(183, 80)" end="(183, 81)">
                        <IdentNode start="(183, 80)" end="(183, 81)" leading="" trailing="&#10;  " raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(184, 3)" end="(186, 82)">
          <OtherNode start="(184, 3)" end="(186, 82)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(184, 3)" end="(186, 82)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(184, 3)" end="(186, 82)">
                <OtherNode start="(184, 3)" end="(184, 24)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(184, 3)" end="(184, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(184, 5)" end="(184, 17)">
                    <NullNode start="(184, 5)" end="(184, 17)">
                      <OtherNode start="(184, 5)" end="(184, 7)" kind="«term[_]»">
                        <AtomNode start="(184, 5)" end="(184, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(184, 6)" end="(184, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(184, 7)" end="(184, 8)" leading="" trailing="     " val=","/>
                      <TermHoleNode start="(184, 13)" end="(184, 14)">
                        <AtomNode start="(184, 13)" end="(184, 14)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(184, 14)" end="(184, 15)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(184, 16)" end="(184, 17)">
                        <AtomNode start="(184, 16)" end="(184, 17)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(184, 18)" end="(184, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(184, 21)" end="(184, 24)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(185, 3)" end="(186, 82)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(185, 3)" end="(185, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(185, 5)" end="(185, 17)">
                    <NullNode start="(185, 5)" end="(185, 17)">
                      <OtherNode start="(185, 5)" end="(185, 11)" kind="«term_::_»">
                        <TermHoleNode start="(185, 5)" end="(185, 6)">
                          <AtomNode start="(185, 5)" end="(185, 6)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(185, 7)" end="(185, 9)" leading="" trailing=" " val="::"/>
                        <TermHoleNode start="(185, 10)" end="(185, 11)">
                          <AtomNode start="(185, 10)" end="(185, 11)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                      </OtherNode>
                      <AtomNode start="(185, 11)" end="(185, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(185, 13)" end="(185, 14)">
                        <AtomNode start="(185, 13)" end="(185, 14)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(185, 14)" end="(185, 15)" leading="" trailing=" " val=","/>
                      <IdentNode start="(185, 16)" end="(185, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(185, 18)" end="(185, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(185, 21)" end="(186, 82)">
                    <AtomNode start="(185, 21)" end="(185, 23)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(186, 5)" end="(186, 82)">
                      <TacticTacticseq1IndentedNode start="(186, 5)" end="(186, 82)">
                        <NullNode start="(186, 5)" end="(186, 82)">
                          <OtherNode start="(186, 5)" end="(186, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ x✝ : List α&#10;h : ∀ (b : α), b ∈ head✝ :: tail✝ → ¬p b = true&#10;⊢ eraseP p (head✝ :: tail✝ ++ x✝) = head✝ :: tail✝ ++ eraseP p x✝" state_after="no goals" tactic="simp [(forall_mem_cons.1 h).1, eraseP_append_right _ (forall_mem_cons.1 h).2]">
                            <AtomNode start="(186, 5)" end="(186, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(186, 10)" end="(186, 82)">
                              <AtomNode start="(186, 10)" end="(186, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(186, 11)" end="(186, 81)">
                                <OtherNode start="(186, 11)" end="(186, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(186, 11)" end="(186, 34)" kind="Lean.Parser.Term.proj">
                                    <OtherNode start="(186, 11)" end="(186, 32)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(186, 11)" end="(186, 12)" leading="" trailing="" val="("/>
                                      <OtherNode start="(186, 12)" end="(186, 31)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(186, 12)" end="(186, 29)" kind="Lean.Parser.Term.proj">
                                          <IdentNode start="(186, 12)" end="(186, 27)" leading="" trailing="" raw_val="forall_mem_cons" val="forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          <AtomNode start="(186, 27)" end="(186, 28)" leading="" trailing="" val="."/>
                                          <OtherNode start="(186, 28)" end="(186, 29)" kind="fieldIdx">
                                            <AtomNode start="(186, 28)" end="(186, 29)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <NullNode start="(186, 30)" end="(186, 31)">
                                          <IdentNode start="(186, 30)" end="(186, 31)" leading="" trailing="" raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(186, 31)" end="(186, 32)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(186, 32)" end="(186, 33)" leading="" trailing="" val="."/>
                                    <OtherNode start="(186, 33)" end="(186, 34)" kind="fieldIdx">
                                      <AtomNode start="(186, 33)" end="(186, 34)" leading="" trailing="" val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(186, 34)" end="(186, 35)" leading="" trailing=" " val=","/>
                                <OtherNode start="(186, 36)" end="(186, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(186, 36)" end="(186, 81)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(186, 36)" end="(186, 55)" leading="" trailing=" " raw_val="eraseP_append_right" val="eraseP_append_right"/>
                                    <NullNode start="(186, 56)" end="(186, 81)">
                                      <TermHoleNode start="(186, 56)" end="(186, 57)">
                                        <AtomNode start="(186, 56)" end="(186, 57)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <OtherNode start="(186, 58)" end="(186, 81)" kind="Lean.Parser.Term.proj">
                                        <OtherNode start="(186, 58)" end="(186, 79)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(186, 58)" end="(186, 59)" leading="" trailing="" val="("/>
                                          <OtherNode start="(186, 59)" end="(186, 78)" kind="Lean.Parser.Term.app">
                                            <OtherNode start="(186, 59)" end="(186, 76)" kind="Lean.Parser.Term.proj">
                                              <IdentNode start="(186, 59)" end="(186, 74)" leading="" trailing="" raw_val="forall_mem_cons" val="forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              <AtomNode start="(186, 74)" end="(186, 75)" leading="" trailing="" val="."/>
                                              <OtherNode start="(186, 75)" end="(186, 76)" kind="fieldIdx">
                                                <AtomNode start="(186, 75)" end="(186, 76)" leading="" trailing=" " val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode start="(186, 77)" end="(186, 78)">
                                              <IdentNode start="(186, 77)" end="(186, 78)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(186, 78)" end="(186, 79)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                        <AtomNode start="(186, 79)" end="(186, 80)" leading="" trailing="" val="."/>
                                        <OtherNode start="(186, 80)" end="(186, 81)" kind="fieldIdx">
                                          <AtomNode start="(186, 80)" end="(186, 81)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(186, 81)" end="(186, 82)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(188, 1)" end="(196, 13)" name="eraseP_append" full_name="List.eraseP_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(188, 1)" end="(196, 13)" name="eraseP_append" full_name="List.eraseP_append" _is_private_decl="False">
        <AtomNode start="(188, 1)" end="(188, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(188, 9)" end="(188, 22)">
          <IdentNode start="(188, 9)" end="(188, 22)" leading="" trailing=" " raw_val="eraseP_append" val="eraseP_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(188, 23)" end="(189, 84)">
          <NullNode start="(188, 23)" end="(188, 39)">
            <OtherNode start="(188, 23)" end="(188, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(188, 23)" end="(188, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(188, 24)" end="(188, 29)">
                <IdentNode start="(188, 24)" end="(188, 26)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(188, 27)" end="(188, 29)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(188, 30)" end="(188, 38)">
                <AtomNode start="(188, 30)" end="(188, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(188, 32)" end="(188, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(188, 32)" end="(188, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(188, 37)" end="(188, 38)">
                    <IdentNode start="(188, 37)" end="(188, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(188, 38)" end="(188, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(188, 40)" end="(189, 84)">
            <AtomNode start="(188, 40)" end="(188, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(189, 5)" end="(189, 84)" kind="«term_=_»">
              <OtherNode start="(189, 5)" end="(189, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(189, 5)" end="(189, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(189, 5)" end="(189, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(189, 5)" end="(189, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(189, 6)" end="(189, 14)" kind="«term_++_»">
                      <IdentNode start="(189, 6)" end="(189, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(189, 9)" end="(189, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(189, 12)" end="(189, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(189, 14)" end="(189, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(189, 15)" end="(189, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(189, 16)" end="(189, 22)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(189, 23)" end="(189, 24)">
                  <IdentNode start="(189, 23)" end="(189, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(189, 25)" end="(189, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(189, 27)" end="(189, 84)" kind="termIfThenElse">
                <AtomNode start="(189, 27)" end="(189, 29)" leading="" trailing=" " val="if"/>
                <OtherNode start="(189, 30)" end="(189, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(189, 30)" end="(189, 36)" leading="" trailing=" " raw_val="l₁.any" val="l₁.any"/>
                  <NullNode start="(189, 37)" end="(189, 38)">
                    <IdentNode start="(189, 37)" end="(189, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(189, 39)" end="(189, 43)" leading="" trailing=" " val="then"/>
                <OtherNode start="(189, 44)" end="(189, 61)" kind="«term_++_»">
                  <OtherNode start="(189, 44)" end="(189, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(189, 44)" end="(189, 53)" leading="" trailing=" " raw_val="l₁.eraseP" val="l₁.eraseP"/>
                    <NullNode start="(189, 54)" end="(189, 55)">
                      <IdentNode start="(189, 54)" end="(189, 55)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(189, 56)" end="(189, 58)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(189, 59)" end="(189, 61)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
                <AtomNode start="(189, 62)" end="(189, 66)" leading="" trailing=" " val="else"/>
                <OtherNode start="(189, 67)" end="(189, 84)" kind="«term_++_»">
                  <IdentNode start="(189, 67)" end="(189, 69)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(189, 70)" end="(189, 72)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(189, 73)" end="(189, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(189, 73)" end="(189, 82)" leading="" trailing=" " raw_val="l₂.eraseP" val="l₂.eraseP"/>
                    <NullNode start="(189, 83)" end="(189, 84)">
                      <IdentNode start="(189, 83)" end="(189, 84)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(189, 85)" end="(196, 13)">
          <AtomNode start="(189, 85)" end="(189, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(189, 88)" end="(196, 13)">
            <AtomNode start="(189, 88)" end="(189, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(190, 3)" end="(196, 13)">
              <TacticTacticseq1IndentedNode start="(190, 3)" end="(196, 13)">
                <NullNode start="(190, 3)" end="(196, 13)">
                  <OtherNode start="(190, 3)" end="(190, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;⊢ eraseP p (l₁ ++ l₂) = if l₁.any p = true then eraseP p l₁ ++ l₂ else l₁ ++ eraseP p l₂" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(190, 3)" end="(190, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(190, 3)" end="(190, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(190, 9)" end="(190, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(190, 13)" end="(190, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(190, 13)" end="(190, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(190, 22)" end="(190, 23)">
                        <LeanBinderidentNode start="(190, 22)" end="(190, 23)">
                          <IdentNode start="(190, 22)" end="(190, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(191, 3)" end="(193, 34)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" tactic="· simp only [any_eq_true] at h&#10;  obtain ⟨x, m, h⟩ := h&#10;  rw [eraseP_append_left h _ m]">
                    <OtherNode start="(191, 3)" end="(191, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(191, 3)" end="(191, 4)" kind="patternIgnore">
                        <OtherNode start="(191, 3)" end="(191, 4)" kind="token.«· »">
                          <AtomNode start="(191, 3)" end="(191, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(191, 5)" end="(193, 34)">
                      <TacticTacticseq1IndentedNode start="(191, 5)" end="(193, 34)">
                        <NullNode start="(191, 5)" end="(193, 34)">
                          <OtherNode start="(191, 5)" end="(191, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂" tactic="simp only [any_eq_true] at h">
                            <AtomNode start="(191, 5)" end="(191, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(191, 10)" end="(191, 14)">
                              <AtomNode start="(191, 10)" end="(191, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(191, 15)" end="(191, 28)">
                              <AtomNode start="(191, 15)" end="(191, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(191, 16)" end="(191, 27)">
                                <OtherNode start="(191, 16)" end="(191, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(191, 16)" end="(191, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(191, 27)" end="(191, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(191, 29)" end="(191, 33)">
                              <OtherNode start="(191, 29)" end="(191, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(191, 29)" end="(191, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(191, 32)" end="(191, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(191, 32)" end="(191, 33)">
                                    <IdentNode start="(191, 32)" end="(191, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(192, 5)" end="(192, 26)" kind="Lean.Parser.Tactic.obtain" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂" state_after="case isTrue.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;x : α&#10;m : x ∈ l₁&#10;h : p x = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂" tactic="obtain ⟨x, m, h⟩ := h">
                            <AtomNode start="(192, 5)" end="(192, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(192, 12)" end="(192, 21)">
                              <OtherNode start="(192, 12)" end="(192, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(192, 12)" end="(192, 21)">
                                  <OtherNode start="(192, 12)" end="(192, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(192, 12)" end="(192, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(192, 13)" end="(192, 20)">
                                      <OtherNode start="(192, 13)" end="(192, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(192, 13)" end="(192, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(192, 13)" end="(192, 14)">
                                            <OtherNode start="(192, 13)" end="(192, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(192, 13)" end="(192, 14)" leading="" trailing="" raw_val="x" val="x"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(192, 14)" end="(192, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(192, 16)" end="(192, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(192, 16)" end="(192, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(192, 16)" end="(192, 17)">
                                            <OtherNode start="(192, 16)" end="(192, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(192, 16)" end="(192, 17)" leading="" trailing="" raw_val="m" val="m"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(192, 17)" end="(192, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(192, 19)" end="(192, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(192, 19)" end="(192, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(192, 19)" end="(192, 20)">
                                            <OtherNode start="(192, 19)" end="(192, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(192, 19)" end="(192, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(192, 20)" end="(192, 21)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(192, 22)" end="(192, 26)">
                              <AtomNode start="(192, 22)" end="(192, 24)" leading="" trailing=" " val=":="/>
                              <NullNode start="(192, 25)" end="(192, 26)">
                                <IdentNode start="(192, 25)" end="(192, 26)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(193, 5)" end="(193, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;x : α&#10;m : x ∈ l₁&#10;h : p x = true&#10;⊢ eraseP p (l₁ ++ l₂) = eraseP p l₁ ++ l₂" state_after="no goals" tactic="rw [eraseP_append_left h _ m]">
                            <AtomNode start="(193, 5)" end="(193, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(193, 8)" end="(193, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(193, 8)" end="(193, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(193, 9)" end="(193, 33)">
                                <OtherNode start="(193, 9)" end="(193, 33)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(193, 9)" end="(193, 33)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(193, 9)" end="(193, 27)" leading="" trailing=" " raw_val="eraseP_append_left" val="eraseP_append_left" full_name="List.eraseP_append_left" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(175, 9)" def_end="(175, 27)"/>
                                    <NullNode start="(193, 28)" end="(193, 33)">
                                      <IdentNode start="(193, 28)" end="(193, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                      <TermHoleNode start="(193, 30)" end="(193, 31)">
                                        <AtomNode start="(193, 30)" end="(193, 31)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <IdentNode start="(193, 32)" end="(193, 33)" leading="" trailing="" raw_val="m" val="m"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(193, 33)" end="(193, 34)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(194, 3)" end="(196, 13)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" state_after="no goals" tactic="· simp only [any_eq_true] at h&#10;  rw [eraseP_append_right _]&#10;  simp_all">
                    <OtherNode start="(194, 3)" end="(194, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(194, 3)" end="(194, 4)" kind="patternIgnore">
                        <OtherNode start="(194, 3)" end="(194, 4)" kind="token.«· »">
                          <AtomNode start="(194, 3)" end="(194, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(194, 5)" end="(196, 13)">
                      <TacticTacticseq1IndentedNode start="(194, 5)" end="(196, 13)">
                        <NullNode start="(194, 5)" end="(196, 13)">
                          <OtherNode start="(194, 5)" end="(194, 33)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬l₁.any p = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" tactic="simp only [any_eq_true] at h">
                            <AtomNode start="(194, 5)" end="(194, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(194, 10)" end="(194, 14)">
                              <AtomNode start="(194, 10)" end="(194, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(194, 15)" end="(194, 28)">
                              <AtomNode start="(194, 15)" end="(194, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(194, 16)" end="(194, 27)">
                                <OtherNode start="(194, 16)" end="(194, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(194, 16)" end="(194, 27)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(194, 27)" end="(194, 28)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(194, 29)" end="(194, 33)">
                              <OtherNode start="(194, 29)" end="(194, 33)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(194, 29)" end="(194, 31)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(194, 32)" end="(194, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(194, 32)" end="(194, 33)">
                                    <IdentNode start="(194, 32)" end="(194, 33)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(195, 5)" end="(195, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ eraseP p (l₁ ++ l₂) = l₁ ++ eraseP p l₂" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ ∀ (b : α), b ∈ l₁ → ¬p b = true" tactic="rw [eraseP_append_right _]">
                            <AtomNode start="(195, 5)" end="(195, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(195, 8)" end="(195, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(195, 8)" end="(195, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(195, 9)" end="(195, 30)">
                                <OtherNode start="(195, 9)" end="(195, 30)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(195, 9)" end="(195, 30)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(195, 9)" end="(195, 28)" leading="" trailing=" " raw_val="eraseP_append_right" val="eraseP_append_right" full_name="List.eraseP_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(182, 9)" def_end="(182, 28)"/>
                                    <NullNode start="(195, 29)" end="(195, 30)">
                                      <TermHoleNode start="(195, 29)" end="(195, 30)">
                                        <AtomNode start="(195, 29)" end="(195, 30)" leading="" trailing="" val="_"/>
                                      </TermHoleNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(195, 30)" end="(195, 31)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(196, 5)" end="(196, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ ∀ (b : α), b ∈ l₁ → ¬p b = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(196, 5)" end="(196, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(198, 1)" end="(204, 23)" name="eraseP_replicate" full_name="List.eraseP_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(198, 1)" end="(204, 23)" name="eraseP_replicate" full_name="List.eraseP_replicate" _is_private_decl="False">
        <AtomNode start="(198, 1)" end="(198, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(198, 9)" end="(198, 25)">
          <IdentNode start="(198, 9)" end="(198, 25)" leading="" trailing=" " raw_val="eraseP_replicate" val="eraseP_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(198, 26)" end="(199, 82)">
          <NullNode start="(198, 26)" end="(198, 58)">
            <OtherNode start="(198, 26)" end="(198, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 26)" end="(198, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 27)" end="(198, 28)">
                <IdentNode start="(198, 27)" end="(198, 28)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(198, 29)" end="(198, 34)">
                <AtomNode start="(198, 29)" end="(198, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(198, 31)" end="(198, 34)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(198, 34)" end="(198, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 36)" end="(198, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 36)" end="(198, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 37)" end="(198, 38)">
                <IdentNode start="(198, 37)" end="(198, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(198, 39)" end="(198, 42)">
                <AtomNode start="(198, 39)" end="(198, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(198, 41)" end="(198, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(198, 42)" end="(198, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 44)" end="(198, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 44)" end="(198, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 45)" end="(198, 46)">
                <IdentNode start="(198, 45)" end="(198, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(198, 47)" end="(198, 57)">
                <AtomNode start="(198, 47)" end="(198, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 49)" end="(198, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(198, 49)" end="(198, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(198, 51)" end="(198, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(198, 53)" end="(198, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 57)" end="(198, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(198, 59)" end="(199, 82)">
            <AtomNode start="(198, 59)" end="(198, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(199, 5)" end="(199, 82)" kind="«term_=_»">
              <OtherNode start="(199, 5)" end="(199, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(199, 5)" end="(199, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(199, 5)" end="(199, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(199, 5)" end="(199, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 6)" end="(199, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(199, 6)" end="(199, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(199, 16)" end="(199, 19)">
                        <IdentNode start="(199, 16)" end="(199, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(199, 18)" end="(199, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(199, 19)" end="(199, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(199, 20)" end="(199, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(199, 21)" end="(199, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(199, 28)" end="(199, 29)">
                  <IdentNode start="(199, 28)" end="(199, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(199, 30)" end="(199, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(199, 32)" end="(199, 82)" kind="termIfThenElse">
                <AtomNode start="(199, 32)" end="(199, 34)" leading="" trailing=" " val="if"/>
                <OtherNode start="(199, 35)" end="(199, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(199, 35)" end="(199, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(199, 37)" end="(199, 38)">
                    <IdentNode start="(199, 37)" end="(199, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(199, 39)" end="(199, 43)" leading="" trailing=" " val="then"/>
                <OtherNode start="(199, 44)" end="(199, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(199, 44)" end="(199, 53)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(199, 54)" end="(199, 63)">
                    <OtherNode start="(199, 54)" end="(199, 61)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(199, 54)" end="(199, 55)" leading="" trailing="" val="("/>
                      <OtherNode start="(199, 55)" end="(199, 60)" kind="«term_-_»">
                        <IdentNode start="(199, 55)" end="(199, 56)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(199, 57)" end="(199, 58)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(199, 59)" end="(199, 60)" kind="num">
                          <AtomNode start="(199, 59)" end="(199, 60)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(199, 60)" end="(199, 61)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(199, 62)" end="(199, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(199, 64)" end="(199, 68)" leading="" trailing=" " val="else"/>
                <OtherNode start="(199, 69)" end="(199, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(199, 69)" end="(199, 78)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(199, 79)" end="(199, 82)">
                    <IdentNode start="(199, 79)" end="(199, 80)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(199, 81)" end="(199, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(199, 83)" end="(204, 23)">
          <AtomNode start="(199, 83)" end="(199, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(199, 86)" end="(204, 23)">
            <AtomNode start="(199, 86)" end="(199, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(200, 3)" end="(204, 23)">
              <TacticTacticseq1IndentedNode start="(200, 3)" end="(204, 23)">
                <NullNode start="(200, 3)" end="(204, 23)">
                  <OtherNode start="(200, 3)" end="(204, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ eraseP p (replicate n a) = if p a = true then replicate (n - 1) a else replicate n a" state_after="no goals" tactic="induction n with&#10;| zero =&amp;gt; simp&#10;| succ n ih =&amp;gt;&#10;  simp only [replicate_succ, eraseP_cons]&#10;  split &amp;lt;;&amp;gt; simp [*]">
                    <AtomNode start="(200, 3)" end="(200, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(200, 13)" end="(200, 14)">
                      <OtherNode start="(200, 13)" end="(200, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(200, 13)" end="(200, 14)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(200, 15)" end="(204, 23)">
                      <OtherNode start="(200, 15)" end="(204, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(200, 15)" end="(200, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(201, 3)" end="(204, 23)">
                          <OtherNode start="(201, 3)" end="(201, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(201, 3)" end="(201, 9)">
                              <OtherNode start="(201, 3)" end="(201, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(201, 3)" end="(201, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(201, 5)" end="(201, 9)">
                                  <NullNode/>
                                  <IdentNode start="(201, 5)" end="(201, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(201, 10)" end="(201, 17)">
                              <AtomNode start="(201, 10)" end="(201, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(201, 13)" end="(201, 17)">
                                <TacticTacticseq1IndentedNode start="(201, 13)" end="(201, 17)">
                                  <NullNode start="(201, 13)" end="(201, 17)">
                                    <OtherNode start="(201, 13)" end="(201, 17)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ eraseP p (replicate 0 a) = if p a = true then replicate (0 - 1) a else replicate 0 a" state_after="no goals" tactic="simp">
                                      <AtomNode start="(201, 13)" end="(201, 17)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(202, 3)" end="(204, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(202, 3)" end="(202, 14)">
                              <OtherNode start="(202, 3)" end="(202, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(202, 3)" end="(202, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(202, 5)" end="(202, 9)">
                                  <NullNode/>
                                  <IdentNode start="(202, 5)" end="(202, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(202, 10)" end="(202, 14)">
                                  <IdentNode start="(202, 10)" end="(202, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                  <IdentNode start="(202, 12)" end="(202, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(202, 15)" end="(204, 23)">
                              <AtomNode start="(202, 15)" end="(202, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(203, 5)" end="(204, 23)">
                                <TacticTacticseq1IndentedNode start="(203, 5)" end="(204, 23)">
                                  <NullNode start="(203, 5)" end="(204, 23)">
                                    <OtherNode start="(203, 5)" end="(203, 44)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;n : Nat&#10;ih : eraseP p (replicate n a) = if p a = true then replicate (n - 1) a else replicate n a&#10;⊢ eraseP p (replicate (n + 1) a) = if p a = true then replicate (n + 1 - 1) a else replicate (n + 1) a" state_after="case succ&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;n : Nat&#10;ih : eraseP p (replicate n a) = if p a = true then replicate (n - 1) a else replicate n a&#10;⊢ (bif p a then replicate n a else a :: eraseP p (replicate n a)) =&#10;    if p a = true then replicate (n + 1 - 1) a else a :: replicate n a" tactic="simp only [replicate_succ, eraseP_cons]">
                                      <AtomNode start="(203, 5)" end="(203, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(203, 10)" end="(203, 14)">
                                        <AtomNode start="(203, 10)" end="(203, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(203, 15)" end="(203, 44)">
                                        <AtomNode start="(203, 15)" end="(203, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(203, 16)" end="(203, 43)">
                                          <OtherNode start="(203, 16)" end="(203, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(203, 16)" end="(203, 30)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(203, 30)" end="(203, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(203, 32)" end="(203, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(203, 32)" end="(203, 43)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(203, 43)" end="(203, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(204, 5)" end="(204, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;n : Nat&#10;ih : eraseP p (replicate n a) = if p a = true then replicate (n - 1) a else replicate n a&#10;⊢ (bif p a then replicate n a else a :: eraseP p (replicate n a)) =&#10;    if p a = true then replicate (n + 1 - 1) a else a :: replicate n a" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                                      <OtherNode start="(204, 5)" end="(204, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(204, 5)" end="(204, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(204, 11)" end="(204, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(204, 15)" end="(204, 23)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(204, 15)" end="(204, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(204, 20)" end="(204, 23)">
                                          <AtomNode start="(204, 20)" end="(204, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(204, 21)" end="(204, 22)">
                                            <OtherNode start="(204, 21)" end="(204, 22)" kind="Lean.Parser.Tactic.simpStar">
                                              <AtomNode start="(204, 21)" end="(204, 22)" leading="" trailing="" val="*"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(204, 22)" end="(204, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(206, 1)" end="(208, 39)" name="eraseP_replicate_of_pos" full_name="List.eraseP_replicate_of_pos">
      <CommandDeclmodifiersNode start="(206, 1)" end="(206, 8)">
        <NullNode/>
        <NullNode start="(206, 1)" end="(206, 8)">
          <OtherNode start="(206, 1)" end="(206, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(206, 1)" end="(206, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(206, 3)" end="(206, 7)">
              <OtherNode start="(206, 3)" end="(206, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(206, 3)" end="(206, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(206, 3)" end="(206, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(206, 7)" end="(206, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(206, 9)" end="(208, 39)" name="eraseP_replicate_of_pos" full_name="List.eraseP_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(206, 9)" end="(206, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(206, 17)" end="(206, 40)">
          <IdentNode start="(206, 17)" end="(206, 40)" leading="" trailing=" " raw_val="eraseP_replicate_of_pos" val="eraseP_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(206, 41)" end="(207, 51)">
          <NullNode start="(206, 41)" end="(206, 68)">
            <OtherNode start="(206, 41)" end="(206, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 41)" end="(206, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 42)" end="(206, 43)">
                <IdentNode start="(206, 42)" end="(206, 43)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(206, 44)" end="(206, 49)">
                <AtomNode start="(206, 44)" end="(206, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(206, 46)" end="(206, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(206, 49)" end="(206, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(206, 51)" end="(206, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 51)" end="(206, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 52)" end="(206, 53)">
                <IdentNode start="(206, 52)" end="(206, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(206, 54)" end="(206, 57)">
                <AtomNode start="(206, 54)" end="(206, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(206, 56)" end="(206, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(206, 57)" end="(206, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(206, 59)" end="(206, 68)">
              <AtomNode start="(206, 59)" end="(206, 60)" leading="" trailing="" val="("/>
              <NullNode start="(206, 60)" end="(206, 61)">
                <IdentNode start="(206, 60)" end="(206, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(206, 62)" end="(206, 67)">
                <AtomNode start="(206, 62)" end="(206, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 64)" end="(206, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(206, 64)" end="(206, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(206, 66)" end="(206, 67)">
                    <IdentNode start="(206, 66)" end="(206, 67)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(206, 67)" end="(206, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(206, 69)" end="(207, 51)">
            <AtomNode start="(206, 69)" end="(206, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(207, 5)" end="(207, 51)" kind="«term_=_»">
              <OtherNode start="(207, 5)" end="(207, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(207, 5)" end="(207, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(207, 5)" end="(207, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(207, 5)" end="(207, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(207, 6)" end="(207, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(207, 6)" end="(207, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(207, 16)" end="(207, 19)">
                        <IdentNode start="(207, 16)" end="(207, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(207, 18)" end="(207, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(207, 19)" end="(207, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(207, 20)" end="(207, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(207, 21)" end="(207, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(207, 28)" end="(207, 29)">
                  <IdentNode start="(207, 28)" end="(207, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(207, 30)" end="(207, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(207, 32)" end="(207, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(207, 32)" end="(207, 41)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(207, 42)" end="(207, 51)">
                  <OtherNode start="(207, 42)" end="(207, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(207, 42)" end="(207, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(207, 43)" end="(207, 48)" kind="«term_-_»">
                      <IdentNode start="(207, 43)" end="(207, 44)" leading="" trailing=" " raw_val="n" val="n"/>
                      <AtomNode start="(207, 45)" end="(207, 46)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(207, 47)" end="(207, 48)" kind="num">
                        <AtomNode start="(207, 47)" end="(207, 48)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(207, 48)" end="(207, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(207, 50)" end="(207, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(207, 52)" end="(208, 39)">
          <AtomNode start="(207, 52)" end="(207, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(207, 55)" end="(208, 39)">
            <AtomNode start="(207, 55)" end="(207, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(208, 3)" end="(208, 39)">
              <TacticTacticseq1IndentedNode start="(208, 3)" end="(208, 39)">
                <NullNode start="(208, 3)" end="(208, 39)">
                  <OtherNode start="(208, 3)" end="(208, 39)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : p a = true&#10;⊢ eraseP p (replicate n a) = replicate (n - 1) a" state_after="no goals" tactic="cases n &amp;lt;;&amp;gt; simp [replicate_succ, h]">
                    <OtherNode start="(208, 3)" end="(208, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(208, 3)" end="(208, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(208, 9)" end="(208, 10)">
                        <OtherNode start="(208, 9)" end="(208, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(208, 9)" end="(208, 10)" leading="" trailing=" " raw_val="n" val="n"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(208, 11)" end="(208, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(208, 15)" end="(208, 39)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(208, 15)" end="(208, 19)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(208, 20)" end="(208, 39)">
                        <AtomNode start="(208, 20)" end="(208, 21)" leading="" trailing="" val="["/>
                        <NullNode start="(208, 21)" end="(208, 38)">
                          <OtherNode start="(208, 21)" end="(208, 35)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(208, 21)" end="(208, 35)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                          <AtomNode start="(208, 35)" end="(208, 36)" leading="" trailing=" " val=","/>
                          <OtherNode start="(208, 37)" end="(208, 38)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(208, 37)" end="(208, 38)" leading="" trailing="" raw_val="h" val="h"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(208, 38)" end="(208, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(210, 1)" end="(212, 42)" name="eraseP_replicate_of_neg" full_name="List.eraseP_replicate_of_neg">
      <CommandDeclmodifiersNode start="(210, 1)" end="(210, 8)">
        <NullNode/>
        <NullNode start="(210, 1)" end="(210, 8)">
          <OtherNode start="(210, 1)" end="(210, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(210, 1)" end="(210, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(210, 3)" end="(210, 7)">
              <OtherNode start="(210, 3)" end="(210, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(210, 3)" end="(210, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(210, 3)" end="(210, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(210, 7)" end="(210, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(210, 9)" end="(212, 42)" name="eraseP_replicate_of_neg" full_name="List.eraseP_replicate_of_neg" _is_private_decl="False">
        <AtomNode start="(210, 9)" end="(210, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(210, 17)" end="(210, 40)">
          <IdentNode start="(210, 17)" end="(210, 40)" leading="" trailing=" " raw_val="eraseP_replicate_of_neg" val="eraseP_replicate_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(210, 41)" end="(211, 45)">
          <NullNode start="(210, 41)" end="(210, 69)">
            <OtherNode start="(210, 41)" end="(210, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(210, 41)" end="(210, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(210, 42)" end="(210, 43)">
                <IdentNode start="(210, 42)" end="(210, 43)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(210, 44)" end="(210, 49)">
                <AtomNode start="(210, 44)" end="(210, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(210, 46)" end="(210, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(210, 49)" end="(210, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(210, 51)" end="(210, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(210, 51)" end="(210, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(210, 52)" end="(210, 53)">
                <IdentNode start="(210, 52)" end="(210, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(210, 54)" end="(210, 57)">
                <AtomNode start="(210, 54)" end="(210, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(210, 56)" end="(210, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(210, 57)" end="(210, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(210, 59)" end="(210, 69)">
              <AtomNode start="(210, 59)" end="(210, 60)" leading="" trailing="" val="("/>
              <NullNode start="(210, 60)" end="(210, 61)">
                <IdentNode start="(210, 60)" end="(210, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(210, 62)" end="(210, 68)">
                <AtomNode start="(210, 62)" end="(210, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(210, 64)" end="(210, 68)" kind="«term¬_»">
                  <AtomNode start="(210, 64)" end="(210, 65)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(210, 65)" end="(210, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(210, 65)" end="(210, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(210, 67)" end="(210, 68)">
                      <IdentNode start="(210, 67)" end="(210, 68)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(210, 68)" end="(210, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(210, 70)" end="(211, 45)">
            <AtomNode start="(210, 70)" end="(210, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(211, 5)" end="(211, 45)" kind="«term_=_»">
              <OtherNode start="(211, 5)" end="(211, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(211, 5)" end="(211, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(211, 5)" end="(211, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(211, 5)" end="(211, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(211, 6)" end="(211, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(211, 6)" end="(211, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(211, 16)" end="(211, 19)">
                        <IdentNode start="(211, 16)" end="(211, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(211, 18)" end="(211, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(211, 19)" end="(211, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(211, 20)" end="(211, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(211, 21)" end="(211, 27)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(211, 28)" end="(211, 29)">
                  <IdentNode start="(211, 28)" end="(211, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(211, 30)" end="(211, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(211, 32)" end="(211, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(211, 32)" end="(211, 41)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(211, 42)" end="(211, 45)">
                  <IdentNode start="(211, 42)" end="(211, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(211, 44)" end="(211, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(211, 46)" end="(212, 42)">
          <AtomNode start="(211, 46)" end="(211, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(211, 49)" end="(212, 42)">
            <AtomNode start="(211, 49)" end="(211, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(212, 3)" end="(212, 42)">
              <TacticTacticseq1IndentedNode start="(212, 3)" end="(212, 42)">
                <NullNode start="(212, 3)" end="(212, 42)">
                  <OtherNode start="(212, 3)" end="(212, 42)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : ¬p a = true&#10;⊢ eraseP p (replicate n a) = replicate n a" state_after="no goals" tactic="rw [eraseP_of_forall_not (by simp_all)]">
                    <AtomNode start="(212, 3)" end="(212, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(212, 6)" end="(212, 42)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(212, 6)" end="(212, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(212, 7)" end="(212, 41)">
                        <OtherNode start="(212, 7)" end="(212, 41)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(212, 7)" end="(212, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(212, 7)" end="(212, 27)" leading="" trailing=" " raw_val="eraseP_of_forall_not" val="eraseP_of_forall_not" full_name="List.eraseP_of_forall_not" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(37, 9)" def_end="(37, 29)"/>
                            <NullNode start="(212, 28)" end="(212, 41)">
                              <OtherNode start="(212, 28)" end="(212, 41)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(212, 28)" end="(212, 29)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(212, 29)" end="(212, 40)">
                                  <AtomNode start="(212, 29)" end="(212, 31)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(212, 32)" end="(212, 40)">
                                    <TacticTacticseq1IndentedNode start="(212, 32)" end="(212, 40)">
                                      <NullNode start="(212, 32)" end="(212, 40)">
                                        <OtherNode start="(212, 32)" end="(212, 40)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;p : α → Bool&#10;n : Nat&#10;a : α&#10;h : ¬p a = true&#10;⊢ ∀ (a_1 : α), a_1 ∈ replicate n a → ¬p a_1 = true" state_after="no goals" tactic="simp_all">
                                          <AtomNode start="(212, 32)" end="(212, 40)" leading="" trailing="" val="simp_all"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(212, 40)" end="(212, 41)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(212, 41)" end="(212, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(214, 1)" end="(221, 40)" name="IsPrefix.eraseP" full_name="List.IsPrefix.eraseP">
      <CommandDeclmodifiersNode start="(214, 1)" end="(214, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(214, 1)" end="(214, 10)">
          <OtherNode start="(214, 1)" end="(214, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(214, 1)" end="(214, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(214, 11)" end="(221, 40)" name="IsPrefix.eraseP" full_name="List.IsPrefix.eraseP" _is_private_decl="False">
        <AtomNode start="(214, 11)" end="(214, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(214, 19)" end="(214, 34)">
          <IdentNode start="(214, 19)" end="(214, 34)" leading="" trailing=" " raw_val="IsPrefix.eraseP" val="IsPrefix.eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(214, 35)" end="(214, 80)">
          <NullNode start="(214, 35)" end="(214, 50)">
            <TermExplicitbinderNode start="(214, 35)" end="(214, 50)">
              <AtomNode start="(214, 35)" end="(214, 36)" leading="" trailing="" val="("/>
              <NullNode start="(214, 36)" end="(214, 37)">
                <IdentNode start="(214, 36)" end="(214, 37)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(214, 38)" end="(214, 49)">
                <AtomNode start="(214, 38)" end="(214, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(214, 40)" end="(214, 49)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(214, 40)" end="(214, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(214, 43)" end="(214, 46)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(214, 47)" end="(214, 49)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(214, 49)" end="(214, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(214, 51)" end="(214, 80)">
            <AtomNode start="(214, 51)" end="(214, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(214, 53)" end="(214, 80)" kind="List.«term_&amp;lt;+:_»">
              <OtherNode start="(214, 53)" end="(214, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(214, 53)" end="(214, 62)" leading="" trailing=" " raw_val="l₁.eraseP" val="l₁.eraseP"/>
                <NullNode start="(214, 63)" end="(214, 64)">
                  <IdentNode start="(214, 63)" end="(214, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(214, 65)" end="(214, 68)" leading="" trailing=" " val="&amp;lt;+:"/>
              <OtherNode start="(214, 69)" end="(214, 80)" kind="Lean.Parser.Term.app">
                <IdentNode start="(214, 69)" end="(214, 78)" leading="" trailing=" " raw_val="l₂.eraseP" val="l₂.eraseP"/>
                <NullNode start="(214, 79)" end="(214, 80)">
                  <IdentNode start="(214, 79)" end="(214, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(214, 81)" end="(221, 40)">
          <AtomNode start="(214, 81)" end="(214, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(214, 84)" end="(221, 40)">
            <AtomNode start="(214, 84)" end="(214, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(215, 3)" end="(221, 40)">
              <TacticTacticseq1IndentedNode start="(215, 3)" end="(221, 40)">
                <NullNode start="(215, 3)" end="(221, 40)">
                  <OtherNode start="(215, 3)" end="(215, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p l₂" state_after="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p l₂" tactic="rw [IsPrefix] at h">
                    <AtomNode start="(215, 3)" end="(215, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(215, 6)" end="(215, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(215, 6)" end="(215, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(215, 7)" end="(215, 15)">
                        <OtherNode start="(215, 7)" end="(215, 15)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(215, 7)" end="(215, 15)" leading="" trailing="" raw_val="IsPrefix" val="IsPrefix" full_name="List.IsPrefix" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(215, 15)" end="(215, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(215, 17)" end="(215, 21)">
                      <OtherNode start="(215, 17)" end="(215, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(215, 17)" end="(215, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(215, 20)" end="(215, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(215, 20)" end="(215, 21)">
                            <IdentNode start="(215, 20)" end="(215, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(216, 3)" end="(216, 23)" kind="Lean.Parser.Tactic.obtain" state_before="α✝ : Type u_1&#10;l₁ l₂ : List α✝&#10;p : α✝ → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p l₂" state_after="case intro&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p (l₁ ++ t)" tactic="obtain ⟨t, rfl⟩ := h">
                    <AtomNode start="(216, 3)" end="(216, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(216, 10)" end="(216, 18)">
                      <OtherNode start="(216, 10)" end="(216, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(216, 10)" end="(216, 18)">
                          <OtherNode start="(216, 10)" end="(216, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(216, 10)" end="(216, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(216, 11)" end="(216, 17)">
                              <OtherNode start="(216, 11)" end="(216, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(216, 11)" end="(216, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(216, 11)" end="(216, 12)">
                                    <OtherNode start="(216, 11)" end="(216, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(216, 11)" end="(216, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(216, 12)" end="(216, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(216, 14)" end="(216, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(216, 14)" end="(216, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(216, 14)" end="(216, 17)">
                                    <OtherNode start="(216, 14)" end="(216, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(216, 14)" end="(216, 17)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(216, 17)" end="(216, 18)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(216, 19)" end="(216, 23)">
                      <AtomNode start="(216, 19)" end="(216, 21)" leading="" trailing=" " val=":="/>
                      <NullNode start="(216, 22)" end="(216, 23)">
                        <IdentNode start="(216, 22)" end="(216, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(217, 3)" end="(217, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p (l₁ ++ t)" state_after="case intro&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;⊢ eraseP p l₁ &amp;lt;+: if l₁.any p = true then eraseP p l₁ ++ t else l₁ ++ eraseP p t" tactic="rw [eraseP_append]">
                    <AtomNode start="(217, 3)" end="(217, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(217, 6)" end="(217, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(217, 6)" end="(217, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(217, 7)" end="(217, 20)">
                        <OtherNode start="(217, 7)" end="(217, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(217, 7)" end="(217, 20)" leading="" trailing="" raw_val="eraseP_append" val="eraseP_append" full_name="List.eraseP_append" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(188, 9)" def_end="(188, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(217, 20)" end="(217, 21)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(218, 3)" end="(218, 8)" kind="Lean.Parser.Tactic.split" state_before="case intro&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;⊢ eraseP p l₁ &amp;lt;+: if l₁.any p = true then eraseP p l₁ ++ t else l₁ ++ eraseP p t" state_after="case intro.isTrue&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p l₁ ++ t&#10;&#10;case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: l₁ ++ eraseP p t" tactic="split">
                    <AtomNode start="(218, 3)" end="(218, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(219, 3)" end="(219, 40)" kind="Lean.cdot" state_before="case intro.isTrue&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p l₁ ++ t&#10;&#10;case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: l₁ ++ eraseP p t" state_after="case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: l₁ ++ eraseP p t" tactic="· exact prefix_append (eraseP p l₁) t">
                    <OtherNode start="(219, 3)" end="(219, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(219, 3)" end="(219, 4)" kind="patternIgnore">
                        <OtherNode start="(219, 3)" end="(219, 4)" kind="token.«· »">
                          <AtomNode start="(219, 3)" end="(219, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(219, 5)" end="(219, 40)">
                      <TacticTacticseq1IndentedNode start="(219, 5)" end="(219, 40)">
                        <NullNode start="(219, 5)" end="(219, 40)">
                          <OtherNode start="(219, 5)" end="(219, 40)" kind="Lean.Parser.Tactic.exact" state_before="case intro.isTrue&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: eraseP p l₁ ++ t" state_after="no goals" tactic="exact prefix_append (eraseP p l₁) t">
                            <AtomNode start="(219, 5)" end="(219, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(219, 11)" end="(219, 40)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(219, 11)" end="(219, 24)" leading="" trailing=" " raw_val="prefix_append" val="prefix_append" full_name="List.prefix_append" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                              <NullNode start="(219, 25)" end="(219, 40)">
                                <OtherNode start="(219, 25)" end="(219, 38)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(219, 25)" end="(219, 26)" leading="" trailing="" val="("/>
                                  <OtherNode start="(219, 26)" end="(219, 37)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(219, 26)" end="(219, 32)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    <NullNode start="(219, 33)" end="(219, 37)">
                                      <IdentNode start="(219, 33)" end="(219, 34)" leading="" trailing=" " raw_val="p" val="p"/>
                                      <IdentNode start="(219, 35)" end="(219, 37)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(219, 37)" end="(219, 38)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <IdentNode start="(219, 39)" end="(219, 40)" leading="" trailing="&#10;  " raw_val="t" val="t"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(220, 3)" end="(221, 40)" kind="Lean.cdot" state_before="case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: l₁ ++ eraseP p t" state_after="no goals" tactic="· rw [eraseP_of_forall_not (by simp_all)]&#10;  exact prefix_append l₁ (eraseP p t)">
                    <OtherNode start="(220, 3)" end="(220, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(220, 3)" end="(220, 4)" kind="patternIgnore">
                        <OtherNode start="(220, 3)" end="(220, 4)" kind="token.«· »">
                          <AtomNode start="(220, 3)" end="(220, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(220, 5)" end="(221, 40)">
                      <TacticTacticseq1IndentedNode start="(220, 5)" end="(221, 40)">
                        <NullNode start="(220, 5)" end="(221, 40)">
                          <OtherNode start="(220, 5)" end="(220, 44)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ eraseP p l₁ &amp;lt;+: l₁ ++ eraseP p t" state_after="case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ l₁ &amp;lt;+: l₁ ++ eraseP p t" tactic="rw [eraseP_of_forall_not (by simp_all)]">
                            <AtomNode start="(220, 5)" end="(220, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(220, 8)" end="(220, 44)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(220, 8)" end="(220, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(220, 9)" end="(220, 43)">
                                <OtherNode start="(220, 9)" end="(220, 43)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(220, 9)" end="(220, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(220, 9)" end="(220, 29)" leading="" trailing=" " raw_val="eraseP_of_forall_not" val="eraseP_of_forall_not" full_name="List.eraseP_of_forall_not" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(37, 9)" def_end="(37, 29)"/>
                                    <NullNode start="(220, 30)" end="(220, 43)">
                                      <OtherNode start="(220, 30)" end="(220, 43)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(220, 30)" end="(220, 31)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(220, 31)" end="(220, 42)">
                                          <AtomNode start="(220, 31)" end="(220, 33)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(220, 34)" end="(220, 42)">
                                            <TacticTacticseq1IndentedNode start="(220, 34)" end="(220, 42)">
                                              <NullNode start="(220, 34)" end="(220, 42)">
                                                <OtherNode start="(220, 34)" end="(220, 42)" kind="Lean.Parser.Tactic.simpAll" state_before="α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ ∀ (a : α✝), a ∈ l₁ → ¬p a = true" state_after="no goals" tactic="simp_all">
                                                  <AtomNode start="(220, 34)" end="(220, 42)" leading="" trailing="" val="simp_all"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(220, 42)" end="(220, 43)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(220, 43)" end="(220, 44)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(221, 5)" end="(221, 40)" kind="Lean.Parser.Tactic.exact" state_before="case intro.isFalse&#10;α✝ : Type u_1&#10;l₁ : List α✝&#10;p : α✝ → Bool&#10;t : List α✝&#10;h✝ : ¬l₁.any p = true&#10;⊢ l₁ &amp;lt;+: l₁ ++ eraseP p t" state_after="no goals" tactic="exact prefix_append l₁ (eraseP p t)">
                            <AtomNode start="(221, 5)" end="(221, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(221, 11)" end="(221, 40)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(221, 11)" end="(221, 24)" leading="" trailing=" " raw_val="prefix_append" val="prefix_append" full_name="List.prefix_append" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                              <NullNode start="(221, 25)" end="(221, 40)">
                                <IdentNode start="(221, 25)" end="(221, 27)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                <OtherNode start="(221, 28)" end="(221, 40)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(221, 28)" end="(221, 29)" leading="" trailing="" val="("/>
                                  <OtherNode start="(221, 29)" end="(221, 39)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(221, 29)" end="(221, 35)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    <NullNode start="(221, 36)" end="(221, 39)">
                                      <IdentNode start="(221, 36)" end="(221, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                                      <IdentNode start="(221, 38)" end="(221, 39)" leading="" trailing="" raw_val="t" val="t"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(221, 39)" end="(221, 40)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(223, 1)" end="(258, 17)" name="eraseP_eq_iff" full_name="List.eraseP_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(223, 1)" end="(258, 17)" name="eraseP_eq_iff" full_name="List.eraseP_eq_iff" _is_private_decl="False">
        <AtomNode start="(223, 1)" end="(223, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(223, 9)" end="(223, 22)">
          <IdentNode start="(223, 9)" end="(223, 22)" leading="" trailing=" " raw_val="eraseP_eq_iff" val="eraseP_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(223, 23)" end="(226, 79)">
          <NullNode start="(223, 23)" end="(223, 39)">
            <OtherNode start="(223, 23)" end="(223, 26)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(223, 23)" end="(223, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(223, 24)" end="(223, 25)">
                <IdentNode start="(223, 24)" end="(223, 25)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(223, 25)" end="(223, 26)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(223, 27)" end="(223, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(223, 27)" end="(223, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(223, 28)" end="(223, 29)">
                <IdentNode start="(223, 28)" end="(223, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(223, 30)" end="(223, 38)">
                <AtomNode start="(223, 30)" end="(223, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(223, 32)" end="(223, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(223, 32)" end="(223, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(223, 37)" end="(223, 38)">
                    <IdentNode start="(223, 37)" end="(223, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(223, 38)" end="(223, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(223, 40)" end="(226, 79)">
            <AtomNode start="(223, 40)" end="(223, 41)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(224, 5)" end="(226, 79)" kind="«term_↔_»">
              <OtherNode start="(224, 5)" end="(224, 20)" kind="«term_=_»">
                <OtherNode start="(224, 5)" end="(224, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(224, 5)" end="(224, 13)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(224, 14)" end="(224, 15)">
                    <IdentNode start="(224, 14)" end="(224, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(224, 16)" end="(224, 17)" leading="" trailing=" " val="="/>
                <IdentNode start="(224, 18)" end="(224, 20)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </OtherNode>
              <AtomNode start="(224, 21)" end="(224, 22)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(225, 7)" end="(226, 79)" kind="«term_∨_»">
                <OtherNode start="(225, 7)" end="(225, 34)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(225, 7)" end="(225, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(225, 8)" end="(225, 33)" kind="«term_∧_»">
                    <OtherNode start="(225, 8)" end="(225, 24)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(225, 8)" end="(225, 9)" leading="" trailing="" val="("/>
                      <OtherNode start="(225, 9)" end="(225, 23)" kind="Lean.«term∀__,_»">
                        <AtomNode start="(225, 9)" end="(225, 10)" leading="" trailing=" " val="∀"/>
                        <LeanBinderidentNode start="(225, 11)" end="(225, 12)">
                          <IdentNode start="(225, 11)" end="(225, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                        <OtherNode start="(225, 13)" end="(225, 16)" kind="Lean.«binderTerm∈_»">
                          <AtomNode start="(225, 13)" end="(225, 14)" leading="" trailing=" " val="∈"/>
                          <IdentNode start="(225, 15)" end="(225, 16)" leading="" trailing="" raw_val="l" val="l"/>
                        </OtherNode>
                        <AtomNode start="(225, 16)" end="(225, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(225, 18)" end="(225, 23)" kind="«term¬_»">
                          <AtomNode start="(225, 18)" end="(225, 19)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(225, 20)" end="(225, 23)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(225, 20)" end="(225, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(225, 22)" end="(225, 23)">
                              <IdentNode start="(225, 22)" end="(225, 23)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(225, 23)" end="(225, 24)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <AtomNode start="(225, 25)" end="(225, 26)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(225, 27)" end="(225, 33)" kind="«term_=_»">
                      <IdentNode start="(225, 27)" end="(225, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(225, 29)" end="(225, 30)" leading="" trailing=" " val="="/>
                      <IdentNode start="(225, 31)" end="(225, 33)" leading="" trailing="" raw_val="l'" val="l'"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(225, 33)" end="(225, 34)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(225, 35)" end="(225, 36)" leading="" trailing="&#10;        " val="∨"/>
                <OtherNode start="(226, 9)" end="(226, 79)" kind="«term∃_,_»">
                  <AtomNode start="(226, 9)" end="(226, 10)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(226, 11)" end="(226, 18)" kind="Lean.explicitBinders">
                    <OtherNode start="(226, 11)" end="(226, 18)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(226, 11)" end="(226, 18)">
                        <LeanBinderidentNode start="(226, 11)" end="(226, 12)">
                          <IdentNode start="(226, 11)" end="(226, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(226, 13)" end="(226, 15)">
                          <IdentNode start="(226, 13)" end="(226, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(226, 16)" end="(226, 18)">
                          <IdentNode start="(226, 16)" end="(226, 18)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(226, 18)" end="(226, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(226, 20)" end="(226, 79)" kind="«term_∧_»">
                    <OtherNode start="(226, 20)" end="(226, 37)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(226, 20)" end="(226, 21)" leading="" trailing="" val="("/>
                      <OtherNode start="(226, 21)" end="(226, 36)" kind="Lean.«term∀__,_»">
                        <AtomNode start="(226, 21)" end="(226, 22)" leading="" trailing=" " val="∀"/>
                        <LeanBinderidentNode start="(226, 23)" end="(226, 24)">
                          <IdentNode start="(226, 23)" end="(226, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                        </LeanBinderidentNode>
                        <OtherNode start="(226, 25)" end="(226, 29)" kind="Lean.«binderTerm∈_»">
                          <AtomNode start="(226, 25)" end="(226, 26)" leading="" trailing=" " val="∈"/>
                          <IdentNode start="(226, 27)" end="(226, 29)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                        </OtherNode>
                        <AtomNode start="(226, 29)" end="(226, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(226, 31)" end="(226, 36)" kind="«term¬_»">
                          <AtomNode start="(226, 31)" end="(226, 32)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(226, 33)" end="(226, 36)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(226, 33)" end="(226, 34)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(226, 35)" end="(226, 36)">
                              <IdentNode start="(226, 35)" end="(226, 36)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(226, 36)" end="(226, 37)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <AtomNode start="(226, 38)" end="(226, 39)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(226, 40)" end="(226, 79)" kind="«term_∧_»">
                      <OtherNode start="(226, 40)" end="(226, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(226, 40)" end="(226, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(226, 42)" end="(226, 43)">
                          <IdentNode start="(226, 42)" end="(226, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(226, 44)" end="(226, 45)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(226, 46)" end="(226, 79)" kind="«term_∧_»">
                        <OtherNode start="(226, 46)" end="(226, 63)" kind="«term_=_»">
                          <IdentNode start="(226, 46)" end="(226, 47)" leading="" trailing=" " raw_val="l" val="l"/>
                          <AtomNode start="(226, 48)" end="(226, 49)" leading="" trailing=" " val="="/>
                          <OtherNode start="(226, 50)" end="(226, 63)" kind="«term_++_»">
                            <IdentNode start="(226, 50)" end="(226, 52)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                            <AtomNode start="(226, 53)" end="(226, 55)" leading="" trailing=" " val="++"/>
                            <OtherNode start="(226, 56)" end="(226, 63)" kind="«term_::_»">
                              <IdentNode start="(226, 56)" end="(226, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                              <AtomNode start="(226, 58)" end="(226, 60)" leading="" trailing=" " val="::"/>
                              <IdentNode start="(226, 61)" end="(226, 63)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(226, 64)" end="(226, 65)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(226, 66)" end="(226, 79)" kind="«term_=_»">
                          <IdentNode start="(226, 66)" end="(226, 68)" leading="" trailing=" " raw_val="l'" val="l'"/>
                          <AtomNode start="(226, 69)" end="(226, 70)" leading="" trailing=" " val="="/>
                          <OtherNode start="(226, 71)" end="(226, 79)" kind="«term_++_»">
                            <IdentNode start="(226, 71)" end="(226, 73)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                            <AtomNode start="(226, 74)" end="(226, 76)" leading="" trailing=" " val="++"/>
                            <IdentNode start="(226, 77)" end="(226, 79)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(226, 80)" end="(258, 17)">
          <AtomNode start="(226, 80)" end="(226, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(226, 83)" end="(258, 17)">
            <AtomNode start="(226, 83)" end="(226, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(227, 3)" end="(258, 17)">
              <TacticTacticseq1IndentedNode start="(227, 3)" end="(258, 17)">
                <NullNode start="(227, 3)" end="(258, 17)">
                  <OtherNode start="(227, 3)" end="(258, 17)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="no goals" tactic="cases exists_or_eq_self_of_eraseP p l with&#10;| inl h =&amp;gt;&#10;  constructor&#10;  · intro h'&#10;    left&#10;    exact ⟨eraseP_eq_self_iff.1 h, by simp_all⟩&#10;  · rintro (⟨-, rfl⟩ | ⟨a, l₁, l₂, h₁, h₂, rfl, rfl⟩)&#10;    · assumption&#10;    · rw [eraseP_append_right _ h₁, eraseP_cons_of_pos h₂]&#10;| inr h =&amp;gt;&#10;  obtain ⟨a, l₁, l₂, h₁, h₂, w₁, w₂⟩ := h&#10;  rw [w₂]&#10;  subst w₁&#10;  constructor&#10;  · rintro rfl&#10;    right&#10;    refine ⟨a, l₁, l₂, ?_⟩&#10;    simp_all&#10;  · rintro (h | h)&#10;    · simp_all&#10;    · obtain ⟨a', l₁', l₂', h₁', h₂', h, rfl⟩ := h&#10;      have p : l₁ = l₁' := by&#10;        have q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂) := by&#10;          rw [takeWhile_append_of_pos (by simp_all),&#10;            takeWhile_cons_of_neg (by simp [h₂]), append_nil]&#10;        have q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂') := by&#10;          rw [takeWhile_append_of_pos (by simpa using h₁'),&#10;            takeWhile_cons_of_neg (by simp [h₂']), append_nil]&#10;        simp [h] at q&#10;        rw [q', q]&#10;      subst p&#10;      simp_all">
                    <AtomNode start="(227, 3)" end="(227, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(227, 9)" end="(227, 40)">
                      <OtherNode start="(227, 9)" end="(227, 40)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <OtherNode start="(227, 9)" end="(227, 40)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(227, 9)" end="(227, 36)" leading="" trailing=" " raw_val="exists_or_eq_self_of_eraseP" val="exists_or_eq_self_of_eraseP" full_name="List.exists_or_eq_self_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(81, 9)" def_end="(81, 36)"/>
                          <NullNode start="(227, 37)" end="(227, 40)">
                            <IdentNode start="(227, 37)" end="(227, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                            <IdentNode start="(227, 39)" end="(227, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(227, 41)" end="(258, 17)">
                      <OtherNode start="(227, 41)" end="(258, 17)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(227, 41)" end="(227, 45)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(228, 3)" end="(258, 17)">
                          <OtherNode start="(228, 3)" end="(235, 61)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(228, 3)" end="(228, 10)">
                              <OtherNode start="(228, 3)" end="(228, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(228, 3)" end="(228, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(228, 5)" end="(228, 8)">
                                  <NullNode/>
                                  <IdentNode start="(228, 5)" end="(228, 8)" leading="" trailing=" " raw_val="inl" val="inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(228, 9)" end="(228, 10)">
                                  <IdentNode start="(228, 9)" end="(228, 10)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(228, 11)" end="(235, 61)">
                              <AtomNode start="(228, 11)" end="(228, 13)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(229, 5)" end="(235, 61)">
                                <TacticTacticseq1IndentedNode start="(229, 5)" end="(235, 61)">
                                  <NullNode start="(229, 5)" end="(235, 61)">
                                    <OtherNode start="(229, 5)" end="(229, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case inl&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="case inl.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l' →&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂&#10;&#10;case inl.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ ((∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂) →&#10;    eraseP p l = l'" tactic="constructor">
                                      <AtomNode start="(229, 5)" end="(229, 16)" leading="" trailing="&#10;    " val="constructor"/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(230, 5)" end="(232, 50)" kind="Lean.cdot" state_before="case inl.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l' →&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂&#10;&#10;case inl.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ ((∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂) →&#10;    eraseP p l = l'" state_after="case inl.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ ((∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂) →&#10;    eraseP p l = l'" tactic="· intro h'&#10;  left&#10;  exact ⟨eraseP_eq_self_iff.1 h, by simp_all⟩">
                                      <OtherNode start="(230, 5)" end="(230, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(230, 5)" end="(230, 6)" kind="patternIgnore">
                                          <OtherNode start="(230, 5)" end="(230, 6)" kind="token.«· »">
                                            <AtomNode start="(230, 5)" end="(230, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(230, 7)" end="(232, 50)">
                                        <TacticTacticseq1IndentedNode start="(230, 7)" end="(232, 50)">
                                          <NullNode start="(230, 7)" end="(232, 50)">
                                            <OtherNode start="(230, 7)" end="(230, 15)" kind="Lean.Parser.Tactic.intro" state_before="case inl.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l' →&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="case inl.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;h' : eraseP p l = l'&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;    ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" tactic="intro h'">
                                              <AtomNode start="(230, 7)" end="(230, 12)" leading="" trailing=" " val="intro"/>
                                              <NullNode start="(230, 13)" end="(230, 15)">
                                                <IdentNode start="(230, 13)" end="(230, 15)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(231, 7)" end="(231, 11)" kind="Lean.Parser.Tactic.left" state_before="case inl.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;h' : eraseP p l = l'&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;    ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="case inl.mp.h&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;h' : eraseP p l = l'&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l'" tactic="left">
                                              <AtomNode start="(231, 7)" end="(231, 11)" leading="" trailing="&#10;      " val="left"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(232, 7)" end="(232, 50)" kind="Lean.Parser.Tactic.exact" state_before="case inl.mp.h&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;h' : eraseP p l = l'&#10;⊢ (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l'" state_after="no goals" tactic="exact ⟨eraseP_eq_self_iff.1 h, by simp_all⟩">
                                              <AtomNode start="(232, 7)" end="(232, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(232, 13)" end="(232, 50)" kind="Lean.Parser.Term.anonymousCtor">
                                                <AtomNode start="(232, 13)" end="(232, 14)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(232, 14)" end="(232, 49)">
                                                  <OtherNode start="(232, 14)" end="(232, 36)" kind="Lean.Parser.Term.app">
                                                    <OtherNode start="(232, 14)" end="(232, 34)" kind="Lean.Parser.Term.proj">
                                                      <IdentNode start="(232, 14)" end="(232, 32)" leading="" trailing="" raw_val="eraseP_eq_self_iff" val="eraseP_eq_self_iff" full_name="List.eraseP_eq_self_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(140, 17)" def_end="(140, 35)"/>
                                                      <AtomNode start="(232, 32)" end="(232, 33)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(232, 33)" end="(232, 34)" kind="fieldIdx">
                                                        <AtomNode start="(232, 33)" end="(232, 34)" leading="" trailing=" " val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode start="(232, 35)" end="(232, 36)">
                                                      <IdentNode start="(232, 35)" end="(232, 36)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(232, 36)" end="(232, 37)" leading="" trailing=" " val=","/>
                                                  <TermBytacticNode start="(232, 38)" end="(232, 49)">
                                                    <AtomNode start="(232, 38)" end="(232, 40)" leading="" trailing=" " val="by"/>
                                                    <TacticTacticseqNode start="(232, 41)" end="(232, 49)">
                                                      <TacticTacticseq1IndentedNode start="(232, 41)" end="(232, 49)">
                                                        <NullNode start="(232, 41)" end="(232, 49)">
                                                          <OtherNode start="(232, 41)" end="(232, 49)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;h' : eraseP p l = l'&#10;⊢ l = l'" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(232, 41)" end="(232, 49)" leading="" trailing="" val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </TacticTacticseq1IndentedNode>
                                                    </TacticTacticseqNode>
                                                  </TermBytacticNode>
                                                </NullNode>
                                                <AtomNode start="(232, 49)" end="(232, 50)" leading="" trailing="&#10;    " val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(233, 5)" end="(235, 61)" kind="Lean.cdot" state_before="case inl.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ ((∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂) →&#10;    eraseP p l = l'" state_after="no goals" tactic="· rintro (⟨-, rfl⟩ | ⟨a, l₁, l₂, h₁, h₂, rfl, rfl⟩)&#10;  · assumption&#10;  · rw [eraseP_append_right _ h₁, eraseP_cons_of_pos h₂]">
                                      <OtherNode start="(233, 5)" end="(233, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(233, 5)" end="(233, 6)" kind="patternIgnore">
                                          <OtherNode start="(233, 5)" end="(233, 6)" kind="token.«· »">
                                            <AtomNode start="(233, 5)" end="(233, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(233, 7)" end="(235, 61)">
                                        <TacticTacticseq1IndentedNode start="(233, 7)" end="(235, 61)">
                                          <NullNode start="(233, 7)" end="(235, 61)">
                                            <OtherNode start="(233, 7)" end="(233, 56)" kind="Lean.Parser.Tactic.rintro" state_before="case inl.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ ((∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂) →&#10;    eraseP p l = l'" state_after="case inl.mpr.inl.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l&#10;&#10;case inl.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;h : eraseP p (l₁ ++ a :: l₂) = l₁ ++ a :: l₂&#10;⊢ eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂" tactic="rintro (⟨-, rfl⟩ | ⟨a, l₁, l₂, h₁, h₂, rfl, rfl⟩)">
                                              <AtomNode start="(233, 7)" end="(233, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(233, 14)" end="(233, 56)">
                                                <OtherNode start="(233, 14)" end="(233, 56)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(233, 14)" end="(233, 56)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                    <AtomNode start="(233, 14)" end="(233, 15)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(233, 15)" end="(233, 55)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                      <OtherNode start="(233, 15)" end="(233, 55)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                        <NullNode start="(233, 15)" end="(233, 55)">
                                                          <OtherNode start="(233, 15)" end="(233, 23)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(233, 15)" end="(233, 16)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(233, 16)" end="(233, 22)">
                                                            <OtherNode start="(233, 16)" end="(233, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 16)" end="(233, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 16)" end="(233, 17)">
                                                            <OtherNode start="(233, 16)" end="(233, 17)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                                            <AtomNode start="(233, 16)" end="(233, 17)" leading="" trailing="" val="-"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 17)" end="(233, 18)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 19)" end="(233, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 19)" end="(233, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 19)" end="(233, 22)">
                                                            <OtherNode start="(233, 19)" end="(233, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 19)" end="(233, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(233, 22)" end="(233, 23)" leading="" trailing=" " val="⟩"/>
                                                          </OtherNode>
                                                          <AtomNode start="(233, 24)" end="(233, 25)" leading="" trailing=" " val="|"/>
                                                          <OtherNode start="(233, 26)" end="(233, 55)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(233, 26)" end="(233, 27)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(233, 27)" end="(233, 54)">
                                                            <OtherNode start="(233, 27)" end="(233, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 27)" end="(233, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 27)" end="(233, 28)">
                                                            <OtherNode start="(233, 27)" end="(233, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 27)" end="(233, 28)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 28)" end="(233, 29)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 30)" end="(233, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 30)" end="(233, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 30)" end="(233, 32)">
                                                            <OtherNode start="(233, 30)" end="(233, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 30)" end="(233, 32)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 32)" end="(233, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 34)" end="(233, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 34)" end="(233, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 34)" end="(233, 36)">
                                                            <OtherNode start="(233, 34)" end="(233, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 34)" end="(233, 36)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 36)" end="(233, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 38)" end="(233, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 38)" end="(233, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 38)" end="(233, 40)">
                                                            <OtherNode start="(233, 38)" end="(233, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 38)" end="(233, 40)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 40)" end="(233, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 42)" end="(233, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 42)" end="(233, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 42)" end="(233, 44)">
                                                            <OtherNode start="(233, 42)" end="(233, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 42)" end="(233, 44)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 44)" end="(233, 45)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 46)" end="(233, 49)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 46)" end="(233, 49)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 46)" end="(233, 49)">
                                                            <OtherNode start="(233, 46)" end="(233, 49)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 46)" end="(233, 49)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 49)" end="(233, 50)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 51)" end="(233, 54)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 51)" end="(233, 54)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 51)" end="(233, 54)">
                                                            <OtherNode start="(233, 51)" end="(233, 54)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 51)" end="(233, 54)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(233, 54)" end="(233, 55)" leading="" trailing="" val="⟩"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <AtomNode start="(233, 55)" end="(233, 56)" leading="" trailing="&#10;      " val=")"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(234, 7)" end="(234, 19)" kind="Lean.cdot" state_before="case inl.mpr.inl.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l&#10;&#10;case inl.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;h : eraseP p (l₁ ++ a :: l₂) = l₁ ++ a :: l₂&#10;⊢ eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂" state_after="case inl.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;h : eraseP p (l₁ ++ a :: l₂) = l₁ ++ a :: l₂&#10;⊢ eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂" tactic="· assumption">
                                              <OtherNode start="(234, 7)" end="(234, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(234, 7)" end="(234, 8)" kind="patternIgnore">
                                                  <OtherNode start="(234, 7)" end="(234, 8)" kind="token.«· »">
                                                    <AtomNode start="(234, 7)" end="(234, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(234, 9)" end="(234, 19)">
                                                <TacticTacticseq1IndentedNode start="(234, 9)" end="(234, 19)">
                                                  <NullNode start="(234, 9)" end="(234, 19)">
                                                    <OtherNode start="(234, 9)" end="(234, 19)" kind="Lean.Parser.Tactic.assumption" state_before="case inl.mpr.inl.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : eraseP p l = l&#10;⊢ eraseP p l = l" state_after="no goals" tactic="assumption">
                                                      <AtomNode start="(234, 9)" end="(234, 19)" leading="" trailing="&#10;      " val="assumption"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(235, 7)" end="(235, 61)" kind="Lean.cdot" state_before="case inl.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;h : eraseP p (l₁ ++ a :: l₂) = l₁ ++ a :: l₂&#10;⊢ eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂" state_after="no goals" tactic="· rw [eraseP_append_right _ h₁, eraseP_cons_of_pos h₂]">
                                              <OtherNode start="(235, 7)" end="(235, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(235, 7)" end="(235, 8)" kind="patternIgnore">
                                                  <OtherNode start="(235, 7)" end="(235, 8)" kind="token.«· »">
                                                    <AtomNode start="(235, 7)" end="(235, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(235, 9)" end="(235, 61)">
                                                <TacticTacticseq1IndentedNode start="(235, 9)" end="(235, 61)">
                                                  <NullNode start="(235, 9)" end="(235, 61)">
                                                    <OtherNode start="(235, 9)" end="(235, 61)" kind="Lean.Parser.Tactic.rwSeq" state_before="case inl.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;h : eraseP p (l₁ ++ a :: l₂) = l₁ ++ a :: l₂&#10;⊢ eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂" state_after="no goals" tactic="rw [eraseP_append_right _ h₁, eraseP_cons_of_pos h₂]">
                                                      <AtomNode start="(235, 9)" end="(235, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(235, 12)" end="(235, 61)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(235, 12)" end="(235, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(235, 13)" end="(235, 60)">
                                                          <OtherNode start="(235, 13)" end="(235, 37)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(235, 13)" end="(235, 37)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(235, 13)" end="(235, 32)" leading="" trailing=" " raw_val="eraseP_append_right" val="eraseP_append_right" full_name="List.eraseP_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(182, 9)" def_end="(182, 28)"/>
                                                            <NullNode start="(235, 33)" end="(235, 37)">
                                                            <TermHoleNode start="(235, 33)" end="(235, 34)">
                                                            <AtomNode start="(235, 33)" end="(235, 34)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(235, 35)" end="(235, 37)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <AtomNode start="(235, 37)" end="(235, 38)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(235, 39)" end="(235, 60)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(235, 39)" end="(235, 60)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(235, 39)" end="(235, 57)" leading="" trailing=" " raw_val="eraseP_cons_of_pos" val="eraseP_cons_of_pos" full_name="List.eraseP_cons_of_pos" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(31, 17)" def_end="(31, 35)"/>
                                                            <NullNode start="(235, 58)" end="(235, 60)">
                                                            <IdentNode start="(235, 58)" end="(235, 60)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(235, 60)" end="(235, 61)" leading="" trailing="&#10;  " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(236, 3)" end="(258, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(236, 3)" end="(236, 10)">
                              <OtherNode start="(236, 3)" end="(236, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(236, 3)" end="(236, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(236, 5)" end="(236, 8)">
                                  <NullNode/>
                                  <IdentNode start="(236, 5)" end="(236, 8)" leading="" trailing=" " raw_val="inr" val="inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(236, 9)" end="(236, 10)">
                                  <IdentNode start="(236, 9)" end="(236, 10)" leading="" trailing=" " raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(236, 11)" end="(258, 17)">
                              <AtomNode start="(236, 11)" end="(236, 13)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(237, 5)" end="(258, 17)">
                                <TacticTacticseq1IndentedNode start="(237, 5)" end="(258, 17)">
                                  <NullNode start="(237, 5)" end="(258, 17)">
                                    <OtherNode start="(237, 5)" end="(237, 44)" kind="Lean.Parser.Tactic.obtain" state_before="case inr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;h : ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ eraseP p l = l₁ ++ l₂&#10;⊢ eraseP p l = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="case inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₁ : l = l₁ ++ a :: l₂&#10;w₂ : eraseP p l = l₁ ++ l₂&#10;⊢ eraseP p l = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" tactic="obtain ⟨a, l₁, l₂, h₁, h₂, w₁, w₂⟩ := h">
                                      <AtomNode start="(237, 5)" end="(237, 11)" leading="" trailing=" " val="obtain"/>
                                      <NullNode start="(237, 12)" end="(237, 39)">
                                        <OtherNode start="(237, 12)" end="(237, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(237, 12)" end="(237, 39)">
                                            <OtherNode start="(237, 12)" end="(237, 39)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                              <AtomNode start="(237, 12)" end="(237, 13)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(237, 13)" end="(237, 38)">
                                                <OtherNode start="(237, 13)" end="(237, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 13)" end="(237, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 13)" end="(237, 14)">
                                                      <OtherNode start="(237, 13)" end="(237, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 13)" end="(237, 14)" leading="" trailing="" raw_val="a" val="a"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(237, 14)" end="(237, 15)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(237, 16)" end="(237, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 16)" end="(237, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 16)" end="(237, 18)">
                                                      <OtherNode start="(237, 16)" end="(237, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 16)" end="(237, 18)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(237, 18)" end="(237, 19)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(237, 20)" end="(237, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 20)" end="(237, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 20)" end="(237, 22)">
                                                      <OtherNode start="(237, 20)" end="(237, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 20)" end="(237, 22)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(237, 22)" end="(237, 23)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(237, 24)" end="(237, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 24)" end="(237, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 24)" end="(237, 26)">
                                                      <OtherNode start="(237, 24)" end="(237, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 24)" end="(237, 26)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(237, 26)" end="(237, 27)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(237, 28)" end="(237, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 28)" end="(237, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 28)" end="(237, 30)">
                                                      <OtherNode start="(237, 28)" end="(237, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 28)" end="(237, 30)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(237, 30)" end="(237, 31)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(237, 32)" end="(237, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 32)" end="(237, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 32)" end="(237, 34)">
                                                      <OtherNode start="(237, 32)" end="(237, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 32)" end="(237, 34)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(237, 34)" end="(237, 35)" leading="" trailing=" " val=","/>
                                                <OtherNode start="(237, 36)" end="(237, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                  <OtherNode start="(237, 36)" end="(237, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                    <NullNode start="(237, 36)" end="(237, 38)">
                                                      <OtherNode start="(237, 36)" end="(237, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                        <IdentNode start="(237, 36)" end="(237, 38)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(237, 38)" end="(237, 39)" leading="" trailing=" " val="⟩"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(237, 40)" end="(237, 44)">
                                        <AtomNode start="(237, 40)" end="(237, 42)" leading="" trailing=" " val=":="/>
                                        <NullNode start="(237, 43)" end="(237, 44)">
                                          <IdentNode start="(237, 43)" end="(237, 44)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                        </NullNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(238, 5)" end="(238, 12)" kind="Lean.Parser.Tactic.rwSeq" state_before="case inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₁ : l = l₁ ++ a :: l₂&#10;w₂ : eraseP p l = l₁ ++ l₂&#10;⊢ eraseP p l = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="case inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₁ : l = l₁ ++ a :: l₂&#10;w₂ : eraseP p l = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" tactic="rw [w₂]">
                                      <AtomNode start="(238, 5)" end="(238, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(238, 8)" end="(238, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(238, 8)" end="(238, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(238, 9)" end="(238, 11)">
                                          <OtherNode start="(238, 9)" end="(238, 11)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(238, 9)" end="(238, 11)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(238, 11)" end="(238, 12)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(239, 5)" end="(239, 13)" kind="Lean.Parser.Tactic.subst" state_before="case inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;l : List α&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₁ : l = l₁ ++ a :: l₂&#10;w₂ : eraseP p l = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' ↔&#10;    (∀ (a : α), a ∈ l → ¬p a = true) ∧ l = l' ∨&#10;      ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="case inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' ↔&#10;    (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1" tactic="subst w₁">
                                      <AtomNode start="(239, 5)" end="(239, 10)" leading="" trailing=" " val="subst"/>
                                      <NullNode start="(239, 11)" end="(239, 13)">
                                        <IdentNode start="(239, 11)" end="(239, 13)" leading="" trailing="&#10;    " raw_val="w₁" val="w₁"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(240, 5)" end="(240, 16)" kind="Lean.Parser.Tactic.constructor" state_before="case inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' ↔&#10;    (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1" state_after="case inr.intro.intro.intro.intro.intro.intro.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' →&#10;    (∀ (a_2 : α), a_2 ∈ l₁ ++ a :: l₂ → ¬p a_2 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_2 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_2 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_2 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;&#10;case inr.intro.intro.intro.intro.intro.intro.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1) →&#10;    l₁ ++ l₂ = l'" tactic="constructor">
                                      <AtomNode start="(240, 5)" end="(240, 16)" leading="" trailing="&#10;    " val="constructor"/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(241, 5)" end="(244, 15)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.intro.intro.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' →&#10;    (∀ (a_2 : α), a_2 ∈ l₁ ++ a :: l₂ → ¬p a_2 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_2 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_2 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_2 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;&#10;case inr.intro.intro.intro.intro.intro.intro.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1) →&#10;    l₁ ++ l₂ = l'" state_after="case inr.intro.intro.intro.intro.intro.intro.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1) →&#10;    l₁ ++ l₂ = l'" tactic="· rintro rfl&#10;  right&#10;  refine ⟨a, l₁, l₂, ?_⟩&#10;  simp_all">
                                      <OtherNode start="(241, 5)" end="(241, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(241, 5)" end="(241, 6)" kind="patternIgnore">
                                          <OtherNode start="(241, 5)" end="(241, 6)" kind="token.«· »">
                                            <AtomNode start="(241, 5)" end="(241, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(241, 7)" end="(244, 15)">
                                        <TacticTacticseq1IndentedNode start="(241, 7)" end="(244, 15)">
                                          <NullNode start="(241, 7)" end="(244, 15)">
                                            <OtherNode start="(241, 7)" end="(241, 17)" kind="Lean.Parser.Tactic.rintro" state_before="case inr.intro.intro.intro.intro.intro.intro.mp&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ l₁ ++ l₂ = l' →&#10;    (∀ (a_2 : α), a_2 ∈ l₁ ++ a :: l₂ → ¬p a_2 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_2 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_2 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_2 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1" state_after="case inr.intro.intro.intro.intro.intro.intro.mp&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l₁ ++ l₂ ∨&#10;    ∃ a_1 l₁_1 l₂_1,&#10;      (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1" tactic="rintro rfl">
                                              <AtomNode start="(241, 7)" end="(241, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(241, 14)" end="(241, 17)">
                                                <OtherNode start="(241, 14)" end="(241, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(241, 14)" end="(241, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(241, 14)" end="(241, 17)" leading="" trailing="&#10;      " raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(242, 7)" end="(242, 12)" kind="Lean.Parser.Tactic.right" state_before="case inr.intro.intro.intro.intro.intro.intro.mp&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l₁ ++ l₂ ∨&#10;    ∃ a_1 l₁_1 l₂_1,&#10;      (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1" state_after="case inr.intro.intro.intro.intro.intro.intro.mp.h&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1" tactic="right">
                                              <AtomNode start="(242, 7)" end="(242, 12)" leading="" trailing="&#10;      " val="right"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(243, 7)" end="(243, 29)" kind="Lean.Parser.Tactic.refine" state_before="case inr.intro.intro.intro.intro.intro.intro.mp.h&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l₁ ++ l₂ = l₁_1 ++ l₂_1" state_after="case inr.intro.intro.intro.intro.intro.intro.mp.h&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l₁ ++ a :: l₂ = l₁ ++ a :: l₂ ∧ l₁ ++ l₂ = l₁ ++ l₂" tactic="refine ⟨a, l₁, l₂, ?_⟩">
                                              <AtomNode start="(243, 7)" end="(243, 13)" leading="" trailing=" " val="refine"/>
                                              <OtherNode start="(243, 14)" end="(243, 29)" kind="Lean.Parser.Term.anonymousCtor">
                                                <AtomNode start="(243, 14)" end="(243, 15)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(243, 15)" end="(243, 28)">
                                                  <IdentNode start="(243, 15)" end="(243, 16)" leading="" trailing="" raw_val="a" val="a"/>
                                                  <AtomNode start="(243, 16)" end="(243, 17)" leading="" trailing=" " val=","/>
                                                  <IdentNode start="(243, 18)" end="(243, 20)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                  <AtomNode start="(243, 20)" end="(243, 21)" leading="" trailing=" " val=","/>
                                                  <IdentNode start="(243, 22)" end="(243, 24)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                  <AtomNode start="(243, 24)" end="(243, 25)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(243, 26)" end="(243, 28)" kind="Lean.Parser.Term.syntheticHole">
                                                    <AtomNode start="(243, 26)" end="(243, 27)" leading="" trailing="" val="?"/>
                                                    <AtomNode start="(243, 27)" end="(243, 28)" leading="" trailing="" val="_"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(243, 28)" end="(243, 29)" leading="" trailing="&#10;      " val="⟩"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(244, 7)" end="(244, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case inr.intro.intro.intro.intro.intro.intro.mp.h&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ (∀ (b : α), b ∈ l₁ → ¬p b = true) ∧ p a = true ∧ l₁ ++ a :: l₂ = l₁ ++ a :: l₂ ∧ l₁ ++ l₂ = l₁ ++ l₂" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(244, 7)" end="(244, 15)" leading="" trailing="&#10;    " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(245, 5)" end="(258, 17)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1) →&#10;    l₁ ++ l₂ = l'" state_after="no goals" tactic="· rintro (h | h)&#10;  · simp_all&#10;  · obtain ⟨a', l₁', l₂', h₁', h₂', h, rfl⟩ := h&#10;    have p : l₁ = l₁' := by&#10;      have q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂) := by&#10;        rw [takeWhile_append_of_pos (by simp_all),&#10;          takeWhile_cons_of_neg (by simp [h₂]), append_nil]&#10;      have q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂') := by&#10;        rw [takeWhile_append_of_pos (by simpa using h₁'),&#10;          takeWhile_cons_of_neg (by simp [h₂']), append_nil]&#10;      simp [h] at q&#10;      rw [q', q]&#10;    subst p&#10;    simp_all">
                                      <OtherNode start="(245, 5)" end="(245, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(245, 5)" end="(245, 6)" kind="patternIgnore">
                                          <OtherNode start="(245, 5)" end="(245, 6)" kind="token.«· »">
                                            <AtomNode start="(245, 5)" end="(245, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(245, 7)" end="(258, 17)">
                                        <TacticTacticseq1IndentedNode start="(245, 7)" end="(258, 17)">
                                          <NullNode start="(245, 7)" end="(258, 17)">
                                            <OtherNode start="(245, 7)" end="(245, 21)" kind="Lean.Parser.Tactic.rintro" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l' ∨&#10;      ∃ a_1 l₁_1 l₂_1,&#10;        (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1) →&#10;    l₁ ++ l₂ = l'" state_after="case inr.intro.intro.intro.intro.intro.intro.mpr.inl&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h : (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l'&#10;⊢ l₁ ++ l₂ = l'&#10;&#10;case inr.intro.intro.intro.intro.intro.intro.mpr.inr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h :&#10;  ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;⊢ l₁ ++ l₂ = l'" tactic="rintro (h | h)">
                                              <AtomNode start="(245, 7)" end="(245, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(245, 14)" end="(245, 21)">
                                                <OtherNode start="(245, 14)" end="(245, 21)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(245, 14)" end="(245, 21)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                    <AtomNode start="(245, 14)" end="(245, 15)" leading="" trailing="" val="("/>
                                                    <OtherNode start="(245, 15)" end="(245, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                      <OtherNode start="(245, 15)" end="(245, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                        <NullNode start="(245, 15)" end="(245, 20)">
                                                          <OtherNode start="(245, 15)" end="(245, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(245, 15)" end="(245, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                                          </OtherNode>
                                                          <AtomNode start="(245, 17)" end="(245, 18)" leading="" trailing=" " val="|"/>
                                                          <OtherNode start="(245, 19)" end="(245, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(245, 19)" end="(245, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <AtomNode start="(245, 20)" end="(245, 21)" leading="" trailing="&#10;      " val=")"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(246, 7)" end="(246, 17)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inl&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h : (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l'&#10;⊢ l₁ ++ l₂ = l'&#10;&#10;case inr.intro.intro.intro.intro.intro.intro.mpr.inr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h :&#10;  ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;⊢ l₁ ++ l₂ = l'" state_after="case inr.intro.intro.intro.intro.intro.intro.mpr.inr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h :&#10;  ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;⊢ l₁ ++ l₂ = l'" tactic="· simp_all">
                                              <OtherNode start="(246, 7)" end="(246, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(246, 7)" end="(246, 8)" kind="patternIgnore">
                                                  <OtherNode start="(246, 7)" end="(246, 8)" kind="token.«· »">
                                                    <AtomNode start="(246, 7)" end="(246, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(246, 9)" end="(246, 17)">
                                                <TacticTacticseq1IndentedNode start="(246, 9)" end="(246, 17)">
                                                  <NullNode start="(246, 9)" end="(246, 17)">
                                                    <OtherNode start="(246, 9)" end="(246, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inl&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h : (∀ (a_1 : α), a_1 ∈ l₁ ++ a :: l₂ → ¬p a_1 = true) ∧ l₁ ++ a :: l₂ = l'&#10;⊢ l₁ ++ l₂ = l'" state_after="no goals" tactic="simp_all">
                                                      <AtomNode start="(246, 9)" end="(246, 17)" leading="" trailing="&#10;      " val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(247, 7)" end="(258, 17)" kind="Lean.cdot" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h :&#10;  ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;⊢ l₁ ++ l₂ = l'" state_after="no goals" tactic="· obtain ⟨a', l₁', l₂', h₁', h₂', h, rfl⟩ := h&#10;  have p : l₁ = l₁' := by&#10;    have q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂) := by&#10;      rw [takeWhile_append_of_pos (by simp_all),&#10;        takeWhile_cons_of_neg (by simp [h₂]), append_nil]&#10;    have q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂') := by&#10;      rw [takeWhile_append_of_pos (by simpa using h₁'),&#10;        takeWhile_cons_of_neg (by simp [h₂']), append_nil]&#10;    simp [h] at q&#10;    rw [q', q]&#10;  subst p&#10;  simp_all">
                                              <OtherNode start="(247, 7)" end="(247, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(247, 7)" end="(247, 8)" kind="patternIgnore">
                                                  <OtherNode start="(247, 7)" end="(247, 8)" kind="token.«· »">
                                                    <AtomNode start="(247, 7)" end="(247, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(247, 9)" end="(258, 17)">
                                                <TacticTacticseq1IndentedNode start="(247, 9)" end="(258, 17)">
                                                  <NullNode start="(247, 9)" end="(258, 17)">
                                                    <OtherNode start="(247, 9)" end="(247, 53)" kind="Lean.Parser.Tactic.obtain" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inr&#10;α : Type u_1&#10;l' : List α&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;h :&#10;  ∃ a_1 l₁_1 l₂_1,&#10;    (∀ (b : α), b ∈ l₁_1 → ¬p b = true) ∧ p a_1 = true ∧ l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ l' = l₁_1 ++ l₂_1&#10;⊢ l₁ ++ l₂ = l'" state_after="case inr.intro.intro.intro.intro.intro.intro.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;⊢ l₁ ++ l₂ = l₁' ++ l₂'" tactic="obtain ⟨a', l₁', l₂', h₁', h₂', h, rfl⟩ := h">
                                                      <AtomNode start="(247, 9)" end="(247, 15)" leading="" trailing=" " val="obtain"/>
                                                      <NullNode start="(247, 16)" end="(247, 48)">
                                                        <OtherNode start="(247, 16)" end="(247, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(247, 16)" end="(247, 48)">
                                                            <OtherNode start="(247, 16)" end="(247, 48)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(247, 16)" end="(247, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(247, 17)" end="(247, 47)">
                                                            <OtherNode start="(247, 17)" end="(247, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 17)" end="(247, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 17)" end="(247, 19)">
                                                            <OtherNode start="(247, 17)" end="(247, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 17)" end="(247, 19)" leading="" trailing="" raw_val="a'" val="a'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(247, 19)" end="(247, 20)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(247, 21)" end="(247, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 21)" end="(247, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 21)" end="(247, 24)">
                                                            <OtherNode start="(247, 21)" end="(247, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 21)" end="(247, 24)" leading="" trailing="" raw_val="l₁'" val="l₁'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(247, 24)" end="(247, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(247, 26)" end="(247, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 26)" end="(247, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 26)" end="(247, 29)">
                                                            <OtherNode start="(247, 26)" end="(247, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 26)" end="(247, 29)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(247, 29)" end="(247, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(247, 31)" end="(247, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 31)" end="(247, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 31)" end="(247, 34)">
                                                            <OtherNode start="(247, 31)" end="(247, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 31)" end="(247, 34)" leading="" trailing="" raw_val="h₁'" val="h₁'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(247, 34)" end="(247, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(247, 36)" end="(247, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 36)" end="(247, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 36)" end="(247, 39)">
                                                            <OtherNode start="(247, 36)" end="(247, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 36)" end="(247, 39)" leading="" trailing="" raw_val="h₂'" val="h₂'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(247, 39)" end="(247, 40)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(247, 41)" end="(247, 42)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 41)" end="(247, 42)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 41)" end="(247, 42)">
                                                            <OtherNode start="(247, 41)" end="(247, 42)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 41)" end="(247, 42)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(247, 42)" end="(247, 43)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(247, 44)" end="(247, 47)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(247, 44)" end="(247, 47)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(247, 44)" end="(247, 47)">
                                                            <OtherNode start="(247, 44)" end="(247, 47)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(247, 44)" end="(247, 47)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(247, 47)" end="(247, 48)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(247, 49)" end="(247, 53)">
                                                        <AtomNode start="(247, 49)" end="(247, 51)" leading="" trailing=" " val=":="/>
                                                        <NullNode start="(247, 52)" end="(247, 53)">
                                                          <IdentNode start="(247, 52)" end="(247, 53)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                        </NullNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(248, 9)" end="(256, 21)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;⊢ l₁ ++ l₂ = l₁' ++ l₂'" state_after="case inr.intro.intro.intro.intro.intro.intro.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p✝ : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p✝ b = true&#10;h₂ : p✝ a = true&#10;w₂ : eraseP p✝ (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p✝ b = true&#10;h₂' : p✝ a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;p : l₁ = l₁'&#10;⊢ l₁ ++ l₂ = l₁' ++ l₂'" tactic="have p : l₁ = l₁' := by&#10;  have q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂) := by&#10;    rw [takeWhile_append_of_pos (by simp_all),&#10;      takeWhile_cons_of_neg (by simp [h₂]), append_nil]&#10;  have q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂') := by&#10;    rw [takeWhile_append_of_pos (by simpa using h₁'),&#10;      takeWhile_cons_of_neg (by simp [h₂']), append_nil]&#10;  simp [h] at q&#10;  rw [q', q]">
                                                      <AtomNode start="(248, 9)" end="(248, 13)" leading="" trailing=" " val="have"/>
                                                      <OtherNode start="(248, 14)" end="(256, 21)" kind="Lean.Parser.Term.haveDecl">
                                                        <OtherNode start="(248, 14)" end="(256, 21)" kind="Lean.Parser.Term.haveIdDecl">
                                                          <OtherNode start="(248, 14)" end="(248, 15)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(248, 14)" end="(248, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(248, 16)" end="(248, 26)">
                                                            <TermTypespecNode start="(248, 16)" end="(248, 26)">
                                                            <AtomNode start="(248, 16)" end="(248, 17)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(248, 18)" end="(248, 26)" kind="«term_=_»">
                                                            <IdentNode start="(248, 18)" end="(248, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                                            <AtomNode start="(248, 21)" end="(248, 22)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(248, 23)" end="(248, 26)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                          </NullNode>
                                                          <AtomNode start="(248, 27)" end="(248, 29)" leading="" trailing=" " val=":="/>
                                                          <TermBytacticNode start="(248, 30)" end="(256, 21)">
                                                            <AtomNode start="(248, 30)" end="(248, 32)" leading="" trailing="&#10;          " val="by"/>
                                                            <TacticTacticseqNode start="(249, 11)" end="(256, 21)">
                                                            <TacticTacticseq1IndentedNode start="(249, 11)" end="(256, 21)">
                                                            <NullNode start="(249, 11)" end="(256, 21)">
                                                            <OtherNode start="(249, 11)" end="(251, 64)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;⊢ l₁ = l₁'" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;⊢ l₁ = l₁'" tactic="have q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂) := by&#10;  rw [takeWhile_append_of_pos (by simp_all),&#10;    takeWhile_cons_of_neg (by simp [h₂]), append_nil]">
                                                            <AtomNode start="(249, 11)" end="(249, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(249, 16)" end="(251, 64)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(249, 16)" end="(251, 64)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(249, 16)" end="(249, 17)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(249, 16)" end="(249, 17)" leading="" trailing=" " raw_val="q" val="q"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(249, 18)" end="(249, 66)">
                                                            <TermTypespecNode start="(249, 18)" end="(249, 66)">
                                                            <AtomNode start="(249, 18)" end="(249, 19)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(249, 20)" end="(249, 66)" kind="«term_=_»">
                                                            <IdentNode start="(249, 20)" end="(249, 22)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                                            <AtomNode start="(249, 23)" end="(249, 24)" leading="" trailing=" " val="="/>
                                                            <OtherNode start="(249, 25)" end="(249, 66)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(249, 25)" end="(249, 34)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="List.takeWhile" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            <NullNode start="(249, 35)" end="(249, 66)">
                                                            <OtherNode start="(249, 35)" end="(249, 50)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(249, 35)" end="(249, 36)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(249, 36)" end="(249, 49)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(249, 36)" end="(249, 39)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(249, 40)" end="(249, 49)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(249, 40)" end="(249, 41)">
                                                            <IdentNode start="(249, 40)" end="(249, 41)" leading="" trailing=" " raw_val="x" val="x"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(249, 42)" end="(249, 44)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(249, 45)" end="(249, 49)" kind="term!_">
                                                            <AtomNode start="(249, 45)" end="(249, 46)" leading="" trailing="" val="!"/>
                                                            <OtherNode start="(249, 46)" end="(249, 49)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(249, 46)" end="(249, 47)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <NullNode start="(249, 48)" end="(249, 49)">
                                                            <IdentNode start="(249, 48)" end="(249, 49)" leading="" trailing="" raw_val="x" val="x"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(249, 49)" end="(249, 50)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(249, 51)" end="(249, 66)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(249, 51)" end="(249, 52)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(249, 52)" end="(249, 65)" kind="«term_++_»">
                                                            <IdentNode start="(249, 52)" end="(249, 54)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                                            <AtomNode start="(249, 55)" end="(249, 57)" leading="" trailing=" " val="++"/>
                                                            <OtherNode start="(249, 58)" end="(249, 65)" kind="«term_::_»">
                                                            <IdentNode start="(249, 58)" end="(249, 59)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <AtomNode start="(249, 60)" end="(249, 62)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(249, 63)" end="(249, 65)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(249, 65)" end="(249, 66)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(249, 67)" end="(249, 69)" leading="" trailing=" " val=":="/>
                                                            <TermBytacticNode start="(249, 70)" end="(251, 64)">
                                                            <AtomNode start="(249, 70)" end="(249, 72)" leading="" trailing="&#10;            " val="by"/>
                                                            <TacticTacticseqNode start="(250, 13)" end="(251, 64)">
                                                            <TacticTacticseq1IndentedNode start="(250, 13)" end="(251, 64)">
                                                            <NullNode start="(250, 13)" end="(251, 64)">
                                                            <OtherNode start="(250, 13)" end="(251, 64)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;⊢ l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)" state_after="no goals" tactic="rw [takeWhile_append_of_pos (by simp_all),&#10;  takeWhile_cons_of_neg (by simp [h₂]), append_nil]">
                                                            <AtomNode start="(250, 13)" end="(250, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(250, 16)" end="(251, 64)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(250, 16)" end="(250, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(250, 17)" end="(251, 63)">
                                                            <OtherNode start="(250, 17)" end="(250, 54)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(250, 17)" end="(250, 54)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(250, 17)" end="(250, 40)" leading="" trailing=" " raw_val="takeWhile_append_of_pos" val="takeWhile_append_of_pos" full_name="List.takeWhile_append_of_pos" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            <NullNode start="(250, 41)" end="(250, 54)">
                                                            <OtherNode start="(250, 41)" end="(250, 54)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(250, 41)" end="(250, 42)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(250, 42)" end="(250, 53)">
                                                            <AtomNode start="(250, 42)" end="(250, 44)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(250, 45)" end="(250, 53)">
                                                            <TacticTacticseq1IndentedNode start="(250, 45)" end="(250, 53)">
                                                            <NullNode start="(250, 45)" end="(250, 53)">
                                                            <OtherNode start="(250, 45)" end="(250, 53)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;⊢ ∀ (a : α), a ∈ l₁ → (!p a) = true" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(250, 45)" end="(250, 53)" leading="" trailing="" val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(250, 53)" end="(250, 54)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(250, 54)" end="(250, 55)" leading="" trailing="&#10;              " val=","/>
                                                            <OtherNode start="(251, 15)" end="(251, 51)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(251, 15)" end="(251, 51)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(251, 15)" end="(251, 36)" leading="" trailing=" " raw_val="takeWhile_cons_of_neg" val="takeWhile_cons_of_neg" full_name="List.takeWhile_cons_of_neg" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            <NullNode start="(251, 37)" end="(251, 51)">
                                                            <OtherNode start="(251, 37)" end="(251, 51)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(251, 37)" end="(251, 38)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(251, 38)" end="(251, 50)">
                                                            <AtomNode start="(251, 38)" end="(251, 40)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(251, 41)" end="(251, 50)">
                                                            <TacticTacticseq1IndentedNode start="(251, 41)" end="(251, 50)">
                                                            <NullNode start="(251, 41)" end="(251, 50)">
                                                            <OtherNode start="(251, 41)" end="(251, 50)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;⊢ ¬(!p a) = true" state_after="no goals" tactic="simp [h₂]">
                                                            <AtomNode start="(251, 41)" end="(251, 45)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(251, 46)" end="(251, 50)">
                                                            <AtomNode start="(251, 46)" end="(251, 47)" leading="" trailing="" val="["/>
                                                            <NullNode start="(251, 47)" end="(251, 49)">
                                                            <OtherNode start="(251, 47)" end="(251, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(251, 47)" end="(251, 49)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(251, 49)" end="(251, 50)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(251, 50)" end="(251, 51)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(251, 51)" end="(251, 52)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(251, 53)" end="(251, 63)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(251, 53)" end="(251, 63)" leading="" trailing="" raw_val="append_nil" val="append_nil" full_name="List.append_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(251, 63)" end="(251, 64)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(252, 11)" end="(254, 65)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;⊢ l₁ = l₁'" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')&#10;⊢ l₁ = l₁'" tactic="have q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂') := by&#10;  rw [takeWhile_append_of_pos (by simpa using h₁'),&#10;    takeWhile_cons_of_neg (by simp [h₂']), append_nil]">
                                                            <AtomNode start="(252, 11)" end="(252, 15)" leading="" trailing=" " val="have"/>
                                                            <OtherNode start="(252, 16)" end="(254, 65)" kind="Lean.Parser.Term.haveDecl">
                                                            <OtherNode start="(252, 16)" end="(254, 65)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(252, 16)" end="(252, 18)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(252, 16)" end="(252, 18)" leading="" trailing=" " raw_val="q'" val="q'"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(252, 19)" end="(252, 71)">
                                                            <TermTypespecNode start="(252, 19)" end="(252, 71)">
                                                            <AtomNode start="(252, 19)" end="(252, 20)" leading="" trailing=" " val=":"/>
                                                            <OtherNode start="(252, 21)" end="(252, 71)" kind="«term_=_»">
                                                            <IdentNode start="(252, 21)" end="(252, 24)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                                                            <AtomNode start="(252, 25)" end="(252, 26)" leading="" trailing=" " val="="/>
                                                            <OtherNode start="(252, 27)" end="(252, 71)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(252, 27)" end="(252, 36)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="List.takeWhile" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            <NullNode start="(252, 37)" end="(252, 71)">
                                                            <OtherNode start="(252, 37)" end="(252, 52)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(252, 37)" end="(252, 38)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(252, 38)" end="(252, 51)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(252, 38)" end="(252, 41)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(252, 42)" end="(252, 51)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(252, 42)" end="(252, 43)">
                                                            <IdentNode start="(252, 42)" end="(252, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(252, 44)" end="(252, 46)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(252, 47)" end="(252, 51)" kind="term!_">
                                                            <AtomNode start="(252, 47)" end="(252, 48)" leading="" trailing="" val="!"/>
                                                            <OtherNode start="(252, 48)" end="(252, 51)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(252, 48)" end="(252, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <NullNode start="(252, 50)" end="(252, 51)">
                                                            <IdentNode start="(252, 50)" end="(252, 51)" leading="" trailing="" raw_val="x" val="x"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(252, 51)" end="(252, 52)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(252, 53)" end="(252, 71)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(252, 53)" end="(252, 54)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(252, 54)" end="(252, 70)" kind="«term_++_»">
                                                            <IdentNode start="(252, 54)" end="(252, 57)" leading="" trailing=" " raw_val="l₁'" val="l₁'"/>
                                                            <AtomNode start="(252, 58)" end="(252, 60)" leading="" trailing=" " val="++"/>
                                                            <OtherNode start="(252, 61)" end="(252, 70)" kind="«term_::_»">
                                                            <IdentNode start="(252, 61)" end="(252, 63)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                                            <AtomNode start="(252, 64)" end="(252, 66)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(252, 67)" end="(252, 70)" leading="" trailing="" raw_val="l₂'" val="l₂'"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(252, 70)" end="(252, 71)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </TermTypespecNode>
                                                            </NullNode>
                                                            <AtomNode start="(252, 72)" end="(252, 74)" leading="" trailing=" " val=":="/>
                                                            <TermBytacticNode start="(252, 75)" end="(254, 65)">
                                                            <AtomNode start="(252, 75)" end="(252, 77)" leading="" trailing="&#10;            " val="by"/>
                                                            <TacticTacticseqNode start="(253, 13)" end="(254, 65)">
                                                            <TacticTacticseq1IndentedNode start="(253, 13)" end="(254, 65)">
                                                            <NullNode start="(253, 13)" end="(254, 65)">
                                                            <OtherNode start="(253, 13)" end="(254, 65)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;⊢ l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')" state_after="no goals" tactic="rw [takeWhile_append_of_pos (by simpa using h₁'),&#10;  takeWhile_cons_of_neg (by simp [h₂']), append_nil]">
                                                            <AtomNode start="(253, 13)" end="(253, 15)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(253, 16)" end="(254, 65)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(253, 16)" end="(253, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(253, 17)" end="(254, 64)">
                                                            <OtherNode start="(253, 17)" end="(253, 61)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(253, 17)" end="(253, 61)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(253, 17)" end="(253, 40)" leading="" trailing=" " raw_val="takeWhile_append_of_pos" val="takeWhile_append_of_pos" full_name="List.takeWhile_append_of_pos" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            <NullNode start="(253, 41)" end="(253, 61)">
                                                            <OtherNode start="(253, 41)" end="(253, 61)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(253, 41)" end="(253, 42)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(253, 42)" end="(253, 60)">
                                                            <AtomNode start="(253, 42)" end="(253, 44)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(253, 45)" end="(253, 60)">
                                                            <TacticTacticseq1IndentedNode start="(253, 45)" end="(253, 60)">
                                                            <NullNode start="(253, 45)" end="(253, 60)">
                                                            <OtherNode start="(253, 45)" end="(253, 60)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;⊢ ∀ (a : α), a ∈ l₁' → (!p a) = true" state_after="no goals" tactic="simpa using h₁'">
                                                            <AtomNode start="(253, 45)" end="(253, 50)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(253, 51)" end="(253, 60)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(253, 51)" end="(253, 60)">
                                                            <AtomNode start="(253, 51)" end="(253, 56)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(253, 57)" end="(253, 60)" leading="" trailing="" raw_val="h₁'" val="h₁'"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(253, 60)" end="(253, 61)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(253, 61)" end="(253, 62)" leading="" trailing="&#10;              " val=","/>
                                                            <OtherNode start="(254, 15)" end="(254, 52)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(254, 15)" end="(254, 52)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(254, 15)" end="(254, 36)" leading="" trailing=" " raw_val="takeWhile_cons_of_neg" val="takeWhile_cons_of_neg" full_name="List.takeWhile_cons_of_neg" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                                            <NullNode start="(254, 37)" end="(254, 52)">
                                                            <OtherNode start="(254, 37)" end="(254, 52)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(254, 37)" end="(254, 38)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(254, 38)" end="(254, 51)">
                                                            <AtomNode start="(254, 38)" end="(254, 40)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(254, 41)" end="(254, 51)">
                                                            <TacticTacticseq1IndentedNode start="(254, 41)" end="(254, 51)">
                                                            <NullNode start="(254, 41)" end="(254, 51)">
                                                            <OtherNode start="(254, 41)" end="(254, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;⊢ ¬(!p a') = true" state_after="no goals" tactic="simp [h₂']">
                                                            <AtomNode start="(254, 41)" end="(254, 45)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(254, 46)" end="(254, 51)">
                                                            <AtomNode start="(254, 46)" end="(254, 47)" leading="" trailing="" val="["/>
                                                            <NullNode start="(254, 47)" end="(254, 50)">
                                                            <OtherNode start="(254, 47)" end="(254, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(254, 47)" end="(254, 50)" leading="" trailing="" raw_val="h₂'" val="h₂'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(254, 50)" end="(254, 51)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(254, 51)" end="(254, 52)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(254, 52)" end="(254, 53)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(254, 54)" end="(254, 64)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(254, 54)" end="(254, 64)" leading="" trailing="" raw_val="append_nil" val="append_nil" full_name="List.append_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(254, 64)" end="(254, 65)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(255, 11)" end="(255, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁ ++ a :: l₂)&#10;q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')&#10;⊢ l₁ = l₁'" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')&#10;⊢ l₁ = l₁'" tactic="simp [h] at q">
                                                            <AtomNode start="(255, 11)" end="(255, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(255, 16)" end="(255, 19)">
                                                            <AtomNode start="(255, 16)" end="(255, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(255, 17)" end="(255, 18)">
                                                            <OtherNode start="(255, 17)" end="(255, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(255, 17)" end="(255, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(255, 18)" end="(255, 19)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(255, 20)" end="(255, 24)">
                                                            <OtherNode start="(255, 20)" end="(255, 24)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(255, 20)" end="(255, 22)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(255, 23)" end="(255, 24)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(255, 23)" end="(255, 24)">
                                                            <IdentNode start="(255, 23)" end="(255, 24)" leading="" trailing="&#10;          " raw_val="q" val="q"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(256, 11)" end="(256, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p b = true&#10;h₂' : p a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;q' : l₁' = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')&#10;q : l₁ = takeWhile (fun x =&amp;gt; !p x) (l₁' ++ a' :: l₂')&#10;⊢ l₁ = l₁'" state_after="no goals" tactic="rw [q', q]">
                                                            <AtomNode start="(256, 11)" end="(256, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(256, 14)" end="(256, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(256, 14)" end="(256, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(256, 15)" end="(256, 20)">
                                                            <OtherNode start="(256, 15)" end="(256, 17)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(256, 15)" end="(256, 17)" leading="" trailing="" raw_val="q'" val="q'"/>
                                                            </OtherNode>
                                                            <AtomNode start="(256, 17)" end="(256, 18)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(256, 19)" end="(256, 20)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(256, 19)" end="(256, 20)" leading="" trailing="" raw_val="q" val="q"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(256, 20)" end="(256, 21)" leading="" trailing="&#10;        " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(257, 9)" end="(257, 16)" kind="Lean.Parser.Tactic.subst" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p✝ : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p✝ b = true&#10;h₂ : p✝ a = true&#10;w₂ : eraseP p✝ (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₁' l₂' : List α&#10;h₁' : ∀ (b : α), b ∈ l₁' → ¬p✝ b = true&#10;h₂' : p✝ a' = true&#10;h : l₁ ++ a :: l₂ = l₁' ++ a' :: l₂'&#10;p : l₁ = l₁'&#10;⊢ l₁ ++ l₂ = l₁' ++ l₂'" state_after="case inr.intro.intro.intro.intro.intro.intro.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₂' : List α&#10;h₂' : p a' = true&#10;h₁' : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h : l₁ ++ a :: l₂ = l₁ ++ a' :: l₂'&#10;⊢ l₁ ++ l₂ = l₁ ++ l₂'" tactic="subst p">
                                                      <AtomNode start="(257, 9)" end="(257, 14)" leading="" trailing=" " val="subst"/>
                                                      <NullNode start="(257, 15)" end="(257, 16)">
                                                        <IdentNode start="(257, 15)" end="(257, 16)" leading="" trailing="&#10;        " raw_val="p" val="p"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(258, 9)" end="(258, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case inr.intro.intro.intro.intro.intro.intro.mpr.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h₂ : p a = true&#10;w₂ : eraseP p (l₁ ++ a :: l₂) = l₁ ++ l₂&#10;a' : α&#10;l₂' : List α&#10;h₂' : p a' = true&#10;h₁' : ∀ (b : α), b ∈ l₁ → ¬p b = true&#10;h : l₁ ++ a :: l₂ = l₁ ++ a' :: l₂'&#10;⊢ l₁ ++ l₂ = l₁ ++ l₂'" state_after="no goals" tactic="simp_all">
                                                      <AtomNode start="(258, 9)" end="(258, 17)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(260, 1)" end="(261, 37)" name="Pairwise.eraseP" full_name="List.Pairwise.eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(260, 1)" end="(261, 37)" name="Pairwise.eraseP" full_name="List.Pairwise.eraseP" _is_private_decl="False">
        <AtomNode start="(260, 1)" end="(260, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(260, 9)" end="(260, 24)">
          <IdentNode start="(260, 9)" end="(260, 24)" leading="" trailing=" " raw_val="Pairwise.eraseP" val="Pairwise.eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(260, 25)" end="(260, 69)">
          <NullNode start="(260, 25)" end="(260, 28)">
            <TermExplicitbinderNode start="(260, 25)" end="(260, 28)">
              <AtomNode start="(260, 25)" end="(260, 26)" leading="" trailing="" val="("/>
              <NullNode start="(260, 26)" end="(260, 27)">
                <IdentNode start="(260, 26)" end="(260, 27)" leading="" trailing="" raw_val="q" val="q"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(260, 27)" end="(260, 28)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(260, 29)" end="(260, 69)">
            <AtomNode start="(260, 29)" end="(260, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(260, 31)" end="(260, 69)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(260, 31)" end="(260, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(260, 31)" end="(260, 39)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(260, 40)" end="(260, 43)">
                  <IdentNode start="(260, 40)" end="(260, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(260, 42)" end="(260, 43)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(260, 44)" end="(260, 45)" leading="" trailing=" " val="→"/>
              <OtherNode start="(260, 46)" end="(260, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(260, 46)" end="(260, 54)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(260, 55)" end="(260, 69)">
                  <IdentNode start="(260, 55)" end="(260, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(260, 57)" end="(260, 69)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(260, 57)" end="(260, 58)" leading="" trailing="" val="("/>
                    <OtherNode start="(260, 58)" end="(260, 68)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(260, 58)" end="(260, 66)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                      <NullNode start="(260, 67)" end="(260, 68)">
                        <IdentNode start="(260, 67)" end="(260, 68)" leading="" trailing="" raw_val="q" val="q"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(260, 68)" end="(260, 69)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(260, 70)" end="(261, 37)">
          <AtomNode start="(260, 70)" end="(260, 72)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(261, 3)" end="(261, 37)" kind="«term_&amp;lt;|_»">
            <IdentNode start="(261, 3)" end="(261, 19)" leading="" trailing=" " raw_val="Pairwise.sublist" val="Pairwise.sublist" full_name="List.Pairwise.sublist" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
            <AtomNode start="(261, 20)" end="(261, 22)" leading="" trailing=" " val="&amp;lt;|"/>
            <IdentNode start="(261, 23)" end="(261, 37)" leading="" trailing="&#10;&#10;" raw_val="eraseP_sublist" val="eraseP_sublist" full_name="List.eraseP_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(104, 9)" def_end="(104, 23)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(263, 1)" end="(264, 20)" name="Nodup.eraseP" full_name="List.Nodup.eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(263, 1)" end="(264, 20)" name="Nodup.eraseP" full_name="List.Nodup.eraseP" _is_private_decl="False">
        <AtomNode start="(263, 1)" end="(263, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(263, 9)" end="(263, 21)">
          <IdentNode start="(263, 9)" end="(263, 21)" leading="" trailing=" " raw_val="Nodup.eraseP" val="Nodup.eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(263, 22)" end="(263, 56)">
          <NullNode start="(263, 22)" end="(263, 25)">
            <TermExplicitbinderNode start="(263, 22)" end="(263, 25)">
              <AtomNode start="(263, 22)" end="(263, 23)" leading="" trailing="" val="("/>
              <NullNode start="(263, 23)" end="(263, 24)">
                <IdentNode start="(263, 23)" end="(263, 24)" leading="" trailing="" raw_val="p" val="p"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(263, 24)" end="(263, 25)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(263, 26)" end="(263, 56)">
            <AtomNode start="(263, 26)" end="(263, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(263, 28)" end="(263, 56)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(263, 28)" end="(263, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(263, 28)" end="(263, 33)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(263, 34)" end="(263, 35)">
                  <IdentNode start="(263, 34)" end="(263, 35)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(263, 36)" end="(263, 37)" leading="" trailing=" " val="→"/>
              <OtherNode start="(263, 38)" end="(263, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(263, 38)" end="(263, 43)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(263, 44)" end="(263, 56)">
                  <OtherNode start="(263, 44)" end="(263, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(263, 44)" end="(263, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(263, 45)" end="(263, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(263, 45)" end="(263, 53)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                      <NullNode start="(263, 54)" end="(263, 55)">
                        <IdentNode start="(263, 54)" end="(263, 55)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(263, 55)" end="(263, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(263, 57)" end="(264, 20)">
          <AtomNode start="(263, 57)" end="(263, 59)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(264, 3)" end="(264, 20)" kind="Lean.Parser.Term.app">
            <IdentNode start="(264, 3)" end="(264, 18)" leading="" trailing=" " raw_val="Pairwise.eraseP" val="Pairwise.eraseP" full_name="List.Pairwise.eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(260, 9)" def_end="(260, 24)"/>
            <NullNode start="(264, 19)" end="(264, 20)">
              <IdentNode start="(264, 19)" end="(264, 20)" leading="" trailing="&#10;&#10;" raw_val="p" val="p"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(266, 1)" end="(278, 65)" name="eraseP_comm" full_name="List.eraseP_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(266, 1)" end="(278, 65)" name="eraseP_comm" full_name="List.eraseP_comm" _is_private_decl="False">
        <AtomNode start="(266, 1)" end="(266, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(266, 9)" end="(266, 20)">
          <IdentNode start="(266, 9)" end="(266, 20)" leading="" trailing=" " raw_val="eraseP_comm" val="eraseP_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(266, 21)" end="(267, 50)">
          <NullNode start="(266, 21)" end="(266, 62)">
            <OtherNode start="(266, 21)" end="(266, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(266, 21)" end="(266, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(266, 22)" end="(266, 23)">
                <IdentNode start="(266, 22)" end="(266, 23)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(266, 24)" end="(266, 32)">
                <AtomNode start="(266, 24)" end="(266, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 26)" end="(266, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(266, 26)" end="(266, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(266, 31)" end="(266, 32)">
                    <IdentNode start="(266, 31)" end="(266, 32)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(266, 32)" end="(266, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(266, 34)" end="(266, 62)">
              <AtomNode start="(266, 34)" end="(266, 35)" leading="" trailing="" val="("/>
              <NullNode start="(266, 35)" end="(266, 36)">
                <IdentNode start="(266, 35)" end="(266, 36)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(266, 37)" end="(266, 61)">
                <AtomNode start="(266, 37)" end="(266, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 39)" end="(266, 61)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(266, 39)" end="(266, 40)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(266, 41)" end="(266, 42)">
                    <IdentNode start="(266, 41)" end="(266, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(266, 43)" end="(266, 46)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(266, 43)" end="(266, 44)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(266, 45)" end="(266, 46)" leading="" trailing="" raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(266, 46)" end="(266, 47)" leading="" trailing=" " val=","/>
                  <OtherNode start="(266, 48)" end="(266, 61)" kind="«term_∨_»">
                    <OtherNode start="(266, 48)" end="(266, 53)" kind="«term¬_»">
                      <AtomNode start="(266, 48)" end="(266, 49)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(266, 50)" end="(266, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(266, 50)" end="(266, 51)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(266, 52)" end="(266, 53)">
                          <IdentNode start="(266, 52)" end="(266, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(266, 54)" end="(266, 55)" leading="" trailing=" " val="∨"/>
                    <OtherNode start="(266, 56)" end="(266, 61)" kind="«term¬_»">
                      <AtomNode start="(266, 56)" end="(266, 57)" leading="" trailing=" " val="¬"/>
                      <OtherNode start="(266, 58)" end="(266, 61)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(266, 58)" end="(266, 59)" leading="" trailing=" " raw_val="q" val="q"/>
                        <NullNode start="(266, 60)" end="(266, 61)">
                          <IdentNode start="(266, 60)" end="(266, 61)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(266, 61)" end="(266, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(266, 63)" end="(267, 50)">
            <AtomNode start="(266, 63)" end="(266, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(267, 5)" end="(267, 50)" kind="«term_=_»">
              <OtherNode start="(267, 5)" end="(267, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(267, 5)" end="(267, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(267, 5)" end="(267, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(267, 5)" end="(267, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(267, 6)" end="(267, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(267, 6)" end="(267, 14)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                      <NullNode start="(267, 15)" end="(267, 16)">
                        <IdentNode start="(267, 15)" end="(267, 16)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(267, 16)" end="(267, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(267, 17)" end="(267, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(267, 18)" end="(267, 24)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(267, 25)" end="(267, 26)">
                  <IdentNode start="(267, 25)" end="(267, 26)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(267, 27)" end="(267, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(267, 29)" end="(267, 50)" kind="Lean.Parser.Term.app">
                <OtherNode start="(267, 29)" end="(267, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(267, 29)" end="(267, 41)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(267, 29)" end="(267, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(267, 30)" end="(267, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(267, 30)" end="(267, 38)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                      <NullNode start="(267, 39)" end="(267, 40)">
                        <IdentNode start="(267, 39)" end="(267, 40)" leading="" trailing="" raw_val="q" val="q"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(267, 40)" end="(267, 41)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(267, 41)" end="(267, 42)" leading="" trailing="" val="."/>
                  <IdentNode start="(267, 42)" end="(267, 48)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(267, 49)" end="(267, 50)">
                  <IdentNode start="(267, 49)" end="(267, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(267, 51)" end="(278, 65)">
          <AtomNode start="(267, 51)" end="(267, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(267, 54)" end="(278, 65)">
            <AtomNode start="(267, 54)" end="(267, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(268, 3)" end="(278, 65)">
              <TacticTacticseq1IndentedNode start="(268, 3)" end="(278, 65)">
                <NullNode start="(268, 3)" end="(278, 65)">
                  <OtherNode start="(268, 3)" end="(278, 65)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p q : α → Bool&#10;l : List α&#10;h : ∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true&#10;⊢ eraseP q (eraseP p l) = eraseP p (eraseP q l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; rfl&#10;| cons a l ih =&amp;gt;&#10;  simp only [eraseP_cons]&#10;  by_cases h₁ : p a&#10;  · by_cases h₂ : q a&#10;    · simp_all&#10;    · simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]&#10;  · by_cases h₂ : q a&#10;    · simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]&#10;    · simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                    <AtomNode start="(268, 3)" end="(268, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(268, 13)" end="(268, 14)">
                      <OtherNode start="(268, 13)" end="(268, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(268, 13)" end="(268, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(268, 15)" end="(278, 65)">
                      <OtherNode start="(268, 15)" end="(278, 65)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(268, 15)" end="(268, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(269, 3)" end="(278, 65)">
                          <OtherNode start="(269, 3)" end="(269, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(269, 3)" end="(269, 8)">
                              <OtherNode start="(269, 3)" end="(269, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(269, 3)" end="(269, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(269, 5)" end="(269, 8)">
                                  <NullNode/>
                                  <IdentNode start="(269, 5)" end="(269, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(269, 9)" end="(269, 15)">
                              <AtomNode start="(269, 9)" end="(269, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(269, 12)" end="(269, 15)">
                                <TacticTacticseq1IndentedNode start="(269, 12)" end="(269, 15)">
                                  <NullNode start="(269, 12)" end="(269, 15)">
                                    <OtherNode start="(269, 12)" end="(269, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;p q : α → Bool&#10;h : ∀ (a : α), a ∈ [] → ¬p a = true ∨ ¬q a = true&#10;⊢ eraseP q (eraseP p []) = eraseP p (eraseP q [])" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(269, 12)" end="(269, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(270, 3)" end="(278, 65)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(270, 3)" end="(270, 16)">
                              <OtherNode start="(270, 3)" end="(270, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(270, 3)" end="(270, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(270, 5)" end="(270, 9)">
                                  <NullNode/>
                                  <IdentNode start="(270, 5)" end="(270, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(270, 10)" end="(270, 16)">
                                  <IdentNode start="(270, 10)" end="(270, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(270, 12)" end="(270, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(270, 14)" end="(270, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(270, 17)" end="(278, 65)">
                              <AtomNode start="(270, 17)" end="(270, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(271, 5)" end="(278, 65)">
                                <TacticTacticseq1IndentedNode start="(271, 5)" end="(278, 65)">
                                  <NullNode start="(271, 5)" end="(278, 65)">
                                    <OtherNode start="(271, 5)" end="(271, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;⊢ eraseP q (eraseP p (a :: l)) = eraseP p (eraseP q (a :: l))" state_after="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="simp only [eraseP_cons]">
                                      <AtomNode start="(271, 5)" end="(271, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(271, 10)" end="(271, 14)">
                                        <AtomNode start="(271, 10)" end="(271, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(271, 15)" end="(271, 28)">
                                        <AtomNode start="(271, 15)" end="(271, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(271, 16)" end="(271, 27)">
                                          <OtherNode start="(271, 16)" end="(271, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(271, 16)" end="(271, 27)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(271, 27)" end="(271, 28)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(272, 5)" end="(272, 22)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)&#10;&#10;case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="by_cases h₁ : p a">
                                      <AtomNode start="(272, 5)" end="(272, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(272, 14)" end="(272, 18)">
                                        <IdentNode start="(272, 14)" end="(272, 16)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                        <AtomNode start="(272, 17)" end="(272, 18)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(272, 19)" end="(272, 22)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(272, 19)" end="(272, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                                        <NullNode start="(272, 21)" end="(272, 22)">
                                          <IdentNode start="(272, 21)" end="(272, 22)" leading="" trailing="&#10;    " raw_val="a" val="a"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(273, 5)" end="(275, 65)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)&#10;&#10;case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="· by_cases h₂ : q a&#10;  · simp_all&#10;  · simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                      <OtherNode start="(273, 5)" end="(273, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(273, 5)" end="(273, 6)" kind="patternIgnore">
                                          <OtherNode start="(273, 5)" end="(273, 6)" kind="token.«· »">
                                            <AtomNode start="(273, 5)" end="(273, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(273, 7)" end="(275, 65)">
                                        <TacticTacticseq1IndentedNode start="(273, 7)" end="(275, 65)">
                                          <NullNode start="(273, 7)" end="(275, 65)">
                                            <OtherNode start="(273, 7)" end="(273, 24)" kind="«tacticBy_cases_:_»" state_before="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)&#10;&#10;case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="by_cases h₂ : q a">
                                              <AtomNode start="(273, 7)" end="(273, 15)" leading="" trailing=" " val="by_cases"/>
                                              <NullNode start="(273, 16)" end="(273, 20)">
                                                <IdentNode start="(273, 16)" end="(273, 18)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                <AtomNode start="(273, 19)" end="(273, 20)" leading="" trailing=" " val=":"/>
                                              </NullNode>
                                              <OtherNode start="(273, 21)" end="(273, 24)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(273, 21)" end="(273, 22)" leading="" trailing=" " raw_val="q" val="q"/>
                                                <NullNode start="(273, 23)" end="(273, 24)">
                                                  <IdentNode start="(273, 23)" end="(273, 24)" leading="" trailing="&#10;      " raw_val="a" val="a"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(274, 7)" end="(274, 17)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)&#10;&#10;case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="· simp_all">
                                              <OtherNode start="(274, 7)" end="(274, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(274, 7)" end="(274, 8)" kind="patternIgnore">
                                                  <OtherNode start="(274, 7)" end="(274, 8)" kind="token.«· »">
                                                    <AtomNode start="(274, 7)" end="(274, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(274, 9)" end="(274, 17)">
                                                <TacticTacticseq1IndentedNode start="(274, 9)" end="(274, 17)">
                                                  <NullNode start="(274, 9)" end="(274, 17)">
                                                    <OtherNode start="(274, 9)" end="(274, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="simp_all">
                                                      <AtomNode start="(274, 9)" end="(274, 17)" leading="" trailing="&#10;      " val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(275, 7)" end="(275, 65)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="· simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                              <OtherNode start="(275, 7)" end="(275, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(275, 7)" end="(275, 8)" kind="patternIgnore">
                                                  <OtherNode start="(275, 7)" end="(275, 8)" kind="token.«· »">
                                                    <AtomNode start="(275, 7)" end="(275, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(275, 9)" end="(275, 65)">
                                                <TacticTacticseq1IndentedNode start="(275, 9)" end="(275, 65)">
                                                  <NullNode start="(275, 9)" end="(275, 65)">
                                                    <OtherNode start="(275, 9)" end="(275, 65)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                                      <AtomNode start="(275, 9)" end="(275, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(275, 14)" end="(275, 65)">
                                                        <AtomNode start="(275, 14)" end="(275, 15)" leading="" trailing="" val="["/>
                                                        <NullNode start="(275, 15)" end="(275, 64)">
                                                          <OtherNode start="(275, 15)" end="(275, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(275, 15)" end="(275, 17)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                          </OtherNode>
                                                          <AtomNode start="(275, 17)" end="(275, 18)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(275, 19)" end="(275, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(275, 19)" end="(275, 21)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                          </OtherNode>
                                                          <AtomNode start="(275, 21)" end="(275, 22)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(275, 23)" end="(275, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(275, 23)" end="(275, 64)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(275, 23)" end="(275, 25)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(275, 26)" end="(275, 64)">
                                                            <OtherNode start="(275, 26)" end="(275, 64)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(275, 26)" end="(275, 27)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(275, 27)" end="(275, 63)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(275, 27)" end="(275, 30)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(275, 31)" end="(275, 63)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(275, 31)" end="(275, 34)">
                                                            <IdentNode start="(275, 31)" end="(275, 32)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <IdentNode start="(275, 33)" end="(275, 34)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(275, 35)" end="(275, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(275, 38)" end="(275, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(275, 38)" end="(275, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(275, 40)" end="(275, 63)">
                                                            <IdentNode start="(275, 40)" end="(275, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <OtherNode start="(275, 42)" end="(275, 63)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(275, 42)" end="(275, 43)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(275, 43)" end="(275, 62)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(275, 43)" end="(275, 58)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(275, 59)" end="(275, 62)">
                                                            <TermHoleNode start="(275, 59)" end="(275, 60)">
                                                            <AtomNode start="(275, 59)" end="(275, 60)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(275, 61)" end="(275, 62)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(275, 62)" end="(275, 63)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(275, 63)" end="(275, 64)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(275, 64)" end="(275, 65)" leading="" trailing="&#10;    " val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(276, 5)" end="(278, 65)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="· by_cases h₂ : q a&#10;  · simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]&#10;  · simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                      <OtherNode start="(276, 5)" end="(276, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(276, 5)" end="(276, 6)" kind="patternIgnore">
                                          <OtherNode start="(276, 5)" end="(276, 6)" kind="token.«· »">
                                            <AtomNode start="(276, 5)" end="(276, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(276, 7)" end="(278, 65)">
                                        <TacticTacticseq1IndentedNode start="(276, 7)" end="(278, 65)">
                                          <NullNode start="(276, 7)" end="(278, 65)">
                                            <OtherNode start="(276, 7)" end="(276, 24)" kind="«tacticBy_cases_:_»" state_before="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)&#10;&#10;case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="by_cases h₂ : q a">
                                              <AtomNode start="(276, 7)" end="(276, 15)" leading="" trailing=" " val="by_cases"/>
                                              <NullNode start="(276, 16)" end="(276, 20)">
                                                <IdentNode start="(276, 16)" end="(276, 18)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                <AtomNode start="(276, 19)" end="(276, 20)" leading="" trailing=" " val=":"/>
                                              </NullNode>
                                              <OtherNode start="(276, 21)" end="(276, 24)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(276, 21)" end="(276, 22)" leading="" trailing=" " raw_val="q" val="q"/>
                                                <NullNode start="(276, 23)" end="(276, 24)">
                                                  <IdentNode start="(276, 23)" end="(276, 24)" leading="" trailing="&#10;      " raw_val="a" val="a"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(277, 7)" end="(277, 65)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)&#10;&#10;case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" tactic="· simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                              <OtherNode start="(277, 7)" end="(277, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(277, 7)" end="(277, 8)" kind="patternIgnore">
                                                  <OtherNode start="(277, 7)" end="(277, 8)" kind="token.«· »">
                                                    <AtomNode start="(277, 7)" end="(277, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(277, 9)" end="(277, 65)">
                                                <TacticTacticseq1IndentedNode start="(277, 9)" end="(277, 65)">
                                                  <NullNode start="(277, 9)" end="(277, 65)">
                                                    <OtherNode start="(277, 9)" end="(277, 65)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                                      <AtomNode start="(277, 9)" end="(277, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(277, 14)" end="(277, 65)">
                                                        <AtomNode start="(277, 14)" end="(277, 15)" leading="" trailing="" val="["/>
                                                        <NullNode start="(277, 15)" end="(277, 64)">
                                                          <OtherNode start="(277, 15)" end="(277, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(277, 15)" end="(277, 17)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                          </OtherNode>
                                                          <AtomNode start="(277, 17)" end="(277, 18)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(277, 19)" end="(277, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(277, 19)" end="(277, 21)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                          </OtherNode>
                                                          <AtomNode start="(277, 21)" end="(277, 22)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(277, 23)" end="(277, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(277, 23)" end="(277, 64)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(277, 23)" end="(277, 25)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(277, 26)" end="(277, 64)">
                                                            <OtherNode start="(277, 26)" end="(277, 64)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(277, 26)" end="(277, 27)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(277, 27)" end="(277, 63)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(277, 27)" end="(277, 30)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(277, 31)" end="(277, 63)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(277, 31)" end="(277, 34)">
                                                            <IdentNode start="(277, 31)" end="(277, 32)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <IdentNode start="(277, 33)" end="(277, 34)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(277, 35)" end="(277, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(277, 38)" end="(277, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(277, 38)" end="(277, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(277, 40)" end="(277, 63)">
                                                            <IdentNode start="(277, 40)" end="(277, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <OtherNode start="(277, 42)" end="(277, 63)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(277, 42)" end="(277, 43)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(277, 43)" end="(277, 62)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(277, 43)" end="(277, 58)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(277, 59)" end="(277, 62)">
                                                            <TermHoleNode start="(277, 59)" end="(277, 60)">
                                                            <AtomNode start="(277, 59)" end="(277, 60)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(277, 61)" end="(277, 62)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(277, 62)" end="(277, 63)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(277, 63)" end="(277, 64)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(277, 64)" end="(277, 65)" leading="" trailing="&#10;      " val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(278, 7)" end="(278, 65)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="· simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                              <OtherNode start="(278, 7)" end="(278, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(278, 7)" end="(278, 8)" kind="patternIgnore">
                                                  <OtherNode start="(278, 7)" end="(278, 8)" kind="token.«· »">
                                                    <AtomNode start="(278, 7)" end="(278, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(278, 9)" end="(278, 65)">
                                                <TacticTacticseq1IndentedNode start="(278, 9)" end="(278, 65)">
                                                  <NullNode start="(278, 9)" end="(278, 65)">
                                                    <OtherNode start="(278, 9)" end="(278, 65)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p q : α → Bool&#10;a : α&#10;l : List α&#10;ih : (∀ (a : α), a ∈ l → ¬p a = true ∨ ¬q a = true) → eraseP q (eraseP p l) = eraseP p (eraseP q l)&#10;h : ∀ (a_1 : α), a_1 ∈ a :: l → ¬p a_1 = true ∨ ¬q a_1 = true&#10;h₁ : ¬p a = true&#10;h₂ : ¬q a = true&#10;⊢ eraseP q (bif p a then l else a :: eraseP p l) = eraseP p (bif q a then l else a :: eraseP q l)" state_after="no goals" tactic="simp [h₁, h₂, ih (fun b m =&amp;gt; h b (mem_cons_of_mem _ m))]">
                                                      <AtomNode start="(278, 9)" end="(278, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(278, 14)" end="(278, 65)">
                                                        <AtomNode start="(278, 14)" end="(278, 15)" leading="" trailing="" val="["/>
                                                        <NullNode start="(278, 15)" end="(278, 64)">
                                                          <OtherNode start="(278, 15)" end="(278, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(278, 15)" end="(278, 17)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                          </OtherNode>
                                                          <AtomNode start="(278, 17)" end="(278, 18)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(278, 19)" end="(278, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(278, 19)" end="(278, 21)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                          </OtherNode>
                                                          <AtomNode start="(278, 21)" end="(278, 22)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(278, 23)" end="(278, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(278, 23)" end="(278, 64)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(278, 23)" end="(278, 25)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(278, 26)" end="(278, 64)">
                                                            <OtherNode start="(278, 26)" end="(278, 64)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(278, 26)" end="(278, 27)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(278, 27)" end="(278, 63)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(278, 27)" end="(278, 30)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(278, 31)" end="(278, 63)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(278, 31)" end="(278, 34)">
                                                            <IdentNode start="(278, 31)" end="(278, 32)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <IdentNode start="(278, 33)" end="(278, 34)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(278, 35)" end="(278, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(278, 38)" end="(278, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(278, 38)" end="(278, 39)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(278, 40)" end="(278, 63)">
                                                            <IdentNode start="(278, 40)" end="(278, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <OtherNode start="(278, 42)" end="(278, 63)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(278, 42)" end="(278, 43)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(278, 43)" end="(278, 62)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(278, 43)" end="(278, 58)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(278, 59)" end="(278, 62)">
                                                            <TermHoleNode start="(278, 59)" end="(278, 60)">
                                                            <AtomNode start="(278, 59)" end="(278, 60)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(278, 61)" end="(278, 62)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(278, 62)" end="(278, 63)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(278, 63)" end="(278, 64)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(278, 64)" end="(278, 65)" leading="" trailing="&#10;&#10;" val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(280, 1)" end="(281, 28)" name="head_eraseP_mem" full_name="List.head_eraseP_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(280, 1)" end="(281, 28)" name="head_eraseP_mem" full_name="List.head_eraseP_mem" _is_private_decl="False">
        <AtomNode start="(280, 1)" end="(280, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(280, 9)" end="(280, 24)">
          <IdentNode start="(280, 9)" end="(280, 24)" leading="" trailing=" " raw_val="head_eraseP_mem" val="head_eraseP_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(280, 25)" end="(280, 85)">
          <NullNode start="(280, 25)" end="(280, 57)">
            <OtherNode start="(280, 25)" end="(280, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(280, 25)" end="(280, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(280, 26)" end="(280, 28)">
                <IdentNode start="(280, 26)" end="(280, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(280, 29)" end="(280, 37)">
                <AtomNode start="(280, 29)" end="(280, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(280, 31)" end="(280, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(280, 31)" end="(280, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(280, 36)" end="(280, 37)">
                    <IdentNode start="(280, 36)" end="(280, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(280, 37)" end="(280, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(280, 39)" end="(280, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(280, 39)" end="(280, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(280, 40)" end="(280, 41)">
                <IdentNode start="(280, 40)" end="(280, 41)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(280, 42)" end="(280, 52)">
                <AtomNode start="(280, 42)" end="(280, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(280, 44)" end="(280, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(280, 44)" end="(280, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(280, 46)" end="(280, 47)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(280, 48)" end="(280, 52)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(280, 52)" end="(280, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(280, 54)" end="(280, 57)">
              <AtomNode start="(280, 54)" end="(280, 55)" leading="" trailing="" val="("/>
              <NullNode start="(280, 55)" end="(280, 56)">
                <IdentNode start="(280, 55)" end="(280, 56)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(280, 56)" end="(280, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(280, 58)" end="(280, 85)">
            <AtomNode start="(280, 58)" end="(280, 59)" leading="" trailing=" " val=":"/>
            <OtherNode start="(280, 60)" end="(280, 85)" kind="«term_∈_»">
              <OtherNode start="(280, 60)" end="(280, 80)" kind="Lean.Parser.Term.app">
                <OtherNode start="(280, 60)" end="(280, 78)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(280, 60)" end="(280, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(280, 60)" end="(280, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(280, 61)" end="(280, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(280, 61)" end="(280, 70)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(280, 71)" end="(280, 72)">
                        <IdentNode start="(280, 71)" end="(280, 72)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(280, 72)" end="(280, 73)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(280, 73)" end="(280, 74)" leading="" trailing="" val="."/>
                  <IdentNode start="(280, 74)" end="(280, 78)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(280, 79)" end="(280, 80)">
                  <IdentNode start="(280, 79)" end="(280, 80)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(280, 81)" end="(280, 82)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(280, 83)" end="(280, 85)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(280, 86)" end="(281, 28)">
          <AtomNode start="(280, 86)" end="(280, 88)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(281, 3)" end="(281, 28)" kind="Lean.Parser.Term.app">
            <IdentNode start="(281, 3)" end="(281, 26)" leading="" trailing=" " raw_val="eraseP_sublist.head_mem" val="eraseP_sublist.head_mem"/>
            <NullNode start="(281, 27)" end="(281, 28)">
              <IdentNode start="(281, 27)" end="(281, 28)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(283, 1)" end="(284, 31)" name="getLast_eraseP_mem" full_name="List.getLast_eraseP_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(283, 1)" end="(284, 31)" name="getLast_eraseP_mem" full_name="List.getLast_eraseP_mem" _is_private_decl="False">
        <AtomNode start="(283, 1)" end="(283, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(283, 9)" end="(283, 27)">
          <IdentNode start="(283, 9)" end="(283, 27)" leading="" trailing=" " raw_val="getLast_eraseP_mem" val="getLast_eraseP_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(283, 28)" end="(283, 91)">
          <NullNode start="(283, 28)" end="(283, 60)">
            <OtherNode start="(283, 28)" end="(283, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(283, 28)" end="(283, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(283, 29)" end="(283, 31)">
                <IdentNode start="(283, 29)" end="(283, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(283, 32)" end="(283, 40)">
                <AtomNode start="(283, 32)" end="(283, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(283, 34)" end="(283, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(283, 34)" end="(283, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(283, 39)" end="(283, 40)">
                    <IdentNode start="(283, 39)" end="(283, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(283, 40)" end="(283, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(283, 42)" end="(283, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(283, 42)" end="(283, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(283, 43)" end="(283, 44)">
                <IdentNode start="(283, 43)" end="(283, 44)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(283, 45)" end="(283, 55)">
                <AtomNode start="(283, 45)" end="(283, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(283, 47)" end="(283, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(283, 47)" end="(283, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(283, 49)" end="(283, 50)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(283, 51)" end="(283, 55)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(283, 55)" end="(283, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(283, 57)" end="(283, 60)">
              <AtomNode start="(283, 57)" end="(283, 58)" leading="" trailing="" val="("/>
              <NullNode start="(283, 58)" end="(283, 59)">
                <IdentNode start="(283, 58)" end="(283, 59)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(283, 59)" end="(283, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(283, 61)" end="(283, 91)">
            <AtomNode start="(283, 61)" end="(283, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(283, 63)" end="(283, 91)" kind="«term_∈_»">
              <OtherNode start="(283, 63)" end="(283, 86)" kind="Lean.Parser.Term.app">
                <OtherNode start="(283, 63)" end="(283, 84)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(283, 63)" end="(283, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(283, 63)" end="(283, 64)" leading="" trailing="" val="("/>
                    <OtherNode start="(283, 64)" end="(283, 75)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(283, 64)" end="(283, 73)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                      <NullNode start="(283, 74)" end="(283, 75)">
                        <IdentNode start="(283, 74)" end="(283, 75)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(283, 75)" end="(283, 76)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(283, 76)" end="(283, 77)" leading="" trailing="" val="."/>
                  <IdentNode start="(283, 77)" end="(283, 84)" leading="" trailing=" " raw_val="getLast" val="getLast" full_name="List.getLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(283, 85)" end="(283, 86)">
                  <IdentNode start="(283, 85)" end="(283, 86)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(283, 87)" end="(283, 88)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(283, 89)" end="(283, 91)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(283, 92)" end="(284, 31)">
          <AtomNode start="(283, 92)" end="(283, 94)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(284, 3)" end="(284, 31)" kind="Lean.Parser.Term.app">
            <IdentNode start="(284, 3)" end="(284, 29)" leading="" trailing=" " raw_val="eraseP_sublist.getLast_mem" val="eraseP_sublist.getLast_mem"/>
            <NullNode start="(284, 30)" end="(284, 31)">
              <IdentNode start="(284, 30)" end="(284, 31)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(286, 1)" end="(298, 25)" name="eraseP_eq_eraseIdx" full_name="List.eraseP_eq_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(286, 1)" end="(298, 25)" name="eraseP_eq_eraseIdx" full_name="List.eraseP_eq_eraseIdx" _is_private_decl="False">
        <AtomNode start="(286, 1)" end="(286, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(286, 9)" end="(286, 27)">
          <IdentNode start="(286, 9)" end="(286, 27)" leading="" trailing=" " raw_val="eraseP_eq_eraseIdx" val="eraseP_eq_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(286, 28)" end="(289, 30)">
          <NullNode start="(286, 28)" end="(286, 56)">
            <OtherNode start="(286, 28)" end="(286, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(286, 28)" end="(286, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(286, 29)" end="(286, 31)">
                <IdentNode start="(286, 29)" end="(286, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(286, 32)" end="(286, 40)">
                <AtomNode start="(286, 32)" end="(286, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(286, 34)" end="(286, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(286, 34)" end="(286, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(286, 39)" end="(286, 40)">
                    <IdentNode start="(286, 39)" end="(286, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(286, 40)" end="(286, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(286, 42)" end="(286, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(286, 42)" end="(286, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(286, 43)" end="(286, 44)">
                <IdentNode start="(286, 43)" end="(286, 44)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(286, 45)" end="(286, 55)">
                <AtomNode start="(286, 45)" end="(286, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(286, 47)" end="(286, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(286, 47)" end="(286, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(286, 49)" end="(286, 50)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(286, 51)" end="(286, 55)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(286, 55)" end="(286, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(286, 57)" end="(289, 30)">
            <AtomNode start="(286, 57)" end="(286, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(287, 5)" end="(289, 30)" kind="«term_=_»">
              <OtherNode start="(287, 5)" end="(287, 16)" kind="Lean.Parser.Term.app">
                <IdentNode start="(287, 5)" end="(287, 14)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                <NullNode start="(287, 15)" end="(287, 16)">
                  <IdentNode start="(287, 15)" end="(287, 16)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(287, 17)" end="(287, 18)" leading="" trailing=" " val="="/>
              <OtherNode start="(287, 19)" end="(289, 30)" kind="Lean.Parser.Term.match">
                <AtomNode start="(287, 19)" end="(287, 24)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(287, 25)" end="(287, 38)">
                  <OtherNode start="(287, 25)" end="(287, 38)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(287, 25)" end="(287, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(287, 25)" end="(287, 36)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(287, 37)" end="(287, 38)">
                        <IdentNode start="(287, 37)" end="(287, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(287, 39)" end="(287, 43)" leading="" trailing="&#10;    " val="with"/>
                <OtherNode start="(288, 5)" end="(289, 30)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(288, 5)" end="(289, 30)">
                    <OtherNode start="(288, 5)" end="(288, 17)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(288, 5)" end="(288, 6)" leading="" trailing=" " val="|"/>
                      <NullNode start="(288, 7)" end="(288, 11)">
                        <NullNode start="(288, 7)" end="(288, 11)">
                          <IdentNode start="(288, 7)" end="(288, 11)" leading="" trailing=" " raw_val="none" val="none" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(288, 12)" end="(288, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(288, 15)" end="(288, 17)" leading="" trailing="&#10;    " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <OtherNode start="(289, 5)" end="(289, 30)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(289, 5)" end="(289, 6)" leading="" trailing=" " val="|"/>
                      <NullNode start="(289, 7)" end="(289, 13)">
                        <NullNode start="(289, 7)" end="(289, 13)">
                          <OtherNode start="(289, 7)" end="(289, 13)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(289, 7)" end="(289, 11)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(289, 12)" end="(289, 13)">
                              <IdentNode start="(289, 12)" end="(289, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(289, 14)" end="(289, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(289, 17)" end="(289, 30)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(289, 17)" end="(289, 28)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                        <NullNode start="(289, 29)" end="(289, 30)">
                          <IdentNode start="(289, 29)" end="(289, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(289, 31)" end="(298, 25)">
          <AtomNode start="(289, 31)" end="(289, 33)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(289, 34)" end="(298, 25)">
            <AtomNode start="(289, 34)" end="(289, 36)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(290, 3)" end="(298, 25)">
              <TacticTacticseq1IndentedNode start="(290, 3)" end="(298, 25)">
                <NullNode start="(290, 3)" end="(298, 25)">
                  <OtherNode start="(290, 3)" end="(298, 25)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; rfl&#10;| cons x xs ih =&amp;gt;&#10;  rw [eraseP_cons, findIdx?_cons]&#10;  by_cases h : p x&#10;  · simp [h]&#10;  · simp only [h]&#10;    rw [ih]&#10;    split &amp;lt;;&amp;gt; simp [*]">
                    <AtomNode start="(290, 3)" end="(290, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(290, 13)" end="(290, 15)">
                      <OtherNode start="(290, 13)" end="(290, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(290, 13)" end="(290, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(290, 16)" end="(298, 25)">
                      <OtherNode start="(290, 16)" end="(298, 25)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(290, 16)" end="(290, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(291, 3)" end="(298, 25)">
                          <OtherNode start="(291, 3)" end="(291, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(291, 3)" end="(291, 8)">
                              <OtherNode start="(291, 3)" end="(291, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(291, 3)" end="(291, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(291, 5)" end="(291, 8)">
                                  <NullNode/>
                                  <IdentNode start="(291, 5)" end="(291, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(291, 9)" end="(291, 15)">
                              <AtomNode start="(291, 9)" end="(291, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(291, 12)" end="(291, 15)">
                                <TacticTacticseq1IndentedNode start="(291, 12)" end="(291, 15)">
                                  <NullNode start="(291, 12)" end="(291, 15)">
                                    <OtherNode start="(291, 12)" end="(291, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ eraseP p [] =&#10;    match findIdx? p [] with&#10;    | none =&amp;gt; []&#10;    | some i =&amp;gt; [].eraseIdx i" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(291, 12)" end="(291, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(292, 3)" end="(298, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(292, 3)" end="(292, 17)">
                              <OtherNode start="(292, 3)" end="(292, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(292, 3)" end="(292, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(292, 5)" end="(292, 9)">
                                  <NullNode/>
                                  <IdentNode start="(292, 5)" end="(292, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(292, 10)" end="(292, 17)">
                                  <IdentNode start="(292, 10)" end="(292, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(292, 12)" end="(292, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(292, 15)" end="(292, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(292, 18)" end="(298, 25)">
                              <AtomNode start="(292, 18)" end="(292, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(293, 5)" end="(298, 25)">
                                <TacticTacticseq1IndentedNode start="(293, 5)" end="(298, 25)">
                                  <NullNode start="(293, 5)" end="(298, 25)">
                                    <OtherNode start="(293, 5)" end="(293, 36)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;⊢ eraseP p (x :: xs) =&#10;    match findIdx? p (x :: xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="rw [eraseP_cons, findIdx?_cons]">
                                      <AtomNode start="(293, 5)" end="(293, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(293, 8)" end="(293, 36)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(293, 8)" end="(293, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(293, 9)" end="(293, 35)">
                                          <OtherNode start="(293, 9)" end="(293, 20)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(293, 9)" end="(293, 20)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                          </OtherNode>
                                          <AtomNode start="(293, 20)" end="(293, 21)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(293, 22)" end="(293, 35)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(293, 22)" end="(293, 35)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(293, 35)" end="(293, 36)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(294, 5)" end="(294, 21)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="by_cases h : p x">
                                      <AtomNode start="(294, 5)" end="(294, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(294, 14)" end="(294, 17)">
                                        <IdentNode start="(294, 14)" end="(294, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <AtomNode start="(294, 16)" end="(294, 17)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(294, 18)" end="(294, 21)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(294, 18)" end="(294, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                        <NullNode start="(294, 20)" end="(294, 21)">
                                          <IdentNode start="(294, 20)" end="(294, 21)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(295, 5)" end="(295, 15)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="· simp [h]">
                                      <OtherNode start="(295, 5)" end="(295, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(295, 5)" end="(295, 6)" kind="patternIgnore">
                                          <OtherNode start="(295, 5)" end="(295, 6)" kind="token.«· »">
                                            <AtomNode start="(295, 5)" end="(295, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(295, 7)" end="(295, 15)">
                                        <TacticTacticseq1IndentedNode start="(295, 7)" end="(295, 15)">
                                          <NullNode start="(295, 7)" end="(295, 15)">
                                            <OtherNode start="(295, 7)" end="(295, 15)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="no goals" tactic="simp [h]">
                                              <AtomNode start="(295, 7)" end="(295, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(295, 12)" end="(295, 15)">
                                                <AtomNode start="(295, 12)" end="(295, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(295, 13)" end="(295, 14)">
                                                  <OtherNode start="(295, 13)" end="(295, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(295, 13)" end="(295, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(295, 14)" end="(295, 15)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(296, 5)" end="(298, 25)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="no goals" tactic="· simp only [h]&#10;  rw [ih]&#10;  split &amp;lt;;&amp;gt; simp [*]">
                                      <OtherNode start="(296, 5)" end="(296, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(296, 5)" end="(296, 6)" kind="patternIgnore">
                                          <OtherNode start="(296, 5)" end="(296, 6)" kind="token.«· »">
                                            <AtomNode start="(296, 5)" end="(296, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(296, 7)" end="(298, 25)">
                                        <TacticTacticseq1IndentedNode start="(296, 7)" end="(298, 25)">
                                          <NullNode start="(296, 7)" end="(298, 25)">
                                            <OtherNode start="(296, 7)" end="(296, 20)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif p x then xs else x :: eraseP p xs) =&#10;    match if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif false then xs else x :: eraseP p xs) =&#10;    match if false = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="simp only [h]">
                                              <AtomNode start="(296, 7)" end="(296, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(296, 12)" end="(296, 16)">
                                                <AtomNode start="(296, 12)" end="(296, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(296, 17)" end="(296, 20)">
                                                <AtomNode start="(296, 17)" end="(296, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(296, 18)" end="(296, 19)">
                                                  <OtherNode start="(296, 18)" end="(296, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(296, 18)" end="(296, 19)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(296, 19)" end="(296, 20)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(297, 7)" end="(297, 14)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif false then xs else x :: eraseP p xs) =&#10;    match if false = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif false then xs&#10;    else&#10;      x ::&#10;        match findIdx? p xs with&#10;        | none =&amp;gt; xs&#10;        | some i =&amp;gt; xs.eraseIdx i) =&#10;    match if false = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="rw [ih]">
                                              <AtomNode start="(297, 7)" end="(297, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(297, 10)" end="(297, 14)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(297, 10)" end="(297, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(297, 11)" end="(297, 13)">
                                                  <OtherNode start="(297, 11)" end="(297, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(297, 11)" end="(297, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(297, 13)" end="(297, 14)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(298, 7)" end="(298, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  eraseP p xs =&#10;    match findIdx? p xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h : ¬p x = true&#10;⊢ (bif false then xs&#10;    else&#10;      x ::&#10;        match findIdx? p xs with&#10;        | none =&amp;gt; xs&#10;        | some i =&amp;gt; xs.eraseIdx i) =&#10;    match if false = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                                              <OtherNode start="(298, 7)" end="(298, 12)" kind="Lean.Parser.Tactic.split">
                                                <AtomNode start="(298, 7)" end="(298, 12)" leading="" trailing=" " val="split"/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(298, 13)" end="(298, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(298, 17)" end="(298, 25)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(298, 17)" end="(298, 21)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(298, 22)" end="(298, 25)">
                                                  <AtomNode start="(298, 22)" end="(298, 23)" leading="" trailing="" val="["/>
                                                  <NullNode start="(298, 23)" end="(298, 24)">
                                                    <OtherNode start="(298, 23)" end="(298, 24)" kind="Lean.Parser.Tactic.simpStar">
                                                      <AtomNode start="(298, 23)" end="(298, 24)" leading="" trailing="" val="*"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(298, 24)" end="(298, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(300, 1)" end="(300, 17)" comment="### erase -/">
      <AtomNode start="(300, 1)" end="(300, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(300, 5)" end="(300, 17)" leading="" trailing="&#10;&#10;" val="### erase -/"/>
    </CommandModuledocNode>
    <CommandSectionNode start="(302, 1)" end="(302, 14)" name="erase">
      <AtomNode start="(302, 1)" end="(302, 8)" leading="" trailing=" " val="section"/>
      <NullNode start="(302, 9)" end="(302, 14)">
        <IdentNode start="(302, 9)" end="(302, 14)" leading="" trailing="&#10;" raw_val="erase" val="erase"/>
      </NullNode>
    </CommandSectionNode>
    <OtherNode start="(303, 1)" end="(303, 17)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(303, 1)" end="(303, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(303, 10)" end="(303, 17)">
        <OtherNode start="(303, 10)" end="(303, 17)" kind="Lean.Parser.Term.instBinder">
          <AtomNode start="(303, 10)" end="(303, 11)" leading="" trailing="" val="["/>
          <NullNode/>
          <OtherNode start="(303, 11)" end="(303, 16)" kind="Lean.Parser.Term.app">
            <IdentNode start="(303, 11)" end="(303, 14)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(303, 15)" end="(303, 16)">
              <IdentNode start="(303, 15)" end="(303, 16)" leading="" trailing="" raw_val="α" val="α"/>
            </NullNode>
          </OtherNode>
          <AtomNode start="(303, 16)" end="(303, 17)" leading="" trailing="&#10;&#10;-- The arguments are explicit to allow determining the type,&#10;-- and to allow rewriting from right to left.&#10;" val="]"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(307, 1)" end="(308, 20)" name="erase_cons_head" full_name="List.erase_cons_head">
      <CommandDeclmodifiersNode start="(307, 1)" end="(307, 8)">
        <NullNode/>
        <NullNode start="(307, 1)" end="(307, 8)">
          <OtherNode start="(307, 1)" end="(307, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(307, 1)" end="(307, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(307, 3)" end="(307, 7)">
              <OtherNode start="(307, 3)" end="(307, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(307, 3)" end="(307, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(307, 3)" end="(307, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(307, 7)" end="(307, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(307, 9)" end="(308, 20)" name="erase_cons_head" full_name="List.erase_cons_head" _is_private_decl="False">
        <AtomNode start="(307, 9)" end="(307, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(307, 17)" end="(307, 32)">
          <IdentNode start="(307, 17)" end="(307, 32)" leading="" trailing=" " raw_val="erase_cons_head" val="erase_cons_head"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(307, 33)" end="(307, 90)">
          <NullNode start="(307, 33)" end="(307, 67)">
            <OtherNode start="(307, 33)" end="(307, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(307, 33)" end="(307, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(307, 34)" end="(307, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(307, 34)" end="(307, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(307, 44)" end="(307, 45)">
                  <IdentNode start="(307, 44)" end="(307, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(307, 45)" end="(307, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(307, 47)" end="(307, 54)">
              <AtomNode start="(307, 47)" end="(307, 48)" leading="" trailing="" val="("/>
              <NullNode start="(307, 48)" end="(307, 49)">
                <IdentNode start="(307, 48)" end="(307, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(307, 50)" end="(307, 53)">
                <AtomNode start="(307, 50)" end="(307, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(307, 52)" end="(307, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(307, 53)" end="(307, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(307, 55)" end="(307, 67)">
              <AtomNode start="(307, 55)" end="(307, 56)" leading="" trailing="" val="("/>
              <NullNode start="(307, 56)" end="(307, 57)">
                <IdentNode start="(307, 56)" end="(307, 57)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(307, 58)" end="(307, 66)">
                <AtomNode start="(307, 58)" end="(307, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(307, 60)" end="(307, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(307, 60)" end="(307, 64)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(307, 65)" end="(307, 66)">
                    <IdentNode start="(307, 65)" end="(307, 66)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(307, 66)" end="(307, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(307, 68)" end="(307, 90)">
            <AtomNode start="(307, 68)" end="(307, 69)" leading="" trailing=" " val=":"/>
            <OtherNode start="(307, 70)" end="(307, 90)" kind="«term_=_»">
              <OtherNode start="(307, 70)" end="(307, 86)" kind="Lean.Parser.Term.app">
                <OtherNode start="(307, 70)" end="(307, 84)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(307, 70)" end="(307, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(307, 70)" end="(307, 71)" leading="" trailing="" val="("/>
                    <OtherNode start="(307, 71)" end="(307, 77)" kind="«term_::_»">
                      <IdentNode start="(307, 71)" end="(307, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(307, 73)" end="(307, 75)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(307, 76)" end="(307, 77)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(307, 77)" end="(307, 78)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(307, 78)" end="(307, 79)" leading="" trailing="" val="."/>
                  <IdentNode start="(307, 79)" end="(307, 84)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(307, 85)" end="(307, 86)">
                  <IdentNode start="(307, 85)" end="(307, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(307, 87)" end="(307, 88)" leading="" trailing=" " val="="/>
              <IdentNode start="(307, 89)" end="(307, 90)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(307, 91)" end="(308, 20)">
          <AtomNode start="(307, 91)" end="(307, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(307, 94)" end="(308, 20)">
            <AtomNode start="(307, 94)" end="(307, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(308, 3)" end="(308, 20)">
              <TacticTacticseq1IndentedNode start="(308, 3)" end="(308, 20)">
                <NullNode start="(308, 3)" end="(308, 20)">
                  <OtherNode start="(308, 3)" end="(308, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (a :: l).erase a = l" state_after="no goals" tactic="simp [erase_cons]">
                    <AtomNode start="(308, 3)" end="(308, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(308, 8)" end="(308, 20)">
                      <AtomNode start="(308, 8)" end="(308, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(308, 9)" end="(308, 19)">
                        <OtherNode start="(308, 9)" end="(308, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(308, 9)" end="(308, 19)" leading="" trailing="" raw_val="erase_cons" val="erase_cons" full_name="List.erase_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(308, 19)" end="(308, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(310, 1)" end="(311, 77)" name="erase_cons_tail" full_name="List.erase_cons_tail">
      <CommandDeclmodifiersNode start="(310, 1)" end="(310, 8)">
        <NullNode/>
        <NullNode start="(310, 1)" end="(310, 8)">
          <OtherNode start="(310, 1)" end="(310, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(310, 1)" end="(310, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(310, 3)" end="(310, 7)">
              <OtherNode start="(310, 3)" end="(310, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(310, 3)" end="(310, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(310, 3)" end="(310, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(310, 7)" end="(310, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(310, 9)" end="(311, 77)" name="erase_cons_tail" full_name="List.erase_cons_tail" _is_private_decl="False">
        <AtomNode start="(310, 9)" end="(310, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(310, 17)" end="(310, 32)">
          <IdentNode start="(310, 17)" end="(310, 32)" leading="" trailing=" " raw_val="erase_cons_tail" val="erase_cons_tail"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(310, 33)" end="(311, 38)">
          <NullNode start="(310, 33)" end="(310, 71)">
            <OtherNode start="(310, 33)" end="(310, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 33)" end="(310, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 34)" end="(310, 37)">
                <IdentNode start="(310, 34)" end="(310, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(310, 36)" end="(310, 37)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(310, 38)" end="(310, 41)">
                <AtomNode start="(310, 38)" end="(310, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(310, 40)" end="(310, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(310, 41)" end="(310, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(310, 43)" end="(310, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 43)" end="(310, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 44)" end="(310, 45)">
                <IdentNode start="(310, 44)" end="(310, 45)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(310, 46)" end="(310, 54)">
                <AtomNode start="(310, 46)" end="(310, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 48)" end="(310, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(310, 48)" end="(310, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(310, 53)" end="(310, 54)">
                    <IdentNode start="(310, 53)" end="(310, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(310, 54)" end="(310, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(310, 56)" end="(310, 71)">
              <AtomNode start="(310, 56)" end="(310, 57)" leading="" trailing="" val="("/>
              <NullNode start="(310, 57)" end="(310, 58)">
                <IdentNode start="(310, 57)" end="(310, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(310, 59)" end="(310, 70)">
                <AtomNode start="(310, 59)" end="(310, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 61)" end="(310, 70)" kind="«term¬_»">
                  <AtomNode start="(310, 61)" end="(310, 62)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(310, 62)" end="(310, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(310, 62)" end="(310, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(310, 63)" end="(310, 69)" kind="«term_==_»">
                      <IdentNode start="(310, 63)" end="(310, 64)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(310, 65)" end="(310, 67)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(310, 68)" end="(310, 69)" leading="" trailing="" raw_val="a" val="a"/>
                    </OtherNode>
                    <AtomNode start="(310, 69)" end="(310, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(310, 70)" end="(310, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(310, 72)" end="(311, 38)">
            <AtomNode start="(310, 72)" end="(310, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(311, 5)" end="(311, 38)" kind="«term_=_»">
              <OtherNode start="(311, 5)" end="(311, 21)" kind="Lean.Parser.Term.app">
                <OtherNode start="(311, 5)" end="(311, 19)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(311, 5)" end="(311, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(311, 5)" end="(311, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(311, 6)" end="(311, 12)" kind="«term_::_»">
                      <IdentNode start="(311, 6)" end="(311, 7)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(311, 8)" end="(311, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(311, 11)" end="(311, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(311, 12)" end="(311, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(311, 13)" end="(311, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(311, 14)" end="(311, 19)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(311, 20)" end="(311, 21)">
                  <IdentNode start="(311, 20)" end="(311, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(311, 22)" end="(311, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(311, 24)" end="(311, 38)" kind="«term_::_»">
                <IdentNode start="(311, 24)" end="(311, 25)" leading="" trailing=" " raw_val="b" val="b"/>
                <AtomNode start="(311, 26)" end="(311, 28)" leading="" trailing=" " val="::"/>
                <OtherNode start="(311, 29)" end="(311, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(311, 29)" end="(311, 36)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                  <NullNode start="(311, 37)" end="(311, 38)">
                    <IdentNode start="(311, 37)" end="(311, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(311, 39)" end="(311, 77)">
          <AtomNode start="(311, 39)" end="(311, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(311, 42)" end="(311, 77)">
            <AtomNode start="(311, 42)" end="(311, 44)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(311, 45)" end="(311, 77)">
              <TacticTacticseq1IndentedNode start="(311, 45)" end="(311, 77)">
                <NullNode start="(311, 45)" end="(311, 77)">
                  <OtherNode start="(311, 45)" end="(311, 77)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;l : List α&#10;h : ¬(b == a) = true&#10;⊢ (b :: l).erase a = b :: l.erase a" state_after="no goals" tactic="simp only [erase_cons, if_neg h]">
                    <AtomNode start="(311, 45)" end="(311, 49)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(311, 50)" end="(311, 54)">
                      <AtomNode start="(311, 50)" end="(311, 54)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(311, 55)" end="(311, 77)">
                      <AtomNode start="(311, 55)" end="(311, 56)" leading="" trailing="" val="["/>
                      <NullNode start="(311, 56)" end="(311, 76)">
                        <OtherNode start="(311, 56)" end="(311, 66)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(311, 56)" end="(311, 66)" leading="" trailing="" raw_val="erase_cons" val="erase_cons" full_name="List.erase_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(311, 66)" end="(311, 67)" leading="" trailing=" " val=","/>
                        <OtherNode start="(311, 68)" end="(311, 76)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(311, 68)" end="(311, 76)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(311, 68)" end="(311, 74)" leading="" trailing=" " raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(311, 75)" end="(311, 76)">
                              <IdentNode start="(311, 75)" end="(311, 76)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(311, 76)" end="(311, 77)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(313, 1)" end="(317, 101)" name="erase_of_not_mem" full_name="List.erase_of_not_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(313, 1)" end="(317, 101)" name="erase_of_not_mem" full_name="List.erase_of_not_mem" _is_private_decl="False">
        <AtomNode start="(313, 1)" end="(313, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(313, 9)" end="(313, 25)">
          <IdentNode start="(313, 9)" end="(313, 25)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(313, 26)" end="(313, 87)">
          <NullNode start="(313, 26)" end="(313, 47)">
            <OtherNode start="(313, 26)" end="(313, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(313, 26)" end="(313, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(313, 27)" end="(313, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(313, 27)" end="(313, 36)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(313, 37)" end="(313, 38)">
                  <IdentNode start="(313, 37)" end="(313, 38)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(313, 38)" end="(313, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(313, 40)" end="(313, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(313, 40)" end="(313, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(313, 41)" end="(313, 42)">
                <IdentNode start="(313, 41)" end="(313, 42)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(313, 43)" end="(313, 46)">
                <AtomNode start="(313, 43)" end="(313, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(313, 45)" end="(313, 46)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(313, 46)" end="(313, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(313, 48)" end="(313, 87)">
            <AtomNode start="(313, 48)" end="(313, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(313, 50)" end="(313, 87)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(313, 50)" end="(313, 51)" leading="" trailing=" " val="∀"/>
              <NullNode start="(313, 52)" end="(313, 64)">
                <OtherNode start="(313, 52)" end="(313, 64)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(313, 52)" end="(313, 53)" leading="" trailing="" val="{"/>
                  <NullNode start="(313, 53)" end="(313, 54)">
                    <IdentNode start="(313, 53)" end="(313, 54)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(313, 55)" end="(313, 63)">
                    <AtomNode start="(313, 55)" end="(313, 56)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(313, 57)" end="(313, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(313, 57)" end="(313, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(313, 62)" end="(313, 63)">
                        <IdentNode start="(313, 62)" end="(313, 63)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(313, 63)" end="(313, 64)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(313, 64)" end="(313, 65)" leading="" trailing=" " val=","/>
              <OtherNode start="(313, 66)" end="(313, 87)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(313, 66)" end="(313, 71)" kind="«term_∉_»">
                  <IdentNode start="(313, 66)" end="(313, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(313, 68)" end="(313, 69)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(313, 70)" end="(313, 71)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(313, 72)" end="(313, 73)" leading="" trailing=" " val="→"/>
                <OtherNode start="(313, 74)" end="(313, 87)" kind="«term_=_»">
                  <OtherNode start="(313, 74)" end="(313, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(313, 74)" end="(313, 81)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                    <NullNode start="(313, 82)" end="(313, 83)">
                      <IdentNode start="(313, 82)" end="(313, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(313, 84)" end="(313, 85)" leading="" trailing=" " val="="/>
                  <IdentNode start="(313, 86)" end="(313, 87)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(314, 3)" end="(317, 101)">
          <OtherNode start="(314, 3)" end="(317, 101)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(314, 3)" end="(317, 101)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(314, 3)" end="(317, 101)">
                <OtherNode start="(314, 3)" end="(314, 17)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(314, 3)" end="(314, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(314, 5)" end="(314, 10)">
                    <NullNode start="(314, 5)" end="(314, 10)">
                      <OtherNode start="(314, 5)" end="(314, 7)" kind="«term[_]»">
                        <AtomNode start="(314, 5)" end="(314, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(314, 6)" end="(314, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(314, 7)" end="(314, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(314, 9)" end="(314, 10)">
                        <AtomNode start="(314, 9)" end="(314, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(314, 11)" end="(314, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(314, 14)" end="(314, 17)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(315, 3)" end="(317, 101)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(315, 3)" end="(315, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(315, 5)" end="(315, 14)">
                    <NullNode start="(315, 5)" end="(315, 14)">
                      <OtherNode start="(315, 5)" end="(315, 11)" kind="«term_::_»">
                        <IdentNode start="(315, 5)" end="(315, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(315, 7)" end="(315, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(315, 10)" end="(315, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(315, 11)" end="(315, 12)" leading="" trailing=" " val=","/>
                      <IdentNode start="(315, 13)" end="(315, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(315, 15)" end="(315, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(315, 18)" end="(317, 101)">
                    <AtomNode start="(315, 18)" end="(315, 20)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(316, 5)" end="(317, 101)">
                      <TacticTacticseq1IndentedNode start="(316, 5)" end="(317, 101)">
                        <NullNode start="(316, 5)" end="(317, 101)">
                          <OtherNode start="(316, 5)" end="(316, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;h : ¬a ∈ b :: l&#10;⊢ (b :: l).erase a = b :: l" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;h : ¬a = b ∧ ¬a ∈ l&#10;⊢ (b :: l).erase a = b :: l" tactic="rw [mem_cons, not_or] at h">
                            <AtomNode start="(316, 5)" end="(316, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(316, 8)" end="(316, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(316, 8)" end="(316, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(316, 9)" end="(316, 25)">
                                <OtherNode start="(316, 9)" end="(316, 17)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(316, 9)" end="(316, 17)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(316, 17)" end="(316, 18)" leading="" trailing=" " val=","/>
                                <OtherNode start="(316, 19)" end="(316, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(316, 19)" end="(316, 25)" leading="" trailing="" raw_val="not_or" val="not_or" full_name="not_or" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(316, 25)" end="(316, 26)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(316, 27)" end="(316, 31)">
                              <OtherNode start="(316, 27)" end="(316, 31)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(316, 27)" end="(316, 29)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(316, 30)" end="(316, 31)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(316, 30)" end="(316, 31)">
                                    <IdentNode start="(316, 30)" end="(316, 31)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(317, 5)" end="(317, 101)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;h : ¬a = b ∧ ¬a ∈ l&#10;⊢ (b :: l).erase a = b :: l" state_after="no goals" tactic="simp only [erase_cons, if_neg, erase_of_not_mem h.2, beq_iff_eq, Ne.symm h.1, not_false_eq_true]">
                            <AtomNode start="(317, 5)" end="(317, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(317, 10)" end="(317, 14)">
                              <AtomNode start="(317, 10)" end="(317, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(317, 15)" end="(317, 101)">
                              <AtomNode start="(317, 15)" end="(317, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(317, 16)" end="(317, 100)">
                                <OtherNode start="(317, 16)" end="(317, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(317, 16)" end="(317, 26)" leading="" trailing="" raw_val="erase_cons" val="erase_cons" full_name="List.erase_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(317, 26)" end="(317, 27)" leading="" trailing=" " val=","/>
                                <OtherNode start="(317, 28)" end="(317, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(317, 28)" end="(317, 34)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(317, 34)" end="(317, 35)" leading="" trailing=" " val=","/>
                                <OtherNode start="(317, 36)" end="(317, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(317, 36)" end="(317, 56)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(317, 36)" end="(317, 52)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem"/>
                                    <NullNode start="(317, 53)" end="(317, 56)">
                                      <OtherNode start="(317, 53)" end="(317, 56)" kind="Lean.Parser.Term.proj">
                                        <IdentNode start="(317, 53)" end="(317, 54)" leading="" trailing="" raw_val="h" val="h"/>
                                        <AtomNode start="(317, 54)" end="(317, 55)" leading="" trailing="" val="."/>
                                        <OtherNode start="(317, 55)" end="(317, 56)" kind="fieldIdx">
                                          <AtomNode start="(317, 55)" end="(317, 56)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(317, 56)" end="(317, 57)" leading="" trailing=" " val=","/>
                                <OtherNode start="(317, 58)" end="(317, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(317, 58)" end="(317, 68)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(317, 68)" end="(317, 69)" leading="" trailing=" " val=","/>
                                <OtherNode start="(317, 70)" end="(317, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(317, 70)" end="(317, 81)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(317, 70)" end="(317, 77)" leading="" trailing=" " raw_val="Ne.symm" val="Ne.symm" full_name="Ne.symm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    <NullNode start="(317, 78)" end="(317, 81)">
                                      <OtherNode start="(317, 78)" end="(317, 81)" kind="Lean.Parser.Term.proj">
                                        <IdentNode start="(317, 78)" end="(317, 79)" leading="" trailing="" raw_val="h" val="h"/>
                                        <AtomNode start="(317, 79)" end="(317, 80)" leading="" trailing="" val="."/>
                                        <OtherNode start="(317, 80)" end="(317, 81)" kind="fieldIdx">
                                          <AtomNode start="(317, 80)" end="(317, 81)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(317, 81)" end="(317, 82)" leading="" trailing=" " val=","/>
                                <OtherNode start="(317, 83)" end="(317, 100)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(317, 83)" end="(317, 100)" leading="" trailing="" raw_val="not_false_eq_true" val="not_false_eq_true" full_name="not_false_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(317, 100)" end="(317, 101)" leading="" trailing="&#10;&#10;-- The arguments are intentionally explicit.&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(320, 1)" end="(325, 46)" name="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(320, 1)" end="(325, 46)" name="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" _is_private_decl="False">
        <AtomNode start="(320, 1)" end="(320, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(320, 9)" end="(320, 25)">
          <IdentNode start="(320, 9)" end="(320, 25)" leading="" trailing=" " raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(320, 26)" end="(320, 78)">
          <NullNode start="(320, 26)" end="(320, 46)">
            <TermExplicitbinderNode start="(320, 26)" end="(320, 33)">
              <AtomNode start="(320, 26)" end="(320, 27)" leading="" trailing="" val="("/>
              <NullNode start="(320, 27)" end="(320, 28)">
                <IdentNode start="(320, 27)" end="(320, 28)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(320, 29)" end="(320, 32)">
                <AtomNode start="(320, 29)" end="(320, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(320, 31)" end="(320, 32)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(320, 32)" end="(320, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(320, 34)" end="(320, 46)">
              <AtomNode start="(320, 34)" end="(320, 35)" leading="" trailing="" val="("/>
              <NullNode start="(320, 35)" end="(320, 36)">
                <IdentNode start="(320, 35)" end="(320, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(320, 37)" end="(320, 45)">
                <AtomNode start="(320, 37)" end="(320, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(320, 39)" end="(320, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(320, 39)" end="(320, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(320, 44)" end="(320, 45)">
                    <IdentNode start="(320, 44)" end="(320, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(320, 45)" end="(320, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(320, 47)" end="(320, 78)">
            <AtomNode start="(320, 47)" end="(320, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(320, 49)" end="(320, 78)" kind="«term_=_»">
              <OtherNode start="(320, 49)" end="(320, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(320, 49)" end="(320, 56)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(320, 57)" end="(320, 58)">
                  <IdentNode start="(320, 57)" end="(320, 58)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(320, 59)" end="(320, 60)" leading="" trailing=" " val="="/>
              <OtherNode start="(320, 61)" end="(320, 78)" kind="Lean.Parser.Term.app">
                <IdentNode start="(320, 61)" end="(320, 69)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                <NullNode start="(320, 70)" end="(320, 78)">
                  <OtherNode start="(320, 70)" end="(320, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(320, 70)" end="(320, 71)" leading="" trailing="" val="("/>
                    <OtherNode start="(320, 71)" end="(320, 77)" kind="«term_==_»">
                      <OtherNode start="(320, 71)" end="(320, 72)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(320, 71)" end="(320, 72)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(320, 73)" end="(320, 75)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(320, 76)" end="(320, 77)" leading="" trailing="" raw_val="a" val="a"/>
                    </OtherNode>
                    <AtomNode start="(320, 77)" end="(320, 78)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(320, 79)" end="(325, 46)">
          <AtomNode start="(320, 79)" end="(320, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(320, 82)" end="(325, 46)">
            <AtomNode start="(320, 82)" end="(320, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(321, 3)" end="(325, 46)">
              <TacticTacticseq1IndentedNode start="(321, 3)" end="(325, 46)">
                <NullNode start="(321, 3)" end="(325, 46)">
                  <OtherNode start="(321, 3)" end="(321, 14)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l : List α&#10;⊢ l.erase a = eraseP (fun x =&amp;gt; x == a) l" state_after="case nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;⊢ [].erase a = eraseP (fun x =&amp;gt; x == a) []&#10;&#10;case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : tail✝.erase a = eraseP (fun x =&amp;gt; x == a) tail✝&#10;⊢ (head✝ :: tail✝).erase a = eraseP (fun x =&amp;gt; x == a) (head✝ :: tail✝)" tactic="induction l">
                    <AtomNode start="(321, 3)" end="(321, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(321, 13)" end="(321, 14)">
                      <OtherNode start="(321, 13)" end="(321, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(321, 13)" end="(321, 14)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(322, 3)" end="(322, 9)" kind="Lean.cdot" state_before="case nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;⊢ [].erase a = eraseP (fun x =&amp;gt; x == a) []&#10;&#10;case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : tail✝.erase a = eraseP (fun x =&amp;gt; x == a) tail✝&#10;⊢ (head✝ :: tail✝).erase a = eraseP (fun x =&amp;gt; x == a) (head✝ :: tail✝)" state_after="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : tail✝.erase a = eraseP (fun x =&amp;gt; x == a) tail✝&#10;⊢ (head✝ :: tail✝).erase a = eraseP (fun x =&amp;gt; x == a) (head✝ :: tail✝)" tactic="· simp">
                    <OtherNode start="(322, 3)" end="(322, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(322, 3)" end="(322, 4)" kind="patternIgnore">
                        <OtherNode start="(322, 3)" end="(322, 4)" kind="token.«· »">
                          <AtomNode start="(322, 3)" end="(322, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(322, 5)" end="(322, 9)">
                      <TacticTacticseq1IndentedNode start="(322, 5)" end="(322, 9)">
                        <NullNode start="(322, 5)" end="(322, 9)">
                          <OtherNode start="(322, 5)" end="(322, 9)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;⊢ [].erase a = eraseP (fun x =&amp;gt; x == a) []" state_after="no goals" tactic="simp">
                            <AtomNode start="(322, 5)" end="(322, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(323, 3)" end="(325, 46)" kind="Lean.cdot" state_before="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : tail✝.erase a = eraseP (fun x =&amp;gt; x == a) tail✝&#10;⊢ (head✝ :: tail✝).erase a = eraseP (fun x =&amp;gt; x == a) (head✝ :: tail✝)" state_after="no goals" tactic="· next b t ih =&amp;gt;&#10;  rw [erase_cons, eraseP_cons, ih]&#10;  if h : b == a then simp [h] else simp [h]">
                    <OtherNode start="(323, 3)" end="(323, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(323, 3)" end="(323, 4)" kind="patternIgnore">
                        <OtherNode start="(323, 3)" end="(323, 4)" kind="token.«· »">
                          <AtomNode start="(323, 3)" end="(323, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(323, 5)" end="(325, 46)">
                      <TacticTacticseq1IndentedNode start="(323, 5)" end="(325, 46)">
                        <NullNode start="(323, 5)" end="(325, 46)">
                          <OtherNode start="(323, 5)" end="(325, 46)" kind="Lean.Parser.Tactic.«tacticNext_=&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : tail✝.erase a = eraseP (fun x =&amp;gt; x == a) tail✝&#10;⊢ (head✝ :: tail✝).erase a = eraseP (fun x =&amp;gt; x == a) (head✝ :: tail✝)" state_after="no goals" tactic="next b t ih =&amp;gt;&#10;rw [erase_cons, eraseP_cons, ih]&#10;if h : b == a then simp [h] else simp [h]">
                            <AtomNode start="(323, 5)" end="(323, 9)" leading="" trailing=" " val="next"/>
                            <NullNode start="(323, 10)" end="(323, 16)">
                              <LeanBinderidentNode start="(323, 10)" end="(323, 11)">
                                <IdentNode start="(323, 10)" end="(323, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                              </LeanBinderidentNode>
                              <LeanBinderidentNode start="(323, 12)" end="(323, 13)">
                                <IdentNode start="(323, 12)" end="(323, 13)" leading="" trailing=" " raw_val="t" val="t"/>
                              </LeanBinderidentNode>
                              <LeanBinderidentNode start="(323, 14)" end="(323, 16)">
                                <IdentNode start="(323, 14)" end="(323, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                              </LeanBinderidentNode>
                            </NullNode>
                            <AtomNode start="(323, 17)" end="(323, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(324, 5)" end="(325, 46)">
                              <TacticTacticseq1IndentedNode start="(324, 5)" end="(325, 46)">
                                <NullNode start="(324, 5)" end="(325, 46)">
                                  <OtherNode start="(324, 5)" end="(324, 37)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;t : List α&#10;ih : t.erase a = eraseP (fun x =&amp;gt; x == a) t&#10;⊢ (b :: t).erase a = eraseP (fun x =&amp;gt; x == a) (b :: t)" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;t : List α&#10;ih : t.erase a = eraseP (fun x =&amp;gt; x == a) t&#10;⊢ (if (b == a) = true then t else b :: eraseP (fun x =&amp;gt; x == a) t) =&#10;    bif b == a then t else b :: eraseP (fun x =&amp;gt; x == a) t" tactic="rw [erase_cons, eraseP_cons, ih]">
                                    <AtomNode start="(324, 5)" end="(324, 7)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(324, 8)" end="(324, 37)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(324, 8)" end="(324, 9)" leading="" trailing="" val="["/>
                                      <NullNode start="(324, 9)" end="(324, 36)">
                                        <OtherNode start="(324, 9)" end="(324, 19)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(324, 9)" end="(324, 19)" leading="" trailing="" raw_val="erase_cons" val="erase_cons" full_name="List.erase_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(324, 19)" end="(324, 20)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(324, 21)" end="(324, 32)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(324, 21)" end="(324, 32)" leading="" trailing="" raw_val="eraseP_cons" val="eraseP_cons" full_name="List.eraseP_cons" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(28, 9)" def_end="(28, 20)"/>
                                        </OtherNode>
                                        <AtomNode start="(324, 32)" end="(324, 33)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(324, 34)" end="(324, 36)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(324, 34)" end="(324, 36)" leading="" trailing="" raw_val="ih" val="ih"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(324, 36)" end="(324, 37)" leading="" trailing="&#10;    " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(325, 5)" end="(325, 46)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;t : List α&#10;ih : t.erase a = eraseP (fun x =&amp;gt; x == a) t&#10;⊢ (if (b == a) = true then t else b :: eraseP (fun x =&amp;gt; x == a) t) =&#10;    bif b == a then t else b :: eraseP (fun x =&amp;gt; x == a) t" state_after="no goals" tactic="if h : b == a then simp [h] else simp [h]">
                                    <AtomNode start="(325, 5)" end="(325, 7)" leading="" trailing=" " val="if"/>
                                    <LeanBinderidentNode start="(325, 8)" end="(325, 9)">
                                      <IdentNode start="(325, 8)" end="(325, 9)" leading="" trailing=" " raw_val="h" val="h"/>
                                    </LeanBinderidentNode>
                                    <AtomNode start="(325, 10)" end="(325, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(325, 12)" end="(325, 18)" kind="«term_==_»">
                                      <IdentNode start="(325, 12)" end="(325, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                      <AtomNode start="(325, 14)" end="(325, 16)" leading="" trailing=" " val="=="/>
                                      <IdentNode start="(325, 17)" end="(325, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                                    </OtherNode>
                                    <AtomNode start="(325, 19)" end="(325, 23)" leading="" trailing=" " val="then"/>
                                    <TacticTacticseqNode start="(325, 24)" end="(325, 32)">
                                      <TacticTacticseq1IndentedNode start="(325, 24)" end="(325, 32)">
                                        <NullNode start="(325, 24)" end="(325, 32)">
                                          <OtherNode start="(325, 24)" end="(325, 32)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;t : List α&#10;ih : t.erase a = eraseP (fun x =&amp;gt; x == a) t&#10;h : (b == a) = true&#10;⊢ (if (b == a) = true then t else b :: eraseP (fun x =&amp;gt; x == a) t) =&#10;    bif b == a then t else b :: eraseP (fun x =&amp;gt; x == a) t" state_after="no goals" tactic="simp [h]">
                                            <AtomNode start="(325, 24)" end="(325, 28)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(325, 29)" end="(325, 32)">
                                              <AtomNode start="(325, 29)" end="(325, 30)" leading="" trailing="" val="["/>
                                              <NullNode start="(325, 30)" end="(325, 31)">
                                                <OtherNode start="(325, 30)" end="(325, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(325, 30)" end="(325, 31)" leading="" trailing="" raw_val="h" val="h"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(325, 31)" end="(325, 32)" leading="" trailing=" " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                    <AtomNode start="(325, 33)" end="(325, 37)" leading="" trailing=" " val="else"/>
                                    <TacticTacticseqNode start="(325, 38)" end="(325, 46)">
                                      <TacticTacticseq1IndentedNode start="(325, 38)" end="(325, 46)">
                                        <NullNode start="(325, 38)" end="(325, 46)">
                                          <OtherNode start="(325, 38)" end="(325, 46)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;t : List α&#10;ih : t.erase a = eraseP (fun x =&amp;gt; x == a) t&#10;h : ¬(b == a) = true&#10;⊢ (if (b == a) = true then t else b :: eraseP (fun x =&amp;gt; x == a) t) =&#10;    bif b == a then t else b :: eraseP (fun x =&amp;gt; x == a) t" state_after="no goals" tactic="simp [h]">
                                            <AtomNode start="(325, 38)" end="(325, 42)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(325, 43)" end="(325, 46)">
                                              <AtomNode start="(325, 43)" end="(325, 44)" leading="" trailing="" val="["/>
                                              <NullNode start="(325, 44)" end="(325, 45)">
                                                <OtherNode start="(325, 44)" end="(325, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(325, 44)" end="(325, 45)" leading="" trailing="" raw_val="h" val="h"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(325, 45)" end="(325, 46)" leading="" trailing="&#10;&#10;-- The arguments are intentionally explicit.&#10;" val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(328, 1)" end="(331, 82)" name="erase_eq_eraseP" full_name="List.erase_eq_eraseP">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(328, 1)" end="(331, 82)" name="erase_eq_eraseP" full_name="List.erase_eq_eraseP" _is_private_decl="False">
        <AtomNode start="(328, 1)" end="(328, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(328, 9)" end="(328, 24)">
          <IdentNode start="(328, 9)" end="(328, 24)" leading="" trailing=" " raw_val="erase_eq_eraseP" val="erase_eq_eraseP"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(328, 25)" end="(328, 94)">
          <NullNode start="(328, 25)" end="(328, 46)">
            <OtherNode start="(328, 25)" end="(328, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(328, 25)" end="(328, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(328, 26)" end="(328, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(328, 26)" end="(328, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(328, 36)" end="(328, 37)">
                  <IdentNode start="(328, 36)" end="(328, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(328, 37)" end="(328, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(328, 39)" end="(328, 46)">
              <AtomNode start="(328, 39)" end="(328, 40)" leading="" trailing="" val="("/>
              <NullNode start="(328, 40)" end="(328, 41)">
                <IdentNode start="(328, 40)" end="(328, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(328, 42)" end="(328, 45)">
                <AtomNode start="(328, 42)" end="(328, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(328, 44)" end="(328, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(328, 45)" end="(328, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(328, 47)" end="(328, 94)">
            <AtomNode start="(328, 47)" end="(328, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(328, 49)" end="(328, 94)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(328, 49)" end="(328, 50)" leading="" trailing=" " val="∀"/>
              <NullNode start="(328, 51)" end="(328, 63)">
                <TermExplicitbinderNode start="(328, 51)" end="(328, 63)">
                  <AtomNode start="(328, 51)" end="(328, 52)" leading="" trailing="" val="("/>
                  <NullNode start="(328, 52)" end="(328, 53)">
                    <IdentNode start="(328, 52)" end="(328, 53)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(328, 54)" end="(328, 62)">
                    <AtomNode start="(328, 54)" end="(328, 55)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(328, 56)" end="(328, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(328, 56)" end="(328, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(328, 61)" end="(328, 62)">
                        <IdentNode start="(328, 61)" end="(328, 62)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(328, 62)" end="(328, 63)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(328, 63)" end="(328, 64)" leading="" trailing=" " val=","/>
              <OtherNode start="(328, 65)" end="(328, 94)" kind="«term_=_»">
                <OtherNode start="(328, 65)" end="(328, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(328, 65)" end="(328, 72)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                  <NullNode start="(328, 73)" end="(328, 74)">
                    <IdentNode start="(328, 73)" end="(328, 74)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(328, 75)" end="(328, 76)" leading="" trailing=" " val="="/>
                <OtherNode start="(328, 77)" end="(328, 94)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(328, 77)" end="(328, 85)" leading="" trailing=" " raw_val="l.eraseP" val="l.eraseP"/>
                  <NullNode start="(328, 86)" end="(328, 94)">
                    <OtherNode start="(328, 86)" end="(328, 94)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(328, 86)" end="(328, 87)" leading="" trailing="" val="("/>
                      <OtherNode start="(328, 87)" end="(328, 93)" kind="«term_==_»">
                        <IdentNode start="(328, 87)" end="(328, 88)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(328, 89)" end="(328, 91)" leading="" trailing=" " val="=="/>
                        <OtherNode start="(328, 92)" end="(328, 93)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(328, 92)" end="(328, 93)" leading="" trailing="" val="·"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(328, 93)" end="(328, 94)" leading="" trailing="&#10;  " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(329, 3)" end="(331, 82)">
          <OtherNode start="(329, 3)" end="(331, 82)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(329, 3)" end="(331, 82)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(329, 3)" end="(331, 82)">
                <OtherNode start="(329, 3)" end="(329, 14)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(329, 3)" end="(329, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(329, 5)" end="(329, 7)">
                    <NullNode start="(329, 5)" end="(329, 7)">
                      <OtherNode start="(329, 5)" end="(329, 7)" kind="«term[_]»">
                        <AtomNode start="(329, 5)" end="(329, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(329, 6)" end="(329, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(329, 8)" end="(329, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(329, 11)" end="(329, 14)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <OtherNode start="(330, 3)" end="(331, 82)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(330, 3)" end="(330, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(330, 5)" end="(330, 11)">
                    <NullNode start="(330, 5)" end="(330, 11)">
                      <OtherNode start="(330, 5)" end="(330, 11)" kind="«term_::_»">
                        <IdentNode start="(330, 5)" end="(330, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(330, 7)" end="(330, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(330, 10)" end="(330, 11)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(330, 12)" end="(330, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(330, 15)" end="(331, 82)">
                    <AtomNode start="(330, 15)" end="(330, 17)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(331, 5)" end="(331, 82)">
                      <TacticTacticseq1IndentedNode start="(331, 5)" end="(331, 82)">
                        <NullNode start="(331, 5)" end="(331, 82)">
                          <OtherNode start="(331, 5)" end="(331, 82)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;⊢ (b :: l).erase a = eraseP (fun x =&amp;gt; a == x) (b :: l)" state_after="no goals" tactic="if h : a = b then simp [h] else simp [h, Ne.symm h, erase_eq_eraseP (l := l)]">
                            <AtomNode start="(331, 5)" end="(331, 7)" leading="" trailing=" " val="if"/>
                            <LeanBinderidentNode start="(331, 8)" end="(331, 9)">
                              <IdentNode start="(331, 8)" end="(331, 9)" leading="" trailing=" " raw_val="h" val="h"/>
                            </LeanBinderidentNode>
                            <AtomNode start="(331, 10)" end="(331, 11)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(331, 12)" end="(331, 17)" kind="«term_=_»">
                              <IdentNode start="(331, 12)" end="(331, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                              <AtomNode start="(331, 14)" end="(331, 15)" leading="" trailing=" " val="="/>
                              <IdentNode start="(331, 16)" end="(331, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                            </OtherNode>
                            <AtomNode start="(331, 18)" end="(331, 22)" leading="" trailing=" " val="then"/>
                            <TacticTacticseqNode start="(331, 23)" end="(331, 31)">
                              <TacticTacticseq1IndentedNode start="(331, 23)" end="(331, 31)">
                                <NullNode start="(331, 23)" end="(331, 31)">
                                  <OtherNode start="(331, 23)" end="(331, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;h : a = b&#10;⊢ (b :: l).erase a = eraseP (fun x =&amp;gt; a == x) (b :: l)" state_after="no goals" tactic="simp [h]">
                                    <AtomNode start="(331, 23)" end="(331, 27)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(331, 28)" end="(331, 31)">
                                      <AtomNode start="(331, 28)" end="(331, 29)" leading="" trailing="" val="["/>
                                      <NullNode start="(331, 29)" end="(331, 30)">
                                        <OtherNode start="(331, 29)" end="(331, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(331, 29)" end="(331, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(331, 30)" end="(331, 31)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                            <AtomNode start="(331, 32)" end="(331, 36)" leading="" trailing=" " val="else"/>
                            <TacticTacticseqNode start="(331, 37)" end="(331, 82)">
                              <TacticTacticseq1IndentedNode start="(331, 37)" end="(331, 82)">
                                <NullNode start="(331, 37)" end="(331, 82)">
                                  <OtherNode start="(331, 37)" end="(331, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;h : ¬a = b&#10;⊢ (b :: l).erase a = eraseP (fun x =&amp;gt; a == x) (b :: l)" state_after="no goals" tactic="simp [h, Ne.symm h, erase_eq_eraseP (l := l)]">
                                    <AtomNode start="(331, 37)" end="(331, 41)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(331, 42)" end="(331, 82)">
                                      <AtomNode start="(331, 42)" end="(331, 43)" leading="" trailing="" val="["/>
                                      <NullNode start="(331, 43)" end="(331, 81)">
                                        <OtherNode start="(331, 43)" end="(331, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(331, 43)" end="(331, 44)" leading="" trailing="" raw_val="h" val="h"/>
                                        </OtherNode>
                                        <AtomNode start="(331, 44)" end="(331, 45)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(331, 46)" end="(331, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(331, 46)" end="(331, 55)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(331, 46)" end="(331, 53)" leading="" trailing=" " raw_val="Ne.symm" val="Ne.symm" full_name="Ne.symm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(331, 54)" end="(331, 55)">
                                              <IdentNode start="(331, 54)" end="(331, 55)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(331, 55)" end="(331, 56)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(331, 57)" end="(331, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(331, 57)" end="(331, 81)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(331, 57)" end="(331, 72)" leading="" trailing=" " raw_val="erase_eq_eraseP" val="erase_eq_eraseP"/>
                                            <NullNode start="(331, 73)" end="(331, 81)">
                                              <OtherNode start="(331, 73)" end="(331, 81)" kind="Lean.Parser.Term.namedArgument">
                                                <AtomNode start="(331, 73)" end="(331, 74)" leading="" trailing="" val="("/>
                                                <IdentNode start="(331, 74)" end="(331, 75)" leading="" trailing=" " raw_val="l" val="l"/>
                                                <AtomNode start="(331, 76)" end="(331, 78)" leading="" trailing=" " val=":="/>
                                                <IdentNode start="(331, 79)" end="(331, 80)" leading="" trailing="" raw_val="l" val="l"/>
                                                <AtomNode start="(331, 80)" end="(331, 81)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(331, 81)" end="(331, 82)" leading="" trailing="&#10;&#10;" val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(333, 1)" end="(336, 7)" name="erase_eq_nil_iff" full_name="List.erase_eq_nil_iff">
      <CommandDeclmodifiersNode start="(333, 1)" end="(333, 8)">
        <NullNode/>
        <NullNode start="(333, 1)" end="(333, 8)">
          <OtherNode start="(333, 1)" end="(333, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(333, 1)" end="(333, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(333, 3)" end="(333, 7)">
              <OtherNode start="(333, 3)" end="(333, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(333, 3)" end="(333, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(333, 3)" end="(333, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(333, 7)" end="(333, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(333, 9)" end="(336, 7)" name="erase_eq_nil_iff" full_name="List.erase_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(333, 9)" end="(333, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(333, 17)" end="(333, 33)">
          <IdentNode start="(333, 17)" end="(333, 33)" leading="" trailing=" " raw_val="erase_eq_nil_iff" val="erase_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(333, 34)" end="(334, 41)">
          <NullNode start="(333, 34)" end="(333, 69)">
            <OtherNode start="(333, 34)" end="(333, 47)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(333, 34)" end="(333, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(333, 35)" end="(333, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(333, 35)" end="(333, 44)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(333, 45)" end="(333, 46)">
                  <IdentNode start="(333, 45)" end="(333, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(333, 46)" end="(333, 47)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(333, 48)" end="(333, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(333, 48)" end="(333, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(333, 49)" end="(333, 51)">
                <IdentNode start="(333, 49)" end="(333, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(333, 52)" end="(333, 60)">
                <AtomNode start="(333, 52)" end="(333, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(333, 54)" end="(333, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(333, 54)" end="(333, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(333, 59)" end="(333, 60)">
                    <IdentNode start="(333, 59)" end="(333, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(333, 60)" end="(333, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(333, 62)" end="(333, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(333, 62)" end="(333, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(333, 63)" end="(333, 64)">
                <IdentNode start="(333, 63)" end="(333, 64)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(333, 65)" end="(333, 68)">
                <AtomNode start="(333, 65)" end="(333, 66)" leading="" trailing=" " val=":"/>
                <IdentNode start="(333, 67)" end="(333, 68)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(333, 68)" end="(333, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(333, 70)" end="(334, 41)">
            <AtomNode start="(333, 70)" end="(333, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(334, 5)" end="(334, 41)" kind="«term_↔_»">
              <OtherNode start="(334, 5)" end="(334, 20)" kind="«term_=_»">
                <OtherNode start="(334, 5)" end="(334, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(334, 5)" end="(334, 13)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(334, 14)" end="(334, 15)">
                    <IdentNode start="(334, 14)" end="(334, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(334, 16)" end="(334, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(334, 18)" end="(334, 20)" kind="«term[_]»">
                  <AtomNode start="(334, 18)" end="(334, 19)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(334, 19)" end="(334, 20)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(334, 21)" end="(334, 22)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(334, 23)" end="(334, 41)" kind="«term_∨_»">
                <OtherNode start="(334, 23)" end="(334, 30)" kind="«term_=_»">
                  <IdentNode start="(334, 23)" end="(334, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(334, 26)" end="(334, 27)" leading="" trailing=" " val="="/>
                  <OtherNode start="(334, 28)" end="(334, 30)" kind="«term[_]»">
                    <AtomNode start="(334, 28)" end="(334, 29)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(334, 29)" end="(334, 30)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(334, 31)" end="(334, 32)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(334, 33)" end="(334, 41)" kind="«term_=_»">
                  <IdentNode start="(334, 33)" end="(334, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(334, 36)" end="(334, 37)" leading="" trailing=" " val="="/>
                  <OtherNode start="(334, 38)" end="(334, 41)" kind="«term[_]»">
                    <AtomNode start="(334, 38)" end="(334, 39)" leading="" trailing="" val="["/>
                    <NullNode start="(334, 39)" end="(334, 40)">
                      <IdentNode start="(334, 39)" end="(334, 40)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(334, 40)" end="(334, 41)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(334, 42)" end="(336, 7)">
          <AtomNode start="(334, 42)" end="(334, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(334, 45)" end="(336, 7)">
            <AtomNode start="(334, 45)" end="(334, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(335, 3)" end="(336, 7)">
              <TacticTacticseq1IndentedNode start="(335, 3)" end="(336, 7)">
                <NullNode start="(335, 3)" end="(336, 7)">
                  <OtherNode start="(335, 3)" end="(335, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;a : α&#10;⊢ xs.erase a = [] ↔ xs = [] ∨ xs = [a]" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;a : α&#10;⊢ eraseP (fun x =&amp;gt; a == x) xs = [] ↔ xs = [] ∨ xs = [a]" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(335, 3)" end="(335, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(335, 6)" end="(335, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(335, 6)" end="(335, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(335, 7)" end="(335, 22)">
                        <OtherNode start="(335, 7)" end="(335, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(335, 7)" end="(335, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(335, 22)" end="(335, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(336, 3)" end="(336, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;a : α&#10;⊢ eraseP (fun x =&amp;gt; a == x) xs = [] ↔ xs = [] ∨ xs = [a]" state_after="no goals" tactic="simp">
                    <AtomNode start="(336, 3)" end="(336, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(338, 1)" end="(339, 41)" name="erase_eq_nil" full_name="List.erase_eq_nil">
      <CommandDeclmodifiersNode start="(338, 1)" end="(338, 55)">
        <NullNode/>
        <NullNode start="(338, 1)" end="(338, 55)">
          <OtherNode start="(338, 1)" end="(338, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(338, 1)" end="(338, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(338, 3)" end="(338, 54)">
              <OtherNode start="(338, 3)" end="(338, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(338, 3)" end="(338, 54)" kind="Lean.deprecated">
                  <AtomNode start="(338, 3)" end="(338, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(338, 14)" end="(338, 30)">
                    <IdentNode start="(338, 14)" end="(338, 30)" leading="" trailing=" " raw_val="erase_eq_nil_iff" val="erase_eq_nil_iff" full_name="List.erase_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(333, 17)" def_end="(333, 33)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(338, 31)" end="(338, 54)">
                    <AtomNode start="(338, 31)" end="(338, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(338, 32)" end="(338, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(338, 38)" end="(338, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(338, 41)" end="(338, 53)" kind="str">
                      <AtomNode start="(338, 41)" end="(338, 53)" leading="" trailing="" val="&amp;quot;2025-01-30&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(338, 53)" end="(338, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(338, 54)" end="(338, 55)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(339, 1)" end="(339, 41)" name="erase_eq_nil">
        <AtomNode start="(339, 1)" end="(339, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(339, 8)" end="(339, 20)">
          <IdentNode start="(339, 8)" end="(339, 20)" leading="" trailing=" " raw_val="erase_eq_nil" val="erase_eq_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(339, 21)" end="(339, 41)">
          <AtomNode start="(339, 21)" end="(339, 23)" leading="" trailing=" " val=":="/>
          <OtherNode start="(339, 24)" end="(339, 41)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(339, 24)" end="(339, 25)" leading="" trailing="" val="@"/>
            <IdentNode start="(339, 25)" end="(339, 41)" leading="" trailing="&#10;&#10;" raw_val="erase_eq_nil_iff" val="erase_eq_nil_iff" full_name="List.erase_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(333, 17)" def_end="(333, 33)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(341, 1)" end="(344, 7)" name="erase_ne_nil_iff" full_name="List.erase_ne_nil_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(341, 1)" end="(344, 7)" name="erase_ne_nil_iff" full_name="List.erase_ne_nil_iff" _is_private_decl="False">
        <AtomNode start="(341, 1)" end="(341, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(341, 9)" end="(341, 25)">
          <IdentNode start="(341, 9)" end="(341, 25)" leading="" trailing=" " raw_val="erase_ne_nil_iff" val="erase_ne_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(341, 26)" end="(342, 41)">
          <NullNode start="(341, 26)" end="(341, 61)">
            <OtherNode start="(341, 26)" end="(341, 39)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(341, 26)" end="(341, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(341, 27)" end="(341, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(341, 27)" end="(341, 36)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(341, 37)" end="(341, 38)">
                  <IdentNode start="(341, 37)" end="(341, 38)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(341, 38)" end="(341, 39)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(341, 40)" end="(341, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 40)" end="(341, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 41)" end="(341, 43)">
                <IdentNode start="(341, 41)" end="(341, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(341, 44)" end="(341, 52)">
                <AtomNode start="(341, 44)" end="(341, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(341, 46)" end="(341, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(341, 46)" end="(341, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(341, 51)" end="(341, 52)">
                    <IdentNode start="(341, 51)" end="(341, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(341, 52)" end="(341, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(341, 54)" end="(341, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(341, 54)" end="(341, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(341, 55)" end="(341, 56)">
                <IdentNode start="(341, 55)" end="(341, 56)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(341, 57)" end="(341, 60)">
                <AtomNode start="(341, 57)" end="(341, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(341, 59)" end="(341, 60)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(341, 60)" end="(341, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(341, 62)" end="(342, 41)">
            <AtomNode start="(341, 62)" end="(341, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(342, 5)" end="(342, 41)" kind="«term_↔_»">
              <OtherNode start="(342, 5)" end="(342, 20)" kind="«term_≠_»">
                <OtherNode start="(342, 5)" end="(342, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(342, 5)" end="(342, 13)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                  <NullNode start="(342, 14)" end="(342, 15)">
                    <IdentNode start="(342, 14)" end="(342, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(342, 16)" end="(342, 17)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(342, 18)" end="(342, 20)" kind="«term[_]»">
                  <AtomNode start="(342, 18)" end="(342, 19)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(342, 19)" end="(342, 20)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(342, 21)" end="(342, 22)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(342, 23)" end="(342, 41)" kind="«term_∧_»">
                <OtherNode start="(342, 23)" end="(342, 30)" kind="«term_≠_»">
                  <IdentNode start="(342, 23)" end="(342, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(342, 26)" end="(342, 27)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(342, 28)" end="(342, 30)" kind="«term[_]»">
                    <AtomNode start="(342, 28)" end="(342, 29)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(342, 29)" end="(342, 30)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(342, 31)" end="(342, 32)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(342, 33)" end="(342, 41)" kind="«term_≠_»">
                  <IdentNode start="(342, 33)" end="(342, 35)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(342, 36)" end="(342, 37)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(342, 38)" end="(342, 41)" kind="«term[_]»">
                    <AtomNode start="(342, 38)" end="(342, 39)" leading="" trailing="" val="["/>
                    <NullNode start="(342, 39)" end="(342, 40)">
                      <IdentNode start="(342, 39)" end="(342, 40)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(342, 40)" end="(342, 41)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(342, 42)" end="(344, 7)">
          <AtomNode start="(342, 42)" end="(342, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(342, 45)" end="(344, 7)">
            <AtomNode start="(342, 45)" end="(342, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(343, 3)" end="(344, 7)">
              <TacticTacticseq1IndentedNode start="(343, 3)" end="(344, 7)">
                <NullNode start="(343, 3)" end="(344, 7)">
                  <OtherNode start="(343, 3)" end="(343, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;a : α&#10;⊢ xs.erase a ≠ [] ↔ xs ≠ [] ∧ xs ≠ [a]" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;a : α&#10;⊢ eraseP (fun x =&amp;gt; a == x) xs ≠ [] ↔ xs ≠ [] ∧ xs ≠ [a]" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(343, 3)" end="(343, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(343, 6)" end="(343, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(343, 6)" end="(343, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(343, 7)" end="(343, 22)">
                        <OtherNode start="(343, 7)" end="(343, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(343, 7)" end="(343, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(343, 22)" end="(343, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(344, 3)" end="(344, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;xs : List α&#10;a : α&#10;⊢ eraseP (fun x =&amp;gt; a == x) xs ≠ [] ↔ xs ≠ [] ∧ xs ≠ [a]" state_after="no goals" tactic="simp">
                    <AtomNode start="(344, 3)" end="(344, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(346, 1)" end="(347, 41)" name="erase_ne_nil" full_name="List.erase_ne_nil">
      <CommandDeclmodifiersNode start="(346, 1)" end="(346, 55)">
        <NullNode/>
        <NullNode start="(346, 1)" end="(346, 55)">
          <OtherNode start="(346, 1)" end="(346, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(346, 1)" end="(346, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(346, 3)" end="(346, 54)">
              <OtherNode start="(346, 3)" end="(346, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(346, 3)" end="(346, 54)" kind="Lean.deprecated">
                  <AtomNode start="(346, 3)" end="(346, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(346, 14)" end="(346, 30)">
                    <IdentNode start="(346, 14)" end="(346, 30)" leading="" trailing=" " raw_val="erase_ne_nil_iff" val="erase_ne_nil_iff" full_name="List.erase_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(341, 9)" def_end="(341, 25)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(346, 31)" end="(346, 54)">
                    <AtomNode start="(346, 31)" end="(346, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(346, 32)" end="(346, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(346, 38)" end="(346, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(346, 41)" end="(346, 53)" kind="str">
                      <AtomNode start="(346, 41)" end="(346, 53)" leading="" trailing="" val="&amp;quot;2025-01-30&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(346, 53)" end="(346, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(346, 54)" end="(346, 55)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(347, 1)" end="(347, 41)" name="erase_ne_nil">
        <AtomNode start="(347, 1)" end="(347, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(347, 8)" end="(347, 20)">
          <IdentNode start="(347, 8)" end="(347, 20)" leading="" trailing=" " raw_val="erase_ne_nil" val="erase_ne_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(347, 21)" end="(347, 41)">
          <AtomNode start="(347, 21)" end="(347, 23)" leading="" trailing=" " val=":="/>
          <OtherNode start="(347, 24)" end="(347, 41)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(347, 24)" end="(347, 25)" leading="" trailing="" val="@"/>
            <IdentNode start="(347, 25)" end="(347, 41)" leading="" trailing="&#10;&#10;" raw_val="erase_ne_nil_iff" val="erase_ne_nil_iff" full_name="List.erase_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(341, 9)" def_end="(341, 25)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(349, 1)" end="(352, 99)" name="exists_erase_eq" full_name="List.exists_erase_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(349, 1)" end="(352, 99)" name="exists_erase_eq" full_name="List.exists_erase_eq" _is_private_decl="False">
        <AtomNode start="(349, 1)" end="(349, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(349, 9)" end="(349, 24)">
          <IdentNode start="(349, 9)" end="(349, 24)" leading="" trailing=" " raw_val="exists_erase_eq" val="exists_erase_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(349, 25)" end="(350, 63)">
          <NullNode start="(349, 25)" end="(349, 71)">
            <OtherNode start="(349, 25)" end="(349, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(349, 25)" end="(349, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(349, 26)" end="(349, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(349, 26)" end="(349, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(349, 36)" end="(349, 37)">
                  <IdentNode start="(349, 36)" end="(349, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(349, 37)" end="(349, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(349, 39)" end="(349, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(349, 39)" end="(349, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(349, 40)" end="(349, 41)">
                <IdentNode start="(349, 40)" end="(349, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(349, 42)" end="(349, 45)">
                <AtomNode start="(349, 42)" end="(349, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(349, 44)" end="(349, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(349, 45)" end="(349, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(349, 47)" end="(349, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(349, 47)" end="(349, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(349, 48)" end="(349, 49)">
                <IdentNode start="(349, 48)" end="(349, 49)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(349, 50)" end="(349, 58)">
                <AtomNode start="(349, 50)" end="(349, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(349, 52)" end="(349, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(349, 52)" end="(349, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(349, 57)" end="(349, 58)">
                    <IdentNode start="(349, 57)" end="(349, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(349, 58)" end="(349, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(349, 60)" end="(349, 71)">
              <AtomNode start="(349, 60)" end="(349, 61)" leading="" trailing="" val="("/>
              <NullNode start="(349, 61)" end="(349, 62)">
                <IdentNode start="(349, 61)" end="(349, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(349, 63)" end="(349, 70)">
                <AtomNode start="(349, 63)" end="(349, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(349, 65)" end="(349, 70)" kind="«term_∈_»">
                  <IdentNode start="(349, 65)" end="(349, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(349, 67)" end="(349, 68)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(349, 69)" end="(349, 70)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(349, 70)" end="(349, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(349, 72)" end="(350, 63)">
            <AtomNode start="(349, 72)" end="(349, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(350, 5)" end="(350, 63)" kind="«term∃_,_»">
              <AtomNode start="(350, 5)" end="(350, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(350, 7)" end="(350, 12)" kind="Lean.explicitBinders">
                <OtherNode start="(350, 7)" end="(350, 12)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(350, 7)" end="(350, 12)">
                    <LeanBinderidentNode start="(350, 7)" end="(350, 9)">
                      <IdentNode start="(350, 7)" end="(350, 9)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </LeanBinderidentNode>
                    <LeanBinderidentNode start="(350, 10)" end="(350, 12)">
                      <IdentNode start="(350, 10)" end="(350, 12)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(350, 12)" end="(350, 13)" leading="" trailing=" " val=","/>
              <OtherNode start="(350, 14)" end="(350, 63)" kind="«term_∧_»">
                <OtherNode start="(350, 14)" end="(350, 20)" kind="«term_∉_»">
                  <IdentNode start="(350, 14)" end="(350, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(350, 16)" end="(350, 17)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(350, 18)" end="(350, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </OtherNode>
                <AtomNode start="(350, 21)" end="(350, 22)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(350, 23)" end="(350, 63)" kind="«term_∧_»">
                  <OtherNode start="(350, 23)" end="(350, 40)" kind="«term_=_»">
                    <IdentNode start="(350, 23)" end="(350, 24)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(350, 25)" end="(350, 26)" leading="" trailing=" " val="="/>
                    <OtherNode start="(350, 27)" end="(350, 40)" kind="«term_++_»">
                      <IdentNode start="(350, 27)" end="(350, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(350, 30)" end="(350, 32)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(350, 33)" end="(350, 40)" kind="«term_::_»">
                        <IdentNode start="(350, 33)" end="(350, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(350, 35)" end="(350, 37)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(350, 38)" end="(350, 40)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(350, 41)" end="(350, 42)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(350, 43)" end="(350, 63)" kind="«term_=_»">
                    <OtherNode start="(350, 43)" end="(350, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(350, 43)" end="(350, 50)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(350, 51)" end="(350, 52)">
                        <IdentNode start="(350, 51)" end="(350, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(350, 53)" end="(350, 54)" leading="" trailing=" " val="="/>
                    <OtherNode start="(350, 55)" end="(350, 63)" kind="«term_++_»">
                      <IdentNode start="(350, 55)" end="(350, 57)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(350, 58)" end="(350, 60)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(350, 61)" end="(350, 63)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(350, 64)" end="(352, 99)">
          <AtomNode start="(350, 64)" end="(350, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(350, 67)" end="(352, 99)">
            <AtomNode start="(350, 67)" end="(350, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(351, 3)" end="(352, 99)">
              <TacticTacticseq1IndentedNode start="(351, 3)" end="(352, 99)">
                <NullNode start="(351, 3)" end="(352, 99)">
                  <OtherNode start="(351, 3)" end="(351, 76)" kind="Lean.Parser.Tactic.tacticLet_" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;w✝ : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : l = l₁ ++ w✝ :: l₂&#10;h₃ : eraseP (BEq.beq a) l = l₁ ++ l₂&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂" tactic="let ⟨_, l₁, l₂, h₁, e, h₂, h₃⟩ := exists_of_eraseP h (beq_self_eq_true _)">
                    <AtomNode start="(351, 3)" end="(351, 6)" leading="" trailing=" " val="let"/>
                    <OtherNode start="(351, 7)" end="(351, 76)" kind="Lean.Parser.Term.letDecl">
                      <OtherNode start="(351, 7)" end="(351, 76)" kind="Lean.Parser.Term.letPatDecl">
                        <OtherNode start="(351, 7)" end="(351, 33)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(351, 7)" end="(351, 8)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(351, 8)" end="(351, 32)">
                            <TermHoleNode start="(351, 8)" end="(351, 9)">
                              <AtomNode start="(351, 8)" end="(351, 9)" leading="" trailing="" val="_"/>
                            </TermHoleNode>
                            <AtomNode start="(351, 9)" end="(351, 10)" leading="" trailing=" " val=","/>
                            <IdentNode start="(351, 11)" end="(351, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                            <AtomNode start="(351, 13)" end="(351, 14)" leading="" trailing=" " val=","/>
                            <IdentNode start="(351, 15)" end="(351, 17)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                            <AtomNode start="(351, 17)" end="(351, 18)" leading="" trailing=" " val=","/>
                            <IdentNode start="(351, 19)" end="(351, 21)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                            <AtomNode start="(351, 21)" end="(351, 22)" leading="" trailing=" " val=","/>
                            <IdentNode start="(351, 23)" end="(351, 24)" leading="" trailing="" raw_val="e" val="e"/>
                            <AtomNode start="(351, 24)" end="(351, 25)" leading="" trailing=" " val=","/>
                            <IdentNode start="(351, 26)" end="(351, 28)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                            <AtomNode start="(351, 28)" end="(351, 29)" leading="" trailing=" " val=","/>
                            <IdentNode start="(351, 30)" end="(351, 32)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                          </NullNode>
                          <AtomNode start="(351, 32)" end="(351, 33)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(351, 34)" end="(351, 36)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(351, 37)" end="(351, 76)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(351, 37)" end="(351, 53)" leading="" trailing=" " raw_val="exists_of_eraseP" val="exists_of_eraseP" full_name="List.exists_of_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(67, 9)" def_end="(67, 25)"/>
                          <NullNode start="(351, 54)" end="(351, 76)">
                            <IdentNode start="(351, 54)" end="(351, 55)" leading="" trailing=" " raw_val="h" val="h"/>
                            <OtherNode start="(351, 56)" end="(351, 76)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(351, 56)" end="(351, 57)" leading="" trailing="" val="("/>
                              <OtherNode start="(351, 57)" end="(351, 75)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(351, 57)" end="(351, 73)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                <NullNode start="(351, 74)" end="(351, 75)">
                                  <TermHoleNode start="(351, 74)" end="(351, 75)">
                                    <AtomNode start="(351, 74)" end="(351, 75)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(351, 75)" end="(351, 76)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(352, 3)" end="(352, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;w✝ : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : l = l₁ ++ w✝ :: l₂&#10;h₃ : eraseP (BEq.beq a) l = l₁ ++ l₂&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.erase a = l₁ ++ l₂" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;w✝ : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : l = l₁ ++ w✝ :: l₂&#10;h₃ : eraseP (BEq.beq a) l = l₁ ++ l₂&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ eraseP (fun x =&amp;gt; a == x) l = l₁ ++ l₂" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(352, 3)" end="(352, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(352, 6)" end="(352, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(352, 6)" end="(352, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(352, 7)" end="(352, 22)">
                        <OtherNode start="(352, 7)" end="(352, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(352, 7)" end="(352, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(352, 22)" end="(352, 23)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(352, 23)" end="(352, 24)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(352, 25)" end="(352, 99)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;w✝ : α&#10;l₁ l₂ : List α&#10;h₁ : ∀ (b : α), b ∈ l₁ → ¬(a == b) = true&#10;e : (a == w✝) = true&#10;h₂ : l = l₁ ++ w✝ :: l₂&#10;h₃ : eraseP (BEq.beq a) l = l₁ ++ l₂&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ eraseP (fun x =&amp;gt; a == x) l = l₁ ++ l₂" state_after="no goals" tactic="exact ⟨l₁, l₂, fun h =&amp;gt; h₁ _ h (beq_self_eq_true _), eq_of_beq e ▸ h₂, h₃⟩">
                    <AtomNode start="(352, 25)" end="(352, 30)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(352, 31)" end="(352, 99)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(352, 31)" end="(352, 32)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(352, 32)" end="(352, 98)">
                        <IdentNode start="(352, 32)" end="(352, 34)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                        <AtomNode start="(352, 34)" end="(352, 35)" leading="" trailing=" " val=","/>
                        <IdentNode start="(352, 36)" end="(352, 38)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        <AtomNode start="(352, 38)" end="(352, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(352, 40)" end="(352, 76)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(352, 40)" end="(352, 43)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(352, 44)" end="(352, 76)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(352, 44)" end="(352, 45)">
                              <IdentNode start="(352, 44)" end="(352, 45)" leading="" trailing=" " raw_val="h" val="h"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(352, 46)" end="(352, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(352, 49)" end="(352, 76)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(352, 49)" end="(352, 51)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                              <NullNode start="(352, 52)" end="(352, 76)">
                                <TermHoleNode start="(352, 52)" end="(352, 53)">
                                  <AtomNode start="(352, 52)" end="(352, 53)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <IdentNode start="(352, 54)" end="(352, 55)" leading="" trailing=" " raw_val="h" val="h"/>
                                <OtherNode start="(352, 56)" end="(352, 76)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(352, 56)" end="(352, 57)" leading="" trailing="" val="("/>
                                  <OtherNode start="(352, 57)" end="(352, 75)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(352, 57)" end="(352, 73)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                    <NullNode start="(352, 74)" end="(352, 75)">
                                      <TermHoleNode start="(352, 74)" end="(352, 75)">
                                        <AtomNode start="(352, 74)" end="(352, 75)" leading="" trailing="" val="_"/>
                                      </TermHoleNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(352, 75)" end="(352, 76)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(352, 76)" end="(352, 77)" leading="" trailing=" " val=","/>
                        <OtherNode start="(352, 78)" end="(352, 94)" kind="Lean.Parser.Term.subst">
                          <OtherNode start="(352, 78)" end="(352, 89)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(352, 78)" end="(352, 87)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(352, 88)" end="(352, 89)">
                              <IdentNode start="(352, 88)" end="(352, 89)" leading="" trailing=" " raw_val="e" val="e"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(352, 90)" end="(352, 91)" leading="" trailing=" " val="▸"/>
                          <NullNode start="(352, 92)" end="(352, 94)">
                            <IdentNode start="(352, 92)" end="(352, 94)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(352, 94)" end="(352, 95)" leading="" trailing=" " val=","/>
                        <IdentNode start="(352, 96)" end="(352, 98)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                      </NullNode>
                      <AtomNode start="(352, 98)" end="(352, 99)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(354, 1)" end="(356, 74)" name="length_erase_of_mem" full_name="List.length_erase_of_mem">
      <CommandDeclmodifiersNode start="(354, 1)" end="(354, 8)">
        <NullNode/>
        <NullNode start="(354, 1)" end="(354, 8)">
          <OtherNode start="(354, 1)" end="(354, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(354, 1)" end="(354, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(354, 3)" end="(354, 7)">
              <OtherNode start="(354, 3)" end="(354, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(354, 3)" end="(354, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(354, 3)" end="(354, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(354, 7)" end="(354, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(354, 9)" end="(356, 74)" name="length_erase_of_mem" full_name="List.length_erase_of_mem" _is_private_decl="False">
        <AtomNode start="(354, 9)" end="(354, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(354, 17)" end="(354, 36)">
          <IdentNode start="(354, 17)" end="(354, 36)" leading="" trailing=" " raw_val="length_erase_of_mem" val="length_erase_of_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(354, 37)" end="(355, 38)">
          <NullNode start="(354, 37)" end="(354, 83)">
            <OtherNode start="(354, 37)" end="(354, 50)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(354, 37)" end="(354, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(354, 38)" end="(354, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(354, 38)" end="(354, 47)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(354, 48)" end="(354, 49)">
                  <IdentNode start="(354, 48)" end="(354, 49)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(354, 49)" end="(354, 50)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(354, 51)" end="(354, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(354, 51)" end="(354, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(354, 52)" end="(354, 53)">
                <IdentNode start="(354, 52)" end="(354, 53)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(354, 54)" end="(354, 57)">
                <AtomNode start="(354, 54)" end="(354, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(354, 56)" end="(354, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(354, 57)" end="(354, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(354, 59)" end="(354, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(354, 59)" end="(354, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(354, 60)" end="(354, 61)">
                <IdentNode start="(354, 60)" end="(354, 61)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(354, 62)" end="(354, 70)">
                <AtomNode start="(354, 62)" end="(354, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(354, 64)" end="(354, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(354, 64)" end="(354, 68)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(354, 69)" end="(354, 70)">
                    <IdentNode start="(354, 69)" end="(354, 70)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(354, 70)" end="(354, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(354, 72)" end="(354, 83)">
              <AtomNode start="(354, 72)" end="(354, 73)" leading="" trailing="" val="("/>
              <NullNode start="(354, 73)" end="(354, 74)">
                <IdentNode start="(354, 73)" end="(354, 74)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(354, 75)" end="(354, 82)">
                <AtomNode start="(354, 75)" end="(354, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(354, 77)" end="(354, 82)" kind="«term_∈_»">
                  <IdentNode start="(354, 77)" end="(354, 78)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(354, 79)" end="(354, 80)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(354, 81)" end="(354, 82)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(354, 82)" end="(354, 83)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(354, 84)" end="(355, 38)">
            <AtomNode start="(354, 84)" end="(354, 85)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(355, 5)" end="(355, 38)" kind="«term_=_»">
              <OtherNode start="(355, 5)" end="(355, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(355, 5)" end="(355, 11)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(355, 12)" end="(355, 23)">
                  <OtherNode start="(355, 12)" end="(355, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(355, 12)" end="(355, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(355, 13)" end="(355, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(355, 13)" end="(355, 20)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(355, 21)" end="(355, 22)">
                        <IdentNode start="(355, 21)" end="(355, 22)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(355, 22)" end="(355, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(355, 24)" end="(355, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(355, 26)" end="(355, 38)" kind="«term_-_»">
                <OtherNode start="(355, 26)" end="(355, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(355, 26)" end="(355, 32)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(355, 33)" end="(355, 34)">
                    <IdentNode start="(355, 33)" end="(355, 34)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(355, 35)" end="(355, 36)" leading="" trailing=" " val="-"/>
                <OtherNode start="(355, 37)" end="(355, 38)" kind="num">
                  <AtomNode start="(355, 37)" end="(355, 38)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(355, 39)" end="(356, 74)">
          <AtomNode start="(355, 39)" end="(355, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(355, 42)" end="(356, 74)">
            <AtomNode start="(355, 42)" end="(355, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(356, 3)" end="(356, 74)">
              <TacticTacticseq1IndentedNode start="(356, 3)" end="(356, 74)">
                <NullNode start="(356, 3)" end="(356, 74)">
                  <OtherNode start="(356, 3)" end="(356, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;⊢ (l.erase a).length = l.length - 1" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;⊢ (eraseP (fun x =&amp;gt; a == x) l).length = l.length - 1" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(356, 3)" end="(356, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(356, 6)" end="(356, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(356, 6)" end="(356, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(356, 7)" end="(356, 22)">
                        <OtherNode start="(356, 7)" end="(356, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(356, 7)" end="(356, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(356, 22)" end="(356, 23)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(356, 23)" end="(356, 24)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(356, 25)" end="(356, 74)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : a ∈ l&#10;⊢ (eraseP (fun x =&amp;gt; a == x) l).length = l.length - 1" state_after="no goals" tactic="exact length_eraseP_of_mem h (beq_self_eq_true a)">
                    <AtomNode start="(356, 25)" end="(356, 30)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(356, 31)" end="(356, 74)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(356, 31)" end="(356, 51)" leading="" trailing=" " raw_val="length_eraseP_of_mem" val="length_eraseP_of_mem" full_name="List.length_eraseP_of_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(90, 17)" def_end="(90, 37)"/>
                      <NullNode start="(356, 52)" end="(356, 74)">
                        <IdentNode start="(356, 52)" end="(356, 53)" leading="" trailing=" " raw_val="h" val="h"/>
                        <OtherNode start="(356, 54)" end="(356, 74)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(356, 54)" end="(356, 55)" leading="" trailing="" val="("/>
                          <OtherNode start="(356, 55)" end="(356, 73)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(356, 55)" end="(356, 71)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                            <NullNode start="(356, 72)" end="(356, 73)">
                              <IdentNode start="(356, 72)" end="(356, 73)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(356, 73)" end="(356, 74)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(358, 1)" end="(361, 31)" name="length_erase" full_name="List.length_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(358, 1)" end="(361, 31)" name="length_erase" full_name="List.length_erase" _is_private_decl="False">
        <AtomNode start="(358, 1)" end="(358, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(358, 9)" end="(358, 21)">
          <IdentNode start="(358, 9)" end="(358, 21)" leading="" trailing=" " raw_val="length_erase" val="length_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(358, 22)" end="(359, 66)">
          <NullNode start="(358, 22)" end="(358, 56)">
            <OtherNode start="(358, 22)" end="(358, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(358, 22)" end="(358, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(358, 23)" end="(358, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(358, 23)" end="(358, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(358, 33)" end="(358, 34)">
                  <IdentNode start="(358, 33)" end="(358, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(358, 34)" end="(358, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(358, 36)" end="(358, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 36)" end="(358, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 37)" end="(358, 38)">
                <IdentNode start="(358, 37)" end="(358, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(358, 39)" end="(358, 42)">
                <AtomNode start="(358, 39)" end="(358, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(358, 41)" end="(358, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(358, 42)" end="(358, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(358, 44)" end="(358, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(358, 44)" end="(358, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(358, 45)" end="(358, 46)">
                <IdentNode start="(358, 45)" end="(358, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(358, 47)" end="(358, 55)">
                <AtomNode start="(358, 47)" end="(358, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(358, 49)" end="(358, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(358, 49)" end="(358, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(358, 54)" end="(358, 55)">
                    <IdentNode start="(358, 54)" end="(358, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(358, 55)" end="(358, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(358, 57)" end="(359, 66)">
            <AtomNode start="(358, 57)" end="(358, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(359, 5)" end="(359, 66)" kind="«term_=_»">
              <OtherNode start="(359, 5)" end="(359, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(359, 5)" end="(359, 11)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(359, 12)" end="(359, 23)">
                  <OtherNode start="(359, 12)" end="(359, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(359, 12)" end="(359, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(359, 13)" end="(359, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(359, 13)" end="(359, 20)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(359, 21)" end="(359, 22)">
                        <IdentNode start="(359, 21)" end="(359, 22)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(359, 22)" end="(359, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(359, 24)" end="(359, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(359, 26)" end="(359, 66)" kind="termIfThenElse">
                <AtomNode start="(359, 26)" end="(359, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(359, 29)" end="(359, 34)" kind="«term_∈_»">
                  <IdentNode start="(359, 29)" end="(359, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(359, 31)" end="(359, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(359, 33)" end="(359, 34)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(359, 35)" end="(359, 39)" leading="" trailing=" " val="then"/>
                <OtherNode start="(359, 40)" end="(359, 52)" kind="«term_-_»">
                  <OtherNode start="(359, 40)" end="(359, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(359, 40)" end="(359, 46)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(359, 47)" end="(359, 48)">
                      <IdentNode start="(359, 47)" end="(359, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(359, 49)" end="(359, 50)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(359, 51)" end="(359, 52)" kind="num">
                    <AtomNode start="(359, 51)" end="(359, 52)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(359, 53)" end="(359, 57)" leading="" trailing=" " val="else"/>
                <OtherNode start="(359, 58)" end="(359, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(359, 58)" end="(359, 64)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(359, 65)" end="(359, 66)">
                    <IdentNode start="(359, 65)" end="(359, 66)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(359, 67)" end="(361, 31)">
          <AtomNode start="(359, 67)" end="(359, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(359, 70)" end="(361, 31)">
            <AtomNode start="(359, 70)" end="(359, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(360, 3)" end="(361, 31)">
              <TacticTacticseq1IndentedNode start="(360, 3)" end="(361, 31)">
                <NullNode start="(360, 3)" end="(361, 31)">
                  <OtherNode start="(360, 3)" end="(360, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (l.erase a).length = if a ∈ l then l.length - 1 else l.length" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (if (l.any fun x =&amp;gt; a == x) = true then l.length - 1 else l.length) = if a ∈ l then l.length - 1 else l.length" tactic="rw [erase_eq_eraseP, length_eraseP]">
                    <AtomNode start="(360, 3)" end="(360, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(360, 6)" end="(360, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(360, 6)" end="(360, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(360, 7)" end="(360, 37)">
                        <OtherNode start="(360, 7)" end="(360, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(360, 7)" end="(360, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                        <AtomNode start="(360, 22)" end="(360, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(360, 24)" end="(360, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(360, 24)" end="(360, 37)" leading="" trailing="" raw_val="length_eraseP" val="length_eraseP" full_name="List.length_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(360, 37)" end="(360, 38)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(361, 3)" end="(361, 31)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (if (l.any fun x =&amp;gt; a == x) = true then l.length - 1 else l.length) = if a ∈ l then l.length - 1 else l.length" state_after="no goals" tactic="split &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(361, 3)" end="(361, 18)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(361, 3)" end="(361, 8)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(361, 3)" end="(361, 8)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(361, 9)" end="(361, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(361, 13)" end="(361, 18)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(361, 13)" end="(361, 18)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(361, 19)" end="(361, 22)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(361, 23)" end="(361, 31)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(361, 23)" end="(361, 31)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(363, 1)" end="(364, 43)" name="erase_sublist" full_name="List.erase_sublist">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(363, 1)" end="(364, 43)" name="erase_sublist" full_name="List.erase_sublist" _is_private_decl="False">
        <AtomNode start="(363, 1)" end="(363, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(363, 9)" end="(363, 22)">
          <IdentNode start="(363, 9)" end="(363, 22)" leading="" trailing=" " raw_val="erase_sublist" val="erase_sublist"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(363, 23)" end="(363, 60)">
          <NullNode start="(363, 23)" end="(363, 43)">
            <OtherNode start="(363, 23)" end="(363, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 23)" end="(363, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 24)" end="(363, 25)">
                <IdentNode start="(363, 24)" end="(363, 25)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(363, 26)" end="(363, 29)">
                <AtomNode start="(363, 26)" end="(363, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(363, 28)" end="(363, 29)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(363, 29)" end="(363, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(363, 31)" end="(363, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(363, 31)" end="(363, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(363, 32)" end="(363, 33)">
                <IdentNode start="(363, 32)" end="(363, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(363, 34)" end="(363, 42)">
                <AtomNode start="(363, 34)" end="(363, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(363, 36)" end="(363, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(363, 36)" end="(363, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(363, 41)" end="(363, 42)">
                    <IdentNode start="(363, 41)" end="(363, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(363, 42)" end="(363, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(363, 44)" end="(363, 60)">
            <AtomNode start="(363, 44)" end="(363, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(363, 46)" end="(363, 60)" kind="List.«term_&amp;lt;+_»">
              <OtherNode start="(363, 46)" end="(363, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(363, 46)" end="(363, 53)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(363, 54)" end="(363, 55)">
                  <IdentNode start="(363, 54)" end="(363, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(363, 56)" end="(363, 58)" leading="" trailing=" " val="&amp;lt;+"/>
              <IdentNode start="(363, 59)" end="(363, 60)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(363, 61)" end="(364, 43)">
          <AtomNode start="(363, 61)" end="(363, 63)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(364, 3)" end="(364, 43)" kind="Lean.Parser.Term.subst">
            <OtherNode start="(364, 3)" end="(364, 23)" kind="Lean.Parser.Term.app">
              <IdentNode start="(364, 3)" end="(364, 19)" leading="" trailing=" " raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(320, 9)" def_end="(320, 25)"/>
              <NullNode start="(364, 20)" end="(364, 23)">
                <IdentNode start="(364, 20)" end="(364, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(364, 22)" end="(364, 23)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
            </OtherNode>
            <AtomNode start="(364, 24)" end="(364, 25)" leading="" trailing=" " val="▸"/>
            <NullNode start="(364, 26)" end="(364, 43)">
              <OtherNode start="(364, 26)" end="(364, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(364, 26)" end="(364, 40)" leading="" trailing=" " raw_val="eraseP_sublist" val="eraseP_sublist" full_name="List.eraseP_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(104, 9)" def_end="(104, 23)"/>
                <NullNode start="(364, 41)" end="(364, 43)">
                  <OtherNode start="(364, 41)" end="(364, 43)" kind="Lean.Parser.Term.ellipsis">
                    <AtomNode start="(364, 41)" end="(364, 43)" leading="" trailing="&#10;&#10;" val=".."/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(366, 1)" end="(366, 82)" name="erase_subset" full_name="List.erase_subset">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(366, 1)" end="(366, 82)" name="erase_subset" full_name="List.erase_subset" _is_private_decl="False">
        <AtomNode start="(366, 1)" end="(366, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(366, 9)" end="(366, 21)">
          <IdentNode start="(366, 9)" end="(366, 21)" leading="" trailing=" " raw_val="erase_subset" val="erase_subset"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(366, 22)" end="(366, 58)">
          <NullNode start="(366, 22)" end="(366, 42)">
            <OtherNode start="(366, 22)" end="(366, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(366, 22)" end="(366, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(366, 23)" end="(366, 24)">
                <IdentNode start="(366, 23)" end="(366, 24)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(366, 25)" end="(366, 28)">
                <AtomNode start="(366, 25)" end="(366, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(366, 27)" end="(366, 28)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(366, 28)" end="(366, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(366, 30)" end="(366, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(366, 30)" end="(366, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(366, 31)" end="(366, 32)">
                <IdentNode start="(366, 31)" end="(366, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(366, 33)" end="(366, 41)">
                <AtomNode start="(366, 33)" end="(366, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(366, 35)" end="(366, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(366, 35)" end="(366, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(366, 40)" end="(366, 41)">
                    <IdentNode start="(366, 40)" end="(366, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(366, 41)" end="(366, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(366, 43)" end="(366, 58)">
            <AtomNode start="(366, 43)" end="(366, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(366, 45)" end="(366, 58)" kind="«term_⊆_»">
              <OtherNode start="(366, 45)" end="(366, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(366, 45)" end="(366, 52)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(366, 53)" end="(366, 54)">
                  <IdentNode start="(366, 53)" end="(366, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(366, 55)" end="(366, 56)" leading="" trailing=" " val="⊆"/>
              <IdentNode start="(366, 57)" end="(366, 58)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(366, 59)" end="(366, 82)">
          <AtomNode start="(366, 59)" end="(366, 61)" leading="" trailing=" " val=":="/>
          <IdentNode start="(366, 62)" end="(366, 82)" leading="" trailing="&#10;&#10;" raw_val="erase_sublist.subset" val="erase_sublist.subset"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(368, 1)" end="(369, 47)" name="Sublist.erase" full_name="List.Sublist.erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(368, 1)" end="(369, 47)" name="Sublist.erase" full_name="List.Sublist.erase" _is_private_decl="False">
        <AtomNode start="(368, 1)" end="(368, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(368, 9)" end="(368, 22)">
          <IdentNode start="(368, 9)" end="(368, 22)" leading="" trailing=" " raw_val="Sublist.erase" val="Sublist.erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(368, 23)" end="(368, 89)">
          <NullNode start="(368, 23)" end="(368, 62)">
            <TermExplicitbinderNode start="(368, 23)" end="(368, 30)">
              <AtomNode start="(368, 23)" end="(368, 24)" leading="" trailing="" val="("/>
              <NullNode start="(368, 24)" end="(368, 25)">
                <IdentNode start="(368, 24)" end="(368, 25)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(368, 26)" end="(368, 29)">
                <AtomNode start="(368, 26)" end="(368, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(368, 28)" end="(368, 29)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(368, 29)" end="(368, 30)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(368, 31)" end="(368, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(368, 31)" end="(368, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(368, 32)" end="(368, 37)">
                <IdentNode start="(368, 32)" end="(368, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(368, 35)" end="(368, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(368, 38)" end="(368, 46)">
                <AtomNode start="(368, 38)" end="(368, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 40)" end="(368, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(368, 40)" end="(368, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(368, 45)" end="(368, 46)">
                    <IdentNode start="(368, 45)" end="(368, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(368, 46)" end="(368, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(368, 48)" end="(368, 62)">
              <AtomNode start="(368, 48)" end="(368, 49)" leading="" trailing="" val="("/>
              <NullNode start="(368, 49)" end="(368, 50)">
                <IdentNode start="(368, 49)" end="(368, 50)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(368, 51)" end="(368, 61)">
                <AtomNode start="(368, 51)" end="(368, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(368, 53)" end="(368, 61)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(368, 53)" end="(368, 55)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(368, 56)" end="(368, 58)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(368, 59)" end="(368, 61)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(368, 61)" end="(368, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(368, 63)" end="(368, 89)">
            <AtomNode start="(368, 63)" end="(368, 64)" leading="" trailing=" " val=":"/>
            <OtherNode start="(368, 65)" end="(368, 89)" kind="List.«term_&amp;lt;+_»">
              <OtherNode start="(368, 65)" end="(368, 75)" kind="Lean.Parser.Term.app">
                <IdentNode start="(368, 65)" end="(368, 73)" leading="" trailing=" " raw_val="l₁.erase" val="l₁.erase"/>
                <NullNode start="(368, 74)" end="(368, 75)">
                  <IdentNode start="(368, 74)" end="(368, 75)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(368, 76)" end="(368, 78)" leading="" trailing=" " val="&amp;lt;+"/>
              <OtherNode start="(368, 79)" end="(368, 89)" kind="Lean.Parser.Term.app">
                <IdentNode start="(368, 79)" end="(368, 87)" leading="" trailing=" " raw_val="l₂.erase" val="l₂.erase"/>
                <NullNode start="(368, 88)" end="(368, 89)">
                  <IdentNode start="(368, 88)" end="(368, 89)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(368, 90)" end="(369, 47)">
          <AtomNode start="(368, 90)" end="(368, 92)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(368, 93)" end="(369, 47)">
            <AtomNode start="(368, 93)" end="(368, 95)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(369, 3)" end="(369, 47)">
              <TacticTacticseq1IndentedNode start="(369, 3)" end="(369, 47)">
                <NullNode start="(369, 3)" end="(369, 47)">
                  <OtherNode start="(369, 3)" end="(369, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ l₁.erase a &amp;lt;+ l₂.erase a" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ eraseP (fun x =&amp;gt; x == a) l₁ &amp;lt;+ eraseP (fun x =&amp;gt; x == a) l₂" tactic="simp only [erase_eq_eraseP']">
                    <AtomNode start="(369, 3)" end="(369, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(369, 8)" end="(369, 12)">
                      <AtomNode start="(369, 8)" end="(369, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(369, 13)" end="(369, 31)">
                      <AtomNode start="(369, 13)" end="(369, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(369, 14)" end="(369, 30)">
                        <OtherNode start="(369, 14)" end="(369, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(369, 14)" end="(369, 30)" leading="" trailing="" raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(320, 9)" def_end="(320, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(369, 30)" end="(369, 31)" leading="" trailing="" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(369, 31)" end="(369, 32)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(369, 33)" end="(369, 47)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ eraseP (fun x =&amp;gt; x == a) l₁ &amp;lt;+ eraseP (fun x =&amp;gt; x == a) l₂" state_after="no goals" tactic="exact h.eraseP">
                    <AtomNode start="(369, 33)" end="(369, 38)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(369, 39)" end="(369, 47)" leading="" trailing="&#10;&#10;" raw_val="h.eraseP" val="h.eraseP"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(371, 1)" end="(372, 47)" name="IsPrefix.erase" full_name="List.IsPrefix.erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(371, 1)" end="(372, 47)" name="IsPrefix.erase" full_name="List.IsPrefix.erase" _is_private_decl="False">
        <AtomNode start="(371, 1)" end="(371, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(371, 9)" end="(371, 23)">
          <IdentNode start="(371, 9)" end="(371, 23)" leading="" trailing=" " raw_val="IsPrefix.erase" val="IsPrefix.erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(371, 24)" end="(371, 92)">
          <NullNode start="(371, 24)" end="(371, 64)">
            <TermExplicitbinderNode start="(371, 24)" end="(371, 31)">
              <AtomNode start="(371, 24)" end="(371, 25)" leading="" trailing="" val="("/>
              <NullNode start="(371, 25)" end="(371, 26)">
                <IdentNode start="(371, 25)" end="(371, 26)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(371, 27)" end="(371, 30)">
                <AtomNode start="(371, 27)" end="(371, 28)" leading="" trailing=" " val=":"/>
                <IdentNode start="(371, 29)" end="(371, 30)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(371, 30)" end="(371, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(371, 32)" end="(371, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(371, 32)" end="(371, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(371, 33)" end="(371, 38)">
                <IdentNode start="(371, 33)" end="(371, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(371, 36)" end="(371, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(371, 39)" end="(371, 47)">
                <AtomNode start="(371, 39)" end="(371, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(371, 41)" end="(371, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(371, 41)" end="(371, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(371, 46)" end="(371, 47)">
                    <IdentNode start="(371, 46)" end="(371, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(371, 47)" end="(371, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(371, 49)" end="(371, 64)">
              <AtomNode start="(371, 49)" end="(371, 50)" leading="" trailing="" val="("/>
              <NullNode start="(371, 50)" end="(371, 51)">
                <IdentNode start="(371, 50)" end="(371, 51)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(371, 52)" end="(371, 63)">
                <AtomNode start="(371, 52)" end="(371, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(371, 54)" end="(371, 63)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(371, 54)" end="(371, 56)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(371, 57)" end="(371, 60)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(371, 61)" end="(371, 63)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(371, 63)" end="(371, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(371, 65)" end="(371, 92)">
            <AtomNode start="(371, 65)" end="(371, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(371, 67)" end="(371, 92)" kind="List.«term_&amp;lt;+:_»">
              <OtherNode start="(371, 67)" end="(371, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(371, 67)" end="(371, 75)" leading="" trailing=" " raw_val="l₁.erase" val="l₁.erase"/>
                <NullNode start="(371, 76)" end="(371, 77)">
                  <IdentNode start="(371, 76)" end="(371, 77)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(371, 78)" end="(371, 81)" leading="" trailing=" " val="&amp;lt;+:"/>
              <OtherNode start="(371, 82)" end="(371, 92)" kind="Lean.Parser.Term.app">
                <IdentNode start="(371, 82)" end="(371, 90)" leading="" trailing=" " raw_val="l₂.erase" val="l₂.erase"/>
                <NullNode start="(371, 91)" end="(371, 92)">
                  <IdentNode start="(371, 91)" end="(371, 92)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(371, 93)" end="(372, 47)">
          <AtomNode start="(371, 93)" end="(371, 95)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(371, 96)" end="(372, 47)">
            <AtomNode start="(371, 96)" end="(371, 98)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(372, 3)" end="(372, 47)">
              <TacticTacticseq1IndentedNode start="(372, 3)" end="(372, 47)">
                <NullNode start="(372, 3)" end="(372, 47)">
                  <OtherNode start="(372, 3)" end="(372, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ l₁.erase a &amp;lt;+: l₂.erase a" state_after="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ eraseP (fun x =&amp;gt; x == a) l₁ &amp;lt;+: eraseP (fun x =&amp;gt; x == a) l₂" tactic="simp only [erase_eq_eraseP']">
                    <AtomNode start="(372, 3)" end="(372, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(372, 8)" end="(372, 12)">
                      <AtomNode start="(372, 8)" end="(372, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(372, 13)" end="(372, 31)">
                      <AtomNode start="(372, 13)" end="(372, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(372, 14)" end="(372, 30)">
                        <OtherNode start="(372, 14)" end="(372, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(372, 14)" end="(372, 30)" leading="" trailing="" raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(320, 9)" def_end="(320, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(372, 30)" end="(372, 31)" leading="" trailing="" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(372, 31)" end="(372, 32)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(372, 33)" end="(372, 47)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ eraseP (fun x =&amp;gt; x == a) l₁ &amp;lt;+: eraseP (fun x =&amp;gt; x == a) l₂" state_after="no goals" tactic="exact h.eraseP">
                    <AtomNode start="(372, 33)" end="(372, 38)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(372, 39)" end="(372, 47)" leading="" trailing="&#10;&#10;" raw_val="h.eraseP" val="h.eraseP"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(374, 1)" end="(375, 26)" name="length_erase_le" full_name="List.length_erase_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(374, 1)" end="(375, 26)" name="length_erase_le" full_name="List.length_erase_le" _is_private_decl="False">
        <AtomNode start="(374, 1)" end="(374, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(374, 9)" end="(374, 24)">
          <IdentNode start="(374, 9)" end="(374, 24)" leading="" trailing=" " raw_val="length_erase_le" val="length_erase_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(374, 25)" end="(374, 77)">
          <NullNode start="(374, 25)" end="(374, 45)">
            <OtherNode start="(374, 25)" end="(374, 32)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(374, 25)" end="(374, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(374, 26)" end="(374, 27)">
                <IdentNode start="(374, 26)" end="(374, 27)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(374, 28)" end="(374, 31)">
                <AtomNode start="(374, 28)" end="(374, 29)" leading="" trailing=" " val=":"/>
                <IdentNode start="(374, 30)" end="(374, 31)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(374, 31)" end="(374, 32)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(374, 33)" end="(374, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(374, 33)" end="(374, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(374, 34)" end="(374, 35)">
                <IdentNode start="(374, 34)" end="(374, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(374, 36)" end="(374, 44)">
                <AtomNode start="(374, 36)" end="(374, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(374, 38)" end="(374, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(374, 38)" end="(374, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(374, 43)" end="(374, 44)">
                    <IdentNode start="(374, 43)" end="(374, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(374, 44)" end="(374, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(374, 46)" end="(374, 77)">
            <AtomNode start="(374, 46)" end="(374, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(374, 48)" end="(374, 77)" kind="«term_≤_»">
              <OtherNode start="(374, 48)" end="(374, 66)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(374, 48)" end="(374, 59)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(374, 48)" end="(374, 49)" leading="" trailing="" val="("/>
                  <OtherNode start="(374, 49)" end="(374, 58)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(374, 49)" end="(374, 56)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                    <NullNode start="(374, 57)" end="(374, 58)">
                      <IdentNode start="(374, 57)" end="(374, 58)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(374, 58)" end="(374, 59)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(374, 59)" end="(374, 60)" leading="" trailing="" val="."/>
                <IdentNode start="(374, 60)" end="(374, 66)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(374, 67)" end="(374, 68)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(374, 69)" end="(374, 77)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(374, 78)" end="(375, 26)">
          <AtomNode start="(374, 78)" end="(374, 80)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(375, 3)" end="(375, 26)" leading="" trailing="&#10;&#10;" raw_val="erase_sublist.length_le" val="erase_sublist.length_le"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(377, 1)" end="(379, 17)" name="le_length_erase" full_name="List.le_length_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(377, 1)" end="(379, 17)" name="le_length_erase" full_name="List.le_length_erase" _is_private_decl="False">
        <AtomNode start="(377, 1)" end="(377, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(377, 9)" end="(377, 24)">
          <IdentNode start="(377, 9)" end="(377, 24)" leading="" trailing=" " raw_val="le_length_erase" val="le_length_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(377, 25)" end="(377, 95)">
          <NullNode start="(377, 25)" end="(377, 59)">
            <OtherNode start="(377, 25)" end="(377, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(377, 25)" end="(377, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(377, 26)" end="(377, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(377, 26)" end="(377, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(377, 36)" end="(377, 37)">
                  <IdentNode start="(377, 36)" end="(377, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(377, 37)" end="(377, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(377, 39)" end="(377, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(377, 39)" end="(377, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(377, 40)" end="(377, 41)">
                <IdentNode start="(377, 40)" end="(377, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(377, 42)" end="(377, 45)">
                <AtomNode start="(377, 42)" end="(377, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(377, 44)" end="(377, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(377, 45)" end="(377, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(377, 47)" end="(377, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(377, 47)" end="(377, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(377, 48)" end="(377, 49)">
                <IdentNode start="(377, 48)" end="(377, 49)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(377, 50)" end="(377, 58)">
                <AtomNode start="(377, 50)" end="(377, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(377, 52)" end="(377, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(377, 52)" end="(377, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(377, 57)" end="(377, 58)">
                    <IdentNode start="(377, 57)" end="(377, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(377, 58)" end="(377, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(377, 60)" end="(377, 95)">
            <AtomNode start="(377, 60)" end="(377, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(377, 62)" end="(377, 95)" kind="«term_≤_»">
              <OtherNode start="(377, 62)" end="(377, 74)" kind="«term_-_»">
                <IdentNode start="(377, 62)" end="(377, 70)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                <AtomNode start="(377, 71)" end="(377, 72)" leading="" trailing=" " val="-"/>
                <OtherNode start="(377, 73)" end="(377, 74)" kind="num">
                  <AtomNode start="(377, 73)" end="(377, 74)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(377, 75)" end="(377, 76)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(377, 77)" end="(377, 95)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(377, 77)" end="(377, 88)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(377, 77)" end="(377, 78)" leading="" trailing="" val="("/>
                  <OtherNode start="(377, 78)" end="(377, 87)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(377, 78)" end="(377, 85)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                    <NullNode start="(377, 86)" end="(377, 87)">
                      <IdentNode start="(377, 86)" end="(377, 87)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(377, 87)" end="(377, 88)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(377, 88)" end="(377, 89)" leading="" trailing="" val="."/>
                <IdentNode start="(377, 89)" end="(377, 95)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(377, 96)" end="(379, 17)">
          <AtomNode start="(377, 96)" end="(377, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(377, 99)" end="(379, 17)">
            <AtomNode start="(377, 99)" end="(377, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(378, 3)" end="(379, 17)">
              <TacticTacticseq1IndentedNode start="(378, 3)" end="(379, 17)">
                <NullNode start="(378, 3)" end="(379, 17)">
                  <OtherNode start="(378, 3)" end="(378, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ l.length - 1 ≤ (l.erase a).length" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ l.length - 1 ≤ if a ∈ l then l.length - 1 else l.length" tactic="rw [length_erase]">
                    <AtomNode start="(378, 3)" end="(378, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(378, 6)" end="(378, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(378, 6)" end="(378, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(378, 7)" end="(378, 19)">
                        <OtherNode start="(378, 7)" end="(378, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(378, 7)" end="(378, 19)" leading="" trailing="" raw_val="length_erase" val="length_erase" full_name="List.length_erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(358, 9)" def_end="(358, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(378, 19)" end="(378, 20)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(379, 3)" end="(379, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ l.length - 1 ≤ if a ∈ l then l.length - 1 else l.length" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(379, 3)" end="(379, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(379, 3)" end="(379, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(379, 9)" end="(379, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(379, 13)" end="(379, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(379, 13)" end="(379, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(381, 1)" end="(381, 94)" name="mem_of_mem_erase" full_name="List.mem_of_mem_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(381, 1)" end="(381, 94)" name="mem_of_mem_erase" full_name="List.mem_of_mem_erase" _is_private_decl="False">
        <AtomNode start="(381, 1)" end="(381, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(381, 9)" end="(381, 25)">
          <IdentNode start="(381, 9)" end="(381, 25)" leading="" trailing=" " raw_val="mem_of_mem_erase" val="mem_of_mem_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(381, 26)" end="(381, 76)">
          <NullNode start="(381, 26)" end="(381, 68)">
            <OtherNode start="(381, 26)" end="(381, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(381, 26)" end="(381, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(381, 27)" end="(381, 30)">
                <IdentNode start="(381, 27)" end="(381, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(381, 29)" end="(381, 30)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(381, 31)" end="(381, 34)">
                <AtomNode start="(381, 31)" end="(381, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(381, 33)" end="(381, 34)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(381, 34)" end="(381, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(381, 36)" end="(381, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(381, 36)" end="(381, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(381, 37)" end="(381, 38)">
                <IdentNode start="(381, 37)" end="(381, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(381, 39)" end="(381, 47)">
                <AtomNode start="(381, 39)" end="(381, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(381, 41)" end="(381, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(381, 41)" end="(381, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(381, 46)" end="(381, 47)">
                    <IdentNode start="(381, 46)" end="(381, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(381, 47)" end="(381, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(381, 49)" end="(381, 68)">
              <AtomNode start="(381, 49)" end="(381, 50)" leading="" trailing="" val="("/>
              <NullNode start="(381, 50)" end="(381, 51)">
                <IdentNode start="(381, 50)" end="(381, 51)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(381, 52)" end="(381, 67)">
                <AtomNode start="(381, 52)" end="(381, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(381, 54)" end="(381, 67)" kind="«term_∈_»">
                  <IdentNode start="(381, 54)" end="(381, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(381, 56)" end="(381, 57)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(381, 58)" end="(381, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(381, 58)" end="(381, 65)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                    <NullNode start="(381, 66)" end="(381, 67)">
                      <IdentNode start="(381, 66)" end="(381, 67)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(381, 67)" end="(381, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(381, 69)" end="(381, 76)">
            <AtomNode start="(381, 69)" end="(381, 70)" leading="" trailing=" " val=":"/>
            <OtherNode start="(381, 71)" end="(381, 76)" kind="«term_∈_»">
              <IdentNode start="(381, 71)" end="(381, 72)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(381, 73)" end="(381, 74)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(381, 75)" end="(381, 76)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(381, 77)" end="(381, 94)">
          <AtomNode start="(381, 77)" end="(381, 79)" leading="" trailing=" " val=":="/>
          <OtherNode start="(381, 80)" end="(381, 94)" kind="Lean.Parser.Term.app">
            <IdentNode start="(381, 80)" end="(381, 92)" leading="" trailing=" " raw_val="erase_subset" val="erase_subset" full_name="List.erase_subset" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(366, 9)" def_end="(366, 21)"/>
            <NullNode start="(381, 93)" end="(381, 94)">
              <IdentNode start="(381, 93)" end="(381, 94)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(383, 1)" end="(385, 65)" name="mem_erase_of_ne" full_name="List.mem_erase_of_ne">
      <CommandDeclmodifiersNode start="(383, 1)" end="(383, 8)">
        <NullNode/>
        <NullNode start="(383, 1)" end="(383, 8)">
          <OtherNode start="(383, 1)" end="(383, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(383, 1)" end="(383, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(383, 3)" end="(383, 7)">
              <OtherNode start="(383, 3)" end="(383, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(383, 3)" end="(383, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(383, 3)" end="(383, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(383, 7)" end="(383, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(383, 9)" end="(385, 65)" name="mem_erase_of_ne" full_name="List.mem_erase_of_ne" _is_private_decl="False">
        <AtomNode start="(383, 9)" end="(383, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(383, 17)" end="(383, 32)">
          <IdentNode start="(383, 17)" end="(383, 32)" leading="" trailing=" " raw_val="mem_erase_of_ne" val="mem_erase_of_ne"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(383, 33)" end="(384, 26)">
          <NullNode start="(383, 33)" end="(383, 82)">
            <OtherNode start="(383, 33)" end="(383, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(383, 33)" end="(383, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(383, 34)" end="(383, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(383, 34)" end="(383, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(383, 44)" end="(383, 45)">
                  <IdentNode start="(383, 44)" end="(383, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(383, 45)" end="(383, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(383, 47)" end="(383, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(383, 47)" end="(383, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(383, 48)" end="(383, 51)">
                <IdentNode start="(383, 48)" end="(383, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(383, 50)" end="(383, 51)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(383, 52)" end="(383, 55)">
                <AtomNode start="(383, 52)" end="(383, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(383, 54)" end="(383, 55)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(383, 55)" end="(383, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(383, 57)" end="(383, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(383, 57)" end="(383, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(383, 58)" end="(383, 59)">
                <IdentNode start="(383, 58)" end="(383, 59)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(383, 60)" end="(383, 68)">
                <AtomNode start="(383, 60)" end="(383, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(383, 62)" end="(383, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(383, 62)" end="(383, 66)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(383, 67)" end="(383, 68)">
                    <IdentNode start="(383, 67)" end="(383, 68)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(383, 68)" end="(383, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(383, 70)" end="(383, 82)">
              <AtomNode start="(383, 70)" end="(383, 71)" leading="" trailing="" val="("/>
              <NullNode start="(383, 71)" end="(383, 73)">
                <IdentNode start="(383, 71)" end="(383, 73)" leading="" trailing=" " raw_val="ab" val="ab"/>
              </NullNode>
              <NullNode start="(383, 74)" end="(383, 81)">
                <AtomNode start="(383, 74)" end="(383, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(383, 76)" end="(383, 81)" kind="«term_≠_»">
                  <IdentNode start="(383, 76)" end="(383, 77)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(383, 78)" end="(383, 79)" leading="" trailing=" " val="≠"/>
                  <IdentNode start="(383, 80)" end="(383, 81)" leading="" trailing="" raw_val="b" val="b"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(383, 81)" end="(383, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(383, 83)" end="(384, 26)">
            <AtomNode start="(383, 83)" end="(383, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(384, 5)" end="(384, 26)" kind="«term_↔_»">
              <OtherNode start="(384, 5)" end="(384, 18)" kind="«term_∈_»">
                <IdentNode start="(384, 5)" end="(384, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(384, 7)" end="(384, 8)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(384, 9)" end="(384, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(384, 9)" end="(384, 16)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                  <NullNode start="(384, 17)" end="(384, 18)">
                    <IdentNode start="(384, 17)" end="(384, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(384, 19)" end="(384, 20)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(384, 21)" end="(384, 26)" kind="«term_∈_»">
                <IdentNode start="(384, 21)" end="(384, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(384, 23)" end="(384, 24)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(384, 25)" end="(384, 26)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(384, 27)" end="(385, 65)">
          <AtomNode start="(384, 27)" end="(384, 29)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(385, 3)" end="(385, 65)" kind="Lean.Parser.Term.subst">
            <OtherNode start="(385, 3)" end="(385, 22)" kind="Lean.Parser.Term.app">
              <IdentNode start="(385, 3)" end="(385, 18)" leading="" trailing=" " raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
              <NullNode start="(385, 19)" end="(385, 22)">
                <IdentNode start="(385, 19)" end="(385, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(385, 21)" end="(385, 22)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
            </OtherNode>
            <AtomNode start="(385, 23)" end="(385, 24)" leading="" trailing=" " val="▸"/>
            <NullNode start="(385, 25)" end="(385, 65)">
              <OtherNode start="(385, 25)" end="(385, 65)" kind="Lean.Parser.Term.app">
                <IdentNode start="(385, 25)" end="(385, 42)" leading="" trailing=" " raw_val="mem_eraseP_of_neg" val="mem_eraseP_of_neg" full_name="List.mem_eraseP_of_neg" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(131, 17)" def_end="(131, 34)"/>
                <NullNode start="(385, 43)" end="(385, 65)">
                  <OtherNode start="(385, 43)" end="(385, 65)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(385, 43)" end="(385, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(385, 44)" end="(385, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(385, 44)" end="(385, 46)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(385, 47)" end="(385, 64)">
                        <IdentNode start="(385, 47)" end="(385, 56)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        <IdentNode start="(385, 57)" end="(385, 64)" leading="" trailing="" raw_val="ab.symm" val="ab.symm"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(385, 64)" end="(385, 65)" leading="" trailing="&#10;&#10;" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(387, 1)" end="(389, 24)" name="erase_eq_self_iff" full_name="List.erase_eq_self_iff">
      <CommandDeclmodifiersNode start="(387, 1)" end="(387, 8)">
        <NullNode/>
        <NullNode start="(387, 1)" end="(387, 8)">
          <OtherNode start="(387, 1)" end="(387, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(387, 1)" end="(387, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(387, 3)" end="(387, 7)">
              <OtherNode start="(387, 3)" end="(387, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(387, 3)" end="(387, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(387, 3)" end="(387, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(387, 7)" end="(387, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(387, 9)" end="(389, 24)" name="erase_eq_self_iff" full_name="List.erase_eq_self_iff" _is_private_decl="False">
        <AtomNode start="(387, 9)" end="(387, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(387, 17)" end="(387, 34)">
          <IdentNode start="(387, 17)" end="(387, 34)" leading="" trailing=" " raw_val="erase_eq_self_iff" val="erase_eq_self_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(387, 35)" end="(387, 85)">
          <NullNode start="(387, 35)" end="(387, 61)">
            <OtherNode start="(387, 35)" end="(387, 48)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(387, 35)" end="(387, 36)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(387, 36)" end="(387, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(387, 36)" end="(387, 45)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(387, 46)" end="(387, 47)">
                  <IdentNode start="(387, 46)" end="(387, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(387, 47)" end="(387, 48)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(387, 49)" end="(387, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(387, 49)" end="(387, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(387, 50)" end="(387, 51)">
                <IdentNode start="(387, 50)" end="(387, 51)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(387, 52)" end="(387, 60)">
                <AtomNode start="(387, 52)" end="(387, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(387, 54)" end="(387, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(387, 54)" end="(387, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(387, 59)" end="(387, 60)">
                    <IdentNode start="(387, 59)" end="(387, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(387, 60)" end="(387, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(387, 62)" end="(387, 85)">
            <AtomNode start="(387, 62)" end="(387, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(387, 64)" end="(387, 85)" kind="«term_↔_»">
              <OtherNode start="(387, 64)" end="(387, 77)" kind="«term_=_»">
                <OtherNode start="(387, 64)" end="(387, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(387, 64)" end="(387, 71)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                  <NullNode start="(387, 72)" end="(387, 73)">
                    <IdentNode start="(387, 72)" end="(387, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(387, 74)" end="(387, 75)" leading="" trailing=" " val="="/>
                <IdentNode start="(387, 76)" end="(387, 77)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
              <AtomNode start="(387, 78)" end="(387, 79)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(387, 80)" end="(387, 85)" kind="«term_∉_»">
                <IdentNode start="(387, 80)" end="(387, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(387, 82)" end="(387, 83)" leading="" trailing=" " val="∉"/>
                <IdentNode start="(387, 84)" end="(387, 85)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(387, 86)" end="(389, 24)">
          <AtomNode start="(387, 86)" end="(387, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(387, 89)" end="(389, 24)">
            <AtomNode start="(387, 89)" end="(387, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(388, 3)" end="(389, 24)">
              <TacticTacticseq1IndentedNode start="(388, 3)" end="(389, 24)">
                <NullNode start="(388, 3)" end="(389, 24)">
                  <OtherNode start="(388, 3)" end="(388, 44)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;⊢ l.erase a = l ↔ ¬a ∈ l" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l → ¬(a_1 == a) = true) ↔ ¬a ∈ l" tactic="rw [erase_eq_eraseP', eraseP_eq_self_iff]">
                    <AtomNode start="(388, 3)" end="(388, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(388, 6)" end="(388, 44)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(388, 6)" end="(388, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(388, 7)" end="(388, 43)">
                        <OtherNode start="(388, 7)" end="(388, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(388, 7)" end="(388, 23)" leading="" trailing="" raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(320, 9)" def_end="(320, 25)"/>
                        </OtherNode>
                        <AtomNode start="(388, 23)" end="(388, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(388, 25)" end="(388, 43)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(388, 25)" end="(388, 43)" leading="" trailing="" raw_val="eraseP_eq_self_iff" val="eraseP_eq_self_iff" full_name="List.eraseP_eq_self_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(140, 17)" def_end="(140, 35)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(388, 43)" end="(388, 44)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(389, 3)" end="(389, 24)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;⊢ (∀ (a_1 : α), a_1 ∈ l → ¬(a_1 == a) = true) ↔ ¬a ∈ l" state_after="no goals" tactic="simp [forall_mem_ne']">
                    <AtomNode start="(389, 3)" end="(389, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(389, 8)" end="(389, 24)">
                      <AtomNode start="(389, 8)" end="(389, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(389, 9)" end="(389, 23)">
                        <OtherNode start="(389, 9)" end="(389, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(389, 9)" end="(389, 23)" leading="" trailing="" raw_val="forall_mem_ne'" val="forall_mem_ne'" full_name="List.forall_mem_ne'" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(389, 23)" end="(389, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(391, 1)" end="(407, 16)" name="erase_filter" full_name="List.erase_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(391, 1)" end="(407, 16)" name="erase_filter" full_name="List.erase_filter" _is_private_decl="False">
        <AtomNode start="(391, 1)" end="(391, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(391, 9)" end="(391, 21)">
          <IdentNode start="(391, 9)" end="(391, 21)" leading="" trailing=" " raw_val="erase_filter" val="erase_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(391, 22)" end="(392, 48)">
          <NullNode start="(391, 22)" end="(391, 63)">
            <OtherNode start="(391, 22)" end="(391, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(391, 22)" end="(391, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(391, 23)" end="(391, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(391, 23)" end="(391, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(391, 33)" end="(391, 34)">
                  <IdentNode start="(391, 33)" end="(391, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(391, 34)" end="(391, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(391, 36)" end="(391, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 36)" end="(391, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 37)" end="(391, 38)">
                <IdentNode start="(391, 37)" end="(391, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(391, 39)" end="(391, 49)">
                <AtomNode start="(391, 39)" end="(391, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(391, 41)" end="(391, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(391, 41)" end="(391, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(391, 43)" end="(391, 44)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(391, 45)" end="(391, 49)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(391, 49)" end="(391, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(391, 51)" end="(391, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 51)" end="(391, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 52)" end="(391, 53)">
                <IdentNode start="(391, 52)" end="(391, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(391, 54)" end="(391, 62)">
                <AtomNode start="(391, 54)" end="(391, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(391, 56)" end="(391, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(391, 56)" end="(391, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(391, 61)" end="(391, 62)">
                    <IdentNode start="(391, 61)" end="(391, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(391, 62)" end="(391, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(391, 64)" end="(392, 48)">
            <AtomNode start="(391, 64)" end="(391, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(392, 5)" end="(392, 48)" kind="«term_=_»">
              <OtherNode start="(392, 5)" end="(392, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(392, 5)" end="(392, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(392, 5)" end="(392, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(392, 5)" end="(392, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(392, 6)" end="(392, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(392, 6)" end="(392, 12)" leading="" trailing=" " raw_val="filter" val="filter" full_name="List.filter" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(392, 13)" end="(392, 16)">
                        <IdentNode start="(392, 13)" end="(392, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(392, 15)" end="(392, 16)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(392, 16)" end="(392, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(392, 17)" end="(392, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(392, 18)" end="(392, 23)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(392, 24)" end="(392, 25)">
                  <IdentNode start="(392, 24)" end="(392, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(392, 26)" end="(392, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(392, 28)" end="(392, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(392, 28)" end="(392, 34)" leading="" trailing=" " raw_val="filter" val="filter" full_name="List.filter" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(392, 35)" end="(392, 48)">
                  <IdentNode start="(392, 35)" end="(392, 36)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(392, 37)" end="(392, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(392, 37)" end="(392, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(392, 38)" end="(392, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(392, 38)" end="(392, 45)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(392, 46)" end="(392, 47)">
                        <IdentNode start="(392, 46)" end="(392, 47)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(392, 47)" end="(392, 48)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(392, 49)" end="(407, 16)">
          <AtomNode start="(392, 49)" end="(392, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(392, 52)" end="(407, 16)">
            <AtomNode start="(392, 52)" end="(392, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(393, 3)" end="(407, 16)">
              <TacticTacticseq1IndentedNode start="(393, 3)" end="(407, 16)">
                <NullNode start="(393, 3)" end="(407, 16)">
                  <OtherNode start="(393, 3)" end="(407, 16)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;l : List α&#10;⊢ (filter f l).erase a = filter f (l.erase a)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; rfl&#10;| cons x xs ih =&amp;gt;&#10;  by_cases h : a = x&#10;  · rw [erase_cons]&#10;    simp only [h, beq_self_eq_true, ↓reduceIte]&#10;    rw [filter_cons]&#10;    split&#10;    · rw [erase_cons_head]&#10;    · rw [erase_of_not_mem]&#10;      simp_all [mem_filter]&#10;  · rw [erase_cons_tail (by simpa using Ne.symm h), filter_cons, filter_cons]&#10;    split&#10;    · rw [erase_cons_tail (by simpa using Ne.symm h), ih]&#10;    · rw [ih]">
                    <AtomNode start="(393, 3)" end="(393, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(393, 13)" end="(393, 14)">
                      <OtherNode start="(393, 13)" end="(393, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(393, 13)" end="(393, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(393, 15)" end="(407, 16)">
                      <OtherNode start="(393, 15)" end="(407, 16)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(393, 15)" end="(393, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(394, 3)" end="(407, 16)">
                          <OtherNode start="(394, 3)" end="(394, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(394, 3)" end="(394, 8)">
                              <OtherNode start="(394, 3)" end="(394, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(394, 3)" end="(394, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(394, 5)" end="(394, 8)">
                                  <NullNode/>
                                  <IdentNode start="(394, 5)" end="(394, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(394, 9)" end="(394, 15)">
                              <AtomNode start="(394, 9)" end="(394, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(394, 12)" end="(394, 15)">
                                <TacticTacticseq1IndentedNode start="(394, 12)" end="(394, 15)">
                                  <NullNode start="(394, 12)" end="(394, 15)">
                                    <OtherNode start="(394, 12)" end="(394, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;⊢ (filter f []).erase a = filter f ([].erase a)" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(394, 12)" end="(394, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(395, 3)" end="(407, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(395, 3)" end="(395, 17)">
                              <OtherNode start="(395, 3)" end="(395, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(395, 3)" end="(395, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(395, 5)" end="(395, 9)">
                                  <NullNode/>
                                  <IdentNode start="(395, 5)" end="(395, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(395, 10)" end="(395, 17)">
                                  <IdentNode start="(395, 10)" end="(395, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(395, 12)" end="(395, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(395, 15)" end="(395, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(395, 18)" end="(407, 16)">
                              <AtomNode start="(395, 18)" end="(395, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(396, 5)" end="(407, 16)">
                                <TacticTacticseq1IndentedNode start="(396, 5)" end="(407, 16)">
                                  <NullNode start="(396, 5)" end="(407, 16)">
                                    <OtherNode start="(396, 5)" end="(396, 23)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" tactic="by_cases h : a = x">
                                      <AtomNode start="(396, 5)" end="(396, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(396, 14)" end="(396, 17)">
                                        <IdentNode start="(396, 14)" end="(396, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <AtomNode start="(396, 16)" end="(396, 17)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(396, 18)" end="(396, 23)" kind="«term_=_»">
                                        <IdentNode start="(396, 18)" end="(396, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <AtomNode start="(396, 20)" end="(396, 21)" leading="" trailing=" " val="="/>
                                        <IdentNode start="(396, 22)" end="(396, 23)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(397, 5)" end="(403, 30)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" tactic="· rw [erase_cons]&#10;  simp only [h, beq_self_eq_true, ↓reduceIte]&#10;  rw [filter_cons]&#10;  split&#10;  · rw [erase_cons_head]&#10;  · rw [erase_of_not_mem]&#10;    simp_all [mem_filter]">
                                      <OtherNode start="(397, 5)" end="(397, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(397, 5)" end="(397, 6)" kind="patternIgnore">
                                          <OtherNode start="(397, 5)" end="(397, 6)" kind="token.«· »">
                                            <AtomNode start="(397, 5)" end="(397, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(397, 7)" end="(403, 30)">
                                        <TacticTacticseq1IndentedNode start="(397, 7)" end="(403, 30)">
                                          <NullNode start="(397, 7)" end="(403, 30)">
                                            <OtherNode start="(397, 7)" end="(397, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f (if (x == a) = true then xs else x :: xs.erase a)" tactic="rw [erase_cons]">
                                              <AtomNode start="(397, 7)" end="(397, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(397, 10)" end="(397, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(397, 10)" end="(397, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(397, 11)" end="(397, 21)">
                                                  <OtherNode start="(397, 11)" end="(397, 21)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(397, 11)" end="(397, 21)" leading="" trailing="" raw_val="erase_cons" val="erase_cons" full_name="List.erase_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(397, 21)" end="(397, 22)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(398, 7)" end="(398, 50)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f (if (x == a) = true then xs else x :: xs.erase a)" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase x = filter f xs" tactic="simp only [h, beq_self_eq_true, ↓reduceIte]">
                                              <AtomNode start="(398, 7)" end="(398, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(398, 12)" end="(398, 16)">
                                                <AtomNode start="(398, 12)" end="(398, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(398, 17)" end="(398, 50)">
                                                <AtomNode start="(398, 17)" end="(398, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(398, 18)" end="(398, 49)">
                                                  <OtherNode start="(398, 18)" end="(398, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(398, 18)" end="(398, 19)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                  <AtomNode start="(398, 19)" end="(398, 20)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(398, 21)" end="(398, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(398, 21)" end="(398, 37)" leading="" trailing="" raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(398, 37)" end="(398, 38)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(398, 39)" end="(398, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode start="(398, 39)" end="(398, 40)">
                                                      <OtherNode start="(398, 39)" end="(398, 40)" kind="Lean.Parser.Tactic.simpPre">
                                                        <AtomNode start="(398, 39)" end="(398, 40)" leading="" trailing="" val="↓"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <IdentNode start="(398, 40)" end="(398, 49)" leading="" trailing="" raw_val="reduceIte" val="reduceIte"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(398, 49)" end="(398, 50)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(399, 7)" end="(399, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (filter f (x :: xs)).erase x = filter f xs" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (if f x = true then x :: filter f xs else filter f xs).erase x = filter f xs" tactic="rw [filter_cons]">
                                              <AtomNode start="(399, 7)" end="(399, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(399, 10)" end="(399, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(399, 10)" end="(399, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(399, 11)" end="(399, 22)">
                                                  <OtherNode start="(399, 11)" end="(399, 22)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(399, 11)" end="(399, 22)" leading="" trailing="" raw_val="filter_cons" val="filter_cons" full_name="List.filter_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(399, 22)" end="(399, 23)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(400, 7)" end="(400, 12)" kind="Lean.Parser.Tactic.split" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;⊢ (if f x = true then x :: filter f xs else filter f xs).erase x = filter f xs" state_after="case pos.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : f x = true&#10;⊢ (x :: filter f xs).erase x = filter f xs&#10;&#10;case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase x = filter f xs" tactic="split">
                                              <AtomNode start="(400, 7)" end="(400, 12)" leading="" trailing="&#10;      " val="split"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(401, 7)" end="(401, 29)" kind="Lean.cdot" state_before="case pos.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : f x = true&#10;⊢ (x :: filter f xs).erase x = filter f xs&#10;&#10;case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase x = filter f xs" state_after="case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase x = filter f xs" tactic="· rw [erase_cons_head]">
                                              <OtherNode start="(401, 7)" end="(401, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(401, 7)" end="(401, 8)" kind="patternIgnore">
                                                  <OtherNode start="(401, 7)" end="(401, 8)" kind="token.«· »">
                                                    <AtomNode start="(401, 7)" end="(401, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(401, 9)" end="(401, 29)">
                                                <TacticTacticseq1IndentedNode start="(401, 9)" end="(401, 29)">
                                                  <NullNode start="(401, 9)" end="(401, 29)">
                                                    <OtherNode start="(401, 9)" end="(401, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : f x = true&#10;⊢ (x :: filter f xs).erase x = filter f xs" state_after="no goals" tactic="rw [erase_cons_head]">
                                                      <AtomNode start="(401, 9)" end="(401, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(401, 12)" end="(401, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(401, 12)" end="(401, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(401, 13)" end="(401, 28)">
                                                          <OtherNode start="(401, 13)" end="(401, 28)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(401, 13)" end="(401, 28)" leading="" trailing="" raw_val="erase_cons_head" val="erase_cons_head" full_name="List.erase_cons_head" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(307, 17)" def_end="(307, 32)"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(401, 28)" end="(401, 29)" leading="" trailing="&#10;      " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(402, 7)" end="(403, 30)" kind="Lean.cdot" state_before="case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase x = filter f xs" state_after="no goals" tactic="· rw [erase_of_not_mem]&#10;  simp_all [mem_filter]">
                                              <OtherNode start="(402, 7)" end="(402, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(402, 7)" end="(402, 8)" kind="patternIgnore">
                                                  <OtherNode start="(402, 7)" end="(402, 8)" kind="token.«· »">
                                                    <AtomNode start="(402, 7)" end="(402, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(402, 9)" end="(403, 30)">
                                                <TacticTacticseq1IndentedNode start="(402, 9)" end="(403, 30)">
                                                  <NullNode start="(402, 9)" end="(403, 30)">
                                                    <OtherNode start="(402, 9)" end="(402, 30)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase x = filter f xs" state_after="case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ ¬x ∈ filter f xs" tactic="rw [erase_of_not_mem]">
                                                      <AtomNode start="(402, 9)" end="(402, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(402, 12)" end="(402, 30)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(402, 12)" end="(402, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(402, 13)" end="(402, 29)">
                                                          <OtherNode start="(402, 13)" end="(402, 29)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(402, 13)" end="(402, 29)" leading="" trailing="" raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(313, 9)" def_end="(313, 25)"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(402, 29)" end="(402, 30)" leading="" trailing="&#10;        " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(403, 9)" end="(403, 30)" kind="Lean.Parser.Tactic.simpAll" state_before="case pos.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : a = x&#10;h✝ : ¬f x = true&#10;⊢ ¬x ∈ filter f xs" state_after="no goals" tactic="simp_all [mem_filter]">
                                                      <AtomNode start="(403, 9)" end="(403, 17)" leading="" trailing=" " val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(403, 18)" end="(403, 30)">
                                                        <AtomNode start="(403, 18)" end="(403, 19)" leading="" trailing="" val="["/>
                                                        <NullNode start="(403, 19)" end="(403, 29)">
                                                          <OtherNode start="(403, 19)" end="(403, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(403, 19)" end="(403, 29)" leading="" trailing="" raw_val="mem_filter" val="mem_filter" full_name="List.mem_filter" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(403, 29)" end="(403, 30)" leading="" trailing="&#10;    " val="]"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(404, 5)" end="(407, 16)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" state_after="no goals" tactic="· rw [erase_cons_tail (by simpa using Ne.symm h), filter_cons, filter_cons]&#10;  split&#10;  · rw [erase_cons_tail (by simpa using Ne.symm h), ih]&#10;  · rw [ih]">
                                      <OtherNode start="(404, 5)" end="(404, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(404, 5)" end="(404, 6)" kind="patternIgnore">
                                          <OtherNode start="(404, 5)" end="(404, 6)" kind="token.«· »">
                                            <AtomNode start="(404, 5)" end="(404, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(404, 7)" end="(407, 16)">
                                        <TacticTacticseq1IndentedNode start="(404, 7)" end="(407, 16)">
                                          <NullNode start="(404, 7)" end="(407, 16)">
                                            <OtherNode start="(404, 7)" end="(404, 80)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (filter f (x :: xs)).erase a = filter f ((x :: xs).erase a)" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (if f x = true then x :: filter f xs else filter f xs).erase a =&#10;    if f x = true then x :: filter f (xs.erase a) else filter f (xs.erase a)" tactic="rw [erase_cons_tail (by simpa using Ne.symm h), filter_cons, filter_cons]">
                                              <AtomNode start="(404, 7)" end="(404, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(404, 10)" end="(404, 80)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(404, 10)" end="(404, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(404, 11)" end="(404, 79)">
                                                  <OtherNode start="(404, 11)" end="(404, 53)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(404, 11)" end="(404, 53)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(404, 11)" end="(404, 26)" leading="" trailing=" " raw_val="erase_cons_tail" val="erase_cons_tail" full_name="List.erase_cons_tail" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(310, 17)" def_end="(310, 32)"/>
                                                      <NullNode start="(404, 27)" end="(404, 53)">
                                                        <OtherNode start="(404, 27)" end="(404, 53)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(404, 27)" end="(404, 28)" leading="" trailing="" val="("/>
                                                          <TermBytacticNode start="(404, 28)" end="(404, 52)">
                                                            <AtomNode start="(404, 28)" end="(404, 30)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(404, 31)" end="(404, 52)">
                                                            <TacticTacticseq1IndentedNode start="(404, 31)" end="(404, 52)">
                                                            <NullNode start="(404, 31)" end="(404, 52)">
                                                            <OtherNode start="(404, 31)" end="(404, 52)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ ¬(x == a) = true" state_after="no goals" tactic="simpa using Ne.symm h">
                                                            <AtomNode start="(404, 31)" end="(404, 36)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(404, 37)" end="(404, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(404, 37)" end="(404, 52)">
                                                            <AtomNode start="(404, 37)" end="(404, 42)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(404, 43)" end="(404, 52)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(404, 43)" end="(404, 50)" leading="" trailing=" " raw_val="Ne.symm" val="Ne.symm" full_name="Ne.symm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(404, 51)" end="(404, 52)">
                                                            <IdentNode start="(404, 51)" end="(404, 52)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(404, 52)" end="(404, 53)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(404, 53)" end="(404, 54)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(404, 55)" end="(404, 66)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(404, 55)" end="(404, 66)" leading="" trailing="" raw_val="filter_cons" val="filter_cons" full_name="List.filter_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(404, 66)" end="(404, 67)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(404, 68)" end="(404, 79)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(404, 68)" end="(404, 79)" leading="" trailing="" raw_val="filter_cons" val="filter_cons" full_name="List.filter_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(404, 79)" end="(404, 80)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(405, 7)" end="(405, 12)" kind="Lean.Parser.Tactic.split" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;⊢ (if f x = true then x :: filter f xs else filter f xs).erase a =&#10;    if f x = true then x :: filter f (xs.erase a) else filter f (xs.erase a)" state_after="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : f x = true&#10;⊢ (x :: filter f xs).erase a = x :: filter f (xs.erase a)&#10;&#10;case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase a = filter f (xs.erase a)" tactic="split">
                                              <AtomNode start="(405, 7)" end="(405, 12)" leading="" trailing="&#10;      " val="split"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(406, 7)" end="(406, 60)" kind="Lean.cdot" state_before="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : f x = true&#10;⊢ (x :: filter f xs).erase a = x :: filter f (xs.erase a)&#10;&#10;case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase a = filter f (xs.erase a)" state_after="case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase a = filter f (xs.erase a)" tactic="· rw [erase_cons_tail (by simpa using Ne.symm h), ih]">
                                              <OtherNode start="(406, 7)" end="(406, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(406, 7)" end="(406, 8)" kind="patternIgnore">
                                                  <OtherNode start="(406, 7)" end="(406, 8)" kind="token.«· »">
                                                    <AtomNode start="(406, 7)" end="(406, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(406, 9)" end="(406, 60)">
                                                <TacticTacticseq1IndentedNode start="(406, 9)" end="(406, 60)">
                                                  <NullNode start="(406, 9)" end="(406, 60)">
                                                    <OtherNode start="(406, 9)" end="(406, 60)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg.isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : f x = true&#10;⊢ (x :: filter f xs).erase a = x :: filter f (xs.erase a)" state_after="no goals" tactic="rw [erase_cons_tail (by simpa using Ne.symm h), ih]">
                                                      <AtomNode start="(406, 9)" end="(406, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(406, 12)" end="(406, 60)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(406, 12)" end="(406, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(406, 13)" end="(406, 59)">
                                                          <OtherNode start="(406, 13)" end="(406, 55)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(406, 13)" end="(406, 55)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(406, 13)" end="(406, 28)" leading="" trailing=" " raw_val="erase_cons_tail" val="erase_cons_tail" full_name="List.erase_cons_tail" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(310, 17)" def_end="(310, 32)"/>
                                                            <NullNode start="(406, 29)" end="(406, 55)">
                                                            <OtherNode start="(406, 29)" end="(406, 55)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(406, 29)" end="(406, 30)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(406, 30)" end="(406, 54)">
                                                            <AtomNode start="(406, 30)" end="(406, 32)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(406, 33)" end="(406, 54)">
                                                            <TacticTacticseq1IndentedNode start="(406, 33)" end="(406, 54)">
                                                            <NullNode start="(406, 33)" end="(406, 54)">
                                                            <OtherNode start="(406, 33)" end="(406, 54)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : f x = true&#10;⊢ ¬(x == a) = true" state_after="no goals" tactic="simpa using Ne.symm h">
                                                            <AtomNode start="(406, 33)" end="(406, 38)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(406, 39)" end="(406, 54)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(406, 39)" end="(406, 54)">
                                                            <AtomNode start="(406, 39)" end="(406, 44)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(406, 45)" end="(406, 54)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(406, 45)" end="(406, 52)" leading="" trailing=" " raw_val="Ne.symm" val="Ne.symm" full_name="Ne.symm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(406, 53)" end="(406, 54)">
                                                            <IdentNode start="(406, 53)" end="(406, 54)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(406, 54)" end="(406, 55)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                          <AtomNode start="(406, 55)" end="(406, 56)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(406, 57)" end="(406, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(406, 57)" end="(406, 59)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(406, 59)" end="(406, 60)" leading="" trailing="&#10;      " val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(407, 7)" end="(407, 16)" kind="Lean.cdot" state_before="case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase a = filter f (xs.erase a)" state_after="no goals" tactic="· rw [ih]">
                                              <OtherNode start="(407, 7)" end="(407, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(407, 7)" end="(407, 8)" kind="patternIgnore">
                                                  <OtherNode start="(407, 7)" end="(407, 8)" kind="token.«· »">
                                                    <AtomNode start="(407, 7)" end="(407, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(407, 9)" end="(407, 16)">
                                                <TacticTacticseq1IndentedNode start="(407, 9)" end="(407, 16)">
                                                  <NullNode start="(407, 9)" end="(407, 16)">
                                                    <OtherNode start="(407, 9)" end="(407, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg.isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;f : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (filter f xs).erase a = filter f (xs.erase a)&#10;h : ¬a = x&#10;h✝ : ¬f x = true&#10;⊢ (filter f xs).erase a = filter f (xs.erase a)" state_after="no goals" tactic="rw [ih]">
                                                      <AtomNode start="(407, 9)" end="(407, 11)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(407, 12)" end="(407, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(407, 12)" end="(407, 13)" leading="" trailing="" val="["/>
                                                        <NullNode start="(407, 13)" end="(407, 15)">
                                                          <OtherNode start="(407, 13)" end="(407, 15)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(407, 13)" end="(407, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(407, 15)" end="(407, 16)" leading="" trailing="&#10;&#10;" val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(409, 1)" end="(411, 77)" name="erase_append_left" full_name="List.erase_append_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(409, 1)" end="(411, 77)" name="erase_append_left" full_name="List.erase_append_left" _is_private_decl="False">
        <AtomNode start="(409, 1)" end="(409, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(409, 9)" end="(409, 26)">
          <IdentNode start="(409, 9)" end="(409, 26)" leading="" trailing=" " raw_val="erase_append_left" val="erase_append_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(409, 27)" end="(410, 42)">
          <NullNode start="(409, 27)" end="(409, 72)">
            <OtherNode start="(409, 27)" end="(409, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(409, 27)" end="(409, 28)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(409, 28)" end="(409, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(409, 28)" end="(409, 37)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(409, 38)" end="(409, 39)">
                  <IdentNode start="(409, 38)" end="(409, 39)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(409, 39)" end="(409, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(409, 41)" end="(409, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(409, 41)" end="(409, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(409, 42)" end="(409, 44)">
                <IdentNode start="(409, 42)" end="(409, 44)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(409, 45)" end="(409, 53)">
                <AtomNode start="(409, 45)" end="(409, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 47)" end="(409, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(409, 47)" end="(409, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(409, 52)" end="(409, 53)">
                    <IdentNode start="(409, 52)" end="(409, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(409, 53)" end="(409, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(409, 55)" end="(409, 59)">
              <AtomNode start="(409, 55)" end="(409, 56)" leading="" trailing="" val="("/>
              <NullNode start="(409, 56)" end="(409, 58)">
                <IdentNode start="(409, 56)" end="(409, 58)" leading="" trailing="" raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(409, 58)" end="(409, 59)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(409, 60)" end="(409, 72)">
              <AtomNode start="(409, 60)" end="(409, 61)" leading="" trailing="" val="("/>
              <NullNode start="(409, 61)" end="(409, 62)">
                <IdentNode start="(409, 61)" end="(409, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(409, 63)" end="(409, 71)">
                <AtomNode start="(409, 63)" end="(409, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(409, 65)" end="(409, 71)" kind="«term_∈_»">
                  <IdentNode start="(409, 65)" end="(409, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(409, 67)" end="(409, 68)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(409, 69)" end="(409, 71)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(409, 71)" end="(409, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(409, 73)" end="(410, 42)">
            <AtomNode start="(409, 73)" end="(409, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(410, 5)" end="(410, 42)" kind="«term_=_»">
              <OtherNode start="(410, 5)" end="(410, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(410, 5)" end="(410, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(410, 5)" end="(410, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(410, 5)" end="(410, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(410, 6)" end="(410, 14)" kind="«term_++_»">
                      <IdentNode start="(410, 6)" end="(410, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(410, 9)" end="(410, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(410, 12)" end="(410, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(410, 14)" end="(410, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(410, 15)" end="(410, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(410, 16)" end="(410, 21)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(410, 22)" end="(410, 23)">
                  <IdentNode start="(410, 22)" end="(410, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(410, 24)" end="(410, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(410, 26)" end="(410, 42)" kind="«term_++_»">
                <OtherNode start="(410, 26)" end="(410, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(410, 26)" end="(410, 34)" leading="" trailing=" " raw_val="l₁.erase" val="l₁.erase"/>
                  <NullNode start="(410, 35)" end="(410, 36)">
                    <IdentNode start="(410, 35)" end="(410, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(410, 37)" end="(410, 39)" leading="" trailing=" " val="++"/>
                <IdentNode start="(410, 40)" end="(410, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(410, 43)" end="(411, 77)">
          <AtomNode start="(410, 43)" end="(410, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(410, 46)" end="(411, 77)">
            <AtomNode start="(410, 46)" end="(410, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(411, 3)" end="(411, 77)">
              <TacticTacticseq1IndentedNode start="(411, 3)" end="(411, 77)">
                <NullNode start="(411, 3)" end="(411, 77)">
                  <OtherNode start="(411, 3)" end="(411, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;h : a ∈ l₁&#10;⊢ (l₁ ++ l₂).erase a = l₁.erase a ++ l₂" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;h : a ∈ l₁&#10;⊢ eraseP (fun x =&amp;gt; a == x) (l₁ ++ l₂) = eraseP (fun x =&amp;gt; a == x) l₁ ++ l₂" tactic="simp [erase_eq_eraseP]">
                    <AtomNode start="(411, 3)" end="(411, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(411, 8)" end="(411, 25)">
                      <AtomNode start="(411, 8)" end="(411, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(411, 9)" end="(411, 24)">
                        <OtherNode start="(411, 9)" end="(411, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(411, 9)" end="(411, 24)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(411, 24)" end="(411, 25)" leading="" trailing="" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(411, 25)" end="(411, 26)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(411, 27)" end="(411, 77)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;a : α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;h : a ∈ l₁&#10;⊢ eraseP (fun x =&amp;gt; a == x) (l₁ ++ l₂) = eraseP (fun x =&amp;gt; a == x) l₁ ++ l₂" state_after="no goals" tactic="exact eraseP_append_left (beq_self_eq_true a) l₂ h">
                    <AtomNode start="(411, 27)" end="(411, 32)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(411, 33)" end="(411, 77)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(411, 33)" end="(411, 51)" leading="" trailing=" " raw_val="eraseP_append_left" val="eraseP_append_left" full_name="List.eraseP_append_left" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(175, 9)" def_end="(175, 27)"/>
                      <NullNode start="(411, 52)" end="(411, 77)">
                        <OtherNode start="(411, 52)" end="(411, 72)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(411, 52)" end="(411, 53)" leading="" trailing="" val="("/>
                          <OtherNode start="(411, 53)" end="(411, 71)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(411, 53)" end="(411, 69)" leading="" trailing=" " raw_val="beq_self_eq_true" val="beq_self_eq_true" full_name="beq_self_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                            <NullNode start="(411, 70)" end="(411, 71)">
                              <IdentNode start="(411, 70)" end="(411, 71)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(411, 71)" end="(411, 72)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <IdentNode start="(411, 73)" end="(411, 75)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <IdentNode start="(411, 76)" end="(411, 77)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(413, 1)" end="(416, 55)" name="erase_append_right" full_name="List.erase_append_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(413, 1)" end="(416, 55)" name="erase_append_right" full_name="List.erase_append_right" _is_private_decl="False">
        <AtomNode start="(413, 1)" end="(413, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(413, 9)" end="(413, 27)">
          <IdentNode start="(413, 9)" end="(413, 27)" leading="" trailing=" " raw_val="erase_append_right" val="erase_append_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(413, 28)" end="(414, 44)">
          <NullNode start="(413, 28)" end="(413, 90)">
            <OtherNode start="(413, 28)" end="(413, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(413, 28)" end="(413, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(413, 29)" end="(413, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(413, 29)" end="(413, 38)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(413, 39)" end="(413, 40)">
                  <IdentNode start="(413, 39)" end="(413, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(413, 40)" end="(413, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(413, 42)" end="(413, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(413, 42)" end="(413, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(413, 43)" end="(413, 44)">
                <IdentNode start="(413, 43)" end="(413, 44)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(413, 45)" end="(413, 48)">
                <AtomNode start="(413, 45)" end="(413, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(413, 47)" end="(413, 48)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(413, 48)" end="(413, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(413, 50)" end="(413, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(413, 50)" end="(413, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(413, 51)" end="(413, 53)">
                <IdentNode start="(413, 51)" end="(413, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              </NullNode>
              <NullNode start="(413, 54)" end="(413, 62)">
                <AtomNode start="(413, 54)" end="(413, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(413, 56)" end="(413, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(413, 56)" end="(413, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(413, 61)" end="(413, 62)">
                    <IdentNode start="(413, 61)" end="(413, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(413, 62)" end="(413, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(413, 64)" end="(413, 77)">
              <AtomNode start="(413, 64)" end="(413, 65)" leading="" trailing="" val="("/>
              <NullNode start="(413, 65)" end="(413, 67)">
                <IdentNode start="(413, 65)" end="(413, 67)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(413, 68)" end="(413, 76)">
                <AtomNode start="(413, 68)" end="(413, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(413, 70)" end="(413, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(413, 70)" end="(413, 74)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(413, 75)" end="(413, 76)">
                    <IdentNode start="(413, 75)" end="(413, 76)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(413, 76)" end="(413, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(413, 78)" end="(413, 90)">
              <AtomNode start="(413, 78)" end="(413, 79)" leading="" trailing="" val="("/>
              <NullNode start="(413, 79)" end="(413, 80)">
                <IdentNode start="(413, 79)" end="(413, 80)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(413, 81)" end="(413, 89)">
                <AtomNode start="(413, 81)" end="(413, 82)" leading="" trailing=" " val=":"/>
                <OtherNode start="(413, 83)" end="(413, 89)" kind="«term_∉_»">
                  <IdentNode start="(413, 83)" end="(413, 84)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(413, 85)" end="(413, 86)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(413, 87)" end="(413, 89)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(413, 89)" end="(413, 90)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(413, 91)" end="(414, 44)">
            <AtomNode start="(413, 91)" end="(413, 92)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(414, 5)" end="(414, 44)" kind="«term_=_»">
              <OtherNode start="(414, 5)" end="(414, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(414, 5)" end="(414, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(414, 5)" end="(414, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(414, 5)" end="(414, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(414, 6)" end="(414, 14)" kind="«term_++_»">
                      <IdentNode start="(414, 6)" end="(414, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(414, 9)" end="(414, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(414, 12)" end="(414, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(414, 14)" end="(414, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(414, 15)" end="(414, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(414, 16)" end="(414, 21)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(414, 22)" end="(414, 23)">
                  <IdentNode start="(414, 22)" end="(414, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(414, 24)" end="(414, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(414, 26)" end="(414, 44)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(414, 26)" end="(414, 27)" leading="" trailing="" val="("/>
                <OtherNode start="(414, 27)" end="(414, 43)" kind="«term_++_»">
                  <IdentNode start="(414, 27)" end="(414, 29)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(414, 30)" end="(414, 32)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(414, 33)" end="(414, 43)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(414, 33)" end="(414, 41)" leading="" trailing=" " raw_val="l₂.erase" val="l₂.erase"/>
                    <NullNode start="(414, 42)" end="(414, 43)">
                      <IdentNode start="(414, 42)" end="(414, 43)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(414, 43)" end="(414, 44)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(414, 45)" end="(416, 55)">
          <AtomNode start="(414, 45)" end="(414, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(414, 48)" end="(416, 55)">
            <AtomNode start="(414, 48)" end="(414, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(415, 3)" end="(416, 55)">
              <TacticTacticseq1IndentedNode start="(415, 3)" end="(416, 55)">
                <NullNode start="(415, 3)" end="(416, 55)">
                  <OtherNode start="(415, 3)" end="(415, 61)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : ¬a ∈ l₁&#10;⊢ (l₁ ++ l₂).erase a = l₁ ++ l₂.erase a" state_after="case a&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : ¬a ∈ l₁&#10;⊢ ∀ (b : α), b ∈ l₁ → ¬(a == b) = true" tactic="rw [erase_eq_eraseP, erase_eq_eraseP, eraseP_append_right]">
                    <AtomNode start="(415, 3)" end="(415, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(415, 6)" end="(415, 61)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(415, 6)" end="(415, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(415, 7)" end="(415, 60)">
                        <OtherNode start="(415, 7)" end="(415, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(415, 7)" end="(415, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                        <AtomNode start="(415, 22)" end="(415, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(415, 24)" end="(415, 39)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(415, 24)" end="(415, 39)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                        <AtomNode start="(415, 39)" end="(415, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(415, 41)" end="(415, 60)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(415, 41)" end="(415, 60)" leading="" trailing="" raw_val="eraseP_append_right" val="eraseP_append_right" full_name="List.eraseP_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(182, 9)" def_end="(182, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(415, 60)" end="(415, 61)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(416, 3)" end="(416, 18)" kind="Lean.Parser.Tactic.intros" state_before="case a&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : ¬a ∈ l₁&#10;⊢ ∀ (b : α), b ∈ l₁ → ¬(a == b) = true" state_after="case a&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : ¬a ∈ l₁&#10;b : α&#10;h' : b ∈ l₁&#10;h'' : (a == b) = true&#10;⊢ False" tactic="intros b h' h''">
                    <AtomNode start="(416, 3)" end="(416, 9)" leading="" trailing=" " val="intros"/>
                    <NullNode start="(416, 10)" end="(416, 18)">
                      <IdentNode start="(416, 10)" end="(416, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                      <IdentNode start="(416, 12)" end="(416, 14)" leading="" trailing=" " raw_val="h'" val="h'"/>
                      <IdentNode start="(416, 15)" end="(416, 18)" leading="" trailing="" raw_val="h''" val="h''"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(416, 18)" end="(416, 19)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(416, 20)" end="(416, 43)" kind="Lean.Parser.Tactic.rwSeq" state_before="case a&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;h : ¬a ∈ l₁&#10;b : α&#10;h' : b ∈ l₁&#10;h'' : (a == b) = true&#10;⊢ False" state_after="case a&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;b : α&#10;h : ¬b ∈ l₁&#10;h' : b ∈ l₁&#10;h'' : (a == b) = true&#10;⊢ False" tactic="rw [eq_of_beq h''] at h">
                    <AtomNode start="(416, 20)" end="(416, 22)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(416, 23)" end="(416, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(416, 23)" end="(416, 24)" leading="" trailing="" val="["/>
                      <NullNode start="(416, 24)" end="(416, 37)">
                        <OtherNode start="(416, 24)" end="(416, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(416, 24)" end="(416, 37)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(416, 24)" end="(416, 33)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(416, 34)" end="(416, 37)">
                              <IdentNode start="(416, 34)" end="(416, 37)" leading="" trailing="" raw_val="h''" val="h''"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(416, 37)" end="(416, 38)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(416, 39)" end="(416, 43)">
                      <OtherNode start="(416, 39)" end="(416, 43)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(416, 39)" end="(416, 41)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(416, 42)" end="(416, 43)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(416, 42)" end="(416, 43)">
                            <IdentNode start="(416, 42)" end="(416, 43)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(416, 43)" end="(416, 44)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(416, 45)" end="(416, 55)" kind="Lean.Parser.Tactic.exact" state_before="case a&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;b : α&#10;h : ¬b ∈ l₁&#10;h' : b ∈ l₁&#10;h'' : (a == b) = true&#10;⊢ False" state_after="no goals" tactic="exact h h'">
                    <AtomNode start="(416, 45)" end="(416, 50)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(416, 51)" end="(416, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(416, 51)" end="(416, 52)" leading="" trailing=" " raw_val="h" val="h"/>
                      <NullNode start="(416, 53)" end="(416, 55)">
                        <IdentNode start="(416, 53)" end="(416, 55)" leading="" trailing="&#10;&#10;" raw_val="h'" val="h'"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(418, 1)" end="(420, 40)" name="erase_append" full_name="List.erase_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(418, 1)" end="(420, 40)" name="erase_append" full_name="List.erase_append" _is_private_decl="False">
        <AtomNode start="(418, 1)" end="(418, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(418, 9)" end="(418, 21)">
          <IdentNode start="(418, 9)" end="(418, 21)" leading="" trailing=" " raw_val="erase_append" val="erase_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(418, 22)" end="(419, 79)">
          <NullNode start="(418, 22)" end="(418, 60)">
            <OtherNode start="(418, 22)" end="(418, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(418, 22)" end="(418, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(418, 23)" end="(418, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(418, 23)" end="(418, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(418, 33)" end="(418, 34)">
                  <IdentNode start="(418, 33)" end="(418, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(418, 34)" end="(418, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(418, 36)" end="(418, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(418, 36)" end="(418, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(418, 37)" end="(418, 38)">
                <IdentNode start="(418, 37)" end="(418, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(418, 39)" end="(418, 42)">
                <AtomNode start="(418, 39)" end="(418, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(418, 41)" end="(418, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(418, 42)" end="(418, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(418, 44)" end="(418, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(418, 44)" end="(418, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(418, 45)" end="(418, 50)">
                <IdentNode start="(418, 45)" end="(418, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(418, 48)" end="(418, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(418, 51)" end="(418, 59)">
                <AtomNode start="(418, 51)" end="(418, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(418, 53)" end="(418, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(418, 53)" end="(418, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(418, 58)" end="(418, 59)">
                    <IdentNode start="(418, 58)" end="(418, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(418, 59)" end="(418, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(418, 61)" end="(419, 79)">
            <AtomNode start="(418, 61)" end="(418, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(419, 5)" end="(419, 79)" kind="«term_=_»">
              <OtherNode start="(419, 5)" end="(419, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(419, 5)" end="(419, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(419, 5)" end="(419, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(419, 5)" end="(419, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(419, 6)" end="(419, 14)" kind="«term_++_»">
                      <IdentNode start="(419, 6)" end="(419, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(419, 9)" end="(419, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(419, 12)" end="(419, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(419, 14)" end="(419, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(419, 15)" end="(419, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(419, 16)" end="(419, 21)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(419, 22)" end="(419, 23)">
                  <IdentNode start="(419, 22)" end="(419, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(419, 24)" end="(419, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(419, 26)" end="(419, 79)" kind="termIfThenElse">
                <AtomNode start="(419, 26)" end="(419, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(419, 29)" end="(419, 35)" kind="«term_∈_»">
                  <IdentNode start="(419, 29)" end="(419, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(419, 31)" end="(419, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(419, 33)" end="(419, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </OtherNode>
                <AtomNode start="(419, 36)" end="(419, 40)" leading="" trailing=" " val="then"/>
                <OtherNode start="(419, 41)" end="(419, 57)" kind="«term_++_»">
                  <OtherNode start="(419, 41)" end="(419, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(419, 41)" end="(419, 49)" leading="" trailing=" " raw_val="l₁.erase" val="l₁.erase"/>
                    <NullNode start="(419, 50)" end="(419, 51)">
                      <IdentNode start="(419, 50)" end="(419, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(419, 52)" end="(419, 54)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(419, 55)" end="(419, 57)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                </OtherNode>
                <AtomNode start="(419, 58)" end="(419, 62)" leading="" trailing=" " val="else"/>
                <OtherNode start="(419, 63)" end="(419, 79)" kind="«term_++_»">
                  <IdentNode start="(419, 63)" end="(419, 65)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(419, 66)" end="(419, 68)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(419, 69)" end="(419, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(419, 69)" end="(419, 77)" leading="" trailing=" " raw_val="l₂.erase" val="l₂.erase"/>
                    <NullNode start="(419, 78)" end="(419, 79)">
                      <IdentNode start="(419, 78)" end="(419, 79)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(419, 80)" end="(420, 40)">
          <AtomNode start="(419, 80)" end="(419, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(419, 83)" end="(420, 40)">
            <AtomNode start="(419, 83)" end="(419, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(420, 3)" end="(420, 40)">
              <TacticTacticseq1IndentedNode start="(420, 3)" end="(420, 40)">
                <NullNode start="(420, 3)" end="(420, 40)">
                  <OtherNode start="(420, 3)" end="(420, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ l₂ : List α&#10;⊢ (l₁ ++ l₂).erase a = if a ∈ l₁ then l₁.erase a ++ l₂ else l₁ ++ l₂.erase a" state_after="no goals" tactic="simp [erase_eq_eraseP, eraseP_append]">
                    <AtomNode start="(420, 3)" end="(420, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(420, 8)" end="(420, 40)">
                      <AtomNode start="(420, 8)" end="(420, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(420, 9)" end="(420, 39)">
                        <OtherNode start="(420, 9)" end="(420, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(420, 9)" end="(420, 24)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                        <AtomNode start="(420, 24)" end="(420, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(420, 26)" end="(420, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(420, 26)" end="(420, 39)" leading="" trailing="" raw_val="eraseP_append" val="eraseP_append" full_name="List.eraseP_append" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(188, 9)" def_end="(188, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(420, 39)" end="(420, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(422, 1)" end="(425, 26)" name="erase_replicate" full_name="List.erase_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(422, 1)" end="(425, 26)" name="erase_replicate" full_name="List.erase_replicate" _is_private_decl="False">
        <AtomNode start="(422, 1)" end="(422, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(422, 9)" end="(422, 24)">
          <IdentNode start="(422, 9)" end="(422, 24)" leading="" trailing=" " raw_val="erase_replicate" val="erase_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(422, 25)" end="(423, 84)">
          <NullNode start="(422, 25)" end="(422, 58)">
            <OtherNode start="(422, 25)" end="(422, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(422, 25)" end="(422, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(422, 26)" end="(422, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(422, 26)" end="(422, 35)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(422, 36)" end="(422, 37)">
                  <IdentNode start="(422, 36)" end="(422, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(422, 37)" end="(422, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(422, 39)" end="(422, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(422, 39)" end="(422, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(422, 40)" end="(422, 41)">
                <IdentNode start="(422, 40)" end="(422, 41)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(422, 42)" end="(422, 47)">
                <AtomNode start="(422, 42)" end="(422, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(422, 44)" end="(422, 47)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(422, 47)" end="(422, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(422, 49)" end="(422, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(422, 49)" end="(422, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(422, 50)" end="(422, 53)">
                <IdentNode start="(422, 50)" end="(422, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(422, 52)" end="(422, 53)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(422, 54)" end="(422, 57)">
                <AtomNode start="(422, 54)" end="(422, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(422, 56)" end="(422, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(422, 57)" end="(422, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(422, 59)" end="(423, 84)">
            <AtomNode start="(422, 59)" end="(422, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(423, 5)" end="(423, 84)" kind="«term_=_»">
              <OtherNode start="(423, 5)" end="(423, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(423, 5)" end="(423, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(423, 5)" end="(423, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(423, 5)" end="(423, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(423, 6)" end="(423, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(423, 6)" end="(423, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(423, 16)" end="(423, 19)">
                        <IdentNode start="(423, 16)" end="(423, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(423, 18)" end="(423, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(423, 19)" end="(423, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(423, 20)" end="(423, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(423, 21)" end="(423, 26)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(423, 27)" end="(423, 28)">
                  <IdentNode start="(423, 27)" end="(423, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(423, 29)" end="(423, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(423, 31)" end="(423, 84)" kind="termIfThenElse">
                <AtomNode start="(423, 31)" end="(423, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(423, 34)" end="(423, 40)" kind="«term_==_»">
                  <IdentNode start="(423, 34)" end="(423, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(423, 36)" end="(423, 38)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(423, 39)" end="(423, 40)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
                <AtomNode start="(423, 41)" end="(423, 45)" leading="" trailing=" " val="then"/>
                <OtherNode start="(423, 46)" end="(423, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 46)" end="(423, 55)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(423, 56)" end="(423, 65)">
                    <OtherNode start="(423, 56)" end="(423, 63)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(423, 56)" end="(423, 57)" leading="" trailing="" val="("/>
                      <OtherNode start="(423, 57)" end="(423, 62)" kind="«term_-_»">
                        <IdentNode start="(423, 57)" end="(423, 58)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(423, 59)" end="(423, 60)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(423, 61)" end="(423, 62)" kind="num">
                          <AtomNode start="(423, 61)" end="(423, 62)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(423, 62)" end="(423, 63)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(423, 64)" end="(423, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(423, 66)" end="(423, 70)" leading="" trailing=" " val="else"/>
                <OtherNode start="(423, 71)" end="(423, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 71)" end="(423, 80)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(423, 81)" end="(423, 84)">
                    <IdentNode start="(423, 81)" end="(423, 82)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(423, 83)" end="(423, 84)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(423, 85)" end="(425, 26)">
          <AtomNode start="(423, 85)" end="(423, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(423, 88)" end="(425, 26)">
            <AtomNode start="(423, 88)" end="(423, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(424, 3)" end="(425, 26)">
              <TacticTacticseq1IndentedNode start="(424, 3)" end="(425, 26)">
                <NullNode start="(424, 3)" end="(425, 26)">
                  <OtherNode start="(424, 3)" end="(424, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ (replicate n a).erase b = if (b == a) = true then replicate (n - 1) a else replicate n a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ eraseP (fun x =&amp;gt; b == x) (replicate n a) = if (b == a) = true then replicate (n - 1) a else replicate n a" tactic="rw [erase_eq_eraseP]">
                    <AtomNode start="(424, 3)" end="(424, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(424, 6)" end="(424, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(424, 6)" end="(424, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(424, 7)" end="(424, 22)">
                        <OtherNode start="(424, 7)" end="(424, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(424, 7)" end="(424, 22)" leading="" trailing="" raw_val="erase_eq_eraseP" val="erase_eq_eraseP" full_name="List.erase_eq_eraseP" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(328, 9)" def_end="(328, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(424, 22)" end="(424, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(425, 3)" end="(425, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a b : α&#10;⊢ eraseP (fun x =&amp;gt; b == x) (replicate n a) = if (b == a) = true then replicate (n - 1) a else replicate n a" state_after="no goals" tactic="simp [eraseP_replicate]">
                    <AtomNode start="(425, 3)" end="(425, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(425, 8)" end="(425, 26)">
                      <AtomNode start="(425, 8)" end="(425, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(425, 9)" end="(425, 25)">
                        <OtherNode start="(425, 9)" end="(425, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(425, 9)" end="(425, 25)" leading="" trailing="" raw_val="eraseP_replicate" val="eraseP_replicate" full_name="List.eraseP_replicate" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(198, 9)" def_end="(198, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(425, 25)" end="(425, 26)" leading="" trailing="&#10;&#10;-- The arguments `a b` are explicit,&#10;-- so they can be specified to prevent `simp` repeatedly applying the lemma.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(429, 1)" end="(443, 47)" name="erase_comm" full_name="List.erase_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(429, 1)" end="(443, 47)" name="erase_comm" full_name="List.erase_comm" _is_private_decl="False">
        <AtomNode start="(429, 1)" end="(429, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(429, 9)" end="(429, 19)">
          <IdentNode start="(429, 9)" end="(429, 19)" leading="" trailing=" " raw_val="erase_comm" val="erase_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(429, 20)" end="(430, 46)">
          <NullNode start="(429, 20)" end="(429, 56)">
            <OtherNode start="(429, 20)" end="(429, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(429, 20)" end="(429, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(429, 21)" end="(429, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(429, 21)" end="(429, 30)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(429, 31)" end="(429, 32)">
                  <IdentNode start="(429, 31)" end="(429, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(429, 32)" end="(429, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(429, 34)" end="(429, 43)">
              <AtomNode start="(429, 34)" end="(429, 35)" leading="" trailing="" val="("/>
              <NullNode start="(429, 35)" end="(429, 38)">
                <IdentNode start="(429, 35)" end="(429, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(429, 37)" end="(429, 38)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(429, 39)" end="(429, 42)">
                <AtomNode start="(429, 39)" end="(429, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(429, 41)" end="(429, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(429, 42)" end="(429, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(429, 44)" end="(429, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(429, 44)" end="(429, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(429, 45)" end="(429, 46)">
                <IdentNode start="(429, 45)" end="(429, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(429, 47)" end="(429, 55)">
                <AtomNode start="(429, 47)" end="(429, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(429, 49)" end="(429, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(429, 49)" end="(429, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(429, 54)" end="(429, 55)">
                    <IdentNode start="(429, 54)" end="(429, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(429, 55)" end="(429, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(429, 57)" end="(430, 46)">
            <AtomNode start="(429, 57)" end="(429, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(430, 5)" end="(430, 46)" kind="«term_=_»">
              <OtherNode start="(430, 5)" end="(430, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(430, 5)" end="(430, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(430, 5)" end="(430, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(430, 5)" end="(430, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(430, 6)" end="(430, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(430, 6)" end="(430, 13)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(430, 14)" end="(430, 15)">
                        <IdentNode start="(430, 14)" end="(430, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(430, 15)" end="(430, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(430, 16)" end="(430, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(430, 17)" end="(430, 22)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(430, 23)" end="(430, 24)">
                  <IdentNode start="(430, 23)" end="(430, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(430, 25)" end="(430, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(430, 27)" end="(430, 46)" kind="Lean.Parser.Term.app">
                <OtherNode start="(430, 27)" end="(430, 44)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(430, 27)" end="(430, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(430, 27)" end="(430, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(430, 28)" end="(430, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(430, 28)" end="(430, 35)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(430, 36)" end="(430, 37)">
                        <IdentNode start="(430, 36)" end="(430, 37)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(430, 37)" end="(430, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(430, 38)" end="(430, 39)" leading="" trailing="" val="."/>
                  <IdentNode start="(430, 39)" end="(430, 44)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(430, 45)" end="(430, 46)">
                  <IdentNode start="(430, 45)" end="(430, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(430, 47)" end="(443, 47)">
          <AtomNode start="(430, 47)" end="(430, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(430, 50)" end="(443, 47)">
            <AtomNode start="(430, 50)" end="(430, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(431, 3)" end="(443, 47)">
              <TacticTacticseq1IndentedNode start="(431, 3)" end="(443, 47)">
                <NullNode start="(431, 3)" end="(443, 47)">
                  <OtherNode start="(431, 3)" end="(431, 48)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" tactic="if ab : a == b then rw [eq_of_beq ab] else ?_">
                    <AtomNode start="(431, 3)" end="(431, 5)" leading="" trailing=" " val="if"/>
                    <LeanBinderidentNode start="(431, 6)" end="(431, 8)">
                      <IdentNode start="(431, 6)" end="(431, 8)" leading="" trailing=" " raw_val="ab" val="ab"/>
                    </LeanBinderidentNode>
                    <AtomNode start="(431, 9)" end="(431, 10)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(431, 11)" end="(431, 17)" kind="«term_==_»">
                      <IdentNode start="(431, 11)" end="(431, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(431, 13)" end="(431, 15)" leading="" trailing=" " val="=="/>
                      <IdentNode start="(431, 16)" end="(431, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                    </OtherNode>
                    <AtomNode start="(431, 18)" end="(431, 22)" leading="" trailing=" " val="then"/>
                    <TacticTacticseqNode start="(431, 23)" end="(431, 40)">
                      <TacticTacticseq1IndentedNode start="(431, 23)" end="(431, 40)">
                        <NullNode start="(431, 23)" end="(431, 40)">
                          <OtherNode start="(431, 23)" end="(431, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : (a == b) = true&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="no goals" tactic="rw [eq_of_beq ab]">
                            <AtomNode start="(431, 23)" end="(431, 25)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(431, 26)" end="(431, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(431, 26)" end="(431, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(431, 27)" end="(431, 39)">
                                <OtherNode start="(431, 27)" end="(431, 39)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(431, 27)" end="(431, 39)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(431, 27)" end="(431, 36)" leading="" trailing=" " raw_val="eq_of_beq" val="eq_of_beq" full_name="LawfulBEq.eq_of_beq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                    <NullNode start="(431, 37)" end="(431, 39)">
                                      <IdentNode start="(431, 37)" end="(431, 39)" leading="" trailing="" raw_val="ab" val="ab"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(431, 39)" end="(431, 40)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                    <AtomNode start="(431, 41)" end="(431, 45)" leading="" trailing=" " val="else"/>
                    <OtherNode start="(431, 46)" end="(431, 48)" kind="Lean.Parser.Term.syntheticHole">
                      <AtomNode start="(431, 46)" end="(431, 47)" leading="" trailing="" val="?"/>
                      <AtomNode start="(431, 47)" end="(431, 48)" leading="" trailing="&#10;  " val="_"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(432, 3)" end="(433, 79)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;ha : a ∈ l&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" tactic="if ha : a ∈ l then ?_ else&#10;  simp only [erase_of_not_mem ha, erase_of_not_mem (mt mem_of_mem_erase ha)]">
                    <AtomNode start="(432, 3)" end="(432, 5)" leading="" trailing=" " val="if"/>
                    <LeanBinderidentNode start="(432, 6)" end="(432, 8)">
                      <IdentNode start="(432, 6)" end="(432, 8)" leading="" trailing=" " raw_val="ha" val="ha"/>
                    </LeanBinderidentNode>
                    <AtomNode start="(432, 9)" end="(432, 10)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(432, 11)" end="(432, 16)" kind="«term_∈_»">
                      <IdentNode start="(432, 11)" end="(432, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(432, 13)" end="(432, 14)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(432, 15)" end="(432, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(432, 17)" end="(432, 21)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(432, 22)" end="(432, 24)" kind="Lean.Parser.Term.syntheticHole">
                      <AtomNode start="(432, 22)" end="(432, 23)" leading="" trailing="" val="?"/>
                      <AtomNode start="(432, 23)" end="(432, 24)" leading="" trailing=" " val="_"/>
                    </OtherNode>
                    <AtomNode start="(432, 25)" end="(432, 29)" leading="" trailing="&#10;    " val="else"/>
                    <TacticTacticseqNode start="(433, 5)" end="(433, 79)">
                      <TacticTacticseq1IndentedNode start="(433, 5)" end="(433, 79)">
                        <NullNode start="(433, 5)" end="(433, 79)">
                          <OtherNode start="(433, 5)" end="(433, 79)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;ha : ¬a ∈ l&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="no goals" tactic="simp only [erase_of_not_mem ha, erase_of_not_mem (mt mem_of_mem_erase ha)]">
                            <AtomNode start="(433, 5)" end="(433, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(433, 10)" end="(433, 14)">
                              <AtomNode start="(433, 10)" end="(433, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(433, 15)" end="(433, 79)">
                              <AtomNode start="(433, 15)" end="(433, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(433, 16)" end="(433, 78)">
                                <OtherNode start="(433, 16)" end="(433, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(433, 16)" end="(433, 35)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(433, 16)" end="(433, 32)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(313, 9)" def_end="(313, 25)"/>
                                    <NullNode start="(433, 33)" end="(433, 35)">
                                      <IdentNode start="(433, 33)" end="(433, 35)" leading="" trailing="" raw_val="ha" val="ha"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(433, 35)" end="(433, 36)" leading="" trailing=" " val=","/>
                                <OtherNode start="(433, 37)" end="(433, 78)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(433, 37)" end="(433, 78)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(433, 37)" end="(433, 53)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(313, 9)" def_end="(313, 25)"/>
                                    <NullNode start="(433, 54)" end="(433, 78)">
                                      <OtherNode start="(433, 54)" end="(433, 78)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(433, 54)" end="(433, 55)" leading="" trailing="" val="("/>
                                        <OtherNode start="(433, 55)" end="(433, 77)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(433, 55)" end="(433, 57)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          <NullNode start="(433, 58)" end="(433, 77)">
                                            <IdentNode start="(433, 58)" end="(433, 74)" leading="" trailing=" " raw_val="mem_of_mem_erase" val="mem_of_mem_erase" full_name="List.mem_of_mem_erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(381, 9)" def_end="(381, 25)"/>
                                            <IdentNode start="(433, 75)" end="(433, 77)" leading="" trailing="" raw_val="ha" val="ha"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(433, 77)" end="(433, 78)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(433, 78)" end="(433, 79)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(434, 3)" end="(435, 79)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;ha : a ∈ l&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;ha : a ∈ l&#10;hb : b ∈ l&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" tactic="if hb : b ∈ l then ?_ else&#10;  simp only [erase_of_not_mem hb, erase_of_not_mem (mt mem_of_mem_erase hb)]">
                    <AtomNode start="(434, 3)" end="(434, 5)" leading="" trailing=" " val="if"/>
                    <LeanBinderidentNode start="(434, 6)" end="(434, 8)">
                      <IdentNode start="(434, 6)" end="(434, 8)" leading="" trailing=" " raw_val="hb" val="hb"/>
                    </LeanBinderidentNode>
                    <AtomNode start="(434, 9)" end="(434, 10)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(434, 11)" end="(434, 16)" kind="«term_∈_»">
                      <IdentNode start="(434, 11)" end="(434, 12)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(434, 13)" end="(434, 14)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(434, 15)" end="(434, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(434, 17)" end="(434, 21)" leading="" trailing=" " val="then"/>
                    <OtherNode start="(434, 22)" end="(434, 24)" kind="Lean.Parser.Term.syntheticHole">
                      <AtomNode start="(434, 22)" end="(434, 23)" leading="" trailing="" val="?"/>
                      <AtomNode start="(434, 23)" end="(434, 24)" leading="" trailing=" " val="_"/>
                    </OtherNode>
                    <AtomNode start="(434, 25)" end="(434, 29)" leading="" trailing="&#10;    " val="else"/>
                    <TacticTacticseqNode start="(435, 5)" end="(435, 79)">
                      <TacticTacticseq1IndentedNode start="(435, 5)" end="(435, 79)">
                        <NullNode start="(435, 5)" end="(435, 79)">
                          <OtherNode start="(435, 5)" end="(435, 79)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;ha : a ∈ l&#10;hb : ¬b ∈ l&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="no goals" tactic="simp only [erase_of_not_mem hb, erase_of_not_mem (mt mem_of_mem_erase hb)]">
                            <AtomNode start="(435, 5)" end="(435, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(435, 10)" end="(435, 14)">
                              <AtomNode start="(435, 10)" end="(435, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(435, 15)" end="(435, 79)">
                              <AtomNode start="(435, 15)" end="(435, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(435, 16)" end="(435, 78)">
                                <OtherNode start="(435, 16)" end="(435, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(435, 16)" end="(435, 35)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(435, 16)" end="(435, 32)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(313, 9)" def_end="(313, 25)"/>
                                    <NullNode start="(435, 33)" end="(435, 35)">
                                      <IdentNode start="(435, 33)" end="(435, 35)" leading="" trailing="" raw_val="hb" val="hb"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(435, 35)" end="(435, 36)" leading="" trailing=" " val=","/>
                                <OtherNode start="(435, 37)" end="(435, 78)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(435, 37)" end="(435, 78)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(435, 37)" end="(435, 53)" leading="" trailing=" " raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(313, 9)" def_end="(313, 25)"/>
                                    <NullNode start="(435, 54)" end="(435, 78)">
                                      <OtherNode start="(435, 54)" end="(435, 78)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(435, 54)" end="(435, 55)" leading="" trailing="" val="("/>
                                        <OtherNode start="(435, 55)" end="(435, 77)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(435, 55)" end="(435, 57)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          <NullNode start="(435, 58)" end="(435, 77)">
                                            <IdentNode start="(435, 58)" end="(435, 74)" leading="" trailing=" " raw_val="mem_of_mem_erase" val="mem_of_mem_erase" full_name="List.mem_of_mem_erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(381, 9)" def_end="(381, 25)"/>
                                            <IdentNode start="(435, 75)" end="(435, 77)" leading="" trailing="" raw_val="hb" val="hb"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(435, 77)" end="(435, 78)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(435, 78)" end="(435, 79)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(436, 3)" end="(443, 47)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;ha : a ∈ l&#10;hb : b ∈ l&#10;⊢ (l.erase a).erase b = (l.erase b).erase a" state_after="no goals" tactic="match l, l.erase a, exists_erase_eq ha with&#10;| _, _, ⟨l₁, l₂, ha', rfl, rfl⟩ =&amp;gt;&#10;  if h₁ : b ∈ l₁ then&#10;    rw [erase_append_left _ h₁, erase_append_left _ h₁,&#10;        erase_append_right _ (mt mem_of_mem_erase ha'), erase_cons_head]&#10;  else&#10;    rw [erase_append_right _ h₁, erase_append_right _ h₁, erase_append_right _ ha',&#10;        erase_cons_tail ab, erase_cons_head]">
                    <AtomNode start="(436, 3)" end="(436, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(436, 9)" end="(436, 41)">
                      <OtherNode start="(436, 9)" end="(436, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(436, 9)" end="(436, 10)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(436, 10)" end="(436, 11)" leading="" trailing=" " val=","/>
                      <OtherNode start="(436, 12)" end="(436, 21)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <OtherNode start="(436, 12)" end="(436, 21)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(436, 12)" end="(436, 19)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                          <NullNode start="(436, 20)" end="(436, 21)">
                            <IdentNode start="(436, 20)" end="(436, 21)" leading="" trailing="" raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(436, 21)" end="(436, 22)" leading="" trailing=" " val=","/>
                      <OtherNode start="(436, 23)" end="(436, 41)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <OtherNode start="(436, 23)" end="(436, 41)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(436, 23)" end="(436, 38)" leading="" trailing=" " raw_val="exists_erase_eq" val="exists_erase_eq" full_name="List.exists_erase_eq" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(349, 9)" def_end="(349, 24)"/>
                          <NullNode start="(436, 39)" end="(436, 41)">
                            <IdentNode start="(436, 39)" end="(436, 41)" leading="" trailing=" " raw_val="ha" val="ha"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(436, 42)" end="(436, 46)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(437, 3)" end="(443, 47)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(437, 3)" end="(443, 47)">
                        <OtherNode start="(437, 3)" end="(443, 47)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(437, 3)" end="(437, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(437, 5)" end="(437, 34)">
                            <NullNode start="(437, 5)" end="(437, 34)">
                              <TermHoleNode start="(437, 5)" end="(437, 6)">
                                <AtomNode start="(437, 5)" end="(437, 6)" leading="" trailing="" val="_"/>
                              </TermHoleNode>
                              <AtomNode start="(437, 6)" end="(437, 7)" leading="" trailing=" " val=","/>
                              <TermHoleNode start="(437, 8)" end="(437, 9)">
                                <AtomNode start="(437, 8)" end="(437, 9)" leading="" trailing="" val="_"/>
                              </TermHoleNode>
                              <AtomNode start="(437, 9)" end="(437, 10)" leading="" trailing=" " val=","/>
                              <OtherNode start="(437, 11)" end="(437, 34)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(437, 11)" end="(437, 12)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(437, 12)" end="(437, 33)">
                                  <IdentNode start="(437, 12)" end="(437, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                  <AtomNode start="(437, 14)" end="(437, 15)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(437, 16)" end="(437, 18)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                  <AtomNode start="(437, 18)" end="(437, 19)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(437, 20)" end="(437, 23)" leading="" trailing="" raw_val="ha'" val="ha'"/>
                                  <AtomNode start="(437, 23)" end="(437, 24)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(437, 25)" end="(437, 28)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <AtomNode start="(437, 28)" end="(437, 29)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(437, 30)" end="(437, 33)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </NullNode>
                                <AtomNode start="(437, 33)" end="(437, 34)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(437, 35)" end="(437, 37)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(438, 5)" end="(443, 47)">
                            <TacticTacticseq1IndentedNode start="(438, 5)" end="(443, 47)">
                              <NullNode start="(438, 5)" end="(443, 47)">
                                <OtherNode start="(438, 5)" end="(443, 47)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;l₁ l₂ : List α&#10;ha' : ¬a ∈ l₁&#10;ha : a ∈ l₁ ++ a :: l₂&#10;hb : b ∈ l₁ ++ a :: l₂&#10;⊢ (l₁ ++ l₂).erase b = ((l₁ ++ a :: l₂).erase b).erase a" state_after="no goals" tactic="if h₁ : b ∈ l₁ then&#10;  rw [erase_append_left _ h₁, erase_append_left _ h₁,&#10;      erase_append_right _ (mt mem_of_mem_erase ha'), erase_cons_head]&#10;else&#10;  rw [erase_append_right _ h₁, erase_append_right _ h₁, erase_append_right _ ha',&#10;      erase_cons_tail ab, erase_cons_head]">
                                  <AtomNode start="(438, 5)" end="(438, 7)" leading="" trailing=" " val="if"/>
                                  <LeanBinderidentNode start="(438, 8)" end="(438, 10)">
                                    <IdentNode start="(438, 8)" end="(438, 10)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                  </LeanBinderidentNode>
                                  <AtomNode start="(438, 11)" end="(438, 12)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(438, 13)" end="(438, 19)" kind="«term_∈_»">
                                    <IdentNode start="(438, 13)" end="(438, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <AtomNode start="(438, 15)" end="(438, 16)" leading="" trailing=" " val="∈"/>
                                    <IdentNode start="(438, 17)" end="(438, 19)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  </OtherNode>
                                  <AtomNode start="(438, 20)" end="(438, 24)" leading="" trailing="&#10;      " val="then"/>
                                  <TacticTacticseqNode start="(439, 7)" end="(440, 75)">
                                    <TacticTacticseq1IndentedNode start="(439, 7)" end="(440, 75)">
                                      <NullNode start="(439, 7)" end="(440, 75)">
                                        <OtherNode start="(439, 7)" end="(440, 75)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;l₁ l₂ : List α&#10;ha' : ¬a ∈ l₁&#10;ha : a ∈ l₁ ++ a :: l₂&#10;hb : b ∈ l₁ ++ a :: l₂&#10;h₁ : b ∈ l₁&#10;⊢ (l₁ ++ l₂).erase b = ((l₁ ++ a :: l₂).erase b).erase a" state_after="no goals" tactic="rw [erase_append_left _ h₁, erase_append_left _ h₁,&#10;    erase_append_right _ (mt mem_of_mem_erase ha'), erase_cons_head]">
                                          <AtomNode start="(439, 7)" end="(439, 9)" leading="" trailing=" " val="rw"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <OtherNode start="(439, 10)" end="(440, 75)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                            <AtomNode start="(439, 10)" end="(439, 11)" leading="" trailing="" val="["/>
                                            <NullNode start="(439, 11)" end="(440, 74)">
                                              <OtherNode start="(439, 11)" end="(439, 33)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(439, 11)" end="(439, 33)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(439, 11)" end="(439, 28)" leading="" trailing=" " raw_val="erase_append_left" val="erase_append_left" full_name="List.erase_append_left" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(409, 9)" def_end="(409, 26)"/>
                                                  <NullNode start="(439, 29)" end="(439, 33)">
                                                    <TermHoleNode start="(439, 29)" end="(439, 30)">
                                                      <AtomNode start="(439, 29)" end="(439, 30)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <IdentNode start="(439, 31)" end="(439, 33)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(439, 33)" end="(439, 34)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(439, 35)" end="(439, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(439, 35)" end="(439, 57)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(439, 35)" end="(439, 52)" leading="" trailing=" " raw_val="erase_append_left" val="erase_append_left" full_name="List.erase_append_left" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(409, 9)" def_end="(409, 26)"/>
                                                  <NullNode start="(439, 53)" end="(439, 57)">
                                                    <TermHoleNode start="(439, 53)" end="(439, 54)">
                                                      <AtomNode start="(439, 53)" end="(439, 54)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <IdentNode start="(439, 55)" end="(439, 57)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(439, 57)" end="(439, 58)" leading="" trailing="&#10;          " val=","/>
                                              <OtherNode start="(440, 11)" end="(440, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(440, 11)" end="(440, 57)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(440, 11)" end="(440, 29)" leading="" trailing=" " raw_val="erase_append_right" val="erase_append_right" full_name="List.erase_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(413, 9)" def_end="(413, 27)"/>
                                                  <NullNode start="(440, 30)" end="(440, 57)">
                                                    <TermHoleNode start="(440, 30)" end="(440, 31)">
                                                      <AtomNode start="(440, 30)" end="(440, 31)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <OtherNode start="(440, 32)" end="(440, 57)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(440, 32)" end="(440, 33)" leading="" trailing="" val="("/>
                                                      <OtherNode start="(440, 33)" end="(440, 56)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(440, 33)" end="(440, 35)" leading="" trailing=" " raw_val="mt" val="mt" full_name="mt" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                        <NullNode start="(440, 36)" end="(440, 56)">
                                                          <IdentNode start="(440, 36)" end="(440, 52)" leading="" trailing=" " raw_val="mem_of_mem_erase" val="mem_of_mem_erase" full_name="List.mem_of_mem_erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(381, 9)" def_end="(381, 25)"/>
                                                          <IdentNode start="(440, 53)" end="(440, 56)" leading="" trailing="" raw_val="ha'" val="ha'"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(440, 56)" end="(440, 57)" leading="" trailing="" val=")"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(440, 57)" end="(440, 58)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(440, 59)" end="(440, 74)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(440, 59)" end="(440, 74)" leading="" trailing="" raw_val="erase_cons_head" val="erase_cons_head" full_name="List.erase_cons_head" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(307, 17)" def_end="(307, 32)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(440, 74)" end="(440, 75)" leading="" trailing="&#10;    " val="]"/>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                  <AtomNode start="(441, 5)" end="(441, 9)" leading="" trailing="&#10;      " val="else"/>
                                  <TacticTacticseqNode start="(442, 7)" end="(443, 47)">
                                    <TacticTacticseq1IndentedNode start="(442, 7)" end="(443, 47)">
                                      <NullNode start="(442, 7)" end="(443, 47)">
                                        <OtherNode start="(442, 7)" end="(443, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;l : List α&#10;ab : ¬(a == b) = true&#10;l₁ l₂ : List α&#10;ha' : ¬a ∈ l₁&#10;ha : a ∈ l₁ ++ a :: l₂&#10;hb : b ∈ l₁ ++ a :: l₂&#10;h₁ : ¬b ∈ l₁&#10;⊢ (l₁ ++ l₂).erase b = ((l₁ ++ a :: l₂).erase b).erase a" state_after="no goals" tactic="rw [erase_append_right _ h₁, erase_append_right _ h₁, erase_append_right _ ha',&#10;    erase_cons_tail ab, erase_cons_head]">
                                          <AtomNode start="(442, 7)" end="(442, 9)" leading="" trailing=" " val="rw"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <OtherNode start="(442, 10)" end="(443, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                            <AtomNode start="(442, 10)" end="(442, 11)" leading="" trailing="" val="["/>
                                            <NullNode start="(442, 11)" end="(443, 46)">
                                              <OtherNode start="(442, 11)" end="(442, 34)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(442, 11)" end="(442, 34)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(442, 11)" end="(442, 29)" leading="" trailing=" " raw_val="erase_append_right" val="erase_append_right" full_name="List.erase_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(413, 9)" def_end="(413, 27)"/>
                                                  <NullNode start="(442, 30)" end="(442, 34)">
                                                    <TermHoleNode start="(442, 30)" end="(442, 31)">
                                                      <AtomNode start="(442, 30)" end="(442, 31)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <IdentNode start="(442, 32)" end="(442, 34)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(442, 34)" end="(442, 35)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(442, 36)" end="(442, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(442, 36)" end="(442, 59)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(442, 36)" end="(442, 54)" leading="" trailing=" " raw_val="erase_append_right" val="erase_append_right" full_name="List.erase_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(413, 9)" def_end="(413, 27)"/>
                                                  <NullNode start="(442, 55)" end="(442, 59)">
                                                    <TermHoleNode start="(442, 55)" end="(442, 56)">
                                                      <AtomNode start="(442, 55)" end="(442, 56)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <IdentNode start="(442, 57)" end="(442, 59)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(442, 59)" end="(442, 60)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(442, 61)" end="(442, 85)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(442, 61)" end="(442, 85)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(442, 61)" end="(442, 79)" leading="" trailing=" " raw_val="erase_append_right" val="erase_append_right" full_name="List.erase_append_right" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(413, 9)" def_end="(413, 27)"/>
                                                  <NullNode start="(442, 80)" end="(442, 85)">
                                                    <TermHoleNode start="(442, 80)" end="(442, 81)">
                                                      <AtomNode start="(442, 80)" end="(442, 81)" leading="" trailing=" " val="_"/>
                                                    </TermHoleNode>
                                                    <IdentNode start="(442, 82)" end="(442, 85)" leading="" trailing="" raw_val="ha'" val="ha'"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(442, 85)" end="(442, 86)" leading="" trailing="&#10;          " val=","/>
                                              <OtherNode start="(443, 11)" end="(443, 29)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <OtherNode start="(443, 11)" end="(443, 29)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(443, 11)" end="(443, 26)" leading="" trailing=" " raw_val="erase_cons_tail" val="erase_cons_tail" full_name="List.erase_cons_tail" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(310, 17)" def_end="(310, 32)"/>
                                                  <NullNode start="(443, 27)" end="(443, 29)">
                                                    <IdentNode start="(443, 27)" end="(443, 29)" leading="" trailing="" raw_val="ab" val="ab"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(443, 29)" end="(443, 30)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(443, 31)" end="(443, 46)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(443, 31)" end="(443, 46)" leading="" trailing="" raw_val="erase_cons_head" val="erase_cons_head" full_name="List.erase_cons_head" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(307, 17)" def_end="(307, 32)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(443, 46)" end="(443, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(445, 1)" end="(457, 40)" name="erase_eq_iff" full_name="List.erase_eq_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(445, 1)" end="(457, 40)" name="erase_eq_iff" full_name="List.erase_eq_iff" _is_private_decl="False">
        <AtomNode start="(445, 1)" end="(445, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(445, 9)" end="(445, 21)">
          <IdentNode start="(445, 9)" end="(445, 21)" leading="" trailing=" " raw_val="erase_eq_iff" val="erase_eq_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(445, 22)" end="(448, 60)">
          <NullNode start="(445, 22)" end="(445, 56)">
            <OtherNode start="(445, 22)" end="(445, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(445, 22)" end="(445, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(445, 23)" end="(445, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(445, 23)" end="(445, 32)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(445, 33)" end="(445, 34)">
                  <IdentNode start="(445, 33)" end="(445, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(445, 34)" end="(445, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(445, 36)" end="(445, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 36)" end="(445, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 37)" end="(445, 38)">
                <IdentNode start="(445, 37)" end="(445, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(445, 39)" end="(445, 42)">
                <AtomNode start="(445, 39)" end="(445, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(445, 41)" end="(445, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(445, 42)" end="(445, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(445, 44)" end="(445, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(445, 44)" end="(445, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(445, 45)" end="(445, 46)">
                <IdentNode start="(445, 45)" end="(445, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(445, 47)" end="(445, 55)">
                <AtomNode start="(445, 47)" end="(445, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(445, 49)" end="(445, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(445, 49)" end="(445, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(445, 54)" end="(445, 55)">
                    <IdentNode start="(445, 54)" end="(445, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(445, 55)" end="(445, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(445, 57)" end="(448, 60)">
            <AtomNode start="(445, 57)" end="(445, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(446, 5)" end="(448, 60)" kind="«term_↔_»">
              <OtherNode start="(446, 5)" end="(446, 19)" kind="«term_=_»">
                <OtherNode start="(446, 5)" end="(446, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(446, 5)" end="(446, 12)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                  <NullNode start="(446, 13)" end="(446, 14)">
                    <IdentNode start="(446, 13)" end="(446, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(446, 15)" end="(446, 16)" leading="" trailing=" " val="="/>
                <IdentNode start="(446, 17)" end="(446, 19)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </OtherNode>
              <AtomNode start="(446, 20)" end="(446, 21)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(447, 7)" end="(448, 60)" kind="«term_∨_»">
                <OtherNode start="(447, 7)" end="(447, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(447, 7)" end="(447, 8)" leading="" trailing="" val="("/>
                  <OtherNode start="(447, 8)" end="(447, 22)" kind="«term_∧_»">
                    <OtherNode start="(447, 8)" end="(447, 13)" kind="«term_∉_»">
                      <IdentNode start="(447, 8)" end="(447, 9)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(447, 10)" end="(447, 11)" leading="" trailing=" " val="∉"/>
                      <IdentNode start="(447, 12)" end="(447, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(447, 14)" end="(447, 15)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(447, 16)" end="(447, 22)" kind="«term_=_»">
                      <IdentNode start="(447, 16)" end="(447, 17)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(447, 18)" end="(447, 19)" leading="" trailing=" " val="="/>
                      <IdentNode start="(447, 20)" end="(447, 22)" leading="" trailing="" raw_val="l'" val="l'"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(447, 22)" end="(447, 23)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(447, 24)" end="(447, 25)" leading="" trailing="&#10;        " val="∨"/>
                <OtherNode start="(448, 9)" end="(448, 60)" kind="«term∃_,_»">
                  <AtomNode start="(448, 9)" end="(448, 10)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(448, 11)" end="(448, 16)" kind="Lean.explicitBinders">
                    <OtherNode start="(448, 11)" end="(448, 16)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(448, 11)" end="(448, 16)">
                        <LeanBinderidentNode start="(448, 11)" end="(448, 13)">
                          <IdentNode start="(448, 11)" end="(448, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(448, 14)" end="(448, 16)">
                          <IdentNode start="(448, 14)" end="(448, 16)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(448, 16)" end="(448, 17)" leading="" trailing=" " val=","/>
                  <OtherNode start="(448, 18)" end="(448, 60)" kind="«term_∧_»">
                    <OtherNode start="(448, 18)" end="(448, 24)" kind="«term_∉_»">
                      <IdentNode start="(448, 18)" end="(448, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(448, 20)" end="(448, 21)" leading="" trailing=" " val="∉"/>
                      <IdentNode start="(448, 22)" end="(448, 24)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </OtherNode>
                    <AtomNode start="(448, 25)" end="(448, 26)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(448, 27)" end="(448, 60)" kind="«term_∧_»">
                      <OtherNode start="(448, 27)" end="(448, 44)" kind="«term_=_»">
                        <IdentNode start="(448, 27)" end="(448, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                        <AtomNode start="(448, 29)" end="(448, 30)" leading="" trailing=" " val="="/>
                        <OtherNode start="(448, 31)" end="(448, 44)" kind="«term_++_»">
                          <IdentNode start="(448, 31)" end="(448, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <AtomNode start="(448, 34)" end="(448, 36)" leading="" trailing=" " val="++"/>
                          <OtherNode start="(448, 37)" end="(448, 44)" kind="«term_::_»">
                            <IdentNode start="(448, 37)" end="(448, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                            <AtomNode start="(448, 39)" end="(448, 41)" leading="" trailing=" " val="::"/>
                            <IdentNode start="(448, 42)" end="(448, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(448, 45)" end="(448, 46)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(448, 47)" end="(448, 60)" kind="«term_=_»">
                        <IdentNode start="(448, 47)" end="(448, 49)" leading="" trailing=" " raw_val="l'" val="l'"/>
                        <AtomNode start="(448, 50)" end="(448, 51)" leading="" trailing=" " val="="/>
                        <OtherNode start="(448, 52)" end="(448, 60)" kind="«term_++_»">
                          <IdentNode start="(448, 52)" end="(448, 54)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <AtomNode start="(448, 55)" end="(448, 57)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(448, 58)" end="(448, 60)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(448, 61)" end="(457, 40)">
          <AtomNode start="(448, 61)" end="(448, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(448, 64)" end="(457, 40)">
            <AtomNode start="(448, 64)" end="(448, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(449, 3)" end="(457, 40)">
              <TacticTacticseq1IndentedNode start="(449, 3)" end="(457, 40)">
                <NullNode start="(449, 3)" end="(457, 40)">
                  <OtherNode start="(449, 3)" end="(449, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ l.erase a = l' ↔ ¬a ∈ l ∧ l = l' ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l → ¬(a_1 == a) = true) ∧ l = l' ∨&#10;      ∃ a_1 l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬(b == a) = true) ∧ (a_1 == a) = true ∧ l = l₁ ++ a_1 :: l₂ ∧ l' = l₁ ++ l₂) ↔&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" tactic="rw [erase_eq_eraseP', eraseP_eq_iff]">
                    <AtomNode start="(449, 3)" end="(449, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(449, 6)" end="(449, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(449, 6)" end="(449, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(449, 7)" end="(449, 38)">
                        <OtherNode start="(449, 7)" end="(449, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(449, 7)" end="(449, 23)" leading="" trailing="" raw_val="erase_eq_eraseP'" val="erase_eq_eraseP'" full_name="List.erase_eq_eraseP'" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(320, 9)" def_end="(320, 25)"/>
                        </OtherNode>
                        <AtomNode start="(449, 23)" end="(449, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(449, 25)" end="(449, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(449, 25)" end="(449, 38)" leading="" trailing="" raw_val="eraseP_eq_iff" val="eraseP_eq_iff" full_name="List.eraseP_eq_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(223, 9)" def_end="(223, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(449, 38)" end="(449, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(450, 3)" end="(450, 58)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ ((∀ (a_1 : α), a_1 ∈ l → ¬(a_1 == a) = true) ∧ l = l' ∨&#10;      ∃ a_1 l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬(b == a) = true) ∧ (a_1 == a) = true ∧ l = l₁ ++ a_1 :: l₂ ∧ l' = l₁ ++ l₂) ↔&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l' = l₁ ++ l₂" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l' = l₁ ++ x) ↔&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x" tactic="simp only [beq_iff_eq, forall_mem_ne', exists_and_left]">
                    <AtomNode start="(450, 3)" end="(450, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(450, 8)" end="(450, 12)">
                      <AtomNode start="(450, 8)" end="(450, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(450, 13)" end="(450, 58)">
                      <AtomNode start="(450, 13)" end="(450, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(450, 14)" end="(450, 57)">
                        <OtherNode start="(450, 14)" end="(450, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(450, 14)" end="(450, 24)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(450, 24)" end="(450, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(450, 26)" end="(450, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(450, 26)" end="(450, 40)" leading="" trailing="" raw_val="forall_mem_ne'" val="forall_mem_ne'" full_name="List.forall_mem_ne'" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(450, 40)" end="(450, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(450, 42)" end="(450, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(450, 42)" end="(450, 57)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(450, 57)" end="(450, 58)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(451, 3)" end="(451, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l' = l₁ ++ x) ↔&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ a_2 l₁, ¬a ∈ l₁ ∧ a_2 = a ∧ ∃ x, l = l₁ ++ a_2 :: x ∧ l' = l₁ ++ x" tactic="constructor">
                    <AtomNode start="(451, 3)" end="(451, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(452, 3)" end="(454, 41)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ a_2 l₁, ¬a ∈ l₁ ∧ a_2 = a ∧ ∃ x, l = l₁ ++ a_2 :: x ∧ l' = l₁ ++ x" state_after="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ a_2 l₁, ¬a ∈ l₁ ∧ a_2 = a ∧ ∃ x, l = l₁ ++ a_2 :: x ∧ l' = l₁ ++ x" tactic="· rintro (⟨h, rfl⟩ | ⟨a', l', h, rfl, xs, rfl, rfl⟩)&#10;  · left; simp_all&#10;  · right; refine ⟨l', h, xs, by simp⟩">
                    <OtherNode start="(452, 3)" end="(452, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(452, 3)" end="(452, 4)" kind="patternIgnore">
                        <OtherNode start="(452, 3)" end="(452, 4)" kind="token.«· »">
                          <AtomNode start="(452, 3)" end="(452, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(452, 5)" end="(454, 41)">
                      <TacticTacticseq1IndentedNode start="(452, 5)" end="(454, 41)">
                        <NullNode start="(452, 5)" end="(454, 41)">
                          <OtherNode start="(452, 5)" end="(452, 55)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x" state_after="case mp.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l = l₁ ++ x&#10;&#10;case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ¬a' ∈ l' ++ a' :: xs ∧ l' ++ a' :: xs = l' ++ xs ∨&#10;    ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" tactic="rintro (⟨h, rfl⟩ | ⟨a', l', h, rfl, xs, rfl, rfl⟩)">
                            <AtomNode start="(452, 5)" end="(452, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(452, 12)" end="(452, 55)">
                              <OtherNode start="(452, 12)" end="(452, 55)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(452, 12)" end="(452, 55)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(452, 12)" end="(452, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(452, 13)" end="(452, 54)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(452, 13)" end="(452, 54)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(452, 13)" end="(452, 54)">
                                        <OtherNode start="(452, 13)" end="(452, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(452, 13)" end="(452, 14)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(452, 14)" end="(452, 20)">
                                            <OtherNode start="(452, 14)" end="(452, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 14)" end="(452, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 14)" end="(452, 15)">
                                                  <OtherNode start="(452, 14)" end="(452, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 14)" end="(452, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 15)" end="(452, 16)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 17)" end="(452, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 17)" end="(452, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 17)" end="(452, 20)">
                                                  <OtherNode start="(452, 17)" end="(452, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 17)" end="(452, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(452, 20)" end="(452, 21)" leading="" trailing=" " val="⟩"/>
                                        </OtherNode>
                                        <AtomNode start="(452, 22)" end="(452, 23)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(452, 24)" end="(452, 54)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(452, 24)" end="(452, 25)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(452, 25)" end="(452, 53)">
                                            <OtherNode start="(452, 25)" end="(452, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 25)" end="(452, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 25)" end="(452, 27)">
                                                  <OtherNode start="(452, 25)" end="(452, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 25)" end="(452, 27)" leading="" trailing="" raw_val="a'" val="a'"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 27)" end="(452, 28)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 29)" end="(452, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 29)" end="(452, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 29)" end="(452, 31)">
                                                  <OtherNode start="(452, 29)" end="(452, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 29)" end="(452, 31)" leading="" trailing="" raw_val="l'" val="l'"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 31)" end="(452, 32)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 33)" end="(452, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 33)" end="(452, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 33)" end="(452, 34)">
                                                  <OtherNode start="(452, 33)" end="(452, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 33)" end="(452, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 34)" end="(452, 35)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 36)" end="(452, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 36)" end="(452, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 36)" end="(452, 39)">
                                                  <OtherNode start="(452, 36)" end="(452, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 36)" end="(452, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 39)" end="(452, 40)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 41)" end="(452, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 41)" end="(452, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 41)" end="(452, 43)">
                                                  <OtherNode start="(452, 41)" end="(452, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 41)" end="(452, 43)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 43)" end="(452, 44)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 45)" end="(452, 48)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 45)" end="(452, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 45)" end="(452, 48)">
                                                  <OtherNode start="(452, 45)" end="(452, 48)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 45)" end="(452, 48)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(452, 48)" end="(452, 49)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(452, 50)" end="(452, 53)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(452, 50)" end="(452, 53)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(452, 50)" end="(452, 53)">
                                                  <OtherNode start="(452, 50)" end="(452, 53)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(452, 50)" end="(452, 53)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(452, 53)" end="(452, 54)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(452, 54)" end="(452, 55)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(453, 5)" end="(453, 21)" kind="Lean.cdot" state_before="case mp.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l = l₁ ++ x&#10;&#10;case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ¬a' ∈ l' ++ a' :: xs ∧ l' ++ a' :: xs = l' ++ xs ∨&#10;    ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" state_after="case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ¬a' ∈ l' ++ a' :: xs ∧ l' ++ a' :: xs = l' ++ xs ∨&#10;    ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" tactic="· left; simp_all">
                            <OtherNode start="(453, 5)" end="(453, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(453, 5)" end="(453, 6)" kind="patternIgnore">
                                <OtherNode start="(453, 5)" end="(453, 6)" kind="token.«· »">
                                  <AtomNode start="(453, 5)" end="(453, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(453, 7)" end="(453, 21)">
                              <TacticTacticseq1IndentedNode start="(453, 7)" end="(453, 21)">
                                <NullNode start="(453, 7)" end="(453, 21)">
                                  <OtherNode start="(453, 7)" end="(453, 11)" kind="Lean.Parser.Tactic.left" state_before="case mp.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l = l₁ ++ x" state_after="case mp.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l" tactic="left">
                                    <AtomNode start="(453, 7)" end="(453, 11)" leading="" trailing="" val="left"/>
                                  </OtherNode>
                                  <AtomNode start="(453, 11)" end="(453, 12)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(453, 13)" end="(453, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(453, 13)" end="(453, 21)" leading="" trailing="&#10;    " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(454, 5)" end="(454, 41)" kind="Lean.cdot" state_before="case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ¬a' ∈ l' ++ a' :: xs ∧ l' ++ a' :: xs = l' ++ xs ∨&#10;    ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" state_after="no goals" tactic="· right; refine ⟨l', h, xs, by simp⟩">
                            <OtherNode start="(454, 5)" end="(454, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(454, 5)" end="(454, 6)" kind="patternIgnore">
                                <OtherNode start="(454, 5)" end="(454, 6)" kind="token.«· »">
                                  <AtomNode start="(454, 5)" end="(454, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(454, 7)" end="(454, 41)">
                              <TacticTacticseq1IndentedNode start="(454, 7)" end="(454, 41)">
                                <NullNode start="(454, 7)" end="(454, 41)">
                                  <OtherNode start="(454, 7)" end="(454, 12)" kind="Lean.Parser.Tactic.right" state_before="case mp.inr.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ¬a' ∈ l' ++ a' :: xs ∧ l' ++ a' :: xs = l' ++ xs ∨&#10;    ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" state_after="case mp.inr.intro.intro.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" tactic="right">
                                    <AtomNode start="(454, 7)" end="(454, 12)" leading="" trailing="" val="right"/>
                                  </OtherNode>
                                  <AtomNode start="(454, 12)" end="(454, 13)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(454, 14)" end="(454, 41)" kind="Lean.Parser.Tactic.refine" state_before="case mp.inr.intro.intro.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ ∃ l₁, ¬a' ∈ l₁ ∧ ∃ x, l' ++ a' :: xs = l₁ ++ a' :: x ∧ l' ++ xs = l₁ ++ x" state_after="no goals" tactic="refine ⟨l', h, xs, by simp⟩">
                                    <AtomNode start="(454, 14)" end="(454, 20)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(454, 21)" end="(454, 41)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(454, 21)" end="(454, 22)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(454, 22)" end="(454, 40)">
                                        <IdentNode start="(454, 22)" end="(454, 24)" leading="" trailing="" raw_val="l'" val="l'"/>
                                        <AtomNode start="(454, 24)" end="(454, 25)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(454, 26)" end="(454, 27)" leading="" trailing="" raw_val="h" val="h"/>
                                        <AtomNode start="(454, 27)" end="(454, 28)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(454, 29)" end="(454, 31)" leading="" trailing="" raw_val="xs" val="xs"/>
                                        <AtomNode start="(454, 31)" end="(454, 32)" leading="" trailing=" " val=","/>
                                        <TermBytacticNode start="(454, 33)" end="(454, 40)">
                                          <AtomNode start="(454, 33)" end="(454, 35)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(454, 36)" end="(454, 40)">
                                            <TacticTacticseq1IndentedNode start="(454, 36)" end="(454, 40)">
                                              <NullNode start="(454, 36)" end="(454, 40)">
                                                <OtherNode start="(454, 36)" end="(454, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a' : α&#10;l' : List α&#10;h : ¬a' ∈ l'&#10;xs : List α&#10;⊢ l' ++ a' :: xs = l' ++ a' :: xs ∧ l' ++ xs = l' ++ xs" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(454, 36)" end="(454, 40)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </NullNode>
                                      <AtomNode start="(454, 40)" end="(454, 41)" leading="" trailing="&#10;  " val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(455, 3)" end="(457, 40)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ a_2 l₁, ¬a ∈ l₁ ∧ a_2 = a ∧ ∃ x, l = l₁ ++ a_2 :: x ∧ l' = l₁ ++ x" state_after="no goals" tactic="· rintro (⟨h, rfl⟩ | ⟨l₁, h, xs, rfl, rfl⟩)&#10;  · left; simp_all&#10;  · right; refine ⟨a, l₁, h, by simp⟩">
                    <OtherNode start="(455, 3)" end="(455, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(455, 3)" end="(455, 4)" kind="patternIgnore">
                        <OtherNode start="(455, 3)" end="(455, 4)" kind="token.«· »">
                          <AtomNode start="(455, 3)" end="(455, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(455, 5)" end="(457, 40)">
                      <TacticTacticseq1IndentedNode start="(455, 5)" end="(457, 40)">
                        <NullNode start="(455, 5)" end="(457, 40)">
                          <OtherNode start="(455, 5)" end="(455, 46)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;l' : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;⊢ (¬a ∈ l ∧ l = l' ∨ ∃ l₁, ¬a ∈ l₁ ∧ ∃ x, l = l₁ ++ a :: x ∧ l' = l₁ ++ x) →&#10;    ¬a ∈ l ∧ l = l' ∨ ∃ a_2 l₁, ¬a ∈ l₁ ∧ a_2 = a ∧ ∃ x, l = l₁ ++ a_2 :: x ∧ l' = l₁ ++ x" state_after="case mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l = l₁ ++ x&#10;&#10;case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ¬a ∈ l₁ ++ a :: xs ∧ l₁ ++ a :: xs = l₁ ++ xs ∨&#10;    ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" tactic="rintro (⟨h, rfl⟩ | ⟨l₁, h, xs, rfl, rfl⟩)">
                            <AtomNode start="(455, 5)" end="(455, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(455, 12)" end="(455, 46)">
                              <OtherNode start="(455, 12)" end="(455, 46)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(455, 12)" end="(455, 46)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                  <AtomNode start="(455, 12)" end="(455, 13)" leading="" trailing="" val="("/>
                                  <OtherNode start="(455, 13)" end="(455, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                    <OtherNode start="(455, 13)" end="(455, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                      <NullNode start="(455, 13)" end="(455, 45)">
                                        <OtherNode start="(455, 13)" end="(455, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(455, 13)" end="(455, 14)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(455, 14)" end="(455, 20)">
                                            <OtherNode start="(455, 14)" end="(455, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 14)" end="(455, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 14)" end="(455, 15)">
                                                  <OtherNode start="(455, 14)" end="(455, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 14)" end="(455, 15)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(455, 15)" end="(455, 16)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(455, 17)" end="(455, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 17)" end="(455, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 17)" end="(455, 20)">
                                                  <OtherNode start="(455, 17)" end="(455, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 17)" end="(455, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(455, 20)" end="(455, 21)" leading="" trailing=" " val="⟩"/>
                                        </OtherNode>
                                        <AtomNode start="(455, 22)" end="(455, 23)" leading="" trailing=" " val="|"/>
                                        <OtherNode start="(455, 24)" end="(455, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(455, 24)" end="(455, 25)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(455, 25)" end="(455, 44)">
                                            <OtherNode start="(455, 25)" end="(455, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 25)" end="(455, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 25)" end="(455, 27)">
                                                  <OtherNode start="(455, 25)" end="(455, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 25)" end="(455, 27)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(455, 27)" end="(455, 28)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(455, 29)" end="(455, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 29)" end="(455, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 29)" end="(455, 30)">
                                                  <OtherNode start="(455, 29)" end="(455, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 29)" end="(455, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(455, 30)" end="(455, 31)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(455, 32)" end="(455, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 32)" end="(455, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 32)" end="(455, 34)">
                                                  <OtherNode start="(455, 32)" end="(455, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 32)" end="(455, 34)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(455, 34)" end="(455, 35)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(455, 36)" end="(455, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 36)" end="(455, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 36)" end="(455, 39)">
                                                  <OtherNode start="(455, 36)" end="(455, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 36)" end="(455, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(455, 39)" end="(455, 40)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(455, 41)" end="(455, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(455, 41)" end="(455, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(455, 41)" end="(455, 44)">
                                                  <OtherNode start="(455, 41)" end="(455, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(455, 41)" end="(455, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(455, 44)" end="(455, 45)" leading="" trailing="" val="⟩"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(455, 45)" end="(455, 46)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(456, 5)" end="(456, 21)" kind="Lean.cdot" state_before="case mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l = l₁ ++ x&#10;&#10;case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ¬a ∈ l₁ ++ a :: xs ∧ l₁ ++ a :: xs = l₁ ++ xs ∨&#10;    ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" state_after="case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ¬a ∈ l₁ ++ a :: xs ∧ l₁ ++ a :: xs = l₁ ++ xs ∨&#10;    ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" tactic="· left; simp_all">
                            <OtherNode start="(456, 5)" end="(456, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(456, 5)" end="(456, 6)" kind="patternIgnore">
                                <OtherNode start="(456, 5)" end="(456, 6)" kind="token.«· »">
                                  <AtomNode start="(456, 5)" end="(456, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(456, 7)" end="(456, 21)">
                              <TacticTacticseq1IndentedNode start="(456, 7)" end="(456, 21)">
                                <NullNode start="(456, 7)" end="(456, 21)">
                                  <OtherNode start="(456, 7)" end="(456, 11)" kind="Lean.Parser.Tactic.left" state_before="case mpr.inl.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l ∨ ∃ a_1 l₁, ¬a ∈ l₁ ∧ a_1 = a ∧ ∃ x, l = l₁ ++ a_1 :: x ∧ l = l₁ ++ x" state_after="case mpr.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l" tactic="left">
                                    <AtomNode start="(456, 7)" end="(456, 11)" leading="" trailing="" val="left"/>
                                  </OtherNode>
                                  <AtomNode start="(456, 11)" end="(456, 12)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(456, 13)" end="(456, 21)" kind="Lean.Parser.Tactic.simpAll" state_before="case mpr.inl.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l" state_after="no goals" tactic="simp_all">
                                    <AtomNode start="(456, 13)" end="(456, 21)" leading="" trailing="&#10;    " val="simp_all"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(457, 5)" end="(457, 40)" kind="Lean.cdot" state_before="case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ¬a ∈ l₁ ++ a :: xs ∧ l₁ ++ a :: xs = l₁ ++ xs ∨&#10;    ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" state_after="no goals" tactic="· right; refine ⟨a, l₁, h, by simp⟩">
                            <OtherNode start="(457, 5)" end="(457, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(457, 5)" end="(457, 6)" kind="patternIgnore">
                                <OtherNode start="(457, 5)" end="(457, 6)" kind="token.«· »">
                                  <AtomNode start="(457, 5)" end="(457, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(457, 7)" end="(457, 40)">
                              <TacticTacticseq1IndentedNode start="(457, 7)" end="(457, 40)">
                                <NullNode start="(457, 7)" end="(457, 40)">
                                  <OtherNode start="(457, 7)" end="(457, 12)" kind="Lean.Parser.Tactic.right" state_before="case mpr.inr.intro.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ¬a ∈ l₁ ++ a :: xs ∧ l₁ ++ a :: xs = l₁ ++ xs ∨&#10;    ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" state_after="case mpr.inr.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" tactic="right">
                                    <AtomNode start="(457, 7)" end="(457, 12)" leading="" trailing="" val="right"/>
                                  </OtherNode>
                                  <AtomNode start="(457, 12)" end="(457, 13)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(457, 14)" end="(457, 40)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.inr.intro.intro.intro.intro.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ ∃ a_1 l₁_1, ¬a ∈ l₁_1 ∧ a_1 = a ∧ ∃ x, l₁ ++ a :: xs = l₁_1 ++ a_1 :: x ∧ l₁ ++ xs = l₁_1 ++ x" state_after="no goals" tactic="refine ⟨a, l₁, h, by simp⟩">
                                    <AtomNode start="(457, 14)" end="(457, 20)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(457, 21)" end="(457, 40)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(457, 21)" end="(457, 22)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(457, 22)" end="(457, 39)">
                                        <IdentNode start="(457, 22)" end="(457, 23)" leading="" trailing="" raw_val="a" val="a"/>
                                        <AtomNode start="(457, 23)" end="(457, 24)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(457, 25)" end="(457, 27)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                        <AtomNode start="(457, 27)" end="(457, 28)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(457, 29)" end="(457, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                        <AtomNode start="(457, 30)" end="(457, 31)" leading="" trailing=" " val=","/>
                                        <TermBytacticNode start="(457, 32)" end="(457, 39)">
                                          <AtomNode start="(457, 32)" end="(457, 34)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(457, 35)" end="(457, 39)">
                                            <TacticTacticseq1IndentedNode start="(457, 35)" end="(457, 39)">
                                              <NullNode start="(457, 35)" end="(457, 39)">
                                                <OtherNode start="(457, 35)" end="(457, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;l₁ : List α&#10;h : ¬a ∈ l₁&#10;xs : List α&#10;⊢ a = a ∧ ∃ x, l₁ ++ a :: xs = l₁ ++ a :: x ∧ l₁ ++ xs = l₁ ++ x" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(457, 35)" end="(457, 39)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </NullNode>
                                      <AtomNode start="(457, 39)" end="(457, 40)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(459, 1)" end="(461, 36)" name="erase_replicate_self" full_name="List.erase_replicate_self">
      <CommandDeclmodifiersNode start="(459, 1)" end="(459, 8)">
        <NullNode/>
        <NullNode start="(459, 1)" end="(459, 8)">
          <OtherNode start="(459, 1)" end="(459, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(459, 1)" end="(459, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(459, 3)" end="(459, 7)">
              <OtherNode start="(459, 3)" end="(459, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(459, 3)" end="(459, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(459, 3)" end="(459, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(459, 7)" end="(459, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(459, 9)" end="(461, 36)" name="erase_replicate_self" full_name="List.erase_replicate_self" _is_private_decl="False">
        <AtomNode start="(459, 9)" end="(459, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(459, 17)" end="(459, 37)">
          <IdentNode start="(459, 17)" end="(459, 37)" leading="" trailing=" " raw_val="erase_replicate_self" val="erase_replicate_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(459, 38)" end="(460, 50)">
          <NullNode start="(459, 38)" end="(459, 59)">
            <OtherNode start="(459, 38)" end="(459, 51)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(459, 38)" end="(459, 39)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(459, 39)" end="(459, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(459, 39)" end="(459, 48)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(459, 49)" end="(459, 50)">
                  <IdentNode start="(459, 49)" end="(459, 50)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(459, 50)" end="(459, 51)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(459, 52)" end="(459, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(459, 52)" end="(459, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(459, 53)" end="(459, 54)">
                <IdentNode start="(459, 53)" end="(459, 54)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(459, 55)" end="(459, 58)">
                <AtomNode start="(459, 55)" end="(459, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(459, 57)" end="(459, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(459, 58)" end="(459, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(459, 60)" end="(460, 50)">
            <AtomNode start="(459, 60)" end="(459, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(460, 5)" end="(460, 50)" kind="«term_=_»">
              <OtherNode start="(460, 5)" end="(460, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(460, 5)" end="(460, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(460, 5)" end="(460, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(460, 5)" end="(460, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(460, 6)" end="(460, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(460, 6)" end="(460, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(460, 16)" end="(460, 19)">
                        <IdentNode start="(460, 16)" end="(460, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(460, 18)" end="(460, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(460, 19)" end="(460, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(460, 20)" end="(460, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(460, 21)" end="(460, 26)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(460, 27)" end="(460, 28)">
                  <IdentNode start="(460, 27)" end="(460, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(460, 29)" end="(460, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(460, 31)" end="(460, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(460, 31)" end="(460, 40)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(460, 41)" end="(460, 50)">
                  <OtherNode start="(460, 41)" end="(460, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(460, 41)" end="(460, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(460, 42)" end="(460, 47)" kind="«term_-_»">
                      <IdentNode start="(460, 42)" end="(460, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                      <AtomNode start="(460, 44)" end="(460, 45)" leading="" trailing=" " val="-"/>
                      <OtherNode start="(460, 46)" end="(460, 47)" kind="num">
                        <AtomNode start="(460, 46)" end="(460, 47)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(460, 47)" end="(460, 48)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(460, 49)" end="(460, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(460, 51)" end="(461, 36)">
          <AtomNode start="(460, 51)" end="(460, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(460, 54)" end="(461, 36)">
            <AtomNode start="(460, 54)" end="(460, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(461, 3)" end="(461, 36)">
              <TacticTacticseq1IndentedNode start="(461, 3)" end="(461, 36)">
                <NullNode start="(461, 3)" end="(461, 36)">
                  <OtherNode start="(461, 3)" end="(461, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ (replicate n a).erase a = replicate (n - 1) a" state_after="no goals" tactic="cases n &amp;lt;;&amp;gt; simp [replicate_succ]">
                    <OtherNode start="(461, 3)" end="(461, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(461, 3)" end="(461, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(461, 9)" end="(461, 10)">
                        <OtherNode start="(461, 9)" end="(461, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(461, 9)" end="(461, 10)" leading="" trailing=" " raw_val="n" val="n"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(461, 11)" end="(461, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(461, 15)" end="(461, 36)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(461, 15)" end="(461, 19)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(461, 20)" end="(461, 36)">
                        <AtomNode start="(461, 20)" end="(461, 21)" leading="" trailing="" val="["/>
                        <NullNode start="(461, 21)" end="(461, 35)">
                          <OtherNode start="(461, 21)" end="(461, 35)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(461, 21)" end="(461, 35)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(461, 35)" end="(461, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(463, 1)" end="(466, 11)" name="erase_replicate_ne" full_name="List.erase_replicate_ne">
      <CommandDeclmodifiersNode start="(463, 1)" end="(463, 8)">
        <NullNode/>
        <NullNode start="(463, 1)" end="(463, 8)">
          <OtherNode start="(463, 1)" end="(463, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(463, 1)" end="(463, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(463, 3)" end="(463, 7)">
              <OtherNode start="(463, 3)" end="(463, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(463, 3)" end="(463, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(463, 3)" end="(463, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(463, 7)" end="(463, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(463, 9)" end="(466, 11)" name="erase_replicate_ne" full_name="List.erase_replicate_ne" _is_private_decl="False">
        <AtomNode start="(463, 9)" end="(463, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(463, 17)" end="(463, 35)">
          <IdentNode start="(463, 17)" end="(463, 35)" leading="" trailing=" " raw_val="erase_replicate_ne" val="erase_replicate_ne"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(463, 36)" end="(464, 44)">
          <NullNode start="(463, 36)" end="(463, 73)">
            <OtherNode start="(463, 36)" end="(463, 49)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(463, 36)" end="(463, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(463, 37)" end="(463, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(463, 37)" end="(463, 46)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(463, 47)" end="(463, 48)">
                  <IdentNode start="(463, 47)" end="(463, 48)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(463, 48)" end="(463, 49)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(463, 50)" end="(463, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(463, 50)" end="(463, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(463, 51)" end="(463, 54)">
                <IdentNode start="(463, 51)" end="(463, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(463, 53)" end="(463, 54)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(463, 55)" end="(463, 58)">
                <AtomNode start="(463, 55)" end="(463, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(463, 57)" end="(463, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(463, 58)" end="(463, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(463, 60)" end="(463, 73)">
              <AtomNode start="(463, 60)" end="(463, 61)" leading="" trailing="" val="("/>
              <NullNode start="(463, 61)" end="(463, 62)">
                <IdentNode start="(463, 61)" end="(463, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(463, 63)" end="(463, 72)">
                <AtomNode start="(463, 63)" end="(463, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(463, 65)" end="(463, 72)" kind="term!_">
                  <AtomNode start="(463, 65)" end="(463, 66)" leading="" trailing="" val="!"/>
                  <OtherNode start="(463, 66)" end="(463, 72)" kind="«term_==_»">
                    <IdentNode start="(463, 66)" end="(463, 67)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(463, 68)" end="(463, 70)" leading="" trailing=" " val="=="/>
                    <IdentNode start="(463, 71)" end="(463, 72)" leading="" trailing="" raw_val="a" val="a"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(463, 72)" end="(463, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(463, 74)" end="(464, 44)">
            <AtomNode start="(463, 74)" end="(463, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(464, 5)" end="(464, 44)" kind="«term_=_»">
              <OtherNode start="(464, 5)" end="(464, 28)" kind="Lean.Parser.Term.app">
                <OtherNode start="(464, 5)" end="(464, 26)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(464, 5)" end="(464, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(464, 5)" end="(464, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(464, 6)" end="(464, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(464, 6)" end="(464, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(464, 16)" end="(464, 19)">
                        <IdentNode start="(464, 16)" end="(464, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(464, 18)" end="(464, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(464, 19)" end="(464, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(464, 20)" end="(464, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(464, 21)" end="(464, 26)" leading="" trailing=" " raw_val="erase" val="erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(464, 27)" end="(464, 28)">
                  <IdentNode start="(464, 27)" end="(464, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(464, 29)" end="(464, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(464, 31)" end="(464, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(464, 31)" end="(464, 40)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(464, 41)" end="(464, 44)">
                  <IdentNode start="(464, 41)" end="(464, 42)" leading="" trailing=" " raw_val="n" val="n"/>
                  <IdentNode start="(464, 43)" end="(464, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(464, 45)" end="(466, 11)">
          <AtomNode start="(464, 45)" end="(464, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(464, 48)" end="(466, 11)">
            <AtomNode start="(464, 48)" end="(464, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(465, 3)" end="(466, 11)">
              <TacticTacticseq1IndentedNode start="(465, 3)" end="(466, 11)">
                <NullNode start="(465, 3)" end="(466, 11)">
                  <OtherNode start="(465, 3)" end="(465, 24)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;h : (!b == a) = true&#10;⊢ (replicate n a).erase b = replicate n a" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;h : (!b == a) = true&#10;⊢ ¬b ∈ replicate n a" tactic="rw [erase_of_not_mem]">
                    <AtomNode start="(465, 3)" end="(465, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(465, 6)" end="(465, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(465, 6)" end="(465, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(465, 7)" end="(465, 23)">
                        <OtherNode start="(465, 7)" end="(465, 23)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(465, 7)" end="(465, 23)" leading="" trailing="" raw_val="erase_of_not_mem" val="erase_of_not_mem" full_name="List.erase_of_not_mem" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(313, 9)" def_end="(313, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(465, 23)" end="(465, 24)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(466, 3)" end="(466, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;n : Nat&#10;inst✝ : LawfulBEq α&#10;a b : α&#10;h : (!b == a) = true&#10;⊢ ¬b ∈ replicate n a" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(466, 3)" end="(466, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(468, 1)" end="(469, 36)" name="Pairwise.erase" full_name="List.Pairwise.erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(468, 1)" end="(469, 36)" name="Pairwise.erase" full_name="List.Pairwise.erase" _is_private_decl="False">
        <AtomNode start="(468, 1)" end="(468, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(468, 9)" end="(468, 23)">
          <IdentNode start="(468, 9)" end="(468, 23)" leading="" trailing=" " raw_val="Pairwise.erase" val="Pairwise.erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(468, 24)" end="(468, 94)">
          <NullNode start="(468, 24)" end="(468, 54)">
            <OtherNode start="(468, 24)" end="(468, 37)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(468, 24)" end="(468, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(468, 25)" end="(468, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(468, 25)" end="(468, 34)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(468, 35)" end="(468, 36)">
                  <IdentNode start="(468, 35)" end="(468, 36)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(468, 36)" end="(468, 37)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(468, 38)" end="(468, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(468, 38)" end="(468, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(468, 39)" end="(468, 40)">
                <IdentNode start="(468, 39)" end="(468, 40)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(468, 41)" end="(468, 49)">
                <AtomNode start="(468, 41)" end="(468, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(468, 43)" end="(468, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(468, 43)" end="(468, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(468, 48)" end="(468, 49)">
                    <IdentNode start="(468, 48)" end="(468, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(468, 49)" end="(468, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(468, 51)" end="(468, 54)">
              <AtomNode start="(468, 51)" end="(468, 52)" leading="" trailing="" val="("/>
              <NullNode start="(468, 52)" end="(468, 53)">
                <IdentNode start="(468, 52)" end="(468, 53)" leading="" trailing="" raw_val="a" val="a"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(468, 53)" end="(468, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(468, 55)" end="(468, 94)">
            <AtomNode start="(468, 55)" end="(468, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(468, 57)" end="(468, 94)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(468, 57)" end="(468, 69)" kind="Lean.Parser.Term.app">
                <IdentNode start="(468, 57)" end="(468, 65)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(468, 66)" end="(468, 69)">
                  <IdentNode start="(468, 66)" end="(468, 67)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(468, 68)" end="(468, 69)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(468, 70)" end="(468, 71)" leading="" trailing=" " val="→"/>
              <OtherNode start="(468, 72)" end="(468, 94)" kind="Lean.Parser.Term.app">
                <IdentNode start="(468, 72)" end="(468, 80)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(468, 81)" end="(468, 94)">
                  <IdentNode start="(468, 81)" end="(468, 82)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(468, 83)" end="(468, 94)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(468, 83)" end="(468, 84)" leading="" trailing="" val="("/>
                    <OtherNode start="(468, 84)" end="(468, 93)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(468, 84)" end="(468, 91)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(468, 92)" end="(468, 93)">
                        <IdentNode start="(468, 92)" end="(468, 93)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(468, 93)" end="(468, 94)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(468, 95)" end="(469, 36)">
          <AtomNode start="(468, 95)" end="(468, 97)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(469, 3)" end="(469, 36)" kind="«term_&amp;lt;|_»">
            <IdentNode start="(469, 3)" end="(469, 19)" leading="" trailing=" " raw_val="Pairwise.sublist" val="Pairwise.sublist" full_name="List.Pairwise.sublist" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
            <AtomNode start="(469, 20)" end="(469, 22)" leading="" trailing=" " val="&amp;lt;|"/>
            <IdentNode start="(469, 23)" end="(469, 36)" leading="" trailing="&#10;&#10;" raw_val="erase_sublist" val="erase_sublist" full_name="List.erase_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(363, 9)" def_end="(363, 22)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(471, 1)" end="(482, 38)" name="Nodup.erase_eq_filter" full_name="List.Nodup.erase_eq_filter">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(471, 1)" end="(482, 38)" name="Nodup.erase_eq_filter" full_name="List.Nodup.erase_eq_filter" _is_private_decl="False">
        <AtomNode start="(471, 1)" end="(471, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(471, 9)" end="(471, 30)">
          <IdentNode start="(471, 9)" end="(471, 30)" leading="" trailing=" " raw_val="Nodup.erase_eq_filter" val="Nodup.erase_eq_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(471, 31)" end="(471, 102)">
          <NullNode start="(471, 31)" end="(471, 70)">
            <OtherNode start="(471, 31)" end="(471, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(471, 31)" end="(471, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(471, 32)" end="(471, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(471, 32)" end="(471, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(471, 42)" end="(471, 43)">
                  <IdentNode start="(471, 42)" end="(471, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(471, 43)" end="(471, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(471, 45)" end="(471, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(471, 45)" end="(471, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(471, 46)" end="(471, 47)">
                <IdentNode start="(471, 46)" end="(471, 47)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(471, 47)" end="(471, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(471, 49)" end="(471, 62)">
              <AtomNode start="(471, 49)" end="(471, 50)" leading="" trailing="" val="("/>
              <NullNode start="(471, 50)" end="(471, 51)">
                <IdentNode start="(471, 50)" end="(471, 51)" leading="" trailing=" " raw_val="d" val="d"/>
              </NullNode>
              <NullNode start="(471, 52)" end="(471, 61)">
                <AtomNode start="(471, 52)" end="(471, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(471, 54)" end="(471, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(471, 54)" end="(471, 59)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(471, 60)" end="(471, 61)">
                    <IdentNode start="(471, 60)" end="(471, 61)" leading="" trailing="" raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(471, 61)" end="(471, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(471, 63)" end="(471, 70)">
              <AtomNode start="(471, 63)" end="(471, 64)" leading="" trailing="" val="("/>
              <NullNode start="(471, 64)" end="(471, 65)">
                <IdentNode start="(471, 64)" end="(471, 65)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(471, 66)" end="(471, 69)">
                <AtomNode start="(471, 66)" end="(471, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(471, 68)" end="(471, 69)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(471, 69)" end="(471, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(471, 71)" end="(471, 102)">
            <AtomNode start="(471, 71)" end="(471, 72)" leading="" trailing=" " val=":"/>
            <OtherNode start="(471, 73)" end="(471, 102)" kind="«term_=_»">
              <OtherNode start="(471, 73)" end="(471, 82)" kind="Lean.Parser.Term.app">
                <IdentNode start="(471, 73)" end="(471, 80)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(471, 81)" end="(471, 82)">
                  <IdentNode start="(471, 81)" end="(471, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(471, 83)" end="(471, 84)" leading="" trailing=" " val="="/>
              <OtherNode start="(471, 85)" end="(471, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(471, 85)" end="(471, 93)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                <NullNode start="(471, 94)" end="(471, 102)">
                  <OtherNode start="(471, 94)" end="(471, 102)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(471, 94)" end="(471, 95)" leading="" trailing="" val="("/>
                    <OtherNode start="(471, 95)" end="(471, 101)" kind="«term_!=_»">
                      <OtherNode start="(471, 95)" end="(471, 96)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(471, 95)" end="(471, 96)" leading="" trailing=" " val="·"/>
                      </OtherNode>
                      <AtomNode start="(471, 97)" end="(471, 99)" leading="" trailing=" " val="!="/>
                      <IdentNode start="(471, 100)" end="(471, 101)" leading="" trailing="" raw_val="a" val="a"/>
                    </OtherNode>
                    <AtomNode start="(471, 101)" end="(471, 102)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(471, 103)" end="(482, 38)">
          <AtomNode start="(471, 103)" end="(471, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(471, 106)" end="(482, 38)">
            <AtomNode start="(471, 106)" end="(471, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(472, 3)" end="(482, 38)">
              <TacticTacticseq1IndentedNode start="(472, 3)" end="(482, 38)">
                <NullNode start="(472, 3)" end="(482, 38)">
                  <OtherNode start="(472, 3)" end="(482, 38)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;d : l.Nodup&#10;a : α&#10;⊢ l.erase a = filter (fun x =&amp;gt; x != a) l" state_after="no goals" tactic="induction d with&#10;| nil =&amp;gt; rfl&#10;| cons m _n ih =&amp;gt;&#10;  rename_i b l&#10;  by_cases h : b = a&#10;  · subst h&#10;    rw [erase_cons_head, filter_cons_of_neg (by simp)]&#10;    apply Eq.symm&#10;    rw [filter_eq_self]&#10;    simpa [@eq_comm α] using m&#10;  · simp [beq_false_of_ne h, ih, h]">
                    <AtomNode start="(472, 3)" end="(472, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(472, 13)" end="(472, 14)">
                      <OtherNode start="(472, 13)" end="(472, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(472, 13)" end="(472, 14)" leading="" trailing=" " raw_val="d" val="d"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(472, 15)" end="(482, 38)">
                      <OtherNode start="(472, 15)" end="(482, 38)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(472, 15)" end="(472, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(473, 3)" end="(482, 38)">
                          <OtherNode start="(473, 3)" end="(473, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(473, 3)" end="(473, 8)">
                              <OtherNode start="(473, 3)" end="(473, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(473, 3)" end="(473, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(473, 5)" end="(473, 8)">
                                  <NullNode/>
                                  <IdentNode start="(473, 5)" end="(473, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.Pairwise.nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(473, 9)" end="(473, 15)">
                              <AtomNode start="(473, 9)" end="(473, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(473, 12)" end="(473, 15)">
                                <TacticTacticseq1IndentedNode start="(473, 12)" end="(473, 15)">
                                  <NullNode start="(473, 12)" end="(473, 15)">
                                    <OtherNode start="(473, 12)" end="(473, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ [].erase a = filter (fun x =&amp;gt; x != a) []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(473, 12)" end="(473, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(474, 3)" end="(482, 38)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(474, 3)" end="(474, 17)">
                              <OtherNode start="(474, 3)" end="(474, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(474, 3)" end="(474, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(474, 5)" end="(474, 9)">
                                  <NullNode/>
                                  <IdentNode start="(474, 5)" end="(474, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.Pairwise.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(474, 10)" end="(474, 17)">
                                  <IdentNode start="(474, 10)" end="(474, 11)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(474, 12)" end="(474, 14)" leading="" trailing=" " raw_val="_n" val="_n"/>
                                  <IdentNode start="(474, 15)" end="(474, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(474, 18)" end="(482, 38)">
                              <AtomNode start="(474, 18)" end="(474, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(475, 5)" end="(482, 38)">
                                <TacticTacticseq1IndentedNode start="(475, 5)" end="(482, 38)">
                                  <NullNode start="(475, 5)" end="(482, 38)">
                                    <OtherNode start="(475, 5)" end="(475, 17)" kind="Lean.Parser.Tactic.renameI" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a a✝ : α&#10;l✝ : List α&#10;m : ∀ (a' : α), a' ∈ l✝ → a✝ ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l✝&#10;ih : l✝.erase a = filter (fun x =&amp;gt; x != a) l✝&#10;⊢ (a✝ :: l✝).erase a = filter (fun x =&amp;gt; x != a) (a✝ :: l✝)" state_after="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" tactic="rename_i b l">
                                      <AtomNode start="(475, 5)" end="(475, 13)" leading="" trailing=" " val="rename_i"/>
                                      <NullNode start="(475, 14)" end="(475, 17)">
                                        <LeanBinderidentNode start="(475, 14)" end="(475, 15)">
                                          <IdentNode start="(475, 14)" end="(475, 15)" leading="" trailing=" " raw_val="b" val="b"/>
                                        </LeanBinderidentNode>
                                        <LeanBinderidentNode start="(475, 16)" end="(475, 17)">
                                          <IdentNode start="(475, 16)" end="(475, 17)" leading="" trailing="&#10;    " raw_val="l" val="l"/>
                                        </LeanBinderidentNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(476, 5)" end="(476, 23)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : ¬b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" tactic="by_cases h : b = a">
                                      <AtomNode start="(476, 5)" end="(476, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(476, 14)" end="(476, 17)">
                                        <IdentNode start="(476, 14)" end="(476, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <AtomNode start="(476, 16)" end="(476, 17)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(476, 18)" end="(476, 23)" kind="«term_=_»">
                                        <IdentNode start="(476, 18)" end="(476, 19)" leading="" trailing=" " raw_val="b" val="b"/>
                                        <AtomNode start="(476, 20)" end="(476, 21)" leading="" trailing=" " val="="/>
                                        <IdentNode start="(476, 22)" end="(476, 23)" leading="" trailing="&#10;    " raw_val="a" val="a"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(477, 5)" end="(481, 33)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : ¬b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : ¬b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" tactic="· subst h&#10;  rw [erase_cons_head, filter_cons_of_neg (by simp)]&#10;  apply Eq.symm&#10;  rw [filter_eq_self]&#10;  simpa [@eq_comm α] using m">
                                      <OtherNode start="(477, 5)" end="(477, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(477, 5)" end="(477, 6)" kind="patternIgnore">
                                          <OtherNode start="(477, 5)" end="(477, 6)" kind="token.«· »">
                                            <AtomNode start="(477, 5)" end="(477, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(477, 7)" end="(481, 33)">
                                        <TacticTacticseq1IndentedNode start="(477, 7)" end="(481, 33)">
                                          <NullNode start="(477, 7)" end="(481, 33)">
                                            <OtherNode start="(477, 7)" end="(477, 14)" kind="Lean.Parser.Tactic.subst" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ (b :: l).erase b = filter (fun x =&amp;gt; x != b) (b :: l)" tactic="subst h">
                                              <AtomNode start="(477, 7)" end="(477, 12)" leading="" trailing=" " val="subst"/>
                                              <NullNode start="(477, 13)" end="(477, 14)">
                                                <IdentNode start="(477, 13)" end="(477, 14)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(478, 7)" end="(478, 57)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ (b :: l).erase b = filter (fun x =&amp;gt; x != b) (b :: l)" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ l = filter (fun x =&amp;gt; x != b) l" tactic="rw [erase_cons_head, filter_cons_of_neg (by simp)]">
                                              <AtomNode start="(478, 7)" end="(478, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(478, 10)" end="(478, 57)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(478, 10)" end="(478, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(478, 11)" end="(478, 56)">
                                                  <OtherNode start="(478, 11)" end="(478, 26)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(478, 11)" end="(478, 26)" leading="" trailing="" raw_val="erase_cons_head" val="erase_cons_head" full_name="List.erase_cons_head" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(307, 17)" def_end="(307, 32)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(478, 26)" end="(478, 27)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(478, 28)" end="(478, 56)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(478, 28)" end="(478, 56)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(478, 28)" end="(478, 46)" leading="" trailing=" " raw_val="filter_cons_of_neg" val="filter_cons_of_neg" full_name="List.filter_cons_of_neg" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                      <NullNode start="(478, 47)" end="(478, 56)">
                                                        <OtherNode start="(478, 47)" end="(478, 56)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(478, 47)" end="(478, 48)" leading="" trailing="" val="("/>
                                                          <TermBytacticNode start="(478, 48)" end="(478, 55)">
                                                            <AtomNode start="(478, 48)" end="(478, 50)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(478, 51)" end="(478, 55)">
                                                            <TacticTacticseq1IndentedNode start="(478, 51)" end="(478, 55)">
                                                            <NullNode start="(478, 51)" end="(478, 55)">
                                                            <OtherNode start="(478, 51)" end="(478, 55)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ ¬(b != b) = true" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(478, 51)" end="(478, 55)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(478, 55)" end="(478, 56)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(478, 56)" end="(478, 57)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(479, 7)" end="(479, 20)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ l = filter (fun x =&amp;gt; x != b) l" state_after="case pos.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ filter (fun x =&amp;gt; x != b) l = l" tactic="apply Eq.symm">
                                              <AtomNode start="(479, 7)" end="(479, 12)" leading="" trailing=" " val="apply"/>
                                              <IdentNode start="(479, 13)" end="(479, 20)" leading="" trailing="&#10;      " raw_val="Eq.symm" val="Eq.symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(480, 7)" end="(480, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case pos.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ filter (fun x =&amp;gt; x != b) l = l" state_after="case pos.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ ∀ (a : α), a ∈ l → (a != b) = true" tactic="rw [filter_eq_self]">
                                              <AtomNode start="(480, 7)" end="(480, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(480, 10)" end="(480, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(480, 10)" end="(480, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(480, 11)" end="(480, 25)">
                                                  <OtherNode start="(480, 11)" end="(480, 25)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(480, 11)" end="(480, 25)" leading="" trailing="" raw_val="filter_eq_self" val="filter_eq_self" full_name="List.filter_eq_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(480, 25)" end="(480, 26)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(481, 7)" end="(481, 33)" kind="Lean.Parser.Tactic.simpa" state_before="case pos.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase b = filter (fun x =&amp;gt; x != b) l&#10;⊢ ∀ (a : α), a ∈ l → (a != b) = true" state_after="no goals" tactic="simpa [@eq_comm α] using m">
                                              <AtomNode start="(481, 7)" end="(481, 12)" leading="" trailing=" " val="simpa"/>
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(481, 13)" end="(481, 33)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(481, 13)" end="(481, 25)">
                                                  <OtherNode start="(481, 13)" end="(481, 25)" kind="Lean.Parser.Tactic.simpArgs">
                                                    <AtomNode start="(481, 13)" end="(481, 14)" leading="" trailing="" val="["/>
                                                    <NullNode start="(481, 14)" end="(481, 24)">
                                                      <OtherNode start="(481, 14)" end="(481, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(481, 14)" end="(481, 24)" kind="Lean.Parser.Term.app">
                                                          <OtherNode start="(481, 14)" end="(481, 22)" kind="Lean.Parser.Term.explicit">
                                                            <AtomNode start="(481, 14)" end="(481, 15)" leading="" trailing="" val="@"/>
                                                            <IdentNode start="(481, 15)" end="(481, 22)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                          </OtherNode>
                                                          <NullNode start="(481, 23)" end="(481, 24)">
                                                            <IdentNode start="(481, 23)" end="(481, 24)" leading="" trailing="" raw_val="α" val="α"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(481, 24)" end="(481, 25)" leading="" trailing=" " val="]"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(481, 26)" end="(481, 33)">
                                                  <AtomNode start="(481, 26)" end="(481, 31)" leading="" trailing=" " val="using"/>
                                                  <IdentNode start="(481, 32)" end="(481, 33)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(482, 5)" end="(482, 38)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : ¬b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" state_after="no goals" tactic="· simp [beq_false_of_ne h, ih, h]">
                                      <OtherNode start="(482, 5)" end="(482, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(482, 5)" end="(482, 6)" kind="patternIgnore">
                                          <OtherNode start="(482, 5)" end="(482, 6)" kind="token.«· »">
                                            <AtomNode start="(482, 5)" end="(482, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(482, 7)" end="(482, 38)">
                                        <TacticTacticseq1IndentedNode start="(482, 7)" end="(482, 38)">
                                          <NullNode start="(482, 7)" end="(482, 38)">
                                            <OtherNode start="(482, 7)" end="(482, 38)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;m : ∀ (a' : α), a' ∈ l → b ≠ a'&#10;_n : Pairwise (fun x1 x2 =&amp;gt; x1 ≠ x2) l&#10;ih : l.erase a = filter (fun x =&amp;gt; x != a) l&#10;h : ¬b = a&#10;⊢ (b :: l).erase a = filter (fun x =&amp;gt; x != a) (b :: l)" state_after="no goals" tactic="simp [beq_false_of_ne h, ih, h]">
                                              <AtomNode start="(482, 7)" end="(482, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(482, 12)" end="(482, 38)">
                                                <AtomNode start="(482, 12)" end="(482, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(482, 13)" end="(482, 37)">
                                                  <OtherNode start="(482, 13)" end="(482, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <OtherNode start="(482, 13)" end="(482, 30)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(482, 13)" end="(482, 28)" leading="" trailing=" " raw_val="beq_false_of_ne" val="beq_false_of_ne" full_name="beq_false_of_ne" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                      <NullNode start="(482, 29)" end="(482, 30)">
                                                        <IdentNode start="(482, 29)" end="(482, 30)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(482, 30)" end="(482, 31)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(482, 32)" end="(482, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(482, 32)" end="(482, 34)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(482, 34)" end="(482, 35)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(482, 36)" end="(482, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(482, 36)" end="(482, 37)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(482, 37)" end="(482, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(484, 1)" end="(485, 65)" name="Nodup.mem_erase_iff" full_name="List.Nodup.mem_erase_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(484, 1)" end="(485, 65)" name="Nodup.mem_erase_iff" full_name="List.Nodup.mem_erase_iff" _is_private_decl="False">
        <AtomNode start="(484, 1)" end="(484, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(484, 9)" end="(484, 28)">
          <IdentNode start="(484, 9)" end="(484, 28)" leading="" trailing=" " raw_val="Nodup.mem_erase_iff" val="Nodup.mem_erase_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(484, 29)" end="(484, 96)">
          <NullNode start="(484, 29)" end="(484, 64)">
            <OtherNode start="(484, 29)" end="(484, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(484, 29)" end="(484, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(484, 30)" end="(484, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(484, 30)" end="(484, 39)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(484, 40)" end="(484, 41)">
                  <IdentNode start="(484, 40)" end="(484, 41)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(484, 41)" end="(484, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(484, 43)" end="(484, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(484, 43)" end="(484, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(484, 44)" end="(484, 45)">
                <IdentNode start="(484, 44)" end="(484, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(484, 46)" end="(484, 49)">
                <AtomNode start="(484, 46)" end="(484, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(484, 48)" end="(484, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(484, 49)" end="(484, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(484, 51)" end="(484, 64)">
              <AtomNode start="(484, 51)" end="(484, 52)" leading="" trailing="" val="("/>
              <NullNode start="(484, 52)" end="(484, 53)">
                <IdentNode start="(484, 52)" end="(484, 53)" leading="" trailing=" " raw_val="d" val="d"/>
              </NullNode>
              <NullNode start="(484, 54)" end="(484, 63)">
                <AtomNode start="(484, 54)" end="(484, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(484, 56)" end="(484, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(484, 56)" end="(484, 61)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(484, 62)" end="(484, 63)">
                    <IdentNode start="(484, 62)" end="(484, 63)" leading="" trailing="" raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(484, 63)" end="(484, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(484, 65)" end="(484, 96)">
            <AtomNode start="(484, 65)" end="(484, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(484, 67)" end="(484, 96)" kind="«term_↔_»">
              <OtherNode start="(484, 67)" end="(484, 80)" kind="«term_∈_»">
                <IdentNode start="(484, 67)" end="(484, 68)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(484, 69)" end="(484, 70)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(484, 71)" end="(484, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(484, 71)" end="(484, 78)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                  <NullNode start="(484, 79)" end="(484, 80)">
                    <IdentNode start="(484, 79)" end="(484, 80)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(484, 81)" end="(484, 82)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(484, 83)" end="(484, 96)" kind="«term_∧_»">
                <OtherNode start="(484, 83)" end="(484, 88)" kind="«term_≠_»">
                  <IdentNode start="(484, 83)" end="(484, 84)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(484, 85)" end="(484, 86)" leading="" trailing=" " val="≠"/>
                  <IdentNode start="(484, 87)" end="(484, 88)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(484, 89)" end="(484, 90)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(484, 91)" end="(484, 96)" kind="«term_∈_»">
                  <IdentNode start="(484, 91)" end="(484, 92)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(484, 93)" end="(484, 94)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(484, 95)" end="(484, 96)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(484, 97)" end="(485, 65)">
          <AtomNode start="(484, 97)" end="(484, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(484, 100)" end="(485, 65)">
            <AtomNode start="(484, 100)" end="(484, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(485, 3)" end="(485, 65)">
              <TacticTacticseq1IndentedNode start="(485, 3)" end="(485, 65)">
                <NullNode start="(485, 3)" end="(485, 65)">
                  <OtherNode start="(485, 3)" end="(485, 65)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;l : List α&#10;b : α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;d : l.Nodup&#10;⊢ a ∈ l.erase b ↔ a ≠ b ∧ a ∈ l" state_after="no goals" tactic="rw [Nodup.erase_eq_filter d, mem_filter, and_comm, bne_iff_ne]">
                    <AtomNode start="(485, 3)" end="(485, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(485, 6)" end="(485, 65)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(485, 6)" end="(485, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(485, 7)" end="(485, 64)">
                        <OtherNode start="(485, 7)" end="(485, 30)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(485, 7)" end="(485, 30)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(485, 7)" end="(485, 28)" leading="" trailing=" " raw_val="Nodup.erase_eq_filter" val="Nodup.erase_eq_filter" full_name="List.Nodup.erase_eq_filter" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(471, 9)" def_end="(471, 30)"/>
                            <NullNode start="(485, 29)" end="(485, 30)">
                              <IdentNode start="(485, 29)" end="(485, 30)" leading="" trailing="" raw_val="d" val="d"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(485, 30)" end="(485, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(485, 32)" end="(485, 42)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(485, 32)" end="(485, 42)" leading="" trailing="" raw_val="mem_filter" val="mem_filter" full_name="List.mem_filter" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(485, 42)" end="(485, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(485, 44)" end="(485, 52)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(485, 44)" end="(485, 52)" leading="" trailing="" raw_val="and_comm" val="and_comm" full_name="and_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                        <AtomNode start="(485, 52)" end="(485, 53)" leading="" trailing=" " val=","/>
                        <OtherNode start="(485, 54)" end="(485, 64)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(485, 54)" end="(485, 64)" leading="" trailing="" raw_val="bne_iff_ne" val="bne_iff_ne" full_name="bne_iff_ne" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(485, 64)" end="(485, 65)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(487, 1)" end="(488, 50)" name="Nodup.not_mem_erase" full_name="List.Nodup.not_mem_erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(487, 1)" end="(488, 50)" name="Nodup.not_mem_erase" full_name="List.Nodup.not_mem_erase" _is_private_decl="False">
        <AtomNode start="(487, 1)" end="(487, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(487, 9)" end="(487, 28)">
          <IdentNode start="(487, 9)" end="(487, 28)" leading="" trailing=" " raw_val="Nodup.not_mem_erase" val="Nodup.not_mem_erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(487, 29)" end="(487, 80)">
          <NullNode start="(487, 29)" end="(487, 64)">
            <OtherNode start="(487, 29)" end="(487, 42)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(487, 29)" end="(487, 30)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(487, 30)" end="(487, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(487, 30)" end="(487, 39)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(487, 40)" end="(487, 41)">
                  <IdentNode start="(487, 40)" end="(487, 41)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(487, 41)" end="(487, 42)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(487, 43)" end="(487, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(487, 43)" end="(487, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(487, 44)" end="(487, 45)">
                <IdentNode start="(487, 44)" end="(487, 45)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(487, 46)" end="(487, 49)">
                <AtomNode start="(487, 46)" end="(487, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(487, 48)" end="(487, 49)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(487, 49)" end="(487, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(487, 51)" end="(487, 64)">
              <AtomNode start="(487, 51)" end="(487, 52)" leading="" trailing="" val="("/>
              <NullNode start="(487, 52)" end="(487, 53)">
                <IdentNode start="(487, 52)" end="(487, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(487, 54)" end="(487, 63)">
                <AtomNode start="(487, 54)" end="(487, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(487, 56)" end="(487, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(487, 56)" end="(487, 61)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(487, 62)" end="(487, 63)">
                    <IdentNode start="(487, 62)" end="(487, 63)" leading="" trailing="" raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(487, 63)" end="(487, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(487, 65)" end="(487, 80)">
            <AtomNode start="(487, 65)" end="(487, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(487, 67)" end="(487, 80)" kind="«term_∉_»">
              <IdentNode start="(487, 67)" end="(487, 68)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(487, 69)" end="(487, 70)" leading="" trailing=" " val="∉"/>
              <OtherNode start="(487, 71)" end="(487, 80)" kind="Lean.Parser.Term.app">
                <IdentNode start="(487, 71)" end="(487, 78)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(487, 79)" end="(487, 80)">
                  <IdentNode start="(487, 79)" end="(487, 80)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(487, 81)" end="(488, 50)">
          <AtomNode start="(487, 81)" end="(487, 83)" leading="" trailing=" " val=":="/>
          <OtherNode start="(487, 84)" end="(488, 50)" kind="Lean.Parser.Term.fun">
            <AtomNode start="(487, 84)" end="(487, 87)" leading="" trailing=" " val="fun"/>
            <OtherNode start="(487, 88)" end="(488, 50)" kind="Lean.Parser.Term.basicFun">
              <NullNode start="(487, 88)" end="(487, 89)">
                <IdentNode start="(487, 88)" end="(487, 89)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(487, 90)" end="(487, 92)" leading="" trailing=" " val="=&amp;gt;"/>
              <TermBytacticNode start="(487, 93)" end="(488, 50)">
                <AtomNode start="(487, 93)" end="(487, 95)" leading="" trailing="&#10;  " val="by"/>
                <TacticTacticseqNode start="(488, 3)" end="(488, 50)">
                  <TacticTacticseq1IndentedNode start="(488, 3)" end="(488, 50)">
                    <NullNode start="(488, 3)" end="(488, 50)">
                      <OtherNode start="(488, 3)" end="(488, 50)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;l : List α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;h : l.Nodup&#10;H : a ∈ l.erase a&#10;⊢ False" state_after="no goals" tactic="simpa using ((Nodup.mem_erase_iff h).mp H).left">
                        <AtomNode start="(488, 3)" end="(488, 8)" leading="" trailing=" " val="simpa"/>
                        <NullNode/>
                        <NullNode/>
                        <OtherNode start="(488, 9)" end="(488, 50)" kind="Lean.Parser.Tactic.simpaArgsRest">
                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <NullNode/>
                          <NullNode/>
                          <NullNode start="(488, 9)" end="(488, 50)">
                            <AtomNode start="(488, 9)" end="(488, 14)" leading="" trailing=" " val="using"/>
                            <OtherNode start="(488, 15)" end="(488, 50)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(488, 15)" end="(488, 45)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(488, 15)" end="(488, 16)" leading="" trailing="" val="("/>
                                <OtherNode start="(488, 16)" end="(488, 44)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(488, 16)" end="(488, 42)" kind="Lean.Parser.Term.proj">
                                    <OtherNode start="(488, 16)" end="(488, 39)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(488, 16)" end="(488, 17)" leading="" trailing="" val="("/>
                                      <OtherNode start="(488, 17)" end="(488, 38)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(488, 17)" end="(488, 36)" leading="" trailing=" " raw_val="Nodup.mem_erase_iff" val="Nodup.mem_erase_iff" full_name="List.Nodup.mem_erase_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(484, 9)" def_end="(484, 28)"/>
                                        <NullNode start="(488, 37)" end="(488, 38)">
                                          <IdentNode start="(488, 37)" end="(488, 38)" leading="" trailing="" raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(488, 38)" end="(488, 39)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(488, 39)" end="(488, 40)" leading="" trailing="" val="."/>
                                    <IdentNode start="(488, 40)" end="(488, 42)" leading="" trailing=" " raw_val="mp" val="mp" full_name="Iff.mp" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                  </OtherNode>
                                  <NullNode start="(488, 43)" end="(488, 44)">
                                    <IdentNode start="(488, 43)" end="(488, 44)" leading="" trailing="" raw_val="H" val="H"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(488, 44)" end="(488, 45)" leading="" trailing="" val=")"/>
                              </OtherNode>
                              <AtomNode start="(488, 45)" end="(488, 46)" leading="" trailing="" val="."/>
                              <IdentNode start="(488, 46)" end="(488, 50)" leading="" trailing="&#10;&#10;" raw_val="left" val="left" full_name="And.left" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </TermBytacticNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(490, 1)" end="(491, 19)" name="Nodup.erase" full_name="List.Nodup.erase">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(490, 1)" end="(491, 19)" name="Nodup.erase" full_name="List.Nodup.erase" _is_private_decl="False">
        <AtomNode start="(490, 1)" end="(490, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(490, 9)" end="(490, 20)">
          <IdentNode start="(490, 9)" end="(490, 20)" leading="" trailing=" " raw_val="Nodup.erase" val="Nodup.erase"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(490, 21)" end="(490, 72)">
          <NullNode start="(490, 21)" end="(490, 42)">
            <OtherNode start="(490, 21)" end="(490, 34)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(490, 21)" end="(490, 22)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(490, 22)" end="(490, 33)" kind="Lean.Parser.Term.app">
                <IdentNode start="(490, 22)" end="(490, 31)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(490, 32)" end="(490, 33)">
                  <IdentNode start="(490, 32)" end="(490, 33)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(490, 33)" end="(490, 34)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(490, 35)" end="(490, 42)">
              <AtomNode start="(490, 35)" end="(490, 36)" leading="" trailing="" val="("/>
              <NullNode start="(490, 36)" end="(490, 37)">
                <IdentNode start="(490, 36)" end="(490, 37)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(490, 38)" end="(490, 41)">
                <AtomNode start="(490, 38)" end="(490, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(490, 40)" end="(490, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(490, 41)" end="(490, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(490, 43)" end="(490, 72)">
            <AtomNode start="(490, 43)" end="(490, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(490, 45)" end="(490, 72)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(490, 45)" end="(490, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(490, 45)" end="(490, 50)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(490, 51)" end="(490, 52)">
                  <IdentNode start="(490, 51)" end="(490, 52)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(490, 53)" end="(490, 54)" leading="" trailing=" " val="→"/>
              <OtherNode start="(490, 55)" end="(490, 72)" kind="Lean.Parser.Term.app">
                <IdentNode start="(490, 55)" end="(490, 60)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(490, 61)" end="(490, 72)">
                  <OtherNode start="(490, 61)" end="(490, 72)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(490, 61)" end="(490, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(490, 62)" end="(490, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(490, 62)" end="(490, 69)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                      <NullNode start="(490, 70)" end="(490, 71)">
                        <IdentNode start="(490, 70)" end="(490, 71)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(490, 71)" end="(490, 72)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(490, 73)" end="(491, 19)">
          <AtomNode start="(490, 73)" end="(490, 75)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(491, 3)" end="(491, 19)" kind="Lean.Parser.Term.app">
            <IdentNode start="(491, 3)" end="(491, 17)" leading="" trailing=" " raw_val="Pairwise.erase" val="Pairwise.erase" full_name="List.Pairwise.erase" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(468, 9)" def_end="(468, 23)"/>
            <NullNode start="(491, 18)" end="(491, 19)">
              <IdentNode start="(491, 18)" end="(491, 19)" leading="" trailing="&#10;&#10;" raw_val="a" val="a"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(493, 1)" end="(494, 27)" name="head_erase_mem" full_name="List.head_erase_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(493, 1)" end="(494, 27)" name="head_erase_mem" full_name="List.head_erase_mem" _is_private_decl="False">
        <AtomNode start="(493, 1)" end="(493, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(493, 9)" end="(493, 23)">
          <IdentNode start="(493, 9)" end="(493, 23)" leading="" trailing=" " raw_val="head_erase_mem" val="head_erase_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(493, 24)" end="(493, 76)">
          <NullNode start="(493, 24)" end="(493, 49)">
            <TermExplicitbinderNode start="(493, 24)" end="(493, 37)">
              <AtomNode start="(493, 24)" end="(493, 25)" leading="" trailing="" val="("/>
              <NullNode start="(493, 25)" end="(493, 27)">
                <IdentNode start="(493, 25)" end="(493, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(493, 28)" end="(493, 36)">
                <AtomNode start="(493, 28)" end="(493, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(493, 30)" end="(493, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(493, 30)" end="(493, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(493, 35)" end="(493, 36)">
                    <IdentNode start="(493, 35)" end="(493, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(493, 36)" end="(493, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(493, 38)" end="(493, 45)">
              <AtomNode start="(493, 38)" end="(493, 39)" leading="" trailing="" val="("/>
              <NullNode start="(493, 39)" end="(493, 40)">
                <IdentNode start="(493, 39)" end="(493, 40)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(493, 41)" end="(493, 44)">
                <AtomNode start="(493, 41)" end="(493, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(493, 43)" end="(493, 44)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(493, 44)" end="(493, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(493, 46)" end="(493, 49)">
              <AtomNode start="(493, 46)" end="(493, 47)" leading="" trailing="" val="("/>
              <NullNode start="(493, 47)" end="(493, 48)">
                <IdentNode start="(493, 47)" end="(493, 48)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(493, 48)" end="(493, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(493, 50)" end="(493, 76)">
            <AtomNode start="(493, 50)" end="(493, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(493, 52)" end="(493, 76)" kind="«term_∈_»">
              <OtherNode start="(493, 52)" end="(493, 71)" kind="Lean.Parser.Term.app">
                <OtherNode start="(493, 52)" end="(493, 69)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(493, 52)" end="(493, 64)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(493, 52)" end="(493, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(493, 53)" end="(493, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(493, 53)" end="(493, 61)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                      <NullNode start="(493, 62)" end="(493, 63)">
                        <IdentNode start="(493, 62)" end="(493, 63)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(493, 63)" end="(493, 64)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(493, 64)" end="(493, 65)" leading="" trailing="" val="."/>
                  <IdentNode start="(493, 65)" end="(493, 69)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(493, 70)" end="(493, 71)">
                  <IdentNode start="(493, 70)" end="(493, 71)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(493, 72)" end="(493, 73)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(493, 74)" end="(493, 76)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(493, 77)" end="(494, 27)">
          <AtomNode start="(493, 77)" end="(493, 79)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(494, 3)" end="(494, 27)" kind="Lean.Parser.Term.app">
            <IdentNode start="(494, 3)" end="(494, 25)" leading="" trailing=" " raw_val="erase_sublist.head_mem" val="erase_sublist.head_mem"/>
            <NullNode start="(494, 26)" end="(494, 27)">
              <IdentNode start="(494, 26)" end="(494, 27)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(496, 1)" end="(497, 30)" name="getLast_erase_mem" full_name="List.getLast_erase_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(496, 1)" end="(497, 30)" name="getLast_erase_mem" full_name="List.getLast_erase_mem" _is_private_decl="False">
        <AtomNode start="(496, 1)" end="(496, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(496, 9)" end="(496, 26)">
          <IdentNode start="(496, 9)" end="(496, 26)" leading="" trailing=" " raw_val="getLast_erase_mem" val="getLast_erase_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(496, 27)" end="(496, 82)">
          <NullNode start="(496, 27)" end="(496, 52)">
            <TermExplicitbinderNode start="(496, 27)" end="(496, 40)">
              <AtomNode start="(496, 27)" end="(496, 28)" leading="" trailing="" val="("/>
              <NullNode start="(496, 28)" end="(496, 30)">
                <IdentNode start="(496, 28)" end="(496, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(496, 31)" end="(496, 39)">
                <AtomNode start="(496, 31)" end="(496, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(496, 33)" end="(496, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(496, 33)" end="(496, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(496, 38)" end="(496, 39)">
                    <IdentNode start="(496, 38)" end="(496, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(496, 39)" end="(496, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(496, 41)" end="(496, 48)">
              <AtomNode start="(496, 41)" end="(496, 42)" leading="" trailing="" val="("/>
              <NullNode start="(496, 42)" end="(496, 43)">
                <IdentNode start="(496, 42)" end="(496, 43)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(496, 44)" end="(496, 47)">
                <AtomNode start="(496, 44)" end="(496, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(496, 46)" end="(496, 47)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(496, 47)" end="(496, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(496, 49)" end="(496, 52)">
              <AtomNode start="(496, 49)" end="(496, 50)" leading="" trailing="" val="("/>
              <NullNode start="(496, 50)" end="(496, 51)">
                <IdentNode start="(496, 50)" end="(496, 51)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(496, 51)" end="(496, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(496, 53)" end="(496, 82)">
            <AtomNode start="(496, 53)" end="(496, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(496, 55)" end="(496, 82)" kind="«term_∈_»">
              <OtherNode start="(496, 55)" end="(496, 77)" kind="Lean.Parser.Term.app">
                <OtherNode start="(496, 55)" end="(496, 75)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(496, 55)" end="(496, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(496, 55)" end="(496, 56)" leading="" trailing="" val="("/>
                    <OtherNode start="(496, 56)" end="(496, 66)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(496, 56)" end="(496, 64)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                      <NullNode start="(496, 65)" end="(496, 66)">
                        <IdentNode start="(496, 65)" end="(496, 66)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(496, 66)" end="(496, 67)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(496, 67)" end="(496, 68)" leading="" trailing="" val="."/>
                  <IdentNode start="(496, 68)" end="(496, 75)" leading="" trailing=" " raw_val="getLast" val="getLast" full_name="List.getLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(496, 76)" end="(496, 77)">
                  <IdentNode start="(496, 76)" end="(496, 77)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(496, 78)" end="(496, 79)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(496, 80)" end="(496, 82)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(496, 83)" end="(497, 30)">
          <AtomNode start="(496, 83)" end="(496, 85)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(497, 3)" end="(497, 30)" kind="Lean.Parser.Term.app">
            <IdentNode start="(497, 3)" end="(497, 28)" leading="" trailing=" " raw_val="erase_sublist.getLast_mem" val="erase_sublist.getLast_mem"/>
            <NullNode start="(497, 29)" end="(497, 30)">
              <IdentNode start="(497, 29)" end="(497, 30)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(499, 1)" end="(510, 25)" name="erase_eq_eraseIdx" full_name="List.erase_eq_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(499, 1)" end="(510, 25)" name="erase_eq_eraseIdx" full_name="List.erase_eq_eraseIdx" _is_private_decl="False">
        <AtomNode start="(499, 1)" end="(499, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(499, 9)" end="(499, 26)">
          <IdentNode start="(499, 9)" end="(499, 26)" leading="" trailing=" " raw_val="erase_eq_eraseIdx" val="erase_eq_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(499, 27)" end="(502, 29)">
          <NullNode start="(499, 27)" end="(499, 47)">
            <TermExplicitbinderNode start="(499, 27)" end="(499, 39)">
              <AtomNode start="(499, 27)" end="(499, 28)" leading="" trailing="" val="("/>
              <NullNode start="(499, 28)" end="(499, 29)">
                <IdentNode start="(499, 28)" end="(499, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(499, 30)" end="(499, 38)">
                <AtomNode start="(499, 30)" end="(499, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(499, 32)" end="(499, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(499, 32)" end="(499, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(499, 37)" end="(499, 38)">
                    <IdentNode start="(499, 37)" end="(499, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(499, 38)" end="(499, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(499, 40)" end="(499, 47)">
              <AtomNode start="(499, 40)" end="(499, 41)" leading="" trailing="" val="("/>
              <NullNode start="(499, 41)" end="(499, 42)">
                <IdentNode start="(499, 41)" end="(499, 42)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(499, 43)" end="(499, 46)">
                <AtomNode start="(499, 43)" end="(499, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(499, 45)" end="(499, 46)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(499, 46)" end="(499, 47)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(499, 48)" end="(502, 29)">
            <AtomNode start="(499, 48)" end="(499, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(500, 5)" end="(502, 29)" kind="«term_=_»">
              <OtherNode start="(500, 5)" end="(500, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(500, 5)" end="(500, 12)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(500, 13)" end="(500, 14)">
                  <IdentNode start="(500, 13)" end="(500, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(500, 15)" end="(500, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(500, 17)" end="(502, 29)" kind="Lean.Parser.Term.match">
                <AtomNode start="(500, 17)" end="(500, 22)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(500, 23)" end="(500, 33)">
                  <OtherNode start="(500, 23)" end="(500, 33)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(500, 23)" end="(500, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(500, 23)" end="(500, 31)" leading="" trailing=" " raw_val="l.idxOf?" val="l.idxOf?"/>
                      <NullNode start="(500, 32)" end="(500, 33)">
                        <IdentNode start="(500, 32)" end="(500, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(500, 34)" end="(500, 38)" leading="" trailing="&#10;    " val="with"/>
                <OtherNode start="(501, 5)" end="(502, 29)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(501, 5)" end="(502, 29)">
                    <OtherNode start="(501, 5)" end="(501, 16)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(501, 5)" end="(501, 6)" leading="" trailing=" " val="|"/>
                      <NullNode start="(501, 7)" end="(501, 11)">
                        <NullNode start="(501, 7)" end="(501, 11)">
                          <IdentNode start="(501, 7)" end="(501, 11)" leading="" trailing=" " raw_val="none" val="none" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(501, 12)" end="(501, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(501, 15)" end="(501, 16)" leading="" trailing="&#10;    " raw_val="l" val="l"/>
                    </OtherNode>
                    <OtherNode start="(502, 5)" end="(502, 29)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(502, 5)" end="(502, 6)" leading="" trailing=" " val="|"/>
                      <NullNode start="(502, 7)" end="(502, 13)">
                        <NullNode start="(502, 7)" end="(502, 13)">
                          <OtherNode start="(502, 7)" end="(502, 13)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(502, 7)" end="(502, 11)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(502, 12)" end="(502, 13)">
                              <IdentNode start="(502, 12)" end="(502, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(502, 14)" end="(502, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(502, 17)" end="(502, 29)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(502, 17)" end="(502, 27)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                        <NullNode start="(502, 28)" end="(502, 29)">
                          <IdentNode start="(502, 28)" end="(502, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(502, 30)" end="(510, 25)">
          <AtomNode start="(502, 30)" end="(502, 32)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(502, 33)" end="(510, 25)">
            <AtomNode start="(502, 33)" end="(502, 35)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(503, 3)" end="(510, 25)">
              <TacticTacticseq1IndentedNode start="(503, 3)" end="(510, 25)">
                <NullNode start="(503, 3)" end="(510, 25)">
                  <OtherNode start="(503, 3)" end="(510, 25)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a =&#10;    match idxOf? a l with&#10;    | none =&amp;gt; l&#10;    | some i =&amp;gt; l.eraseIdx i" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  rw [erase_cons, idxOf?_cons]&#10;  split&#10;  · simp&#10;  · simp [ih]&#10;    split &amp;lt;;&amp;gt; simp [*]">
                    <AtomNode start="(503, 3)" end="(503, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(503, 13)" end="(503, 14)">
                      <OtherNode start="(503, 13)" end="(503, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(503, 13)" end="(503, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(503, 15)" end="(510, 25)">
                      <OtherNode start="(503, 15)" end="(510, 25)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(503, 15)" end="(503, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(504, 3)" end="(510, 25)">
                          <OtherNode start="(504, 3)" end="(504, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(504, 3)" end="(504, 8)">
                              <OtherNode start="(504, 3)" end="(504, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(504, 3)" end="(504, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(504, 5)" end="(504, 8)">
                                  <NullNode/>
                                  <IdentNode start="(504, 5)" end="(504, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(504, 9)" end="(504, 16)">
                              <AtomNode start="(504, 9)" end="(504, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(504, 12)" end="(504, 16)">
                                <TacticTacticseq1IndentedNode start="(504, 12)" end="(504, 16)">
                                  <NullNode start="(504, 12)" end="(504, 16)">
                                    <OtherNode start="(504, 12)" end="(504, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;⊢ [].erase a =&#10;    match idxOf? a [] with&#10;    | none =&amp;gt; []&#10;    | some i =&amp;gt; [].eraseIdx i" state_after="no goals" tactic="simp">
                                      <AtomNode start="(504, 12)" end="(504, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(505, 3)" end="(510, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(505, 3)" end="(505, 17)">
                              <OtherNode start="(505, 3)" end="(505, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(505, 3)" end="(505, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(505, 5)" end="(505, 9)">
                                  <NullNode/>
                                  <IdentNode start="(505, 5)" end="(505, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(505, 10)" end="(505, 17)">
                                  <IdentNode start="(505, 10)" end="(505, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(505, 12)" end="(505, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(505, 15)" end="(505, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(505, 18)" end="(510, 25)">
                              <AtomNode start="(505, 18)" end="(505, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(506, 5)" end="(510, 25)">
                                <TacticTacticseq1IndentedNode start="(506, 5)" end="(510, 25)">
                                  <NullNode start="(506, 5)" end="(510, 25)">
                                    <OtherNode start="(506, 5)" end="(506, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;⊢ (x :: xs).erase a =&#10;    match idxOf? a (x :: xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;⊢ (if (x == a) = true then xs else x :: xs.erase a) =&#10;    match if (x == a) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="rw [erase_cons, idxOf?_cons]">
                                      <AtomNode start="(506, 5)" end="(506, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(506, 8)" end="(506, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(506, 8)" end="(506, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(506, 9)" end="(506, 32)">
                                          <OtherNode start="(506, 9)" end="(506, 19)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(506, 9)" end="(506, 19)" leading="" trailing="" raw_val="erase_cons" val="erase_cons" full_name="List.erase_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(506, 19)" end="(506, 20)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(506, 21)" end="(506, 32)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(506, 21)" end="(506, 32)" leading="" trailing="" raw_val="idxOf?_cons" val="idxOf?_cons" full_name="List.idxOf?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(506, 32)" end="(506, 33)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(507, 5)" end="(507, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;⊢ (if (x == a) = true then xs else x :: xs.erase a) =&#10;    match if (x == a) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case cons.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : (x == a) = true&#10;⊢ xs =&#10;    match some 0 with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ x :: xs.erase a =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="split">
                                      <AtomNode start="(507, 5)" end="(507, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(508, 5)" end="(508, 11)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : (x == a) = true&#10;⊢ xs =&#10;    match some 0 with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ x :: xs.erase a =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ x :: xs.erase a =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="· simp">
                                      <OtherNode start="(508, 5)" end="(508, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(508, 5)" end="(508, 6)" kind="patternIgnore">
                                          <OtherNode start="(508, 5)" end="(508, 6)" kind="token.«· »">
                                            <AtomNode start="(508, 5)" end="(508, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(508, 7)" end="(508, 11)">
                                        <TacticTacticseq1IndentedNode start="(508, 7)" end="(508, 11)">
                                          <NullNode start="(508, 7)" end="(508, 11)">
                                            <OtherNode start="(508, 7)" end="(508, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : (x == a) = true&#10;⊢ xs =&#10;    match some 0 with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="no goals" tactic="simp">
                                              <AtomNode start="(508, 7)" end="(508, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(509, 5)" end="(510, 25)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ x :: xs.erase a =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="no goals" tactic="· simp [ih]&#10;  split &amp;lt;;&amp;gt; simp [*]">
                                      <OtherNode start="(509, 5)" end="(509, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(509, 5)" end="(509, 6)" kind="patternIgnore">
                                          <OtherNode start="(509, 5)" end="(509, 6)" kind="token.«· »">
                                            <AtomNode start="(509, 5)" end="(509, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(509, 7)" end="(510, 25)">
                                        <TacticTacticseq1IndentedNode start="(509, 7)" end="(510, 25)">
                                          <NullNode start="(509, 7)" end="(510, 25)">
                                            <OtherNode start="(509, 7)" end="(509, 16)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ x :: xs.erase a =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ (x ::&#10;      match idxOf? a xs with&#10;      | none =&amp;gt; xs&#10;      | some i =&amp;gt; xs.eraseIdx i) =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" tactic="simp [ih]">
                                              <AtomNode start="(509, 7)" end="(509, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(509, 12)" end="(509, 16)">
                                                <AtomNode start="(509, 12)" end="(509, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(509, 13)" end="(509, 15)">
                                                  <OtherNode start="(509, 13)" end="(509, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(509, 13)" end="(509, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(509, 15)" end="(509, 16)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(510, 7)" end="(510, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.isFalse&#10;α : Type u_1&#10;inst✝ : BEq α&#10;a x : α&#10;xs : List α&#10;ih :&#10;  xs.erase a =&#10;    match idxOf? a xs with&#10;    | none =&amp;gt; xs&#10;    | some i =&amp;gt; xs.eraseIdx i&#10;h✝ : ¬(x == a) = true&#10;⊢ (x ::&#10;      match idxOf? a xs with&#10;      | none =&amp;gt; xs&#10;      | some i =&amp;gt; xs.eraseIdx i) =&#10;    match Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs) with&#10;    | none =&amp;gt; x :: xs&#10;    | some i =&amp;gt; (x :: xs).eraseIdx i" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                                              <OtherNode start="(510, 7)" end="(510, 12)" kind="Lean.Parser.Tactic.split">
                                                <AtomNode start="(510, 7)" end="(510, 12)" leading="" trailing=" " val="split"/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(510, 13)" end="(510, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(510, 17)" end="(510, 25)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(510, 17)" end="(510, 21)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(510, 22)" end="(510, 25)">
                                                  <AtomNode start="(510, 22)" end="(510, 23)" leading="" trailing="" val="["/>
                                                  <NullNode start="(510, 23)" end="(510, 24)">
                                                    <OtherNode start="(510, 23)" end="(510, 24)" kind="Lean.Parser.Tactic.simpStar">
                                                      <AtomNode start="(510, 23)" end="(510, 24)" leading="" trailing="" val="*"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(510, 24)" end="(510, 25)" leading="" trailing="&#10;&#10;" val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(512, 1)" end="(512, 10)" name="erase">
      <AtomNode start="(512, 1)" end="(512, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(512, 5)" end="(512, 10)">
        <IdentNode start="(512, 5)" end="(512, 10)" leading="" trailing="&#10;&#10;" raw_val="erase" val="erase"/>
      </NullNode>
    </CommandEndNode>
    <CommandModuledocNode start="(514, 1)" end="(514, 20)" comment="### eraseIdx -/">
      <AtomNode start="(514, 1)" end="(514, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(514, 5)" end="(514, 20)" leading="" trailing="&#10;&#10;" val="### eraseIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(516, 1)" end="(527, 12)" name="length_eraseIdx" full_name="List.length_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(516, 1)" end="(527, 12)" name="length_eraseIdx" full_name="List.length_eraseIdx" _is_private_decl="False">
        <AtomNode start="(516, 1)" end="(516, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(516, 9)" end="(516, 24)">
          <IdentNode start="(516, 9)" end="(516, 24)" leading="" trailing=" " raw_val="length_eraseIdx" val="length_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(516, 25)" end="(517, 76)">
          <NullNode start="(516, 25)" end="(516, 47)">
            <OtherNode start="(516, 25)" end="(516, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(516, 25)" end="(516, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(516, 26)" end="(516, 27)">
                <IdentNode start="(516, 26)" end="(516, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(516, 28)" end="(516, 36)">
                <AtomNode start="(516, 28)" end="(516, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(516, 30)" end="(516, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(516, 30)" end="(516, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(516, 35)" end="(516, 36)">
                    <IdentNode start="(516, 35)" end="(516, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(516, 36)" end="(516, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(516, 38)" end="(516, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(516, 38)" end="(516, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(516, 39)" end="(516, 40)">
                <IdentNode start="(516, 39)" end="(516, 40)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(516, 41)" end="(516, 46)">
                <AtomNode start="(516, 41)" end="(516, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(516, 43)" end="(516, 46)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(516, 46)" end="(516, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(516, 48)" end="(517, 76)">
            <AtomNode start="(516, 48)" end="(516, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(517, 5)" end="(517, 76)" kind="«term_=_»">
              <OtherNode start="(517, 5)" end="(517, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(517, 5)" end="(517, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(517, 5)" end="(517, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(517, 6)" end="(517, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(517, 6)" end="(517, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(517, 17)" end="(517, 18)">
                      <IdentNode start="(517, 17)" end="(517, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(517, 18)" end="(517, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(517, 19)" end="(517, 20)" leading="" trailing="" val="."/>
                <IdentNode start="(517, 20)" end="(517, 26)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(517, 27)" end="(517, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(517, 29)" end="(517, 76)" kind="termIfThenElse">
                <AtomNode start="(517, 29)" end="(517, 31)" leading="" trailing=" " val="if"/>
                <OtherNode start="(517, 32)" end="(517, 44)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(517, 32)" end="(517, 33)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(517, 34)" end="(517, 35)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(517, 36)" end="(517, 44)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                </OtherNode>
                <AtomNode start="(517, 45)" end="(517, 49)" leading="" trailing=" " val="then"/>
                <OtherNode start="(517, 50)" end="(517, 62)" kind="«term_-_»">
                  <IdentNode start="(517, 50)" end="(517, 58)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                  <AtomNode start="(517, 59)" end="(517, 60)" leading="" trailing=" " val="-"/>
                  <OtherNode start="(517, 61)" end="(517, 62)" kind="num">
                    <AtomNode start="(517, 61)" end="(517, 62)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(517, 63)" end="(517, 67)" leading="" trailing=" " val="else"/>
                <IdentNode start="(517, 68)" end="(517, 76)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(517, 77)" end="(527, 12)">
          <AtomNode start="(517, 77)" end="(517, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(517, 80)" end="(527, 12)">
            <AtomNode start="(517, 80)" end="(517, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(518, 3)" end="(527, 12)">
              <TacticTacticseq1IndentedNode start="(518, 3)" end="(527, 12)">
                <NullNode start="(518, 3)" end="(527, 12)">
                  <OtherNode start="(518, 3)" end="(527, 12)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length" state_after="no goals" tactic="induction l generalizing i with&#10;| nil =&amp;gt; simp&#10;| cons x l ih =&amp;gt;&#10;  cases i with&#10;  | zero =&amp;gt; simp&#10;  | succ i =&amp;gt;&#10;    simp only [eraseIdx, length_cons, ih, add_one_lt_add_one_iff, Nat.add_one_sub_one]&#10;    split&#10;    · cases l &amp;lt;;&amp;gt; simp_all&#10;    · rfl">
                    <AtomNode start="(518, 3)" end="(518, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(518, 13)" end="(518, 14)">
                      <OtherNode start="(518, 13)" end="(518, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(518, 13)" end="(518, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(518, 15)" end="(518, 29)">
                      <AtomNode start="(518, 15)" end="(518, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(518, 28)" end="(518, 29)">
                        <IdentNode start="(518, 28)" end="(518, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(518, 30)" end="(527, 12)">
                      <OtherNode start="(518, 30)" end="(527, 12)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(518, 30)" end="(518, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(519, 3)" end="(527, 12)">
                          <OtherNode start="(519, 3)" end="(519, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(519, 3)" end="(519, 8)">
                              <OtherNode start="(519, 3)" end="(519, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(519, 3)" end="(519, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(519, 5)" end="(519, 8)">
                                  <NullNode/>
                                  <IdentNode start="(519, 5)" end="(519, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(519, 9)" end="(519, 16)">
                              <AtomNode start="(519, 9)" end="(519, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(519, 12)" end="(519, 16)">
                                <TacticTacticseq1IndentedNode start="(519, 12)" end="(519, 16)">
                                  <NullNode start="(519, 12)" end="(519, 16)">
                                    <OtherNode start="(519, 12)" end="(519, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;i : Nat&#10;⊢ ([].eraseIdx i).length = if i &amp;lt; [].length then [].length - 1 else [].length" state_after="no goals" tactic="simp">
                                      <AtomNode start="(519, 12)" end="(519, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(520, 3)" end="(527, 12)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(520, 3)" end="(520, 16)">
                              <OtherNode start="(520, 3)" end="(520, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(520, 3)" end="(520, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(520, 5)" end="(520, 9)">
                                  <NullNode/>
                                  <IdentNode start="(520, 5)" end="(520, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(520, 10)" end="(520, 16)">
                                  <IdentNode start="(520, 10)" end="(520, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(520, 12)" end="(520, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(520, 14)" end="(520, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(520, 17)" end="(527, 12)">
                              <AtomNode start="(520, 17)" end="(520, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(521, 5)" end="(527, 12)">
                                <TacticTacticseq1IndentedNode start="(521, 5)" end="(527, 12)">
                                  <NullNode start="(521, 5)" end="(527, 12)">
                                    <OtherNode start="(521, 5)" end="(527, 12)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;⊢ ((x :: l).eraseIdx i).length = if i &amp;lt; (x :: l).length then (x :: l).length - 1 else (x :: l).length" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt; simp&#10;| succ i =&amp;gt;&#10;  simp only [eraseIdx, length_cons, ih, add_one_lt_add_one_iff, Nat.add_one_sub_one]&#10;  split&#10;  · cases l &amp;lt;;&amp;gt; simp_all&#10;  · rfl">
                                      <AtomNode start="(521, 5)" end="(521, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(521, 11)" end="(521, 12)">
                                        <OtherNode start="(521, 11)" end="(521, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(521, 11)" end="(521, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(521, 13)" end="(527, 12)">
                                        <OtherNode start="(521, 13)" end="(527, 12)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(521, 13)" end="(521, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(522, 5)" end="(527, 12)">
                                            <OtherNode start="(522, 5)" end="(522, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(522, 5)" end="(522, 11)">
                                                <OtherNode start="(522, 5)" end="(522, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(522, 5)" end="(522, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(522, 7)" end="(522, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(522, 7)" end="(522, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(522, 12)" end="(522, 19)">
                                                <AtomNode start="(522, 12)" end="(522, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(522, 15)" end="(522, 19)">
                                                  <TacticTacticseq1IndentedNode start="(522, 15)" end="(522, 19)">
                                                    <NullNode start="(522, 15)" end="(522, 19)">
                                                      <OtherNode start="(522, 15)" end="(522, 19)" kind="Lean.Parser.Tactic.simp" state_before="case cons.zero&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;⊢ ((x :: l).eraseIdx 0).length = if 0 &amp;lt; (x :: l).length then (x :: l).length - 1 else (x :: l).length" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(522, 15)" end="(522, 19)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(523, 5)" end="(527, 12)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(523, 5)" end="(523, 13)">
                                                <OtherNode start="(523, 5)" end="(523, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(523, 5)" end="(523, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(523, 7)" end="(523, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(523, 7)" end="(523, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(523, 12)" end="(523, 13)">
                                                    <IdentNode start="(523, 12)" end="(523, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(523, 14)" end="(527, 12)">
                                                <AtomNode start="(523, 14)" end="(523, 16)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(524, 7)" end="(527, 12)">
                                                  <TacticTacticseq1IndentedNode start="(524, 7)" end="(527, 12)">
                                                    <NullNode start="(524, 7)" end="(527, 12)">
                                                      <OtherNode start="(524, 7)" end="(524, 89)" kind="Lean.Parser.Tactic.simp" state_before="case cons.succ&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;⊢ ((x :: l).eraseIdx (i + 1)).length = if i + 1 &amp;lt; (x :: l).length then (x :: l).length - 1 else (x :: l).length" state_after="case cons.succ&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;⊢ (if i &amp;lt; l.length then l.length - 1 else l.length) + 1 = if i &amp;lt; l.length then l.length else l.length + 1" tactic="simp only [eraseIdx, length_cons, ih, add_one_lt_add_one_iff, Nat.add_one_sub_one]">
                                                        <AtomNode start="(524, 7)" end="(524, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(524, 12)" end="(524, 16)">
                                                          <AtomNode start="(524, 12)" end="(524, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(524, 17)" end="(524, 89)">
                                                          <AtomNode start="(524, 17)" end="(524, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(524, 18)" end="(524, 88)">
                                                            <OtherNode start="(524, 18)" end="(524, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(524, 18)" end="(524, 26)" leading="" trailing="" raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(524, 26)" end="(524, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(524, 28)" end="(524, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(524, 28)" end="(524, 39)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(524, 39)" end="(524, 40)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(524, 41)" end="(524, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(524, 41)" end="(524, 43)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(524, 43)" end="(524, 44)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(524, 45)" end="(524, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(524, 45)" end="(524, 67)" leading="" trailing="" raw_val="add_one_lt_add_one_iff" val="add_one_lt_add_one_iff" full_name="Nat.add_one_lt_add_one_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(524, 67)" end="(524, 68)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(524, 69)" end="(524, 88)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(524, 69)" end="(524, 88)" leading="" trailing="" raw_val="Nat.add_one_sub_one" val="Nat.add_one_sub_one" full_name="Nat.add_one_sub_one" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(524, 88)" end="(524, 89)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(525, 7)" end="(525, 12)" kind="Lean.Parser.Tactic.split" state_before="case cons.succ&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;⊢ (if i &amp;lt; l.length then l.length - 1 else l.length) + 1 = if i &amp;lt; l.length then l.length else l.length + 1" state_after="case cons.succ.isTrue&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : i &amp;lt; l.length&#10;⊢ l.length - 1 + 1 = l.length&#10;&#10;case cons.succ.isFalse&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ l.length + 1 = l.length + 1" tactic="split">
                                                        <AtomNode start="(525, 7)" end="(525, 12)" leading="" trailing="&#10;      " val="split"/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(526, 7)" end="(526, 29)" kind="Lean.cdot" state_before="case cons.succ.isTrue&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : i &amp;lt; l.length&#10;⊢ l.length - 1 + 1 = l.length&#10;&#10;case cons.succ.isFalse&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ l.length + 1 = l.length + 1" state_after="case cons.succ.isFalse&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ l.length + 1 = l.length + 1" tactic="· cases l &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(526, 7)" end="(526, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(526, 7)" end="(526, 8)" kind="patternIgnore">
                                                            <OtherNode start="(526, 7)" end="(526, 8)" kind="token.«· »">
                                                            <AtomNode start="(526, 7)" end="(526, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(526, 9)" end="(526, 29)">
                                                          <TacticTacticseq1IndentedNode start="(526, 9)" end="(526, 29)">
                                                            <NullNode start="(526, 9)" end="(526, 29)">
                                                            <OtherNode start="(526, 9)" end="(526, 29)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.succ.isTrue&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : i &amp;lt; l.length&#10;⊢ l.length - 1 + 1 = l.length" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; simp_all">
                                                            <OtherNode start="(526, 9)" end="(526, 16)" kind="Lean.Parser.Tactic.cases">
                                                            <AtomNode start="(526, 9)" end="(526, 14)" leading="" trailing=" " val="cases"/>
                                                            <NullNode start="(526, 15)" end="(526, 16)">
                                                            <OtherNode start="(526, 15)" end="(526, 16)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(526, 15)" end="(526, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(526, 17)" end="(526, 20)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                            <OtherNode start="(526, 21)" end="(526, 29)" kind="Lean.Parser.Tactic.simpAll">
                                                            <AtomNode start="(526, 21)" end="(526, 29)" leading="" trailing="&#10;      " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(527, 7)" end="(527, 12)" kind="Lean.cdot" state_before="case cons.succ.isFalse&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ l.length + 1 = l.length + 1" state_after="no goals" tactic="· rfl">
                                                        <OtherNode start="(527, 7)" end="(527, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(527, 7)" end="(527, 8)" kind="patternIgnore">
                                                            <OtherNode start="(527, 7)" end="(527, 8)" kind="token.«· »">
                                                            <AtomNode start="(527, 7)" end="(527, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(527, 9)" end="(527, 12)">
                                                          <TacticTacticseq1IndentedNode start="(527, 9)" end="(527, 12)">
                                                            <NullNode start="(527, 9)" end="(527, 12)">
                                                            <OtherNode start="(527, 9)" end="(527, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.succ.isFalse&#10;α : Type u_1&#10;x : α&#10;l : List α&#10;ih : ∀ {i : Nat}, (l.eraseIdx i).length = if i &amp;lt; l.length then l.length - 1 else l.length&#10;i : Nat&#10;h✝ : ¬i &amp;lt; l.length&#10;⊢ l.length + 1 = l.length + 1" state_after="no goals" tactic="rfl">
                                                            <AtomNode start="(527, 9)" end="(527, 12)" leading="" trailing="&#10;&#10;" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(529, 1)" end="(531, 28)" name="length_eraseIdx_of_lt" full_name="List.length_eraseIdx_of_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(529, 1)" end="(531, 28)" name="length_eraseIdx_of_lt" full_name="List.length_eraseIdx_of_lt" _is_private_decl="False">
        <AtomNode start="(529, 1)" end="(529, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(529, 9)" end="(529, 30)">
          <IdentNode start="(529, 9)" end="(529, 30)" leading="" trailing=" " raw_val="length_eraseIdx_of_lt" val="length_eraseIdx_of_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(529, 31)" end="(530, 41)">
          <NullNode start="(529, 31)" end="(529, 66)">
            <OtherNode start="(529, 31)" end="(529, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(529, 31)" end="(529, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(529, 32)" end="(529, 33)">
                <IdentNode start="(529, 32)" end="(529, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(529, 34)" end="(529, 42)">
                <AtomNode start="(529, 34)" end="(529, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(529, 36)" end="(529, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(529, 36)" end="(529, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(529, 41)" end="(529, 42)">
                    <IdentNode start="(529, 41)" end="(529, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(529, 42)" end="(529, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(529, 44)" end="(529, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(529, 44)" end="(529, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(529, 45)" end="(529, 46)">
                <IdentNode start="(529, 45)" end="(529, 46)" leading="" trailing="" raw_val="i" val="i"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(529, 46)" end="(529, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(529, 48)" end="(529, 66)">
              <AtomNode start="(529, 48)" end="(529, 49)" leading="" trailing="" val="("/>
              <NullNode start="(529, 49)" end="(529, 50)">
                <IdentNode start="(529, 49)" end="(529, 50)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(529, 51)" end="(529, 65)">
                <AtomNode start="(529, 51)" end="(529, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(529, 53)" end="(529, 65)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(529, 53)" end="(529, 54)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(529, 55)" end="(529, 56)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(529, 57)" end="(529, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(529, 57)" end="(529, 63)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(529, 64)" end="(529, 65)">
                      <IdentNode start="(529, 64)" end="(529, 65)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(529, 65)" end="(529, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(529, 67)" end="(530, 41)">
            <AtomNode start="(529, 67)" end="(529, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(530, 5)" end="(530, 41)" kind="«term_=_»">
              <OtherNode start="(530, 5)" end="(530, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(530, 5)" end="(530, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(530, 5)" end="(530, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(530, 6)" end="(530, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(530, 6)" end="(530, 16)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(530, 17)" end="(530, 18)">
                      <IdentNode start="(530, 17)" end="(530, 18)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(530, 18)" end="(530, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(530, 19)" end="(530, 20)" leading="" trailing="" val="."/>
                <IdentNode start="(530, 20)" end="(530, 26)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(530, 27)" end="(530, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(530, 29)" end="(530, 41)" kind="«term_-_»">
                <OtherNode start="(530, 29)" end="(530, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(530, 29)" end="(530, 35)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(530, 36)" end="(530, 37)">
                    <IdentNode start="(530, 36)" end="(530, 37)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(530, 38)" end="(530, 39)" leading="" trailing=" " val="-"/>
                <OtherNode start="(530, 40)" end="(530, 41)" kind="num">
                  <AtomNode start="(530, 40)" end="(530, 41)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(530, 42)" end="(531, 28)">
          <AtomNode start="(530, 42)" end="(530, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(530, 45)" end="(531, 28)">
            <AtomNode start="(530, 45)" end="(530, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(531, 3)" end="(531, 28)">
              <TacticTacticseq1IndentedNode start="(531, 3)" end="(531, 28)">
                <NullNode start="(531, 3)" end="(531, 28)">
                  <OtherNode start="(531, 3)" end="(531, 28)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;h : i &amp;lt; l.length&#10;⊢ (l.eraseIdx i).length = l.length - 1" state_after="no goals" tactic="simp [length_eraseIdx, h]">
                    <AtomNode start="(531, 3)" end="(531, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(531, 8)" end="(531, 28)">
                      <AtomNode start="(531, 8)" end="(531, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(531, 9)" end="(531, 27)">
                        <OtherNode start="(531, 9)" end="(531, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(531, 9)" end="(531, 24)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(516, 9)" def_end="(516, 24)"/>
                        </OtherNode>
                        <AtomNode start="(531, 24)" end="(531, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(531, 26)" end="(531, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(531, 26)" end="(531, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(531, 27)" end="(531, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(533, 1)" end="(533, 89)" name="eraseIdx_zero" full_name="List.eraseIdx_zero">
      <CommandDeclmodifiersNode start="(533, 1)" end="(533, 8)">
        <NullNode/>
        <NullNode start="(533, 1)" end="(533, 8)">
          <OtherNode start="(533, 1)" end="(533, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(533, 1)" end="(533, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(533, 3)" end="(533, 7)">
              <OtherNode start="(533, 3)" end="(533, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(533, 3)" end="(533, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(533, 3)" end="(533, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(533, 7)" end="(533, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(533, 9)" end="(533, 89)" name="eraseIdx_zero" full_name="List.eraseIdx_zero" _is_private_decl="False">
        <AtomNode start="(533, 9)" end="(533, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(533, 17)" end="(533, 30)">
          <IdentNode start="(533, 17)" end="(533, 30)" leading="" trailing=" " raw_val="eraseIdx_zero" val="eraseIdx_zero"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(533, 31)" end="(533, 67)">
          <NullNode start="(533, 31)" end="(533, 43)">
            <OtherNode start="(533, 31)" end="(533, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(533, 31)" end="(533, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(533, 32)" end="(533, 33)">
                <IdentNode start="(533, 32)" end="(533, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(533, 34)" end="(533, 42)">
                <AtomNode start="(533, 34)" end="(533, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(533, 36)" end="(533, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(533, 36)" end="(533, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(533, 41)" end="(533, 42)">
                    <IdentNode start="(533, 41)" end="(533, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(533, 42)" end="(533, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(533, 44)" end="(533, 67)">
            <AtomNode start="(533, 44)" end="(533, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(533, 46)" end="(533, 67)" kind="«term_=_»">
              <OtherNode start="(533, 46)" end="(533, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(533, 46)" end="(533, 54)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(533, 55)" end="(533, 58)">
                  <IdentNode start="(533, 55)" end="(533, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                  <OtherNode start="(533, 57)" end="(533, 58)" kind="num">
                    <AtomNode start="(533, 57)" end="(533, 58)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(533, 59)" end="(533, 60)" leading="" trailing=" " val="="/>
              <IdentNode start="(533, 61)" end="(533, 67)" leading="" trailing=" " raw_val="l.tail" val="l.tail"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(533, 68)" end="(533, 89)">
          <AtomNode start="(533, 68)" end="(533, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(533, 71)" end="(533, 89)">
            <AtomNode start="(533, 71)" end="(533, 73)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(533, 74)" end="(533, 89)">
              <TacticTacticseq1IndentedNode start="(533, 74)" end="(533, 89)">
                <NullNode start="(533, 74)" end="(533, 89)">
                  <OtherNode start="(533, 74)" end="(533, 89)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;⊢ l.eraseIdx 0 = l.tail" state_after="no goals" tactic="cases l &amp;lt;;&amp;gt; rfl">
                    <OtherNode start="(533, 74)" end="(533, 81)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(533, 74)" end="(533, 79)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(533, 80)" end="(533, 81)">
                        <OtherNode start="(533, 80)" end="(533, 81)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(533, 80)" end="(533, 81)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(533, 82)" end="(533, 85)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(533, 86)" end="(533, 89)" kind="Lean.Parser.Tactic.tacticRfl">
                      <AtomNode start="(533, 86)" end="(533, 89)" leading="" trailing="&#10;&#10;" val="rfl"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(535, 1)" end="(539, 60)" name="eraseIdx_eq_take_drop_succ" full_name="List.eraseIdx_eq_take_drop_succ">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(535, 1)" end="(539, 60)" name="eraseIdx_eq_take_drop_succ" full_name="List.eraseIdx_eq_take_drop_succ" _is_private_decl="False">
        <AtomNode start="(535, 1)" end="(535, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(535, 9)" end="(535, 35)">
          <IdentNode start="(535, 9)" end="(535, 35)" leading="" trailing=" " raw_val="eraseIdx_eq_take_drop_succ" val="eraseIdx_eq_take_drop_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(535, 36)" end="(536, 72)">
          <NullNode/>
          <TermTypespecNode start="(535, 36)" end="(536, 72)">
            <AtomNode start="(535, 36)" end="(535, 37)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(536, 5)" end="(536, 72)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(536, 5)" end="(536, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(536, 7)" end="(536, 29)">
                <TermExplicitbinderNode start="(536, 7)" end="(536, 19)">
                  <AtomNode start="(536, 7)" end="(536, 8)" leading="" trailing="" val="("/>
                  <NullNode start="(536, 8)" end="(536, 9)">
                    <IdentNode start="(536, 8)" end="(536, 9)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(536, 10)" end="(536, 18)">
                    <AtomNode start="(536, 10)" end="(536, 11)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(536, 12)" end="(536, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(536, 12)" end="(536, 16)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(536, 17)" end="(536, 18)">
                        <IdentNode start="(536, 17)" end="(536, 18)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(536, 18)" end="(536, 19)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(536, 20)" end="(536, 29)">
                  <AtomNode start="(536, 20)" end="(536, 21)" leading="" trailing="" val="("/>
                  <NullNode start="(536, 21)" end="(536, 22)">
                    <IdentNode start="(536, 21)" end="(536, 22)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                  <NullNode start="(536, 23)" end="(536, 28)">
                    <AtomNode start="(536, 23)" end="(536, 24)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(536, 25)" end="(536, 28)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(536, 28)" end="(536, 29)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(536, 29)" end="(536, 30)" leading="" trailing=" " val=","/>
              <OtherNode start="(536, 31)" end="(536, 72)" kind="«term_=_»">
                <OtherNode start="(536, 31)" end="(536, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(536, 31)" end="(536, 41)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                  <NullNode start="(536, 42)" end="(536, 43)">
                    <IdentNode start="(536, 42)" end="(536, 43)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(536, 44)" end="(536, 45)" leading="" trailing=" " val="="/>
                <OtherNode start="(536, 46)" end="(536, 72)" kind="«term_++_»">
                  <OtherNode start="(536, 46)" end="(536, 54)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(536, 46)" end="(536, 52)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                    <NullNode start="(536, 53)" end="(536, 54)">
                      <IdentNode start="(536, 53)" end="(536, 54)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(536, 55)" end="(536, 57)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(536, 58)" end="(536, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(536, 58)" end="(536, 64)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                    <NullNode start="(536, 65)" end="(536, 72)">
                      <OtherNode start="(536, 65)" end="(536, 72)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(536, 65)" end="(536, 66)" leading="" trailing="" val="("/>
                        <OtherNode start="(536, 66)" end="(536, 71)" kind="«term_+_»">
                          <IdentNode start="(536, 66)" end="(536, 67)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(536, 68)" end="(536, 69)" leading="" trailing=" " val="+"/>
                          <OtherNode start="(536, 70)" end="(536, 71)" kind="num">
                            <AtomNode start="(536, 70)" end="(536, 71)" leading="" trailing="" val="1"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(536, 71)" end="(536, 72)" leading="" trailing="&#10;  " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(537, 3)" end="(539, 60)">
          <OtherNode start="(537, 3)" end="(539, 60)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(537, 3)" end="(539, 60)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(537, 3)" end="(539, 60)">
                <OtherNode start="(537, 3)" end="(537, 22)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(537, 3)" end="(537, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(537, 5)" end="(537, 11)">
                    <NullNode start="(537, 5)" end="(537, 11)">
                      <IdentNode start="(537, 5)" end="(537, 8)" leading="" trailing="" raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(537, 8)" end="(537, 9)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(537, 10)" end="(537, 11)">
                        <AtomNode start="(537, 10)" end="(537, 11)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(537, 12)" end="(537, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(537, 15)" end="(537, 22)">
                    <AtomNode start="(537, 15)" end="(537, 17)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(537, 18)" end="(537, 22)">
                      <TacticTacticseq1IndentedNode start="(537, 18)" end="(537, 22)">
                        <NullNode start="(537, 18)" end="(537, 22)">
                          <OtherNode start="(537, 18)" end="(537, 22)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x✝ : Nat&#10;⊢ [].eraseIdx x✝ = take x✝ [] ++ drop (x✝ + 1) []" state_after="no goals" tactic="simp">
                            <AtomNode start="(537, 18)" end="(537, 22)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(538, 3)" end="(538, 23)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(538, 3)" end="(538, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(538, 5)" end="(538, 12)">
                    <NullNode start="(538, 5)" end="(538, 12)">
                      <OtherNode start="(538, 5)" end="(538, 9)" kind="«term_::_»">
                        <IdentNode start="(538, 5)" end="(538, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(538, 6)" end="(538, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(538, 8)" end="(538, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(538, 9)" end="(538, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(538, 11)" end="(538, 12)" kind="num">
                        <AtomNode start="(538, 11)" end="(538, 12)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(538, 13)" end="(538, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(538, 16)" end="(538, 23)">
                    <AtomNode start="(538, 16)" end="(538, 18)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(538, 19)" end="(538, 23)">
                      <TacticTacticseq1IndentedNode start="(538, 19)" end="(538, 23)">
                        <NullNode start="(538, 19)" end="(538, 23)">
                          <OtherNode start="(538, 19)" end="(538, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;⊢ (a :: l).eraseIdx 0 = take 0 (a :: l) ++ drop (0 + 1) (a :: l)" state_after="no goals" tactic="simp">
                            <AtomNode start="(538, 19)" end="(538, 23)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(539, 3)" end="(539, 60)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(539, 3)" end="(539, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(539, 5)" end="(539, 16)">
                    <NullNode start="(539, 5)" end="(539, 16)">
                      <OtherNode start="(539, 5)" end="(539, 9)" kind="«term_::_»">
                        <IdentNode start="(539, 5)" end="(539, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(539, 6)" end="(539, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(539, 8)" end="(539, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(539, 9)" end="(539, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(539, 11)" end="(539, 16)" kind="«term_+_»">
                        <IdentNode start="(539, 11)" end="(539, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(539, 13)" end="(539, 14)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(539, 15)" end="(539, 16)" kind="num">
                          <AtomNode start="(539, 15)" end="(539, 16)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(539, 17)" end="(539, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(539, 20)" end="(539, 60)">
                    <AtomNode start="(539, 20)" end="(539, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(539, 23)" end="(539, 60)">
                      <TacticTacticseq1IndentedNode start="(539, 23)" end="(539, 60)">
                        <NullNode start="(539, 23)" end="(539, 60)">
                          <OtherNode start="(539, 23)" end="(539, 60)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ (a :: l).eraseIdx (i + 1) = take (i + 1) (a :: l) ++ drop (i + 1 + 1) (a :: l)" state_after="no goals" tactic="simp [eraseIdx_eq_take_drop_succ l i]">
                            <AtomNode start="(539, 23)" end="(539, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(539, 28)" end="(539, 60)">
                              <AtomNode start="(539, 28)" end="(539, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(539, 29)" end="(539, 59)">
                                <OtherNode start="(539, 29)" end="(539, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(539, 29)" end="(539, 59)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(539, 29)" end="(539, 55)" leading="" trailing=" " raw_val="eraseIdx_eq_take_drop_succ" val="eraseIdx_eq_take_drop_succ"/>
                                    <NullNode start="(539, 56)" end="(539, 59)">
                                      <IdentNode start="(539, 56)" end="(539, 57)" leading="" trailing=" " raw_val="l" val="l"/>
                                      <IdentNode start="(539, 58)" end="(539, 59)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(539, 59)" end="(539, 60)" leading="" trailing="&#10;&#10;-- See `Init.Data.List.Nat.Erase` for `getElem?_eraseIdx` and `getElem_eraseIdx`.&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(543, 1)" end="(547, 39)" name="eraseIdx_eq_nil_iff" full_name="List.eraseIdx_eq_nil_iff">
      <CommandDeclmodifiersNode start="(543, 1)" end="(543, 8)">
        <NullNode/>
        <NullNode start="(543, 1)" end="(543, 8)">
          <OtherNode start="(543, 1)" end="(543, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(543, 1)" end="(543, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(543, 3)" end="(543, 7)">
              <OtherNode start="(543, 3)" end="(543, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(543, 3)" end="(543, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(543, 3)" end="(543, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(543, 7)" end="(543, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(543, 9)" end="(547, 39)" name="eraseIdx_eq_nil_iff" full_name="List.eraseIdx_eq_nil_iff" _is_private_decl="False">
        <AtomNode start="(543, 9)" end="(543, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(543, 17)" end="(543, 36)">
          <IdentNode start="(543, 17)" end="(543, 36)" leading="" trailing=" " raw_val="eraseIdx_eq_nil_iff" val="eraseIdx_eq_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(543, 37)" end="(543, 113)">
          <NullNode start="(543, 37)" end="(543, 59)">
            <OtherNode start="(543, 37)" end="(543, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(543, 37)" end="(543, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(543, 38)" end="(543, 39)">
                <IdentNode start="(543, 38)" end="(543, 39)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(543, 40)" end="(543, 48)">
                <AtomNode start="(543, 40)" end="(543, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(543, 42)" end="(543, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(543, 42)" end="(543, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(543, 47)" end="(543, 48)">
                    <IdentNode start="(543, 47)" end="(543, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(543, 48)" end="(543, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(543, 50)" end="(543, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(543, 50)" end="(543, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(543, 51)" end="(543, 52)">
                <IdentNode start="(543, 51)" end="(543, 52)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(543, 53)" end="(543, 58)">
                <AtomNode start="(543, 53)" end="(543, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(543, 55)" end="(543, 58)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(543, 58)" end="(543, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(543, 60)" end="(543, 113)">
            <AtomNode start="(543, 60)" end="(543, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(543, 62)" end="(543, 113)" kind="«term_↔_»">
              <OtherNode start="(543, 62)" end="(543, 79)" kind="«term_=_»">
                <OtherNode start="(543, 62)" end="(543, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(543, 62)" end="(543, 70)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(543, 71)" end="(543, 74)">
                    <IdentNode start="(543, 71)" end="(543, 72)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(543, 73)" end="(543, 74)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(543, 75)" end="(543, 76)" leading="" trailing=" " val="="/>
                <OtherNode start="(543, 77)" end="(543, 79)" kind="«term[_]»">
                  <AtomNode start="(543, 77)" end="(543, 78)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(543, 78)" end="(543, 79)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(543, 80)" end="(543, 81)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(543, 82)" end="(543, 113)" kind="«term_∨_»">
                <OtherNode start="(543, 82)" end="(543, 88)" kind="«term_=_»">
                  <IdentNode start="(543, 82)" end="(543, 83)" leading="" trailing=" " raw_val="l" val="l"/>
                  <AtomNode start="(543, 84)" end="(543, 85)" leading="" trailing=" " val="="/>
                  <OtherNode start="(543, 86)" end="(543, 88)" kind="«term[_]»">
                    <AtomNode start="(543, 86)" end="(543, 87)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(543, 87)" end="(543, 88)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(543, 89)" end="(543, 90)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(543, 91)" end="(543, 113)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(543, 91)" end="(543, 92)" leading="" trailing="" val="("/>
                  <OtherNode start="(543, 92)" end="(543, 112)" kind="«term_∧_»">
                    <OtherNode start="(543, 92)" end="(543, 104)" kind="«term_=_»">
                      <OtherNode start="(543, 92)" end="(543, 100)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(543, 92)" end="(543, 98)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(543, 99)" end="(543, 100)">
                          <IdentNode start="(543, 99)" end="(543, 100)" leading="" trailing=" " raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(543, 101)" end="(543, 102)" leading="" trailing=" " val="="/>
                      <OtherNode start="(543, 103)" end="(543, 104)" kind="num">
                        <AtomNode start="(543, 103)" end="(543, 104)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(543, 105)" end="(543, 106)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(543, 107)" end="(543, 112)" kind="«term_=_»">
                      <IdentNode start="(543, 107)" end="(543, 108)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(543, 109)" end="(543, 110)" leading="" trailing=" " val="="/>
                      <OtherNode start="(543, 111)" end="(543, 112)" kind="num">
                        <AtomNode start="(543, 111)" end="(543, 112)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(543, 112)" end="(543, 113)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(543, 114)" end="(547, 39)">
          <AtomNode start="(543, 114)" end="(543, 116)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(543, 117)" end="(547, 39)">
            <AtomNode start="(543, 117)" end="(543, 119)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(544, 3)" end="(547, 39)">
              <TacticTacticseq1IndentedNode start="(544, 3)" end="(547, 39)">
                <NullNode start="(544, 3)" end="(547, 39)">
                  <OtherNode start="(544, 3)" end="(547, 39)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.eraseIdx i = [] ↔ l = [] ∨ l.length = 1 ∧ i = 0" state_after="no goals" tactic="match l, i with&#10;| [], _&#10;| a::l, 0&#10;| a::l, i + 1 =&amp;gt; simp [Nat.succ_inj]">
                    <AtomNode start="(544, 3)" end="(544, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(544, 9)" end="(544, 13)">
                      <OtherNode start="(544, 9)" end="(544, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(544, 9)" end="(544, 10)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(544, 10)" end="(544, 11)" leading="" trailing=" " val=","/>
                      <OtherNode start="(544, 12)" end="(544, 13)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(544, 12)" end="(544, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(544, 14)" end="(544, 18)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(545, 3)" end="(547, 39)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(545, 3)" end="(547, 39)">
                        <OtherNode start="(545, 3)" end="(547, 39)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(545, 3)" end="(545, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(545, 5)" end="(547, 16)">
                            <NullNode start="(545, 5)" end="(545, 10)">
                              <OtherNode start="(545, 5)" end="(545, 7)" kind="«term[_]»">
                                <AtomNode start="(545, 5)" end="(545, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(545, 6)" end="(545, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(545, 7)" end="(545, 8)" leading="" trailing=" " val=","/>
                              <TermHoleNode start="(545, 9)" end="(545, 10)">
                                <AtomNode start="(545, 9)" end="(545, 10)" leading="" trailing="&#10;  " val="_"/>
                              </TermHoleNode>
                            </NullNode>
                            <AtomNode start="(546, 3)" end="(546, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(546, 5)" end="(546, 12)">
                              <OtherNode start="(546, 5)" end="(546, 9)" kind="«term_::_»">
                                <IdentNode start="(546, 5)" end="(546, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(546, 6)" end="(546, 8)" leading="" trailing="" val="::"/>
                                <IdentNode start="(546, 8)" end="(546, 9)" leading="" trailing="" raw_val="l" val="l"/>
                              </OtherNode>
                              <AtomNode start="(546, 9)" end="(546, 10)" leading="" trailing=" " val=","/>
                              <OtherNode start="(546, 11)" end="(546, 12)" kind="num">
                                <AtomNode start="(546, 11)" end="(546, 12)" leading="" trailing="&#10;  " val="0"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(547, 3)" end="(547, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(547, 5)" end="(547, 16)">
                              <OtherNode start="(547, 5)" end="(547, 9)" kind="«term_::_»">
                                <IdentNode start="(547, 5)" end="(547, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(547, 6)" end="(547, 8)" leading="" trailing="" val="::"/>
                                <IdentNode start="(547, 8)" end="(547, 9)" leading="" trailing="" raw_val="l" val="l"/>
                              </OtherNode>
                              <AtomNode start="(547, 9)" end="(547, 10)" leading="" trailing=" " val=","/>
                              <OtherNode start="(547, 11)" end="(547, 16)" kind="«term_+_»">
                                <IdentNode start="(547, 11)" end="(547, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                <AtomNode start="(547, 13)" end="(547, 14)" leading="" trailing=" " val="+"/>
                                <OtherNode start="(547, 15)" end="(547, 16)" kind="num">
                                  <AtomNode start="(547, 15)" end="(547, 16)" leading="" trailing=" " val="1"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(547, 17)" end="(547, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(547, 20)" end="(547, 39)">
                            <TacticTacticseq1IndentedNode start="(547, 20)" end="(547, 39)">
                              <NullNode start="(547, 20)" end="(547, 39)">
                                <OtherNode start="(547, 20)" end="(547, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l✝ : List α&#10;i✝ : Nat&#10;a : α&#10;l : List α&#10;i : Nat&#10;⊢ (a :: l).eraseIdx (i + 1) = [] ↔ a :: l = [] ∨ (a :: l).length = 1 ∧ i + 1 = 0" state_after="no goals" tactic="simp [Nat.succ_inj]">
                                  <AtomNode start="(547, 20)" end="(547, 24)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(547, 25)" end="(547, 39)">
                                    <AtomNode start="(547, 25)" end="(547, 26)" leading="" trailing="" val="["/>
                                    <NullNode start="(547, 26)" end="(547, 38)">
                                      <OtherNode start="(547, 26)" end="(547, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(547, 26)" end="(547, 38)" leading="" trailing="" raw_val="Nat.succ_inj" val="Nat.succ_inj" full_name="Nat.succ_inj" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(547, 38)" end="(547, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(549, 1)" end="(550, 47)" name="eraseIdx_eq_nil" full_name="List.eraseIdx_eq_nil">
      <CommandDeclmodifiersNode start="(549, 1)" end="(549, 58)">
        <NullNode/>
        <NullNode start="(549, 1)" end="(549, 58)">
          <OtherNode start="(549, 1)" end="(549, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(549, 1)" end="(549, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(549, 3)" end="(549, 57)">
              <OtherNode start="(549, 3)" end="(549, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(549, 3)" end="(549, 57)" kind="Lean.deprecated">
                  <AtomNode start="(549, 3)" end="(549, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(549, 14)" end="(549, 33)">
                    <IdentNode start="(549, 14)" end="(549, 33)" leading="" trailing=" " raw_val="eraseIdx_eq_nil_iff" val="eraseIdx_eq_nil_iff" full_name="List.eraseIdx_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(543, 17)" def_end="(543, 36)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(549, 34)" end="(549, 57)">
                    <AtomNode start="(549, 34)" end="(549, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(549, 35)" end="(549, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(549, 41)" end="(549, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(549, 44)" end="(549, 56)" kind="str">
                      <AtomNode start="(549, 44)" end="(549, 56)" leading="" trailing="" val="&amp;quot;2025-01-30&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(549, 56)" end="(549, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(549, 57)" end="(549, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(550, 1)" end="(550, 47)" name="eraseIdx_eq_nil">
        <AtomNode start="(550, 1)" end="(550, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(550, 8)" end="(550, 23)">
          <IdentNode start="(550, 8)" end="(550, 23)" leading="" trailing=" " raw_val="eraseIdx_eq_nil" val="eraseIdx_eq_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(550, 24)" end="(550, 47)">
          <AtomNode start="(550, 24)" end="(550, 26)" leading="" trailing=" " val=":="/>
          <OtherNode start="(550, 27)" end="(550, 47)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(550, 27)" end="(550, 28)" leading="" trailing="" val="@"/>
            <IdentNode start="(550, 28)" end="(550, 47)" leading="" trailing="&#10;&#10;" raw_val="eraseIdx_eq_nil_iff" val="eraseIdx_eq_nil_iff" full_name="List.eraseIdx_eq_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(543, 17)" def_end="(543, 36)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(552, 1)" end="(556, 35)" name="eraseIdx_ne_nil_iff" full_name="List.eraseIdx_ne_nil_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(552, 1)" end="(556, 35)" name="eraseIdx_ne_nil_iff" full_name="List.eraseIdx_ne_nil_iff" _is_private_decl="False">
        <AtomNode start="(552, 1)" end="(552, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(552, 9)" end="(552, 28)">
          <IdentNode start="(552, 9)" end="(552, 28)" leading="" trailing=" " raw_val="eraseIdx_ne_nil_iff" val="eraseIdx_ne_nil_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(552, 29)" end="(552, 111)">
          <NullNode start="(552, 29)" end="(552, 51)">
            <OtherNode start="(552, 29)" end="(552, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(552, 29)" end="(552, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(552, 30)" end="(552, 31)">
                <IdentNode start="(552, 30)" end="(552, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(552, 32)" end="(552, 40)">
                <AtomNode start="(552, 32)" end="(552, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(552, 34)" end="(552, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(552, 34)" end="(552, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(552, 39)" end="(552, 40)">
                    <IdentNode start="(552, 39)" end="(552, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(552, 40)" end="(552, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(552, 42)" end="(552, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(552, 42)" end="(552, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(552, 43)" end="(552, 44)">
                <IdentNode start="(552, 43)" end="(552, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(552, 45)" end="(552, 50)">
                <AtomNode start="(552, 45)" end="(552, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(552, 47)" end="(552, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(552, 50)" end="(552, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(552, 52)" end="(552, 111)">
            <AtomNode start="(552, 52)" end="(552, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(552, 54)" end="(552, 111)" kind="«term_↔_»">
              <OtherNode start="(552, 54)" end="(552, 71)" kind="«term_≠_»">
                <OtherNode start="(552, 54)" end="(552, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(552, 54)" end="(552, 62)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(552, 63)" end="(552, 66)">
                    <IdentNode start="(552, 63)" end="(552, 64)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(552, 65)" end="(552, 66)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(552, 67)" end="(552, 68)" leading="" trailing=" " val="≠"/>
                <OtherNode start="(552, 69)" end="(552, 71)" kind="«term[_]»">
                  <AtomNode start="(552, 69)" end="(552, 70)" leading="" trailing="" val="["/>
                  <NullNode/>
                  <AtomNode start="(552, 70)" end="(552, 71)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(552, 72)" end="(552, 73)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(552, 74)" end="(552, 111)" kind="«term_∨_»">
                <OtherNode start="(552, 74)" end="(552, 86)" kind="«term_≤_»">
                  <OtherNode start="(552, 74)" end="(552, 75)" kind="num">
                    <AtomNode start="(552, 74)" end="(552, 75)" leading="" trailing=" " val="2"/>
                  </OtherNode>
                  <AtomNode start="(552, 76)" end="(552, 77)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(552, 78)" end="(552, 86)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                </OtherNode>
                <AtomNode start="(552, 87)" end="(552, 88)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(552, 89)" end="(552, 111)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(552, 89)" end="(552, 90)" leading="" trailing="" val="("/>
                  <OtherNode start="(552, 90)" end="(552, 110)" kind="«term_∧_»">
                    <OtherNode start="(552, 90)" end="(552, 102)" kind="«term_=_»">
                      <IdentNode start="(552, 90)" end="(552, 98)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                      <AtomNode start="(552, 99)" end="(552, 100)" leading="" trailing=" " val="="/>
                      <OtherNode start="(552, 101)" end="(552, 102)" kind="num">
                        <AtomNode start="(552, 101)" end="(552, 102)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(552, 103)" end="(552, 104)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(552, 105)" end="(552, 110)" kind="«term_≠_»">
                      <IdentNode start="(552, 105)" end="(552, 106)" leading="" trailing=" " raw_val="i" val="i"/>
                      <AtomNode start="(552, 107)" end="(552, 108)" leading="" trailing=" " val="≠"/>
                      <OtherNode start="(552, 109)" end="(552, 110)" kind="num">
                        <AtomNode start="(552, 109)" end="(552, 110)" leading="" trailing="" val="0"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(552, 110)" end="(552, 111)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(552, 112)" end="(556, 35)">
          <AtomNode start="(552, 112)" end="(552, 114)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(552, 115)" end="(556, 35)">
            <AtomNode start="(552, 115)" end="(552, 117)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(553, 3)" end="(556, 35)">
              <TacticTacticseq1IndentedNode start="(553, 3)" end="(556, 35)">
                <NullNode start="(553, 3)" end="(556, 35)">
                  <OtherNode start="(553, 3)" end="(556, 35)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.eraseIdx i ≠ [] ↔ 2 ≤ l.length ∨ l.length = 1 ∧ i ≠ 0" state_after="no goals" tactic="match l with&#10;| []&#10;| [a]&#10;| a::b::l =&amp;gt; simp [Nat.succ_inj]">
                    <AtomNode start="(553, 3)" end="(553, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(553, 9)" end="(553, 10)">
                      <OtherNode start="(553, 9)" end="(553, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(553, 9)" end="(553, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(553, 11)" end="(553, 15)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(554, 3)" end="(556, 35)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(554, 3)" end="(556, 35)">
                        <OtherNode start="(554, 3)" end="(556, 35)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(554, 3)" end="(554, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(554, 5)" end="(556, 12)">
                            <NullNode start="(554, 5)" end="(554, 7)">
                              <OtherNode start="(554, 5)" end="(554, 7)" kind="«term[_]»">
                                <AtomNode start="(554, 5)" end="(554, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(554, 6)" end="(554, 7)" leading="" trailing="&#10;  " val="]"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(555, 3)" end="(555, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(555, 5)" end="(555, 8)">
                              <OtherNode start="(555, 5)" end="(555, 8)" kind="«term[_]»">
                                <AtomNode start="(555, 5)" end="(555, 6)" leading="" trailing="" val="["/>
                                <NullNode start="(555, 6)" end="(555, 7)">
                                  <IdentNode start="(555, 6)" end="(555, 7)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                                <AtomNode start="(555, 7)" end="(555, 8)" leading="" trailing="&#10;  " val="]"/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(556, 3)" end="(556, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(556, 5)" end="(556, 12)">
                              <OtherNode start="(556, 5)" end="(556, 12)" kind="«term_::_»">
                                <IdentNode start="(556, 5)" end="(556, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(556, 6)" end="(556, 8)" leading="" trailing="" val="::"/>
                                <OtherNode start="(556, 8)" end="(556, 12)" kind="«term_::_»">
                                  <IdentNode start="(556, 8)" end="(556, 9)" leading="" trailing="" raw_val="b" val="b"/>
                                  <AtomNode start="(556, 9)" end="(556, 11)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(556, 11)" end="(556, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(556, 13)" end="(556, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(556, 16)" end="(556, 35)">
                            <TacticTacticseq1IndentedNode start="(556, 16)" end="(556, 35)">
                              <NullNode start="(556, 16)" end="(556, 35)">
                                <OtherNode start="(556, 16)" end="(556, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l✝ : List α&#10;i : Nat&#10;a b : α&#10;l : List α&#10;⊢ (a :: b :: l).eraseIdx i ≠ [] ↔ 2 ≤ (a :: b :: l).length ∨ (a :: b :: l).length = 1 ∧ i ≠ 0" state_after="no goals" tactic="simp [Nat.succ_inj]">
                                  <AtomNode start="(556, 16)" end="(556, 20)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(556, 21)" end="(556, 35)">
                                    <AtomNode start="(556, 21)" end="(556, 22)" leading="" trailing="" val="["/>
                                    <NullNode start="(556, 22)" end="(556, 34)">
                                      <OtherNode start="(556, 22)" end="(556, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(556, 22)" end="(556, 34)" leading="" trailing="" raw_val="Nat.succ_inj" val="Nat.succ_inj" full_name="Nat.succ_inj" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(556, 34)" end="(556, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(558, 1)" end="(559, 47)" name="eraseIdx_ne_nil" full_name="List.eraseIdx_ne_nil">
      <CommandDeclmodifiersNode start="(558, 1)" end="(558, 58)">
        <NullNode/>
        <NullNode start="(558, 1)" end="(558, 58)">
          <OtherNode start="(558, 1)" end="(558, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(558, 1)" end="(558, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(558, 3)" end="(558, 57)">
              <OtherNode start="(558, 3)" end="(558, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(558, 3)" end="(558, 57)" kind="Lean.deprecated">
                  <AtomNode start="(558, 3)" end="(558, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(558, 14)" end="(558, 33)">
                    <IdentNode start="(558, 14)" end="(558, 33)" leading="" trailing=" " raw_val="eraseIdx_ne_nil_iff" val="eraseIdx_ne_nil_iff" full_name="List.eraseIdx_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(552, 9)" def_end="(552, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(558, 34)" end="(558, 57)">
                    <AtomNode start="(558, 34)" end="(558, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(558, 35)" end="(558, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(558, 41)" end="(558, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(558, 44)" end="(558, 56)" kind="str">
                      <AtomNode start="(558, 44)" end="(558, 56)" leading="" trailing="" val="&amp;quot;2025-01-30&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(558, 56)" end="(558, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(558, 57)" end="(558, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(559, 1)" end="(559, 47)" name="eraseIdx_ne_nil">
        <AtomNode start="(559, 1)" end="(559, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(559, 8)" end="(559, 23)">
          <IdentNode start="(559, 8)" end="(559, 23)" leading="" trailing=" " raw_val="eraseIdx_ne_nil" val="eraseIdx_ne_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(559, 24)" end="(559, 47)">
          <AtomNode start="(559, 24)" end="(559, 26)" leading="" trailing=" " val=":="/>
          <OtherNode start="(559, 27)" end="(559, 47)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(559, 27)" end="(559, 28)" leading="" trailing="" val="@"/>
            <IdentNode start="(559, 28)" end="(559, 47)" leading="" trailing="&#10;&#10;" raw_val="eraseIdx_ne_nil_iff" val="eraseIdx_ne_nil_iff" full_name="List.eraseIdx_ne_nil_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(552, 9)" def_end="(552, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(561, 1)" end="(564, 46)" name="eraseIdx_sublist" full_name="List.eraseIdx_sublist">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(561, 1)" end="(564, 46)" name="eraseIdx_sublist" full_name="List.eraseIdx_sublist" _is_private_decl="False">
        <AtomNode start="(561, 1)" end="(561, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(561, 9)" end="(561, 25)">
          <IdentNode start="(561, 9)" end="(561, 25)" leading="" trailing=" " raw_val="eraseIdx_sublist" val="eraseIdx_sublist"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(561, 26)" end="(561, 71)">
          <NullNode/>
          <TermTypespecNode start="(561, 26)" end="(561, 71)">
            <AtomNode start="(561, 26)" end="(561, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(561, 28)" end="(561, 71)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(561, 28)" end="(561, 29)" leading="" trailing=" " val="∀"/>
              <NullNode start="(561, 30)" end="(561, 52)">
                <TermExplicitbinderNode start="(561, 30)" end="(561, 42)">
                  <AtomNode start="(561, 30)" end="(561, 31)" leading="" trailing="" val="("/>
                  <NullNode start="(561, 31)" end="(561, 32)">
                    <IdentNode start="(561, 31)" end="(561, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(561, 33)" end="(561, 41)">
                    <AtomNode start="(561, 33)" end="(561, 34)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(561, 35)" end="(561, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(561, 35)" end="(561, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(561, 40)" end="(561, 41)">
                        <IdentNode start="(561, 40)" end="(561, 41)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(561, 41)" end="(561, 42)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(561, 43)" end="(561, 52)">
                  <AtomNode start="(561, 43)" end="(561, 44)" leading="" trailing="" val="("/>
                  <NullNode start="(561, 44)" end="(561, 45)">
                    <IdentNode start="(561, 44)" end="(561, 45)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                  <NullNode start="(561, 46)" end="(561, 51)">
                    <AtomNode start="(561, 46)" end="(561, 47)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(561, 48)" end="(561, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(561, 51)" end="(561, 52)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(561, 52)" end="(561, 53)" leading="" trailing=" " val=","/>
              <OtherNode start="(561, 54)" end="(561, 71)" kind="List.«term_&amp;lt;+_»">
                <OtherNode start="(561, 54)" end="(561, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(561, 54)" end="(561, 62)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(561, 63)" end="(561, 66)">
                    <IdentNode start="(561, 63)" end="(561, 64)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(561, 65)" end="(561, 66)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(561, 67)" end="(561, 69)" leading="" trailing=" " val="&amp;lt;+"/>
                <IdentNode start="(561, 70)" end="(561, 71)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(562, 3)" end="(564, 46)">
          <OtherNode start="(562, 3)" end="(564, 46)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(562, 3)" end="(564, 46)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(562, 3)" end="(564, 46)">
                <OtherNode start="(562, 3)" end="(562, 21)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(562, 3)" end="(562, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(562, 5)" end="(562, 10)">
                    <NullNode start="(562, 5)" end="(562, 10)">
                      <OtherNode start="(562, 5)" end="(562, 7)" kind="«term[_]»">
                        <AtomNode start="(562, 5)" end="(562, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(562, 6)" end="(562, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(562, 7)" end="(562, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(562, 9)" end="(562, 10)">
                        <AtomNode start="(562, 9)" end="(562, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(562, 11)" end="(562, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(562, 14)" end="(562, 21)">
                    <AtomNode start="(562, 14)" end="(562, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(562, 17)" end="(562, 21)">
                      <TacticTacticseq1IndentedNode start="(562, 17)" end="(562, 21)">
                        <NullNode start="(562, 17)" end="(562, 21)">
                          <OtherNode start="(562, 17)" end="(562, 21)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x✝ : Nat&#10;⊢ [].eraseIdx x✝ &amp;lt;+ []" state_after="no goals" tactic="simp">
                            <AtomNode start="(562, 17)" end="(562, 21)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(563, 3)" end="(563, 23)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(563, 3)" end="(563, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(563, 5)" end="(563, 12)">
                    <NullNode start="(563, 5)" end="(563, 12)">
                      <OtherNode start="(563, 5)" end="(563, 9)" kind="«term_::_»">
                        <IdentNode start="(563, 5)" end="(563, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(563, 6)" end="(563, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(563, 8)" end="(563, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(563, 9)" end="(563, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(563, 11)" end="(563, 12)" kind="num">
                        <AtomNode start="(563, 11)" end="(563, 12)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(563, 13)" end="(563, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(563, 16)" end="(563, 23)">
                    <AtomNode start="(563, 16)" end="(563, 18)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(563, 19)" end="(563, 23)">
                      <TacticTacticseq1IndentedNode start="(563, 19)" end="(563, 23)">
                        <NullNode start="(563, 19)" end="(563, 23)">
                          <OtherNode start="(563, 19)" end="(563, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;⊢ (a :: l).eraseIdx 0 &amp;lt;+ a :: l" state_after="no goals" tactic="simp">
                            <AtomNode start="(563, 19)" end="(563, 23)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(564, 3)" end="(564, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(564, 3)" end="(564, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(564, 5)" end="(564, 16)">
                    <NullNode start="(564, 5)" end="(564, 16)">
                      <OtherNode start="(564, 5)" end="(564, 9)" kind="«term_::_»">
                        <IdentNode start="(564, 5)" end="(564, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(564, 6)" end="(564, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(564, 8)" end="(564, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(564, 9)" end="(564, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(564, 11)" end="(564, 16)" kind="«term_+_»">
                        <IdentNode start="(564, 11)" end="(564, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                        <AtomNode start="(564, 13)" end="(564, 14)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(564, 15)" end="(564, 16)" kind="num">
                          <AtomNode start="(564, 15)" end="(564, 16)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(564, 17)" end="(564, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(564, 20)" end="(564, 46)">
                    <AtomNode start="(564, 20)" end="(564, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(564, 23)" end="(564, 46)">
                      <TacticTacticseq1IndentedNode start="(564, 23)" end="(564, 46)">
                        <NullNode start="(564, 23)" end="(564, 46)">
                          <OtherNode start="(564, 23)" end="(564, 46)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;k : Nat&#10;⊢ (a :: l).eraseIdx (k + 1) &amp;lt;+ a :: l" state_after="no goals" tactic="simp [eraseIdx_sublist]">
                            <AtomNode start="(564, 23)" end="(564, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(564, 28)" end="(564, 46)">
                              <AtomNode start="(564, 28)" end="(564, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(564, 29)" end="(564, 45)">
                                <OtherNode start="(564, 29)" end="(564, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(564, 29)" end="(564, 45)" leading="" trailing="" raw_val="eraseIdx_sublist" val="eraseIdx_sublist"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(564, 45)" end="(564, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(566, 1)" end="(567, 31)" name="mem_of_mem_eraseIdx" full_name="List.mem_of_mem_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(566, 1)" end="(567, 31)" name="mem_of_mem_eraseIdx" full_name="List.mem_of_mem_eraseIdx" _is_private_decl="False">
        <AtomNode start="(566, 1)" end="(566, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(566, 9)" end="(566, 28)">
          <IdentNode start="(566, 9)" end="(566, 28)" leading="" trailing=" " raw_val="mem_of_mem_eraseIdx" val="mem_of_mem_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(566, 29)" end="(566, 90)">
          <NullNode start="(566, 29)" end="(566, 82)">
            <OtherNode start="(566, 29)" end="(566, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(566, 29)" end="(566, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(566, 30)" end="(566, 31)">
                <IdentNode start="(566, 30)" end="(566, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(566, 32)" end="(566, 40)">
                <AtomNode start="(566, 32)" end="(566, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(566, 34)" end="(566, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(566, 34)" end="(566, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(566, 39)" end="(566, 40)">
                    <IdentNode start="(566, 39)" end="(566, 40)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(566, 40)" end="(566, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(566, 42)" end="(566, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(566, 42)" end="(566, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(566, 43)" end="(566, 44)">
                <IdentNode start="(566, 43)" end="(566, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(566, 45)" end="(566, 50)">
                <AtomNode start="(566, 45)" end="(566, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(566, 47)" end="(566, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(566, 50)" end="(566, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(566, 52)" end="(566, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(566, 52)" end="(566, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(566, 53)" end="(566, 54)">
                <IdentNode start="(566, 53)" end="(566, 54)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(566, 55)" end="(566, 58)">
                <AtomNode start="(566, 55)" end="(566, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(566, 57)" end="(566, 58)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(566, 58)" end="(566, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(566, 60)" end="(566, 82)">
              <AtomNode start="(566, 60)" end="(566, 61)" leading="" trailing="" val="("/>
              <NullNode start="(566, 61)" end="(566, 62)">
                <IdentNode start="(566, 61)" end="(566, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(566, 63)" end="(566, 81)">
                <AtomNode start="(566, 63)" end="(566, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(566, 65)" end="(566, 81)" kind="«term_∈_»">
                  <IdentNode start="(566, 65)" end="(566, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(566, 67)" end="(566, 68)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(566, 69)" end="(566, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(566, 69)" end="(566, 79)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                    <NullNode start="(566, 80)" end="(566, 81)">
                      <IdentNode start="(566, 80)" end="(566, 81)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(566, 81)" end="(566, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(566, 83)" end="(566, 90)">
            <AtomNode start="(566, 83)" end="(566, 84)" leading="" trailing=" " val=":"/>
            <OtherNode start="(566, 85)" end="(566, 90)" kind="«term_∈_»">
              <IdentNode start="(566, 85)" end="(566, 86)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(566, 87)" end="(566, 88)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(566, 89)" end="(566, 90)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(566, 91)" end="(567, 31)">
          <AtomNode start="(566, 91)" end="(566, 93)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(567, 3)" end="(567, 31)" kind="Lean.Parser.Term.app">
            <OtherNode start="(567, 3)" end="(567, 29)" kind="Lean.Parser.Term.proj">
              <OtherNode start="(567, 3)" end="(567, 25)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(567, 3)" end="(567, 4)" leading="" trailing="" val="("/>
                <OtherNode start="(567, 4)" end="(567, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(567, 4)" end="(567, 20)" leading="" trailing=" " raw_val="eraseIdx_sublist" val="eraseIdx_sublist" full_name="List.eraseIdx_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(561, 9)" def_end="(561, 25)"/>
                  <NullNode start="(567, 21)" end="(567, 24)">
                    <TermHoleNode start="(567, 21)" end="(567, 22)">
                      <AtomNode start="(567, 21)" end="(567, 22)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                    <TermHoleNode start="(567, 23)" end="(567, 24)">
                      <AtomNode start="(567, 23)" end="(567, 24)" leading="" trailing="" val="_"/>
                    </TermHoleNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(567, 24)" end="(567, 25)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(567, 25)" end="(567, 26)" leading="" trailing="" val="."/>
              <IdentNode start="(567, 26)" end="(567, 29)" leading="" trailing=" " raw_val="mem" val="mem" full_name="List.Sublist.mem" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
            </OtherNode>
            <NullNode start="(567, 30)" end="(567, 31)">
              <IdentNode start="(567, 30)" end="(567, 31)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(569, 1)" end="(570, 32)" name="eraseIdx_subset" full_name="List.eraseIdx_subset">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(569, 1)" end="(570, 32)" name="eraseIdx_subset" full_name="List.eraseIdx_subset" _is_private_decl="False">
        <AtomNode start="(569, 1)" end="(569, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(569, 9)" end="(569, 24)">
          <IdentNode start="(569, 9)" end="(569, 24)" leading="" trailing=" " raw_val="eraseIdx_subset" val="eraseIdx_subset"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(569, 25)" end="(569, 66)">
          <NullNode start="(569, 25)" end="(569, 47)">
            <OtherNode start="(569, 25)" end="(569, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(569, 25)" end="(569, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(569, 26)" end="(569, 27)">
                <IdentNode start="(569, 26)" end="(569, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(569, 28)" end="(569, 36)">
                <AtomNode start="(569, 28)" end="(569, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(569, 30)" end="(569, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(569, 30)" end="(569, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(569, 35)" end="(569, 36)">
                    <IdentNode start="(569, 35)" end="(569, 36)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(569, 36)" end="(569, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(569, 38)" end="(569, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(569, 38)" end="(569, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(569, 39)" end="(569, 40)">
                <IdentNode start="(569, 39)" end="(569, 40)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(569, 41)" end="(569, 46)">
                <AtomNode start="(569, 41)" end="(569, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(569, 43)" end="(569, 46)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(569, 46)" end="(569, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(569, 48)" end="(569, 66)">
            <AtomNode start="(569, 48)" end="(569, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(569, 50)" end="(569, 66)" kind="«term_⊆_»">
              <OtherNode start="(569, 50)" end="(569, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(569, 50)" end="(569, 58)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(569, 59)" end="(569, 62)">
                  <IdentNode start="(569, 59)" end="(569, 60)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(569, 61)" end="(569, 62)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(569, 63)" end="(569, 64)" leading="" trailing=" " val="⊆"/>
              <IdentNode start="(569, 65)" end="(569, 66)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(569, 67)" end="(570, 32)">
          <AtomNode start="(569, 67)" end="(569, 69)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(570, 3)" end="(570, 32)" kind="Lean.Parser.Term.proj">
            <OtherNode start="(570, 3)" end="(570, 25)" kind="Lean.Parser.Term.paren">
              <AtomNode start="(570, 3)" end="(570, 4)" leading="" trailing="" val="("/>
              <OtherNode start="(570, 4)" end="(570, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(570, 4)" end="(570, 20)" leading="" trailing=" " raw_val="eraseIdx_sublist" val="eraseIdx_sublist" full_name="List.eraseIdx_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(561, 9)" def_end="(561, 25)"/>
                <NullNode start="(570, 21)" end="(570, 24)">
                  <TermHoleNode start="(570, 21)" end="(570, 22)">
                    <AtomNode start="(570, 21)" end="(570, 22)" leading="" trailing=" " val="_"/>
                  </TermHoleNode>
                  <TermHoleNode start="(570, 23)" end="(570, 24)">
                    <AtomNode start="(570, 23)" end="(570, 24)" leading="" trailing="" val="_"/>
                  </TermHoleNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(570, 24)" end="(570, 25)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(570, 25)" end="(570, 26)" leading="" trailing="" val="."/>
            <IdentNode start="(570, 26)" end="(570, 32)" leading="" trailing="&#10;&#10;" raw_val="subset" val="subset" full_name="List.Sublist.subset" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(572, 1)" end="(576, 46)" name="eraseIdx_eq_self" full_name="List.eraseIdx_eq_self">
      <CommandDeclmodifiersNode start="(572, 1)" end="(572, 8)">
        <NullNode/>
        <NullNode start="(572, 1)" end="(572, 8)">
          <OtherNode start="(572, 1)" end="(572, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(572, 1)" end="(572, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(572, 3)" end="(572, 7)">
              <OtherNode start="(572, 3)" end="(572, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(572, 3)" end="(572, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(572, 3)" end="(572, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(572, 7)" end="(572, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(573, 1)" end="(576, 46)" name="eraseIdx_eq_self" full_name="List.eraseIdx_eq_self" _is_private_decl="False">
        <AtomNode start="(573, 1)" end="(573, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(573, 9)" end="(573, 25)">
          <IdentNode start="(573, 9)" end="(573, 25)" leading="" trailing=" " raw_val="eraseIdx_eq_self" val="eraseIdx_eq_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(573, 26)" end="(573, 85)">
          <NullNode/>
          <TermTypespecNode start="(573, 26)" end="(573, 85)">
            <AtomNode start="(573, 26)" end="(573, 27)" leading="" trailing=" " val=":"/>
            <OtherNode start="(573, 28)" end="(573, 85)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(573, 28)" end="(573, 29)" leading="" trailing=" " val="∀"/>
              <NullNode start="(573, 30)" end="(573, 52)">
                <OtherNode start="(573, 30)" end="(573, 42)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(573, 30)" end="(573, 31)" leading="" trailing="" val="{"/>
                  <NullNode start="(573, 31)" end="(573, 32)">
                    <IdentNode start="(573, 31)" end="(573, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(573, 33)" end="(573, 41)">
                    <AtomNode start="(573, 33)" end="(573, 34)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(573, 35)" end="(573, 41)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(573, 35)" end="(573, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(573, 40)" end="(573, 41)">
                        <IdentNode start="(573, 40)" end="(573, 41)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(573, 41)" end="(573, 42)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <OtherNode start="(573, 43)" end="(573, 52)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(573, 43)" end="(573, 44)" leading="" trailing="" val="{"/>
                  <NullNode start="(573, 44)" end="(573, 45)">
                    <IdentNode start="(573, 44)" end="(573, 45)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                  <NullNode start="(573, 46)" end="(573, 51)">
                    <AtomNode start="(573, 46)" end="(573, 47)" leading="" trailing=" " val=":"/>
                    <IdentNode start="(573, 48)" end="(573, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </NullNode>
                  <AtomNode start="(573, 51)" end="(573, 52)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(573, 52)" end="(573, 53)" leading="" trailing=" " val=","/>
              <OtherNode start="(573, 54)" end="(573, 85)" kind="«term_↔_»">
                <OtherNode start="(573, 54)" end="(573, 70)" kind="«term_=_»">
                  <OtherNode start="(573, 54)" end="(573, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(573, 54)" end="(573, 62)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(573, 63)" end="(573, 66)">
                      <IdentNode start="(573, 63)" end="(573, 64)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(573, 65)" end="(573, 66)" leading="" trailing=" " raw_val="k" val="k"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(573, 67)" end="(573, 68)" leading="" trailing=" " val="="/>
                  <IdentNode start="(573, 69)" end="(573, 70)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(573, 71)" end="(573, 72)" leading="" trailing=" " val="↔"/>
                <OtherNode start="(573, 73)" end="(573, 85)" kind="«term_≤_»">
                  <OtherNode start="(573, 73)" end="(573, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(573, 73)" end="(573, 79)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(573, 80)" end="(573, 81)">
                      <IdentNode start="(573, 80)" end="(573, 81)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(573, 82)" end="(573, 83)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(573, 84)" end="(573, 85)" leading="" trailing="&#10;  " raw_val="k" val="k"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(574, 3)" end="(576, 46)">
          <OtherNode start="(574, 3)" end="(576, 46)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(574, 3)" end="(576, 46)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(574, 3)" end="(576, 46)">
                <OtherNode start="(574, 3)" end="(574, 21)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(574, 3)" end="(574, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(574, 5)" end="(574, 10)">
                    <NullNode start="(574, 5)" end="(574, 10)">
                      <OtherNode start="(574, 5)" end="(574, 7)" kind="«term[_]»">
                        <AtomNode start="(574, 5)" end="(574, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(574, 6)" end="(574, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(574, 7)" end="(574, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(574, 9)" end="(574, 10)">
                        <AtomNode start="(574, 9)" end="(574, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(574, 11)" end="(574, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(574, 14)" end="(574, 21)">
                    <AtomNode start="(574, 14)" end="(574, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(574, 17)" end="(574, 21)">
                      <TacticTacticseq1IndentedNode start="(574, 17)" end="(574, 21)">
                        <NullNode start="(574, 17)" end="(574, 21)">
                          <OtherNode start="(574, 17)" end="(574, 21)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x✝ : Nat&#10;⊢ [].eraseIdx x✝ = [] ↔ [].length ≤ x✝" state_after="no goals" tactic="simp">
                            <AtomNode start="(574, 17)" end="(574, 21)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(575, 3)" end="(575, 49)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(575, 3)" end="(575, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(575, 5)" end="(575, 12)">
                    <NullNode start="(575, 5)" end="(575, 12)">
                      <OtherNode start="(575, 5)" end="(575, 9)" kind="«term_::_»">
                        <IdentNode start="(575, 5)" end="(575, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(575, 6)" end="(575, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(575, 8)" end="(575, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(575, 9)" end="(575, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(575, 11)" end="(575, 12)" kind="num">
                        <AtomNode start="(575, 11)" end="(575, 12)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(575, 13)" end="(575, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(575, 16)" end="(575, 49)">
                    <AtomNode start="(575, 16)" end="(575, 18)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(575, 19)" end="(575, 49)">
                      <TacticTacticseq1IndentedNode start="(575, 19)" end="(575, 49)">
                        <NullNode start="(575, 19)" end="(575, 49)">
                          <OtherNode start="(575, 19)" end="(575, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;⊢ (a :: l).eraseIdx 0 = a :: l ↔ (a :: l).length ≤ 0" state_after="no goals" tactic="simp [(cons_ne_self _ _).symm]">
                            <AtomNode start="(575, 19)" end="(575, 23)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(575, 24)" end="(575, 49)">
                              <AtomNode start="(575, 24)" end="(575, 25)" leading="" trailing="" val="["/>
                              <NullNode start="(575, 25)" end="(575, 48)">
                                <OtherNode start="(575, 25)" end="(575, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(575, 25)" end="(575, 48)" kind="Lean.Parser.Term.proj">
                                    <OtherNode start="(575, 25)" end="(575, 43)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(575, 25)" end="(575, 26)" leading="" trailing="" val="("/>
                                      <OtherNode start="(575, 26)" end="(575, 42)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(575, 26)" end="(575, 38)" leading="" trailing=" " raw_val="cons_ne_self" val="cons_ne_self" full_name="List.cons_ne_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        <NullNode start="(575, 39)" end="(575, 42)">
                                          <TermHoleNode start="(575, 39)" end="(575, 40)">
                                            <AtomNode start="(575, 39)" end="(575, 40)" leading="" trailing=" " val="_"/>
                                          </TermHoleNode>
                                          <TermHoleNode start="(575, 41)" end="(575, 42)">
                                            <AtomNode start="(575, 41)" end="(575, 42)" leading="" trailing="" val="_"/>
                                          </TermHoleNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(575, 42)" end="(575, 43)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(575, 43)" end="(575, 44)" leading="" trailing="" val="."/>
                                    <IdentNode start="(575, 44)" end="(575, 48)" leading="" trailing="" raw_val="symm" val="symm" full_name="Ne.symm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(575, 48)" end="(575, 49)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(576, 3)" end="(576, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(576, 3)" end="(576, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(576, 5)" end="(576, 16)">
                    <NullNode start="(576, 5)" end="(576, 16)">
                      <OtherNode start="(576, 5)" end="(576, 9)" kind="«term_::_»">
                        <IdentNode start="(576, 5)" end="(576, 6)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(576, 6)" end="(576, 8)" leading="" trailing="" val="::"/>
                        <IdentNode start="(576, 8)" end="(576, 9)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(576, 9)" end="(576, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(576, 11)" end="(576, 16)" kind="«term_+_»">
                        <IdentNode start="(576, 11)" end="(576, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                        <AtomNode start="(576, 13)" end="(576, 14)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(576, 15)" end="(576, 16)" kind="num">
                          <AtomNode start="(576, 15)" end="(576, 16)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(576, 17)" end="(576, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(576, 20)" end="(576, 46)">
                    <AtomNode start="(576, 20)" end="(576, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(576, 23)" end="(576, 46)">
                      <TacticTacticseq1IndentedNode start="(576, 23)" end="(576, 46)">
                        <NullNode start="(576, 23)" end="(576, 46)">
                          <OtherNode start="(576, 23)" end="(576, 46)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;l : List α&#10;k : Nat&#10;⊢ (a :: l).eraseIdx (k + 1) = a :: l ↔ (a :: l).length ≤ k + 1" state_after="no goals" tactic="simp [eraseIdx_eq_self]">
                            <AtomNode start="(576, 23)" end="(576, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(576, 28)" end="(576, 46)">
                              <AtomNode start="(576, 28)" end="(576, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(576, 29)" end="(576, 45)">
                                <OtherNode start="(576, 29)" end="(576, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(576, 29)" end="(576, 45)" leading="" trailing="" raw_val="eraseIdx_eq_self" val="eraseIdx_eq_self"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(576, 45)" end="(576, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(578, 1)" end="(579, 28)" name="eraseIdx_of_length_le" full_name="List.eraseIdx_of_length_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(578, 1)" end="(579, 28)" name="eraseIdx_of_length_le" full_name="List.eraseIdx_of_length_le" _is_private_decl="False">
        <AtomNode start="(578, 1)" end="(578, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(578, 9)" end="(578, 30)">
          <IdentNode start="(578, 9)" end="(578, 30)" leading="" trailing=" " raw_val="eraseIdx_of_length_le" val="eraseIdx_of_length_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(578, 31)" end="(578, 91)">
          <NullNode start="(578, 31)" end="(578, 72)">
            <OtherNode start="(578, 31)" end="(578, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(578, 31)" end="(578, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(578, 32)" end="(578, 33)">
                <IdentNode start="(578, 32)" end="(578, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(578, 34)" end="(578, 42)">
                <AtomNode start="(578, 34)" end="(578, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(578, 36)" end="(578, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(578, 36)" end="(578, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(578, 41)" end="(578, 42)">
                    <IdentNode start="(578, 41)" end="(578, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(578, 42)" end="(578, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(578, 44)" end="(578, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(578, 44)" end="(578, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(578, 45)" end="(578, 46)">
                <IdentNode start="(578, 45)" end="(578, 46)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(578, 47)" end="(578, 52)">
                <AtomNode start="(578, 47)" end="(578, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(578, 49)" end="(578, 52)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(578, 52)" end="(578, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(578, 54)" end="(578, 72)">
              <AtomNode start="(578, 54)" end="(578, 55)" leading="" trailing="" val="("/>
              <NullNode start="(578, 55)" end="(578, 56)">
                <IdentNode start="(578, 55)" end="(578, 56)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(578, 57)" end="(578, 71)">
                <AtomNode start="(578, 57)" end="(578, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(578, 59)" end="(578, 71)" kind="«term_≤_»">
                  <OtherNode start="(578, 59)" end="(578, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(578, 59)" end="(578, 65)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(578, 66)" end="(578, 67)">
                      <IdentNode start="(578, 66)" end="(578, 67)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(578, 68)" end="(578, 69)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(578, 70)" end="(578, 71)" leading="" trailing="" raw_val="k" val="k"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(578, 71)" end="(578, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(578, 73)" end="(578, 91)">
            <AtomNode start="(578, 73)" end="(578, 74)" leading="" trailing=" " val=":"/>
            <OtherNode start="(578, 75)" end="(578, 91)" kind="«term_=_»">
              <OtherNode start="(578, 75)" end="(578, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(578, 75)" end="(578, 83)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(578, 84)" end="(578, 87)">
                  <IdentNode start="(578, 84)" end="(578, 85)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(578, 86)" end="(578, 87)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(578, 88)" end="(578, 89)" leading="" trailing=" " val="="/>
              <IdentNode start="(578, 90)" end="(578, 91)" leading="" trailing=" " raw_val="l" val="l"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(578, 92)" end="(579, 28)">
          <AtomNode start="(578, 92)" end="(578, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(578, 95)" end="(579, 28)">
            <AtomNode start="(578, 95)" end="(578, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(579, 3)" end="(579, 28)">
              <TacticTacticseq1IndentedNode start="(579, 3)" end="(579, 28)">
                <NullNode start="(579, 3)" end="(579, 28)">
                  <OtherNode start="(579, 3)" end="(579, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;k : Nat&#10;h : l.length ≤ k&#10;⊢ l.eraseIdx k = l" state_after="no goals" tactic="rw [eraseIdx_eq_self.2 h]">
                    <AtomNode start="(579, 3)" end="(579, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(579, 6)" end="(579, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(579, 6)" end="(579, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(579, 7)" end="(579, 27)">
                        <OtherNode start="(579, 7)" end="(579, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(579, 7)" end="(579, 27)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(579, 7)" end="(579, 25)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(579, 7)" end="(579, 23)" leading="" trailing="" raw_val="eraseIdx_eq_self" val="eraseIdx_eq_self" full_name="List.eraseIdx_eq_self" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(573, 9)" def_end="(573, 25)"/>
                              <AtomNode start="(579, 23)" end="(579, 24)" leading="" trailing="" val="."/>
                              <OtherNode start="(579, 24)" end="(579, 25)" kind="fieldIdx">
                                <AtomNode start="(579, 24)" end="(579, 25)" leading="" trailing=" " val="2"/>
                              </OtherNode>
                            </OtherNode>
                            <NullNode start="(579, 26)" end="(579, 27)">
                              <IdentNode start="(579, 26)" end="(579, 27)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(579, 27)" end="(579, 28)" leading="" trailing="&#10;&#10;-- Arguments are intentionally explicit.&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(582, 1)" end="(583, 35)" name="length_eraseIdx_le" full_name="List.length_eraseIdx_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(582, 1)" end="(583, 35)" name="length_eraseIdx_le" full_name="List.length_eraseIdx_le" _is_private_decl="False">
        <AtomNode start="(582, 1)" end="(582, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(582, 9)" end="(582, 27)">
          <IdentNode start="(582, 9)" end="(582, 27)" leading="" trailing=" " raw_val="length_eraseIdx_le" val="length_eraseIdx_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(582, 28)" end="(582, 85)">
          <NullNode start="(582, 28)" end="(582, 50)">
            <TermExplicitbinderNode start="(582, 28)" end="(582, 40)">
              <AtomNode start="(582, 28)" end="(582, 29)" leading="" trailing="" val="("/>
              <NullNode start="(582, 29)" end="(582, 30)">
                <IdentNode start="(582, 29)" end="(582, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(582, 31)" end="(582, 39)">
                <AtomNode start="(582, 31)" end="(582, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(582, 33)" end="(582, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(582, 33)" end="(582, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(582, 38)" end="(582, 39)">
                    <IdentNode start="(582, 38)" end="(582, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(582, 39)" end="(582, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(582, 41)" end="(582, 50)">
              <AtomNode start="(582, 41)" end="(582, 42)" leading="" trailing="" val="("/>
              <NullNode start="(582, 42)" end="(582, 43)">
                <IdentNode start="(582, 42)" end="(582, 43)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(582, 44)" end="(582, 49)">
                <AtomNode start="(582, 44)" end="(582, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(582, 46)" end="(582, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(582, 49)" end="(582, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(582, 51)" end="(582, 85)">
            <AtomNode start="(582, 51)" end="(582, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(582, 53)" end="(582, 85)" kind="«term_≤_»">
              <OtherNode start="(582, 53)" end="(582, 74)" kind="Lean.Parser.Term.app">
                <IdentNode start="(582, 53)" end="(582, 59)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(582, 60)" end="(582, 74)">
                  <OtherNode start="(582, 60)" end="(582, 74)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(582, 60)" end="(582, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(582, 61)" end="(582, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(582, 61)" end="(582, 71)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(582, 72)" end="(582, 73)">
                        <IdentNode start="(582, 72)" end="(582, 73)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(582, 73)" end="(582, 74)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(582, 75)" end="(582, 76)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(582, 77)" end="(582, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(582, 77)" end="(582, 83)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(582, 84)" end="(582, 85)">
                  <IdentNode start="(582, 84)" end="(582, 85)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(582, 86)" end="(583, 35)">
          <AtomNode start="(582, 86)" end="(582, 88)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(583, 3)" end="(583, 35)" kind="Lean.Parser.Term.proj">
            <OtherNode start="(583, 3)" end="(583, 25)" kind="Lean.Parser.Term.paren">
              <AtomNode start="(583, 3)" end="(583, 4)" leading="" trailing="" val="("/>
              <OtherNode start="(583, 4)" end="(583, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(583, 4)" end="(583, 20)" leading="" trailing=" " raw_val="eraseIdx_sublist" val="eraseIdx_sublist" full_name="List.eraseIdx_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(561, 9)" def_end="(561, 25)"/>
                <NullNode start="(583, 21)" end="(583, 24)">
                  <TermHoleNode start="(583, 21)" end="(583, 22)">
                    <AtomNode start="(583, 21)" end="(583, 22)" leading="" trailing=" " val="_"/>
                  </TermHoleNode>
                  <TermHoleNode start="(583, 23)" end="(583, 24)">
                    <AtomNode start="(583, 23)" end="(583, 24)" leading="" trailing="" val="_"/>
                  </TermHoleNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(583, 24)" end="(583, 25)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(583, 25)" end="(583, 26)" leading="" trailing="" val="."/>
            <IdentNode start="(583, 26)" end="(583, 35)" leading="" trailing="&#10;&#10;-- Arguments are intentionally explicit.&#10;" raw_val="length_le" val="length_le" full_name="List.Sublist.length_le" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(586, 1)" end="(588, 17)" name="le_length_eraseIdx" full_name="List.le_length_eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(586, 1)" end="(588, 17)" name="le_length_eraseIdx" full_name="List.le_length_eraseIdx" _is_private_decl="False">
        <AtomNode start="(586, 1)" end="(586, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(586, 9)" end="(586, 27)">
          <IdentNode start="(586, 9)" end="(586, 27)" leading="" trailing=" " raw_val="le_length_eraseIdx" val="le_length_eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(586, 28)" end="(586, 89)">
          <NullNode start="(586, 28)" end="(586, 50)">
            <TermExplicitbinderNode start="(586, 28)" end="(586, 40)">
              <AtomNode start="(586, 28)" end="(586, 29)" leading="" trailing="" val="("/>
              <NullNode start="(586, 29)" end="(586, 30)">
                <IdentNode start="(586, 29)" end="(586, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(586, 31)" end="(586, 39)">
                <AtomNode start="(586, 31)" end="(586, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(586, 33)" end="(586, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(586, 33)" end="(586, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(586, 38)" end="(586, 39)">
                    <IdentNode start="(586, 38)" end="(586, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(586, 39)" end="(586, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(586, 41)" end="(586, 50)">
              <AtomNode start="(586, 41)" end="(586, 42)" leading="" trailing="" val="("/>
              <NullNode start="(586, 42)" end="(586, 43)">
                <IdentNode start="(586, 42)" end="(586, 43)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(586, 44)" end="(586, 49)">
                <AtomNode start="(586, 44)" end="(586, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(586, 46)" end="(586, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(586, 49)" end="(586, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(586, 51)" end="(586, 89)">
            <AtomNode start="(586, 51)" end="(586, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(586, 53)" end="(586, 89)" kind="«term_≤_»">
              <OtherNode start="(586, 53)" end="(586, 65)" kind="«term_-_»">
                <OtherNode start="(586, 53)" end="(586, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(586, 53)" end="(586, 59)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(586, 60)" end="(586, 61)">
                    <IdentNode start="(586, 60)" end="(586, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(586, 62)" end="(586, 63)" leading="" trailing=" " val="-"/>
                <OtherNode start="(586, 64)" end="(586, 65)" kind="num">
                  <AtomNode start="(586, 64)" end="(586, 65)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(586, 66)" end="(586, 67)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(586, 68)" end="(586, 89)" kind="Lean.Parser.Term.app">
                <IdentNode start="(586, 68)" end="(586, 74)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(586, 75)" end="(586, 89)">
                  <OtherNode start="(586, 75)" end="(586, 89)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(586, 75)" end="(586, 76)" leading="" trailing="" val="("/>
                    <OtherNode start="(586, 76)" end="(586, 88)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(586, 76)" end="(586, 86)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(586, 87)" end="(586, 88)">
                        <IdentNode start="(586, 87)" end="(586, 88)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(586, 88)" end="(586, 89)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(586, 90)" end="(588, 17)">
          <AtomNode start="(586, 90)" end="(586, 92)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(586, 93)" end="(588, 17)">
            <AtomNode start="(586, 93)" end="(586, 95)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(587, 3)" end="(588, 17)">
              <TacticTacticseq1IndentedNode start="(587, 3)" end="(588, 17)">
                <NullNode start="(587, 3)" end="(588, 17)">
                  <OtherNode start="(587, 3)" end="(587, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.length - 1 ≤ (l.eraseIdx i).length" state_after="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.length - 1 ≤ if i &amp;lt; l.length then l.length - 1 else l.length" tactic="rw [length_eraseIdx]">
                    <AtomNode start="(587, 3)" end="(587, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(587, 6)" end="(587, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(587, 6)" end="(587, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(587, 7)" end="(587, 22)">
                        <OtherNode start="(587, 7)" end="(587, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(587, 7)" end="(587, 22)" leading="" trailing="" raw_val="length_eraseIdx" val="length_eraseIdx" full_name="List.length_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(516, 9)" def_end="(516, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(587, 22)" end="(587, 23)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(588, 3)" end="(588, 17)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.length - 1 ≤ if i &amp;lt; l.length then l.length - 1 else l.length" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(588, 3)" end="(588, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(588, 3)" end="(588, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(588, 9)" end="(588, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(588, 13)" end="(588, 17)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(588, 13)" end="(588, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(590, 1)" end="(597, 68)" name="eraseIdx_append_of_lt_length" full_name="List.eraseIdx_append_of_lt_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(590, 1)" end="(597, 68)" name="eraseIdx_append_of_lt_length" full_name="List.eraseIdx_append_of_lt_length" _is_private_decl="False">
        <AtomNode start="(590, 1)" end="(590, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(590, 9)" end="(590, 37)">
          <IdentNode start="(590, 9)" end="(590, 37)" leading="" trailing=" " raw_val="eraseIdx_append_of_lt_length" val="eraseIdx_append_of_lt_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(590, 38)" end="(591, 46)">
          <NullNode start="(590, 38)" end="(590, 94)">
            <OtherNode start="(590, 38)" end="(590, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(590, 38)" end="(590, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(590, 39)" end="(590, 40)">
                <IdentNode start="(590, 39)" end="(590, 40)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(590, 41)" end="(590, 49)">
                <AtomNode start="(590, 41)" end="(590, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(590, 43)" end="(590, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(590, 43)" end="(590, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(590, 48)" end="(590, 49)">
                    <IdentNode start="(590, 48)" end="(590, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(590, 49)" end="(590, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(590, 51)" end="(590, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(590, 51)" end="(590, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(590, 52)" end="(590, 53)">
                <IdentNode start="(590, 52)" end="(590, 53)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(590, 54)" end="(590, 59)">
                <AtomNode start="(590, 54)" end="(590, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(590, 56)" end="(590, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(590, 59)" end="(590, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(590, 61)" end="(590, 80)">
              <AtomNode start="(590, 61)" end="(590, 62)" leading="" trailing="" val="("/>
              <NullNode start="(590, 62)" end="(590, 64)">
                <IdentNode start="(590, 62)" end="(590, 64)" leading="" trailing=" " raw_val="hk" val="hk"/>
              </NullNode>
              <NullNode start="(590, 65)" end="(590, 79)">
                <AtomNode start="(590, 65)" end="(590, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(590, 67)" end="(590, 79)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(590, 67)" end="(590, 68)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(590, 69)" end="(590, 70)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(590, 71)" end="(590, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(590, 71)" end="(590, 77)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(590, 78)" end="(590, 79)">
                      <IdentNode start="(590, 78)" end="(590, 79)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(590, 79)" end="(590, 80)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(590, 81)" end="(590, 94)">
              <AtomNode start="(590, 81)" end="(590, 82)" leading="" trailing="" val="("/>
              <NullNode start="(590, 82)" end="(590, 84)">
                <IdentNode start="(590, 82)" end="(590, 84)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(590, 85)" end="(590, 93)">
                <AtomNode start="(590, 85)" end="(590, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(590, 87)" end="(590, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(590, 87)" end="(590, 91)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(590, 92)" end="(590, 93)">
                    <IdentNode start="(590, 92)" end="(590, 93)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(590, 93)" end="(590, 94)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(590, 95)" end="(591, 46)">
            <AtomNode start="(590, 95)" end="(590, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(591, 5)" end="(591, 46)" kind="«term_=_»">
              <OtherNode start="(591, 5)" end="(591, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(591, 5)" end="(591, 13)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(591, 14)" end="(591, 25)">
                  <OtherNode start="(591, 14)" end="(591, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(591, 14)" end="(591, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(591, 15)" end="(591, 22)" kind="«term_++_»">
                      <IdentNode start="(591, 15)" end="(591, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(591, 17)" end="(591, 19)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(591, 20)" end="(591, 22)" leading="" trailing="" raw_val="l'" val="l'"/>
                    </OtherNode>
                    <AtomNode start="(591, 22)" end="(591, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(591, 24)" end="(591, 25)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(591, 26)" end="(591, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(591, 28)" end="(591, 46)" kind="«term_++_»">
                <OtherNode start="(591, 28)" end="(591, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(591, 28)" end="(591, 36)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(591, 37)" end="(591, 40)">
                    <IdentNode start="(591, 37)" end="(591, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(591, 39)" end="(591, 40)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(591, 41)" end="(591, 43)" leading="" trailing=" " val="++"/>
                <IdentNode start="(591, 44)" end="(591, 46)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(591, 47)" end="(597, 68)">
          <AtomNode start="(591, 47)" end="(591, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(591, 50)" end="(597, 68)">
            <AtomNode start="(591, 50)" end="(591, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(592, 3)" end="(597, 68)">
              <TacticTacticseq1IndentedNode start="(592, 3)" end="(597, 68)">
                <NullNode start="(592, 3)" end="(597, 68)">
                  <OtherNode start="(592, 3)" end="(597, 68)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List α&#10;k : Nat&#10;hk : k &amp;lt; l.length&#10;l' : List α&#10;⊢ (l ++ l').eraseIdx k = l.eraseIdx k ++ l'" state_after="no goals" tactic="induction l generalizing k with&#10;| nil =&amp;gt; simp_all&#10;| cons x l ih =&amp;gt;&#10;  cases k with&#10;  | zero =&amp;gt; rfl&#10;  | succ k =&amp;gt; simp_all [eraseIdx_cons_succ, Nat.succ_lt_succ_iff]">
                    <AtomNode start="(592, 3)" end="(592, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(592, 13)" end="(592, 14)">
                      <OtherNode start="(592, 13)" end="(592, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(592, 13)" end="(592, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(592, 15)" end="(592, 29)">
                      <AtomNode start="(592, 15)" end="(592, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(592, 28)" end="(592, 29)">
                        <IdentNode start="(592, 28)" end="(592, 29)" leading="" trailing=" " raw_val="k" val="k"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(592, 30)" end="(597, 68)">
                      <OtherNode start="(592, 30)" end="(597, 68)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(592, 30)" end="(592, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(593, 3)" end="(597, 68)">
                          <OtherNode start="(593, 3)" end="(593, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(593, 3)" end="(593, 8)">
                              <OtherNode start="(593, 3)" end="(593, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(593, 3)" end="(593, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(593, 5)" end="(593, 8)">
                                  <NullNode/>
                                  <IdentNode start="(593, 5)" end="(593, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(593, 9)" end="(593, 20)">
                              <AtomNode start="(593, 9)" end="(593, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(593, 12)" end="(593, 20)">
                                <TacticTacticseq1IndentedNode start="(593, 12)" end="(593, 20)">
                                  <NullNode start="(593, 12)" end="(593, 20)">
                                    <OtherNode start="(593, 12)" end="(593, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;l' : List α&#10;k : Nat&#10;hk : k &amp;lt; [].length&#10;⊢ ([] ++ l').eraseIdx k = [].eraseIdx k ++ l'" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(593, 12)" end="(593, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(594, 3)" end="(597, 68)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(594, 3)" end="(594, 16)">
                              <OtherNode start="(594, 3)" end="(594, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(594, 3)" end="(594, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(594, 5)" end="(594, 9)">
                                  <NullNode/>
                                  <IdentNode start="(594, 5)" end="(594, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(594, 10)" end="(594, 16)">
                                  <IdentNode start="(594, 10)" end="(594, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(594, 12)" end="(594, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(594, 14)" end="(594, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(594, 17)" end="(597, 68)">
                              <AtomNode start="(594, 17)" end="(594, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(595, 5)" end="(597, 68)">
                                <TacticTacticseq1IndentedNode start="(595, 5)" end="(597, 68)">
                                  <NullNode start="(595, 5)" end="(597, 68)">
                                    <OtherNode start="(595, 5)" end="(597, 68)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;l' : List α&#10;x : α&#10;l : List α&#10;ih : ∀ {k : Nat}, k &amp;lt; l.length → (l ++ l').eraseIdx k = l.eraseIdx k ++ l'&#10;k : Nat&#10;hk : k &amp;lt; (x :: l).length&#10;⊢ (x :: l ++ l').eraseIdx k = (x :: l).eraseIdx k ++ l'" state_after="no goals" tactic="cases k with&#10;| zero =&amp;gt; rfl&#10;| succ k =&amp;gt; simp_all [eraseIdx_cons_succ, Nat.succ_lt_succ_iff]">
                                      <AtomNode start="(595, 5)" end="(595, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(595, 11)" end="(595, 12)">
                                        <OtherNode start="(595, 11)" end="(595, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(595, 11)" end="(595, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(595, 13)" end="(597, 68)">
                                        <OtherNode start="(595, 13)" end="(597, 68)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(595, 13)" end="(595, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(596, 5)" end="(597, 68)">
                                            <OtherNode start="(596, 5)" end="(596, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(596, 5)" end="(596, 11)">
                                                <OtherNode start="(596, 5)" end="(596, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(596, 5)" end="(596, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(596, 7)" end="(596, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(596, 7)" end="(596, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(596, 12)" end="(596, 18)">
                                                <AtomNode start="(596, 12)" end="(596, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(596, 15)" end="(596, 18)">
                                                  <TacticTacticseq1IndentedNode start="(596, 15)" end="(596, 18)">
                                                    <NullNode start="(596, 15)" end="(596, 18)">
                                                      <OtherNode start="(596, 15)" end="(596, 18)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.zero&#10;α : Type u_1&#10;l' : List α&#10;x : α&#10;l : List α&#10;ih : ∀ {k : Nat}, k &amp;lt; l.length → (l ++ l').eraseIdx k = l.eraseIdx k ++ l'&#10;hk : 0 &amp;lt; (x :: l).length&#10;⊢ (x :: l ++ l').eraseIdx 0 = (x :: l).eraseIdx 0 ++ l'" state_after="no goals" tactic="rfl">
                                                        <AtomNode start="(596, 15)" end="(596, 18)" leading="" trailing="&#10;    " val="rfl"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(597, 5)" end="(597, 68)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(597, 5)" end="(597, 13)">
                                                <OtherNode start="(597, 5)" end="(597, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(597, 5)" end="(597, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(597, 7)" end="(597, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(597, 7)" end="(597, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(597, 12)" end="(597, 13)">
                                                    <IdentNode start="(597, 12)" end="(597, 13)" leading="" trailing=" " raw_val="k" val="k"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(597, 14)" end="(597, 68)">
                                                <AtomNode start="(597, 14)" end="(597, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(597, 17)" end="(597, 68)">
                                                  <TacticTacticseq1IndentedNode start="(597, 17)" end="(597, 68)">
                                                    <NullNode start="(597, 17)" end="(597, 68)">
                                                      <OtherNode start="(597, 17)" end="(597, 68)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.succ&#10;α : Type u_1&#10;l' : List α&#10;x : α&#10;l : List α&#10;ih : ∀ {k : Nat}, k &amp;lt; l.length → (l ++ l').eraseIdx k = l.eraseIdx k ++ l'&#10;k : Nat&#10;hk : k + 1 &amp;lt; (x :: l).length&#10;⊢ (x :: l ++ l').eraseIdx (k + 1) = (x :: l).eraseIdx (k + 1) ++ l'" state_after="no goals" tactic="simp_all [eraseIdx_cons_succ, Nat.succ_lt_succ_iff]">
                                                        <AtomNode start="(597, 17)" end="(597, 25)" leading="" trailing=" " val="simp_all"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(597, 26)" end="(597, 68)">
                                                          <AtomNode start="(597, 26)" end="(597, 27)" leading="" trailing="" val="["/>
                                                          <NullNode start="(597, 27)" end="(597, 67)">
                                                            <OtherNode start="(597, 27)" end="(597, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(597, 27)" end="(597, 45)" leading="" trailing="" raw_val="eraseIdx_cons_succ" val="eraseIdx_cons_succ" full_name="List.eraseIdx_cons_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(597, 45)" end="(597, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(597, 47)" end="(597, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(597, 47)" end="(597, 67)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(597, 67)" end="(597, 68)" leading="" trailing="&#10;&#10;" val="]"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(599, 1)" end="(606, 65)" name="eraseIdx_append_of_length_le" full_name="List.eraseIdx_append_of_length_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(599, 1)" end="(606, 65)" name="eraseIdx_append_of_length_le" full_name="List.eraseIdx_append_of_length_le" _is_private_decl="False">
        <AtomNode start="(599, 1)" end="(599, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(599, 9)" end="(599, 37)">
          <IdentNode start="(599, 9)" end="(599, 37)" leading="" trailing=" " raw_val="eraseIdx_append_of_length_le" val="eraseIdx_append_of_length_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(599, 38)" end="(600, 59)">
          <NullNode start="(599, 38)" end="(599, 94)">
            <OtherNode start="(599, 38)" end="(599, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(599, 38)" end="(599, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(599, 39)" end="(599, 40)">
                <IdentNode start="(599, 39)" end="(599, 40)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(599, 41)" end="(599, 49)">
                <AtomNode start="(599, 41)" end="(599, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(599, 43)" end="(599, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(599, 43)" end="(599, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(599, 48)" end="(599, 49)">
                    <IdentNode start="(599, 48)" end="(599, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(599, 49)" end="(599, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(599, 51)" end="(599, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(599, 51)" end="(599, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(599, 52)" end="(599, 53)">
                <IdentNode start="(599, 52)" end="(599, 53)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(599, 54)" end="(599, 59)">
                <AtomNode start="(599, 54)" end="(599, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(599, 56)" end="(599, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(599, 59)" end="(599, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(599, 61)" end="(599, 80)">
              <AtomNode start="(599, 61)" end="(599, 62)" leading="" trailing="" val="("/>
              <NullNode start="(599, 62)" end="(599, 64)">
                <IdentNode start="(599, 62)" end="(599, 64)" leading="" trailing=" " raw_val="hk" val="hk"/>
              </NullNode>
              <NullNode start="(599, 65)" end="(599, 79)">
                <AtomNode start="(599, 65)" end="(599, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(599, 67)" end="(599, 79)" kind="«term_≤_»">
                  <OtherNode start="(599, 67)" end="(599, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(599, 67)" end="(599, 73)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(599, 74)" end="(599, 75)">
                      <IdentNode start="(599, 74)" end="(599, 75)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(599, 76)" end="(599, 77)" leading="" trailing=" " val="≤"/>
                  <IdentNode start="(599, 78)" end="(599, 79)" leading="" trailing="" raw_val="k" val="k"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(599, 79)" end="(599, 80)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(599, 81)" end="(599, 94)">
              <AtomNode start="(599, 81)" end="(599, 82)" leading="" trailing="" val="("/>
              <NullNode start="(599, 82)" end="(599, 84)">
                <IdentNode start="(599, 82)" end="(599, 84)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(599, 85)" end="(599, 93)">
                <AtomNode start="(599, 85)" end="(599, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(599, 87)" end="(599, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(599, 87)" end="(599, 91)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(599, 92)" end="(599, 93)">
                    <IdentNode start="(599, 92)" end="(599, 93)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(599, 93)" end="(599, 94)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(599, 95)" end="(600, 59)">
            <AtomNode start="(599, 95)" end="(599, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(600, 5)" end="(600, 59)" kind="«term_=_»">
              <OtherNode start="(600, 5)" end="(600, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(600, 5)" end="(600, 13)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(600, 14)" end="(600, 25)">
                  <OtherNode start="(600, 14)" end="(600, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(600, 14)" end="(600, 15)" leading="" trailing="" val="("/>
                    <OtherNode start="(600, 15)" end="(600, 22)" kind="«term_++_»">
                      <IdentNode start="(600, 15)" end="(600, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(600, 17)" end="(600, 19)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(600, 20)" end="(600, 22)" leading="" trailing="" raw_val="l'" val="l'"/>
                    </OtherNode>
                    <AtomNode start="(600, 22)" end="(600, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(600, 24)" end="(600, 25)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(600, 26)" end="(600, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(600, 28)" end="(600, 59)" kind="«term_++_»">
                <IdentNode start="(600, 28)" end="(600, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                <AtomNode start="(600, 30)" end="(600, 32)" leading="" trailing=" " val="++"/>
                <OtherNode start="(600, 33)" end="(600, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(600, 33)" end="(600, 41)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(600, 42)" end="(600, 59)">
                    <IdentNode start="(600, 42)" end="(600, 44)" leading="" trailing=" " raw_val="l'" val="l'"/>
                    <OtherNode start="(600, 45)" end="(600, 59)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(600, 45)" end="(600, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(600, 46)" end="(600, 58)" kind="«term_-_»">
                        <IdentNode start="(600, 46)" end="(600, 47)" leading="" trailing=" " raw_val="k" val="k"/>
                        <AtomNode start="(600, 48)" end="(600, 49)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(600, 50)" end="(600, 58)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(600, 50)" end="(600, 56)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(600, 57)" end="(600, 58)">
                            <IdentNode start="(600, 57)" end="(600, 58)" leading="" trailing="" raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(600, 58)" end="(600, 59)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(600, 60)" end="(606, 65)">
          <AtomNode start="(600, 60)" end="(600, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(600, 63)" end="(606, 65)">
            <AtomNode start="(600, 63)" end="(600, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(601, 3)" end="(606, 65)">
              <TacticTacticseq1IndentedNode start="(601, 3)" end="(606, 65)">
                <NullNode start="(601, 3)" end="(606, 65)">
                  <OtherNode start="(601, 3)" end="(606, 65)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List α&#10;k : Nat&#10;hk : l.length ≤ k&#10;l' : List α&#10;⊢ (l ++ l').eraseIdx k = l ++ l'.eraseIdx (k - l.length)" state_after="no goals" tactic="induction l generalizing k with&#10;| nil =&amp;gt; simp_all&#10;| cons x l ih =&amp;gt;&#10;  cases k with&#10;  | zero =&amp;gt; simp_all&#10;  | succ k =&amp;gt; simp_all [eraseIdx_cons_succ, Nat.succ_sub_succ]">
                    <AtomNode start="(601, 3)" end="(601, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(601, 13)" end="(601, 14)">
                      <OtherNode start="(601, 13)" end="(601, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(601, 13)" end="(601, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(601, 15)" end="(601, 29)">
                      <AtomNode start="(601, 15)" end="(601, 27)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(601, 28)" end="(601, 29)">
                        <IdentNode start="(601, 28)" end="(601, 29)" leading="" trailing=" " raw_val="k" val="k"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(601, 30)" end="(606, 65)">
                      <OtherNode start="(601, 30)" end="(606, 65)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(601, 30)" end="(601, 34)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(602, 3)" end="(606, 65)">
                          <OtherNode start="(602, 3)" end="(602, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(602, 3)" end="(602, 8)">
                              <OtherNode start="(602, 3)" end="(602, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(602, 3)" end="(602, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(602, 5)" end="(602, 8)">
                                  <NullNode/>
                                  <IdentNode start="(602, 5)" end="(602, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(602, 9)" end="(602, 20)">
                              <AtomNode start="(602, 9)" end="(602, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(602, 12)" end="(602, 20)">
                                <TacticTacticseq1IndentedNode start="(602, 12)" end="(602, 20)">
                                  <NullNode start="(602, 12)" end="(602, 20)">
                                    <OtherNode start="(602, 12)" end="(602, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;l' : List α&#10;k : Nat&#10;hk : [].length ≤ k&#10;⊢ ([] ++ l').eraseIdx k = [] ++ l'.eraseIdx (k - [].length)" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(602, 12)" end="(602, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(603, 3)" end="(606, 65)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(603, 3)" end="(603, 16)">
                              <OtherNode start="(603, 3)" end="(603, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(603, 3)" end="(603, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(603, 5)" end="(603, 9)">
                                  <NullNode/>
                                  <IdentNode start="(603, 5)" end="(603, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(603, 10)" end="(603, 16)">
                                  <IdentNode start="(603, 10)" end="(603, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(603, 12)" end="(603, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(603, 14)" end="(603, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(603, 17)" end="(606, 65)">
                              <AtomNode start="(603, 17)" end="(603, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(604, 5)" end="(606, 65)">
                                <TacticTacticseq1IndentedNode start="(604, 5)" end="(606, 65)">
                                  <NullNode start="(604, 5)" end="(606, 65)">
                                    <OtherNode start="(604, 5)" end="(606, 65)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;l' : List α&#10;x : α&#10;l : List α&#10;ih : ∀ {k : Nat}, l.length ≤ k → (l ++ l').eraseIdx k = l ++ l'.eraseIdx (k - l.length)&#10;k : Nat&#10;hk : (x :: l).length ≤ k&#10;⊢ (x :: l ++ l').eraseIdx k = x :: l ++ l'.eraseIdx (k - (x :: l).length)" state_after="no goals" tactic="cases k with&#10;| zero =&amp;gt; simp_all&#10;| succ k =&amp;gt; simp_all [eraseIdx_cons_succ, Nat.succ_sub_succ]">
                                      <AtomNode start="(604, 5)" end="(604, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(604, 11)" end="(604, 12)">
                                        <OtherNode start="(604, 11)" end="(604, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(604, 11)" end="(604, 12)" leading="" trailing=" " raw_val="k" val="k"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(604, 13)" end="(606, 65)">
                                        <OtherNode start="(604, 13)" end="(606, 65)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(604, 13)" end="(604, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(605, 5)" end="(606, 65)">
                                            <OtherNode start="(605, 5)" end="(605, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(605, 5)" end="(605, 11)">
                                                <OtherNode start="(605, 5)" end="(605, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(605, 5)" end="(605, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(605, 7)" end="(605, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(605, 7)" end="(605, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(605, 12)" end="(605, 23)">
                                                <AtomNode start="(605, 12)" end="(605, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(605, 15)" end="(605, 23)">
                                                  <TacticTacticseq1IndentedNode start="(605, 15)" end="(605, 23)">
                                                    <NullNode start="(605, 15)" end="(605, 23)">
                                                      <OtherNode start="(605, 15)" end="(605, 23)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.zero&#10;α : Type u_1&#10;l' : List α&#10;x : α&#10;l : List α&#10;ih : ∀ {k : Nat}, l.length ≤ k → (l ++ l').eraseIdx k = l ++ l'.eraseIdx (k - l.length)&#10;hk : (x :: l).length ≤ 0&#10;⊢ (x :: l ++ l').eraseIdx 0 = x :: l ++ l'.eraseIdx (0 - (x :: l).length)" state_after="no goals" tactic="simp_all">
                                                        <AtomNode start="(605, 15)" end="(605, 23)" leading="" trailing="&#10;    " val="simp_all"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(606, 5)" end="(606, 65)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(606, 5)" end="(606, 13)">
                                                <OtherNode start="(606, 5)" end="(606, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(606, 5)" end="(606, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(606, 7)" end="(606, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(606, 7)" end="(606, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(606, 12)" end="(606, 13)">
                                                    <IdentNode start="(606, 12)" end="(606, 13)" leading="" trailing=" " raw_val="k" val="k"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(606, 14)" end="(606, 65)">
                                                <AtomNode start="(606, 14)" end="(606, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(606, 17)" end="(606, 65)">
                                                  <TacticTacticseq1IndentedNode start="(606, 17)" end="(606, 65)">
                                                    <NullNode start="(606, 17)" end="(606, 65)">
                                                      <OtherNode start="(606, 17)" end="(606, 65)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.succ&#10;α : Type u_1&#10;l' : List α&#10;x : α&#10;l : List α&#10;ih : ∀ {k : Nat}, l.length ≤ k → (l ++ l').eraseIdx k = l ++ l'.eraseIdx (k - l.length)&#10;k : Nat&#10;hk : (x :: l).length ≤ k + 1&#10;⊢ (x :: l ++ l').eraseIdx (k + 1) = x :: l ++ l'.eraseIdx (k + 1 - (x :: l).length)" state_after="no goals" tactic="simp_all [eraseIdx_cons_succ, Nat.succ_sub_succ]">
                                                        <AtomNode start="(606, 17)" end="(606, 25)" leading="" trailing=" " val="simp_all"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(606, 26)" end="(606, 65)">
                                                          <AtomNode start="(606, 26)" end="(606, 27)" leading="" trailing="" val="["/>
                                                          <NullNode start="(606, 27)" end="(606, 64)">
                                                            <OtherNode start="(606, 27)" end="(606, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(606, 27)" end="(606, 45)" leading="" trailing="" raw_val="eraseIdx_cons_succ" val="eraseIdx_cons_succ" full_name="List.eraseIdx_cons_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(606, 45)" end="(606, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(606, 47)" end="(606, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(606, 47)" end="(606, 64)" leading="" trailing="" raw_val="Nat.succ_sub_succ" val="Nat.succ_sub_succ" full_name="Nat.succ_sub_succ" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(606, 64)" end="(606, 65)" leading="" trailing="&#10;&#10;" val="]"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(608, 1)" end="(617, 50)" name="eraseIdx_replicate" full_name="List.eraseIdx_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(608, 1)" end="(617, 50)" name="eraseIdx_replicate" full_name="List.eraseIdx_replicate" _is_private_decl="False">
        <AtomNode start="(608, 1)" end="(608, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(608, 9)" end="(608, 27)">
          <IdentNode start="(608, 9)" end="(608, 27)" leading="" trailing=" " raw_val="eraseIdx_replicate" val="eraseIdx_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(608, 28)" end="(609, 86)">
          <NullNode start="(608, 28)" end="(608, 55)">
            <OtherNode start="(608, 28)" end="(608, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 28)" end="(608, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 29)" end="(608, 30)">
                <IdentNode start="(608, 29)" end="(608, 30)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(608, 31)" end="(608, 36)">
                <AtomNode start="(608, 31)" end="(608, 32)" leading="" trailing=" " val=":"/>
                <IdentNode start="(608, 33)" end="(608, 36)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(608, 36)" end="(608, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(608, 38)" end="(608, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 38)" end="(608, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 39)" end="(608, 40)">
                <IdentNode start="(608, 39)" end="(608, 40)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(608, 41)" end="(608, 44)">
                <AtomNode start="(608, 41)" end="(608, 42)" leading="" trailing=" " val=":"/>
                <IdentNode start="(608, 43)" end="(608, 44)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(608, 44)" end="(608, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(608, 46)" end="(608, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(608, 46)" end="(608, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(608, 47)" end="(608, 48)">
                <IdentNode start="(608, 47)" end="(608, 48)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(608, 49)" end="(608, 54)">
                <AtomNode start="(608, 49)" end="(608, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(608, 51)" end="(608, 54)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(608, 54)" end="(608, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(608, 56)" end="(609, 86)">
            <AtomNode start="(608, 56)" end="(608, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(609, 5)" end="(609, 86)" kind="«term_=_»">
              <OtherNode start="(609, 5)" end="(609, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(609, 5)" end="(609, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(609, 5)" end="(609, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(609, 5)" end="(609, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(609, 6)" end="(609, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(609, 6)" end="(609, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(609, 16)" end="(609, 19)">
                        <IdentNode start="(609, 16)" end="(609, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(609, 18)" end="(609, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(609, 19)" end="(609, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(609, 20)" end="(609, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(609, 21)" end="(609, 29)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(609, 30)" end="(609, 31)">
                  <IdentNode start="(609, 30)" end="(609, 31)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(609, 32)" end="(609, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(609, 34)" end="(609, 86)" kind="termIfThenElse">
                <AtomNode start="(609, 34)" end="(609, 36)" leading="" trailing=" " val="if"/>
                <OtherNode start="(609, 37)" end="(609, 42)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(609, 37)" end="(609, 38)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(609, 39)" end="(609, 40)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(609, 41)" end="(609, 42)" leading="" trailing=" " raw_val="n" val="n"/>
                </OtherNode>
                <AtomNode start="(609, 43)" end="(609, 47)" leading="" trailing=" " val="then"/>
                <OtherNode start="(609, 48)" end="(609, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(609, 48)" end="(609, 57)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(609, 58)" end="(609, 67)">
                    <OtherNode start="(609, 58)" end="(609, 65)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(609, 58)" end="(609, 59)" leading="" trailing="" val="("/>
                      <OtherNode start="(609, 59)" end="(609, 64)" kind="«term_-_»">
                        <IdentNode start="(609, 59)" end="(609, 60)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(609, 61)" end="(609, 62)" leading="" trailing=" " val="-"/>
                        <OtherNode start="(609, 63)" end="(609, 64)" kind="num">
                          <AtomNode start="(609, 63)" end="(609, 64)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(609, 64)" end="(609, 65)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(609, 66)" end="(609, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(609, 68)" end="(609, 72)" leading="" trailing=" " val="else"/>
                <OtherNode start="(609, 73)" end="(609, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(609, 73)" end="(609, 82)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(609, 83)" end="(609, 86)">
                    <IdentNode start="(609, 83)" end="(609, 84)" leading="" trailing=" " raw_val="n" val="n"/>
                    <IdentNode start="(609, 85)" end="(609, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(609, 87)" end="(617, 50)">
          <AtomNode start="(609, 87)" end="(609, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(609, 90)" end="(617, 50)">
            <AtomNode start="(609, 90)" end="(609, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(610, 3)" end="(617, 50)">
              <TacticTacticseq1IndentedNode start="(610, 3)" end="(617, 50)">
                <NullNode start="(610, 3)" end="(617, 50)">
                  <OtherNode start="(610, 3)" end="(610, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;⊢ (replicate n a).eraseIdx k = if k &amp;lt; n then replicate (n - 1) a else replicate n a" state_after="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate (n - 1) a&#10;&#10;case isFalse&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : ¬k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate n a" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(610, 3)" end="(610, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(610, 3)" end="(610, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(610, 9)" end="(610, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(610, 13)" end="(610, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(610, 13)" end="(610, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(610, 22)" end="(610, 23)">
                        <LeanBinderidentNode start="(610, 22)" end="(610, 23)">
                          <IdentNode start="(610, 22)" end="(610, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(611, 3)" end="(616, 14)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate (n - 1) a&#10;&#10;case isFalse&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : ¬k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate n a" state_after="case isFalse&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : ¬k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate n a" tactic="· rw [eq_replicate_iff, length_eraseIdx_of_lt (by simpa using h)]&#10;  simp only [length_replicate, true_and]&#10;  intro b m&#10;  replace m := mem_of_mem_eraseIdx m&#10;  simp only [mem_replicate] at m&#10;  exact m.2">
                    <OtherNode start="(611, 3)" end="(611, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(611, 3)" end="(611, 4)" kind="patternIgnore">
                        <OtherNode start="(611, 3)" end="(611, 4)" kind="token.«· »">
                          <AtomNode start="(611, 3)" end="(611, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(611, 5)" end="(616, 14)">
                      <TacticTacticseq1IndentedNode start="(611, 5)" end="(616, 14)">
                        <NullNode start="(611, 5)" end="(616, 14)">
                          <OtherNode start="(611, 5)" end="(611, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate (n - 1) a" state_after="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).length - 1 = n - 1 ∧ ∀ (b : α), b ∈ (replicate n a).eraseIdx k → b = a" tactic="rw [eq_replicate_iff, length_eraseIdx_of_lt (by simpa using h)]">
                            <AtomNode start="(611, 5)" end="(611, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(611, 8)" end="(611, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(611, 8)" end="(611, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(611, 9)" end="(611, 67)">
                                <OtherNode start="(611, 9)" end="(611, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(611, 9)" end="(611, 25)" leading="" trailing="" raw_val="eq_replicate_iff" val="eq_replicate_iff" full_name="List.eq_replicate_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(611, 25)" end="(611, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(611, 27)" end="(611, 67)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(611, 27)" end="(611, 67)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(611, 27)" end="(611, 48)" leading="" trailing=" " raw_val="length_eraseIdx_of_lt" val="length_eraseIdx_of_lt" full_name="List.length_eraseIdx_of_lt" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(529, 9)" def_end="(529, 30)"/>
                                    <NullNode start="(611, 49)" end="(611, 67)">
                                      <OtherNode start="(611, 49)" end="(611, 67)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(611, 49)" end="(611, 50)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(611, 50)" end="(611, 66)">
                                          <AtomNode start="(611, 50)" end="(611, 52)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(611, 53)" end="(611, 66)">
                                            <TacticTacticseq1IndentedNode start="(611, 53)" end="(611, 66)">
                                              <NullNode start="(611, 53)" end="(611, 66)">
                                                <OtherNode start="(611, 53)" end="(611, 66)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ k &amp;lt; (replicate n a).length" state_after="no goals" tactic="simpa using h">
                                                  <AtomNode start="(611, 53)" end="(611, 58)" leading="" trailing=" " val="simpa"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode start="(611, 59)" end="(611, 66)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(611, 59)" end="(611, 66)">
                                                      <AtomNode start="(611, 59)" end="(611, 64)" leading="" trailing=" " val="using"/>
                                                      <IdentNode start="(611, 65)" end="(611, 66)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(611, 66)" end="(611, 67)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(611, 67)" end="(611, 68)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(612, 5)" end="(612, 43)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ (replicate n a).length - 1 = n - 1 ∧ ∀ (b : α), b ∈ (replicate n a).eraseIdx k → b = a" state_after="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ ∀ (b : α), b ∈ (replicate n a).eraseIdx k → b = a" tactic="simp only [length_replicate, true_and]">
                            <AtomNode start="(612, 5)" end="(612, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(612, 10)" end="(612, 14)">
                              <AtomNode start="(612, 10)" end="(612, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(612, 15)" end="(612, 43)">
                              <AtomNode start="(612, 15)" end="(612, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(612, 16)" end="(612, 42)">
                                <OtherNode start="(612, 16)" end="(612, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(612, 16)" end="(612, 32)" leading="" trailing="" raw_val="length_replicate" val="length_replicate" full_name="List.length_replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(612, 32)" end="(612, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(612, 34)" end="(612, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(612, 34)" end="(612, 42)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(612, 42)" end="(612, 43)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(613, 5)" end="(613, 14)" kind="Lean.Parser.Tactic.intro" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;⊢ ∀ (b : α), b ∈ (replicate n a).eraseIdx k → b = a" state_after="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;b : α&#10;m : b ∈ (replicate n a).eraseIdx k&#10;⊢ b = a" tactic="intro b m">
                            <AtomNode start="(613, 5)" end="(613, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(613, 11)" end="(613, 14)">
                              <IdentNode start="(613, 11)" end="(613, 12)" leading="" trailing=" " raw_val="b" val="b"/>
                              <IdentNode start="(613, 13)" end="(613, 14)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(614, 5)" end="(614, 39)" kind="Lean.Parser.Tactic.replace" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;b : α&#10;m : b ∈ (replicate n a).eraseIdx k&#10;⊢ b = a" state_after="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;b : α&#10;m : b ∈ replicate n a&#10;⊢ b = a" tactic="replace m := mem_of_mem_eraseIdx m">
                            <AtomNode start="(614, 5)" end="(614, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(614, 13)" end="(614, 39)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(614, 13)" end="(614, 39)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(614, 13)" end="(614, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(614, 13)" end="(614, 14)" leading="" trailing=" " raw_val="m" val="m"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(614, 15)" end="(614, 17)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(614, 18)" end="(614, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(614, 18)" end="(614, 37)" leading="" trailing=" " raw_val="mem_of_mem_eraseIdx" val="mem_of_mem_eraseIdx" full_name="List.mem_of_mem_eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(566, 9)" def_end="(566, 28)"/>
                                  <NullNode start="(614, 38)" end="(614, 39)">
                                    <IdentNode start="(614, 38)" end="(614, 39)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(615, 5)" end="(615, 35)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;b : α&#10;m : b ∈ replicate n a&#10;⊢ b = a" state_after="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;b : α&#10;m : n ≠ 0 ∧ b = a&#10;⊢ b = a" tactic="simp only [mem_replicate] at m">
                            <AtomNode start="(615, 5)" end="(615, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(615, 10)" end="(615, 14)">
                              <AtomNode start="(615, 10)" end="(615, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(615, 15)" end="(615, 30)">
                              <AtomNode start="(615, 15)" end="(615, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(615, 16)" end="(615, 29)">
                                <OtherNode start="(615, 16)" end="(615, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(615, 16)" end="(615, 29)" leading="" trailing="" raw_val="mem_replicate" val="mem_replicate" full_name="List.mem_replicate" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(615, 29)" end="(615, 30)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(615, 31)" end="(615, 35)">
                              <OtherNode start="(615, 31)" end="(615, 35)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(615, 31)" end="(615, 33)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(615, 34)" end="(615, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(615, 34)" end="(615, 35)">
                                    <IdentNode start="(615, 34)" end="(615, 35)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(616, 5)" end="(616, 14)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : k &amp;lt; n&#10;b : α&#10;m : n ≠ 0 ∧ b = a&#10;⊢ b = a" state_after="no goals" tactic="exact m.2">
                            <AtomNode start="(616, 5)" end="(616, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(616, 11)" end="(616, 14)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(616, 11)" end="(616, 12)" leading="" trailing="" raw_val="m" val="m"/>
                              <AtomNode start="(616, 12)" end="(616, 13)" leading="" trailing="" val="."/>
                              <OtherNode start="(616, 13)" end="(616, 14)" kind="fieldIdx">
                                <AtomNode start="(616, 13)" end="(616, 14)" leading="" trailing="&#10;  " val="2"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(617, 3)" end="(617, 50)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : ¬k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate n a" state_after="no goals" tactic="· rw [eraseIdx_of_length_le (by simpa using h)]">
                    <OtherNode start="(617, 3)" end="(617, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(617, 3)" end="(617, 4)" kind="patternIgnore">
                        <OtherNode start="(617, 3)" end="(617, 4)" kind="token.«· »">
                          <AtomNode start="(617, 3)" end="(617, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(617, 5)" end="(617, 50)">
                      <TacticTacticseq1IndentedNode start="(617, 5)" end="(617, 50)">
                        <NullNode start="(617, 5)" end="(617, 50)">
                          <OtherNode start="(617, 5)" end="(617, 50)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : ¬k &amp;lt; n&#10;⊢ (replicate n a).eraseIdx k = replicate n a" state_after="no goals" tactic="rw [eraseIdx_of_length_le (by simpa using h)]">
                            <AtomNode start="(617, 5)" end="(617, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(617, 8)" end="(617, 50)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(617, 8)" end="(617, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(617, 9)" end="(617, 49)">
                                <OtherNode start="(617, 9)" end="(617, 49)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(617, 9)" end="(617, 49)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(617, 9)" end="(617, 30)" leading="" trailing=" " raw_val="eraseIdx_of_length_le" val="eraseIdx_of_length_le" full_name="List.eraseIdx_of_length_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(578, 9)" def_end="(578, 30)"/>
                                    <NullNode start="(617, 31)" end="(617, 49)">
                                      <OtherNode start="(617, 31)" end="(617, 49)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(617, 31)" end="(617, 32)" leading="" trailing="" val="("/>
                                        <TermBytacticNode start="(617, 32)" end="(617, 48)">
                                          <AtomNode start="(617, 32)" end="(617, 34)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(617, 35)" end="(617, 48)">
                                            <TacticTacticseq1IndentedNode start="(617, 35)" end="(617, 48)">
                                              <NullNode start="(617, 35)" end="(617, 48)">
                                                <OtherNode start="(617, 35)" end="(617, 48)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;k : Nat&#10;h : ¬k &amp;lt; n&#10;⊢ (replicate n a).length ≤ k" state_after="no goals" tactic="simpa using h">
                                                  <AtomNode start="(617, 35)" end="(617, 40)" leading="" trailing=" " val="simpa"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode start="(617, 41)" end="(617, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(617, 41)" end="(617, 48)">
                                                      <AtomNode start="(617, 41)" end="(617, 46)" leading="" trailing=" " val="using"/>
                                                      <IdentNode start="(617, 47)" end="(617, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(617, 48)" end="(617, 49)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(617, 49)" end="(617, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(619, 1)" end="(620, 43)" name="Pairwise.eraseIdx" full_name="List.Pairwise.eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(619, 1)" end="(620, 43)" name="Pairwise.eraseIdx" full_name="List.Pairwise.eraseIdx" _is_private_decl="False">
        <AtomNode start="(619, 1)" end="(619, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(619, 9)" end="(619, 26)">
          <IdentNode start="(619, 9)" end="(619, 26)" leading="" trailing=" " raw_val="Pairwise.eraseIdx" val="Pairwise.eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(619, 27)" end="(619, 86)">
          <NullNode start="(619, 27)" end="(619, 43)">
            <OtherNode start="(619, 27)" end="(619, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(619, 27)" end="(619, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(619, 28)" end="(619, 29)">
                <IdentNode start="(619, 28)" end="(619, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(619, 30)" end="(619, 38)">
                <AtomNode start="(619, 30)" end="(619, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(619, 32)" end="(619, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(619, 32)" end="(619, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(619, 37)" end="(619, 38)">
                    <IdentNode start="(619, 37)" end="(619, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(619, 38)" end="(619, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(619, 40)" end="(619, 43)">
              <AtomNode start="(619, 40)" end="(619, 41)" leading="" trailing="" val="("/>
              <NullNode start="(619, 41)" end="(619, 42)">
                <IdentNode start="(619, 41)" end="(619, 42)" leading="" trailing="" raw_val="k" val="k"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(619, 42)" end="(619, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(619, 44)" end="(619, 86)">
            <AtomNode start="(619, 44)" end="(619, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(619, 46)" end="(619, 86)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(619, 46)" end="(619, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(619, 46)" end="(619, 54)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(619, 55)" end="(619, 58)">
                  <IdentNode start="(619, 55)" end="(619, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(619, 57)" end="(619, 58)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(619, 59)" end="(619, 60)" leading="" trailing=" " val="→"/>
              <OtherNode start="(619, 61)" end="(619, 86)" kind="Lean.Parser.Term.app">
                <IdentNode start="(619, 61)" end="(619, 69)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(619, 70)" end="(619, 86)">
                  <IdentNode start="(619, 70)" end="(619, 71)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(619, 72)" end="(619, 86)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(619, 72)" end="(619, 73)" leading="" trailing="" val="("/>
                    <OtherNode start="(619, 73)" end="(619, 85)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(619, 73)" end="(619, 83)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(619, 84)" end="(619, 85)">
                        <IdentNode start="(619, 84)" end="(619, 85)" leading="" trailing="" raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(619, 85)" end="(619, 86)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(619, 87)" end="(620, 43)">
          <AtomNode start="(619, 87)" end="(619, 89)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(620, 3)" end="(620, 43)" kind="«term_&amp;lt;|_»">
            <IdentNode start="(620, 3)" end="(620, 19)" leading="" trailing=" " raw_val="Pairwise.sublist" val="Pairwise.sublist" full_name="List.Pairwise.sublist" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
            <AtomNode start="(620, 20)" end="(620, 22)" leading="" trailing=" " val="&amp;lt;|"/>
            <OtherNode start="(620, 23)" end="(620, 43)" kind="Lean.Parser.Term.app">
              <IdentNode start="(620, 23)" end="(620, 39)" leading="" trailing=" " raw_val="eraseIdx_sublist" val="eraseIdx_sublist" full_name="List.eraseIdx_sublist" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(561, 9)" def_end="(561, 25)"/>
              <NullNode start="(620, 40)" end="(620, 43)">
                <TermHoleNode start="(620, 40)" end="(620, 41)">
                  <AtomNode start="(620, 40)" end="(620, 41)" leading="" trailing=" " val="_"/>
                </TermHoleNode>
                <TermHoleNode start="(620, 42)" end="(620, 43)">
                  <AtomNode start="(620, 42)" end="(620, 43)" leading="" trailing="&#10;&#10;" val="_"/>
                </TermHoleNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(622, 1)" end="(623, 22)" name="Nodup.eraseIdx" full_name="List.Nodup.eraseIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(622, 1)" end="(623, 22)" name="Nodup.eraseIdx" full_name="List.Nodup.eraseIdx" _is_private_decl="False">
        <AtomNode start="(622, 1)" end="(622, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(622, 9)" end="(622, 23)">
          <IdentNode start="(622, 9)" end="(622, 23)" leading="" trailing=" " raw_val="Nodup.eraseIdx" val="Nodup.eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(622, 24)" end="(622, 73)">
          <NullNode start="(622, 24)" end="(622, 40)">
            <OtherNode start="(622, 24)" end="(622, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(622, 24)" end="(622, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(622, 25)" end="(622, 26)">
                <IdentNode start="(622, 25)" end="(622, 26)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(622, 27)" end="(622, 35)">
                <AtomNode start="(622, 27)" end="(622, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(622, 29)" end="(622, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(622, 29)" end="(622, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(622, 34)" end="(622, 35)">
                    <IdentNode start="(622, 34)" end="(622, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(622, 35)" end="(622, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(622, 37)" end="(622, 40)">
              <AtomNode start="(622, 37)" end="(622, 38)" leading="" trailing="" val="("/>
              <NullNode start="(622, 38)" end="(622, 39)">
                <IdentNode start="(622, 38)" end="(622, 39)" leading="" trailing="" raw_val="k" val="k"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(622, 39)" end="(622, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(622, 41)" end="(622, 73)">
            <AtomNode start="(622, 41)" end="(622, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(622, 43)" end="(622, 73)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(622, 43)" end="(622, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(622, 43)" end="(622, 48)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(622, 49)" end="(622, 50)">
                  <IdentNode start="(622, 49)" end="(622, 50)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(622, 51)" end="(622, 52)" leading="" trailing=" " val="→"/>
              <OtherNode start="(622, 53)" end="(622, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(622, 53)" end="(622, 58)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(622, 59)" end="(622, 73)">
                  <OtherNode start="(622, 59)" end="(622, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(622, 59)" end="(622, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(622, 60)" end="(622, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(622, 60)" end="(622, 70)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                      <NullNode start="(622, 71)" end="(622, 72)">
                        <IdentNode start="(622, 71)" end="(622, 72)" leading="" trailing="" raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(622, 72)" end="(622, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(622, 74)" end="(623, 22)">
          <AtomNode start="(622, 74)" end="(622, 76)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(623, 3)" end="(623, 22)" kind="Lean.Parser.Term.app">
            <IdentNode start="(623, 3)" end="(623, 20)" leading="" trailing=" " raw_val="Pairwise.eraseIdx" val="Pairwise.eraseIdx" full_name="List.Pairwise.eraseIdx" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(619, 9)" def_end="(619, 26)"/>
            <NullNode start="(623, 21)" end="(623, 22)">
              <IdentNode start="(623, 21)" end="(623, 22)" leading="" trailing="&#10;&#10;" raw_val="k" val="k"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(625, 1)" end="(632, 71)" name="IsPrefix.eraseIdx" full_name="List.IsPrefix.eraseIdx">
      <CommandDeclmodifiersNode start="(625, 1)" end="(625, 10)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(625, 1)" end="(625, 10)">
          <OtherNode start="(625, 1)" end="(625, 10)" kind="Lean.Parser.Command.protected">
            <AtomNode start="(625, 1)" end="(625, 10)" leading="" trailing=" " val="protected"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(625, 11)" end="(632, 71)" name="IsPrefix.eraseIdx" full_name="List.IsPrefix.eraseIdx" _is_private_decl="False">
        <AtomNode start="(625, 11)" end="(625, 18)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(625, 19)" end="(625, 36)">
          <IdentNode start="(625, 19)" end="(625, 36)" leading="" trailing=" " raw_val="IsPrefix.eraseIdx" val="IsPrefix.eraseIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(625, 37)" end="(626, 35)">
          <NullNode start="(625, 37)" end="(625, 77)">
            <OtherNode start="(625, 37)" end="(625, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(625, 37)" end="(625, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(625, 38)" end="(625, 42)">
                <IdentNode start="(625, 38)" end="(625, 39)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(625, 40)" end="(625, 42)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(625, 43)" end="(625, 51)">
                <AtomNode start="(625, 43)" end="(625, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(625, 45)" end="(625, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(625, 45)" end="(625, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(625, 50)" end="(625, 51)">
                    <IdentNode start="(625, 50)" end="(625, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(625, 51)" end="(625, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(625, 53)" end="(625, 67)">
              <AtomNode start="(625, 53)" end="(625, 54)" leading="" trailing="" val="("/>
              <NullNode start="(625, 54)" end="(625, 55)">
                <IdentNode start="(625, 54)" end="(625, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(625, 56)" end="(625, 66)">
                <AtomNode start="(625, 56)" end="(625, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(625, 58)" end="(625, 66)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(625, 58)" end="(625, 59)" leading="" trailing=" " raw_val="l" val="l"/>
                  <AtomNode start="(625, 60)" end="(625, 63)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(625, 64)" end="(625, 66)" leading="" trailing="" raw_val="l'" val="l'"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(625, 66)" end="(625, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(625, 68)" end="(625, 77)">
              <AtomNode start="(625, 68)" end="(625, 69)" leading="" trailing="" val="("/>
              <NullNode start="(625, 69)" end="(625, 70)">
                <IdentNode start="(625, 69)" end="(625, 70)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(625, 71)" end="(625, 76)">
                <AtomNode start="(625, 71)" end="(625, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(625, 73)" end="(625, 76)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(625, 76)" end="(625, 77)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(625, 78)" end="(626, 35)">
            <AtomNode start="(625, 78)" end="(625, 79)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(626, 5)" end="(626, 35)" kind="List.«term_&amp;lt;+:_»">
              <OtherNode start="(626, 5)" end="(626, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(626, 5)" end="(626, 13)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(626, 14)" end="(626, 17)">
                  <IdentNode start="(626, 14)" end="(626, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(626, 16)" end="(626, 17)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(626, 18)" end="(626, 21)" leading="" trailing=" " val="&amp;lt;+:"/>
              <OtherNode start="(626, 22)" end="(626, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(626, 22)" end="(626, 30)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(626, 31)" end="(626, 35)">
                  <IdentNode start="(626, 31)" end="(626, 33)" leading="" trailing=" " raw_val="l'" val="l'"/>
                  <IdentNode start="(626, 34)" end="(626, 35)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(626, 36)" end="(632, 71)">
          <AtomNode start="(626, 36)" end="(626, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(626, 39)" end="(632, 71)">
            <AtomNode start="(626, 39)" end="(626, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(627, 3)" end="(632, 71)">
              <TacticTacticseq1IndentedNode start="(627, 3)" end="(632, 71)">
                <NullNode start="(627, 3)" end="(632, 71)">
                  <OtherNode start="(627, 3)" end="(627, 25)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;l l' : List α&#10;h : l &amp;lt;+: l'&#10;k : Nat&#10;⊢ l.eraseIdx k &amp;lt;+: l'.eraseIdx k" state_after="case intro&#10;α : Type u_1&#10;l : List α&#10;k : Nat&#10;t : List α&#10;⊢ l.eraseIdx k &amp;lt;+: (l ++ t).eraseIdx k" tactic="rcases h with ⟨t, rfl⟩">
                    <AtomNode start="(627, 3)" end="(627, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(627, 10)" end="(627, 11)">
                      <OtherNode start="(627, 10)" end="(627, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(627, 10)" end="(627, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(627, 12)" end="(627, 25)">
                      <AtomNode start="(627, 12)" end="(627, 16)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(627, 17)" end="(627, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(627, 17)" end="(627, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(627, 17)" end="(627, 25)">
                            <OtherNode start="(627, 17)" end="(627, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(627, 17)" end="(627, 18)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(627, 18)" end="(627, 24)">
                                <OtherNode start="(627, 18)" end="(627, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(627, 18)" end="(627, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(627, 18)" end="(627, 19)">
                                      <OtherNode start="(627, 18)" end="(627, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(627, 18)" end="(627, 19)" leading="" trailing="" raw_val="t" val="t"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(627, 19)" end="(627, 20)" leading="" trailing=" " val=","/>
                                <OtherNode start="(627, 21)" end="(627, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(627, 21)" end="(627, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(627, 21)" end="(627, 24)">
                                      <OtherNode start="(627, 21)" end="(627, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(627, 21)" end="(627, 24)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(627, 24)" end="(627, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(628, 3)" end="(632, 71)" kind="Lean.Parser.Tactic.tacDepIfThenElse" state_before="case intro&#10;α : Type u_1&#10;l : List α&#10;k : Nat&#10;t : List α&#10;⊢ l.eraseIdx k &amp;lt;+: (l ++ t).eraseIdx k" state_after="no goals" tactic="if hkl : k &amp;lt; length l then&#10;  simp [eraseIdx_append_of_lt_length hkl]&#10;else&#10;  rw [Nat.not_lt] at hkl&#10;  simp [eraseIdx_append_of_length_le hkl, eraseIdx_of_length_le hkl]">
                    <AtomNode start="(628, 3)" end="(628, 5)" leading="" trailing=" " val="if"/>
                    <LeanBinderidentNode start="(628, 6)" end="(628, 9)">
                      <IdentNode start="(628, 6)" end="(628, 9)" leading="" trailing=" " raw_val="hkl" val="hkl"/>
                    </LeanBinderidentNode>
                    <AtomNode start="(628, 10)" end="(628, 11)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(628, 12)" end="(628, 24)" kind="«term_&amp;lt;_»">
                      <IdentNode start="(628, 12)" end="(628, 13)" leading="" trailing=" " raw_val="k" val="k"/>
                      <AtomNode start="(628, 14)" end="(628, 15)" leading="" trailing=" " val="&amp;lt;"/>
                      <OtherNode start="(628, 16)" end="(628, 24)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(628, 16)" end="(628, 22)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(628, 23)" end="(628, 24)">
                          <IdentNode start="(628, 23)" end="(628, 24)" leading="" trailing=" " raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(628, 25)" end="(628, 29)" leading="" trailing="&#10;    " val="then"/>
                    <TacticTacticseqNode start="(629, 5)" end="(629, 44)">
                      <TacticTacticseq1IndentedNode start="(629, 5)" end="(629, 44)">
                        <NullNode start="(629, 5)" end="(629, 44)">
                          <OtherNode start="(629, 5)" end="(629, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;k : Nat&#10;t : List α&#10;hkl : k &amp;lt; l.length&#10;⊢ l.eraseIdx k &amp;lt;+: (l ++ t).eraseIdx k" state_after="no goals" tactic="simp [eraseIdx_append_of_lt_length hkl]">
                            <AtomNode start="(629, 5)" end="(629, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(629, 10)" end="(629, 44)">
                              <AtomNode start="(629, 10)" end="(629, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(629, 11)" end="(629, 43)">
                                <OtherNode start="(629, 11)" end="(629, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(629, 11)" end="(629, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(629, 11)" end="(629, 39)" leading="" trailing=" " raw_val="eraseIdx_append_of_lt_length" val="eraseIdx_append_of_lt_length" full_name="List.eraseIdx_append_of_lt_length" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(590, 9)" def_end="(590, 37)"/>
                                    <NullNode start="(629, 40)" end="(629, 43)">
                                      <IdentNode start="(629, 40)" end="(629, 43)" leading="" trailing="" raw_val="hkl" val="hkl"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(629, 43)" end="(629, 44)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                    <AtomNode start="(630, 3)" end="(630, 7)" leading="" trailing="&#10;    " val="else"/>
                    <TacticTacticseqNode start="(631, 5)" end="(632, 71)">
                      <TacticTacticseq1IndentedNode start="(631, 5)" end="(632, 71)">
                        <NullNode start="(631, 5)" end="(632, 71)">
                          <OtherNode start="(631, 5)" end="(631, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;k : Nat&#10;t : List α&#10;hkl : ¬k &amp;lt; l.length&#10;⊢ l.eraseIdx k &amp;lt;+: (l ++ t).eraseIdx k" state_after="α : Type u_1&#10;l : List α&#10;k : Nat&#10;t : List α&#10;hkl : l.length ≤ k&#10;⊢ l.eraseIdx k &amp;lt;+: (l ++ t).eraseIdx k" tactic="rw [Nat.not_lt] at hkl">
                            <AtomNode start="(631, 5)" end="(631, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(631, 8)" end="(631, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(631, 8)" end="(631, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(631, 9)" end="(631, 19)">
                                <OtherNode start="(631, 9)" end="(631, 19)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(631, 9)" end="(631, 19)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(631, 19)" end="(631, 20)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(631, 21)" end="(631, 27)">
                              <OtherNode start="(631, 21)" end="(631, 27)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(631, 21)" end="(631, 23)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(631, 24)" end="(631, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(631, 24)" end="(631, 27)">
                                    <IdentNode start="(631, 24)" end="(631, 27)" leading="" trailing="&#10;    " raw_val="hkl" val="hkl"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(632, 5)" end="(632, 71)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;k : Nat&#10;t : List α&#10;hkl : l.length ≤ k&#10;⊢ l.eraseIdx k &amp;lt;+: (l ++ t).eraseIdx k" state_after="no goals" tactic="simp [eraseIdx_append_of_length_le hkl, eraseIdx_of_length_le hkl]">
                            <AtomNode start="(632, 5)" end="(632, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(632, 10)" end="(632, 71)">
                              <AtomNode start="(632, 10)" end="(632, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(632, 11)" end="(632, 70)">
                                <OtherNode start="(632, 11)" end="(632, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(632, 11)" end="(632, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(632, 11)" end="(632, 39)" leading="" trailing=" " raw_val="eraseIdx_append_of_length_le" val="eraseIdx_append_of_length_le" full_name="List.eraseIdx_append_of_length_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(599, 9)" def_end="(599, 37)"/>
                                    <NullNode start="(632, 40)" end="(632, 43)">
                                      <IdentNode start="(632, 40)" end="(632, 43)" leading="" trailing="" raw_val="hkl" val="hkl"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(632, 43)" end="(632, 44)" leading="" trailing=" " val=","/>
                                <OtherNode start="(632, 45)" end="(632, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(632, 45)" end="(632, 70)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(632, 45)" end="(632, 66)" leading="" trailing=" " raw_val="eraseIdx_of_length_le" val="eraseIdx_of_length_le" full_name="List.eraseIdx_of_length_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(578, 9)" def_end="(578, 30)"/>
                                    <NullNode start="(632, 67)" end="(632, 70)">
                                      <IdentNode start="(632, 67)" end="(632, 70)" leading="" trailing="" raw_val="hkl" val="hkl"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(632, 70)" end="(632, 71)" leading="" trailing="&#10;&#10;-- See also `mem_eraseIdx_iff_getElem` and `mem_eraseIdx_iff_getElem?` in&#10;-- `Init/Data/List/Nat/Basic.lean`.&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(637, 1)" end="(651, 48)" name="erase_eq_eraseIdx_of_idxOf" full_name="List.erase_eq_eraseIdx_of_idxOf">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(637, 1)" end="(651, 48)" name="erase_eq_eraseIdx_of_idxOf" full_name="List.erase_eq_eraseIdx_of_idxOf" _is_private_decl="False">
        <AtomNode start="(637, 1)" end="(637, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(637, 9)" end="(637, 35)">
          <IdentNode start="(637, 9)" end="(637, 35)" leading="" trailing=" " raw_val="erase_eq_eraseIdx_of_idxOf" val="erase_eq_eraseIdx_of_idxOf"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(637, 36)" end="(639, 29)">
          <NullNode start="(637, 36)" end="(638, 55)">
            <OtherNode start="(637, 36)" end="(637, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(637, 36)" end="(637, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(637, 37)" end="(637, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(637, 37)" end="(637, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(637, 41)" end="(637, 42)">
                  <IdentNode start="(637, 41)" end="(637, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(637, 42)" end="(637, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(637, 44)" end="(637, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(637, 44)" end="(637, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(637, 45)" end="(637, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(637, 45)" end="(637, 54)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(637, 55)" end="(637, 56)">
                  <IdentNode start="(637, 55)" end="(637, 56)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(637, 56)" end="(637, 57)" leading="" trailing="&#10;    " val="]"/>
            </OtherNode>
            <OtherNode start="(638, 5)" end="(638, 17)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(638, 5)" end="(638, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(638, 6)" end="(638, 7)">
                <IdentNode start="(638, 6)" end="(638, 7)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(638, 8)" end="(638, 16)">
                <AtomNode start="(638, 8)" end="(638, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(638, 10)" end="(638, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(638, 10)" end="(638, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(638, 15)" end="(638, 16)">
                    <IdentNode start="(638, 15)" end="(638, 16)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(638, 16)" end="(638, 17)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(638, 18)" end="(638, 25)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(638, 18)" end="(638, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(638, 19)" end="(638, 20)">
                <IdentNode start="(638, 19)" end="(638, 20)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(638, 21)" end="(638, 24)">
                <AtomNode start="(638, 21)" end="(638, 22)" leading="" trailing=" " val=":"/>
                <IdentNode start="(638, 23)" end="(638, 24)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(638, 24)" end="(638, 25)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(638, 26)" end="(638, 35)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(638, 26)" end="(638, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(638, 27)" end="(638, 28)">
                <IdentNode start="(638, 27)" end="(638, 28)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(638, 29)" end="(638, 34)">
                <AtomNode start="(638, 29)" end="(638, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(638, 31)" end="(638, 34)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(638, 34)" end="(638, 35)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(638, 36)" end="(638, 55)">
              <AtomNode start="(638, 36)" end="(638, 37)" leading="" trailing="" val="("/>
              <NullNode start="(638, 37)" end="(638, 38)">
                <IdentNode start="(638, 37)" end="(638, 38)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(638, 39)" end="(638, 54)">
                <AtomNode start="(638, 39)" end="(638, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(638, 41)" end="(638, 54)" kind="«term_=_»">
                  <OtherNode start="(638, 41)" end="(638, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(638, 41)" end="(638, 48)" leading="" trailing=" " raw_val="l.idxOf" val="l.idxOf"/>
                    <NullNode start="(638, 49)" end="(638, 50)">
                      <IdentNode start="(638, 49)" end="(638, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(638, 51)" end="(638, 52)" leading="" trailing=" " val="="/>
                  <IdentNode start="(638, 53)" end="(638, 54)" leading="" trailing="" raw_val="i" val="i"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(638, 54)" end="(638, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(638, 56)" end="(639, 29)">
            <AtomNode start="(638, 56)" end="(638, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(639, 5)" end="(639, 29)" kind="«term_=_»">
              <OtherNode start="(639, 5)" end="(639, 14)" kind="Lean.Parser.Term.app">
                <IdentNode start="(639, 5)" end="(639, 12)" leading="" trailing=" " raw_val="l.erase" val="l.erase"/>
                <NullNode start="(639, 13)" end="(639, 14)">
                  <IdentNode start="(639, 13)" end="(639, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(639, 15)" end="(639, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(639, 17)" end="(639, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(639, 17)" end="(639, 27)" leading="" trailing=" " raw_val="l.eraseIdx" val="l.eraseIdx"/>
                <NullNode start="(639, 28)" end="(639, 29)">
                  <IdentNode start="(639, 28)" end="(639, 29)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(639, 30)" end="(651, 48)">
          <AtomNode start="(639, 30)" end="(639, 32)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(639, 33)" end="(651, 48)">
            <AtomNode start="(639, 33)" end="(639, 35)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(640, 3)" end="(651, 48)">
              <TacticTacticseq1IndentedNode start="(640, 3)" end="(651, 48)">
                <NullNode start="(640, 3)" end="(651, 48)">
                  <OtherNode start="(640, 3)" end="(640, 10)" kind="Lean.Parser.Tactic.subst" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;i : Nat&#10;w : idxOf a l = i&#10;⊢ l.erase a = l.eraseIdx i" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a = l.eraseIdx (idxOf a l)" tactic="subst w">
                    <AtomNode start="(640, 3)" end="(640, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(640, 9)" end="(640, 10)">
                      <IdentNode start="(640, 9)" end="(640, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(641, 3)" end="(641, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a = l.eraseIdx (idxOf a l)" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" tactic="rw [erase_eq_iff]">
                    <AtomNode start="(641, 3)" end="(641, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(641, 6)" end="(641, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(641, 6)" end="(641, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(641, 7)" end="(641, 19)">
                        <OtherNode start="(641, 7)" end="(641, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(641, 7)" end="(641, 19)" leading="" trailing="" raw_val="erase_eq_iff" val="erase_eq_iff" full_name="List.erase_eq_iff" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(445, 9)" def_end="(445, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(641, 19)" end="(641, 20)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(642, 3)" end="(642, 21)" kind="«tacticBy_cases_:_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" state_after="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" tactic="by_cases h : a ∈ l">
                    <AtomNode start="(642, 3)" end="(642, 11)" leading="" trailing=" " val="by_cases"/>
                    <NullNode start="(642, 12)" end="(642, 15)">
                      <IdentNode start="(642, 12)" end="(642, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                      <AtomNode start="(642, 14)" end="(642, 15)" leading="" trailing=" " val=":"/>
                    </NullNode>
                    <OtherNode start="(642, 16)" end="(642, 21)" kind="«term_∈_»">
                      <IdentNode start="(642, 16)" end="(642, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(642, 18)" end="(642, 19)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(642, 20)" end="(642, 21)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(643, 3)" end="(647, 11)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂&#10;&#10;case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" state_after="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" tactic="· right&#10;  obtain ⟨as, bs, rfl, h'⟩ := eq_append_cons_of_mem h&#10;  refine ⟨as, bs, h', by simp, ?_⟩&#10;  rw [idxOf_append, if_neg h', idxOf_cons_self, eraseIdx_append_of_length_le] &amp;lt;;&amp;gt;&#10;    simp">
                    <OtherNode start="(643, 3)" end="(643, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(643, 3)" end="(643, 4)" kind="patternIgnore">
                        <OtherNode start="(643, 3)" end="(643, 4)" kind="token.«· »">
                          <AtomNode start="(643, 3)" end="(643, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(643, 5)" end="(647, 11)">
                      <TacticTacticseq1IndentedNode start="(643, 5)" end="(647, 11)">
                        <NullNode start="(643, 5)" end="(647, 11)">
                          <OtherNode start="(643, 5)" end="(643, 10)" kind="Lean.Parser.Tactic.right" state_before="case pos&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" state_after="case pos.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" tactic="right">
                            <AtomNode start="(643, 5)" end="(643, 10)" leading="" trailing="&#10;    " val="right"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(644, 5)" end="(644, 56)" kind="Lean.Parser.Tactic.obtain" state_before="case pos.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" state_after="case pos.h.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as bs : List α&#10;h' : ¬a ∈ as&#10;h : a ∈ as ++ a :: bs&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ as ++ a :: bs = l₁ ++ a :: l₂ ∧ (as ++ a :: bs).eraseIdx (idxOf a (as ++ a :: bs)) = l₁ ++ l₂" tactic="obtain ⟨as, bs, rfl, h'⟩ := eq_append_cons_of_mem h">
                            <AtomNode start="(644, 5)" end="(644, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(644, 12)" end="(644, 29)">
                              <OtherNode start="(644, 12)" end="(644, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(644, 12)" end="(644, 29)">
                                  <OtherNode start="(644, 12)" end="(644, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(644, 12)" end="(644, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(644, 13)" end="(644, 28)">
                                      <OtherNode start="(644, 13)" end="(644, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(644, 13)" end="(644, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(644, 13)" end="(644, 15)">
                                            <OtherNode start="(644, 13)" end="(644, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(644, 13)" end="(644, 15)" leading="" trailing="" raw_val="as" val="as"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(644, 15)" end="(644, 16)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(644, 17)" end="(644, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(644, 17)" end="(644, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(644, 17)" end="(644, 19)">
                                            <OtherNode start="(644, 17)" end="(644, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(644, 17)" end="(644, 19)" leading="" trailing="" raw_val="bs" val="bs"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(644, 19)" end="(644, 20)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(644, 21)" end="(644, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(644, 21)" end="(644, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(644, 21)" end="(644, 24)">
                                            <OtherNode start="(644, 21)" end="(644, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(644, 21)" end="(644, 24)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(644, 24)" end="(644, 25)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(644, 26)" end="(644, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(644, 26)" end="(644, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(644, 26)" end="(644, 28)">
                                            <OtherNode start="(644, 26)" end="(644, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(644, 26)" end="(644, 28)" leading="" trailing="" raw_val="h'" val="h'"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(644, 28)" end="(644, 29)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(644, 30)" end="(644, 56)">
                              <AtomNode start="(644, 30)" end="(644, 32)" leading="" trailing=" " val=":="/>
                              <NullNode start="(644, 33)" end="(644, 56)">
                                <OtherNode start="(644, 33)" end="(644, 56)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(644, 33)" end="(644, 54)" leading="" trailing=" " raw_val="eq_append_cons_of_mem" val="eq_append_cons_of_mem" full_name="List.eq_append_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                  <NullNode start="(644, 55)" end="(644, 56)">
                                    <IdentNode start="(644, 55)" end="(644, 56)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(645, 5)" end="(645, 37)" kind="Lean.Parser.Tactic.refine" state_before="case pos.h.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as bs : List α&#10;h' : ¬a ∈ as&#10;h : a ∈ as ++ a :: bs&#10;⊢ ∃ l₁ l₂, ¬a ∈ l₁ ∧ as ++ a :: bs = l₁ ++ a :: l₂ ∧ (as ++ a :: bs).eraseIdx (idxOf a (as ++ a :: bs)) = l₁ ++ l₂" state_after="case pos.h.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as bs : List α&#10;h' : ¬a ∈ as&#10;h : a ∈ as ++ a :: bs&#10;⊢ (as ++ a :: bs).eraseIdx (idxOf a (as ++ a :: bs)) = as ++ bs" tactic="refine ⟨as, bs, h', by simp, ?_⟩">
                            <AtomNode start="(645, 5)" end="(645, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(645, 12)" end="(645, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(645, 12)" end="(645, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(645, 13)" end="(645, 36)">
                                <IdentNode start="(645, 13)" end="(645, 15)" leading="" trailing="" raw_val="as" val="as"/>
                                <AtomNode start="(645, 15)" end="(645, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(645, 17)" end="(645, 19)" leading="" trailing="" raw_val="bs" val="bs"/>
                                <AtomNode start="(645, 19)" end="(645, 20)" leading="" trailing=" " val=","/>
                                <IdentNode start="(645, 21)" end="(645, 23)" leading="" trailing="" raw_val="h'" val="h'"/>
                                <AtomNode start="(645, 23)" end="(645, 24)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(645, 25)" end="(645, 32)">
                                  <AtomNode start="(645, 25)" end="(645, 27)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(645, 28)" end="(645, 32)">
                                    <TacticTacticseq1IndentedNode start="(645, 28)" end="(645, 32)">
                                      <NullNode start="(645, 28)" end="(645, 32)">
                                        <OtherNode start="(645, 28)" end="(645, 32)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as bs : List α&#10;h' : ¬a ∈ as&#10;h : a ∈ as ++ a :: bs&#10;⊢ as ++ a :: bs = as ++ a :: bs" state_after="no goals" tactic="simp">
                                          <AtomNode start="(645, 28)" end="(645, 32)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(645, 32)" end="(645, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(645, 34)" end="(645, 36)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(645, 34)" end="(645, 35)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(645, 35)" end="(645, 36)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(645, 36)" end="(645, 37)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(646, 5)" end="(647, 11)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case pos.h.intro.intro.intro&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;as bs : List α&#10;h' : ¬a ∈ as&#10;h : a ∈ as ++ a :: bs&#10;⊢ (as ++ a :: bs).eraseIdx (idxOf a (as ++ a :: bs)) = as ++ bs" state_after="no goals" tactic="rw [idxOf_append, if_neg h', idxOf_cons_self, eraseIdx_append_of_length_le] &amp;lt;;&amp;gt;&#10;  simp">
                            <OtherNode start="(646, 5)" end="(646, 80)" kind="Lean.Parser.Tactic.rwSeq">
                              <AtomNode start="(646, 5)" end="(646, 7)" leading="" trailing=" " val="rw"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(646, 8)" end="(646, 80)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                <AtomNode start="(646, 8)" end="(646, 9)" leading="" trailing="" val="["/>
                                <NullNode start="(646, 9)" end="(646, 79)">
                                  <OtherNode start="(646, 9)" end="(646, 21)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(646, 9)" end="(646, 21)" leading="" trailing="" raw_val="idxOf_append" val="idxOf_append" full_name="List.idxOf_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(646, 21)" end="(646, 22)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(646, 23)" end="(646, 32)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <OtherNode start="(646, 23)" end="(646, 32)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(646, 23)" end="(646, 29)" leading="" trailing=" " raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                      <NullNode start="(646, 30)" end="(646, 32)">
                                        <IdentNode start="(646, 30)" end="(646, 32)" leading="" trailing="" raw_val="h'" val="h'"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(646, 32)" end="(646, 33)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(646, 34)" end="(646, 49)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(646, 34)" end="(646, 49)" leading="" trailing="" raw_val="idxOf_cons_self" val="idxOf_cons_self" full_name="List.idxOf_cons_self" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(646, 49)" end="(646, 50)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(646, 51)" end="(646, 79)" kind="Lean.Parser.Tactic.rwRule">
                                    <NullNode/>
                                    <IdentNode start="(646, 51)" end="(646, 79)" leading="" trailing="" raw_val="eraseIdx_append_of_length_le" val="eraseIdx_append_of_length_le" full_name="List.eraseIdx_append_of_length_le" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(599, 9)" def_end="(599, 37)"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(646, 79)" end="(646, 80)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(646, 81)" end="(646, 84)" leading="" trailing="&#10;      " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(647, 7)" end="(647, 11)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(647, 7)" end="(647, 11)" leading="" trailing="&#10;  " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(648, 3)" end="(651, 48)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" state_after="no goals" tactic="· left&#10;  refine ⟨h, ?_⟩&#10;  rw [eq_comm, eraseIdx_eq_self]&#10;  exact Nat.le_of_eq (idxOf_eq_length h).symm">
                    <OtherNode start="(648, 3)" end="(648, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(648, 3)" end="(648, 4)" kind="patternIgnore">
                        <OtherNode start="(648, 3)" end="(648, 4)" kind="token.«· »">
                          <AtomNode start="(648, 3)" end="(648, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(648, 5)" end="(651, 48)">
                      <TacticTacticseq1IndentedNode start="(648, 5)" end="(651, 48)">
                        <NullNode start="(648, 5)" end="(651, 48)">
                          <OtherNode start="(648, 5)" end="(648, 9)" kind="Lean.Parser.Tactic.left" state_before="case neg&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l) ∨ ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ l.eraseIdx (idxOf a l) = l₁ ++ l₂" state_after="case neg.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l)" tactic="left">
                            <AtomNode start="(648, 5)" end="(648, 9)" leading="" trailing="&#10;    " val="left"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(649, 5)" end="(649, 19)" kind="Lean.Parser.Tactic.refine" state_before="case neg.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ ¬a ∈ l ∧ l = l.eraseIdx (idxOf a l)" state_after="case neg.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ l = l.eraseIdx (idxOf a l)" tactic="refine ⟨h, ?_⟩">
                            <AtomNode start="(649, 5)" end="(649, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(649, 12)" end="(649, 19)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(649, 12)" end="(649, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(649, 13)" end="(649, 18)">
                                <IdentNode start="(649, 13)" end="(649, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                <AtomNode start="(649, 14)" end="(649, 15)" leading="" trailing=" " val=","/>
                                <OtherNode start="(649, 16)" end="(649, 18)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(649, 16)" end="(649, 17)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(649, 17)" end="(649, 18)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(649, 18)" end="(649, 19)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(650, 5)" end="(650, 35)" kind="Lean.Parser.Tactic.rwSeq" state_before="case neg.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ l = l.eraseIdx (idxOf a l)" state_after="case neg.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ l.length ≤ idxOf a l" tactic="rw [eq_comm, eraseIdx_eq_self]">
                            <AtomNode start="(650, 5)" end="(650, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(650, 8)" end="(650, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(650, 8)" end="(650, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(650, 9)" end="(650, 34)">
                                <OtherNode start="(650, 9)" end="(650, 16)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(650, 9)" end="(650, 16)" leading="" trailing="" raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(650, 16)" end="(650, 17)" leading="" trailing=" " val=","/>
                                <OtherNode start="(650, 18)" end="(650, 34)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(650, 18)" end="(650, 34)" leading="" trailing="" raw_val="eraseIdx_eq_self" val="eraseIdx_eq_self" full_name="List.eraseIdx_eq_self" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(573, 9)" def_end="(573, 25)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(650, 34)" end="(650, 35)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(651, 5)" end="(651, 48)" kind="Lean.Parser.Tactic.exact" state_before="case neg.h&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : ¬a ∈ l&#10;⊢ l.length ≤ idxOf a l" state_after="no goals" tactic="exact Nat.le_of_eq (idxOf_eq_length h).symm">
                            <AtomNode start="(651, 5)" end="(651, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(651, 11)" end="(651, 48)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(651, 11)" end="(651, 23)" leading="" trailing=" " raw_val="Nat.le_of_eq" val="Nat.le_of_eq" full_name="Nat.le_of_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(651, 24)" end="(651, 48)">
                                <OtherNode start="(651, 24)" end="(651, 48)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(651, 24)" end="(651, 43)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(651, 24)" end="(651, 25)" leading="" trailing="" val="("/>
                                    <OtherNode start="(651, 25)" end="(651, 42)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(651, 25)" end="(651, 40)" leading="" trailing=" " raw_val="idxOf_eq_length" val="idxOf_eq_length" full_name="List.idxOf_eq_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean"/>
                                      <NullNode start="(651, 41)" end="(651, 42)">
                                        <IdentNode start="(651, 41)" end="(651, 42)" leading="" trailing="" raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(651, 42)" end="(651, 43)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(651, 43)" end="(651, 44)" leading="" trailing="" val="."/>
                                  <IdentNode start="(651, 44)" end="(651, 48)" leading="" trailing="&#10;&#10;" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(653, 1)" end="(654, 67)" name="erase_eq_eraseIdx_of_indexOf" full_name="List.erase_eq_eraseIdx_of_indexOf">
      <CommandDeclmodifiersNode start="(653, 1)" end="(653, 65)">
        <NullNode/>
        <NullNode start="(653, 1)" end="(653, 65)">
          <OtherNode start="(653, 1)" end="(653, 65)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(653, 1)" end="(653, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(653, 3)" end="(653, 64)">
              <OtherNode start="(653, 3)" end="(653, 64)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(653, 3)" end="(653, 64)" kind="Lean.deprecated">
                  <AtomNode start="(653, 3)" end="(653, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(653, 14)" end="(653, 40)">
                    <IdentNode start="(653, 14)" end="(653, 40)" leading="" trailing=" " raw_val="erase_eq_eraseIdx_of_idxOf" val="erase_eq_eraseIdx_of_idxOf" full_name="List.erase_eq_eraseIdx_of_idxOf" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(637, 9)" def_end="(637, 35)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(653, 41)" end="(653, 64)">
                    <AtomNode start="(653, 41)" end="(653, 42)" leading="" trailing="" val="("/>
                    <AtomNode start="(653, 42)" end="(653, 47)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(653, 48)" end="(653, 50)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(653, 51)" end="(653, 63)" kind="str">
                      <AtomNode start="(653, 51)" end="(653, 63)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(653, 63)" end="(653, 64)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(653, 64)" end="(653, 65)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(654, 1)" end="(654, 67)" name="erase_eq_eraseIdx_of_indexOf">
        <AtomNode start="(654, 1)" end="(654, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(654, 8)" end="(654, 36)">
          <IdentNode start="(654, 8)" end="(654, 36)" leading="" trailing=" " raw_val="erase_eq_eraseIdx_of_indexOf" val="erase_eq_eraseIdx_of_indexOf"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(654, 37)" end="(654, 67)">
          <AtomNode start="(654, 37)" end="(654, 39)" leading="" trailing=" " val=":="/>
          <OtherNode start="(654, 40)" end="(654, 67)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(654, 40)" end="(654, 41)" leading="" trailing="" val="@"/>
            <IdentNode start="(654, 41)" end="(654, 67)" leading="" trailing="&#10;&#10;" raw_val="erase_eq_eraseIdx_of_idxOf" val="erase_eq_eraseIdx_of_idxOf" full_name="List.erase_eq_eraseIdx_of_idxOf" mod_name="Init.Data.List.Erase" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Erase.lean" def_start="(637, 9)" def_end="(637, 35)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(656, 1)" end="(656, 9)" name="List">
      <AtomNode start="(656, 1)" end="(656, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(656, 5)" end="(656, 9)">
        <IdentNode start="(656, 5)" end="(656, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(13, 1)" end="(15, 3)" text="# Lemmas about `List.eraseP`, `List.erase`, and `List.eraseIdx`.&#10;-/"/>
    <Comment start="(17, 38)" end="(18, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(18, 39)" end="(20, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(24, 1)" end="(24, 18)" text="### eraseP -/"/>
    <Comment start="(80, 1)" end="(81, 1)" text="-- The arguments are explicit here, so this lemma can be used as a case split.&#10;"/>
    <Comment start="(300, 1)" end="(300, 17)" text="### erase -/"/>
    <Comment start="(305, 1)" end="(307, 1)" text="-- The arguments are explicit to allow determining the type,&#10;-- and to allow rewriting from right to left.&#10;"/>
    <Comment start="(319, 1)" end="(320, 1)" text="-- The arguments are intentionally explicit.&#10;"/>
    <Comment start="(327, 1)" end="(328, 1)" text="-- The arguments are intentionally explicit.&#10;"/>
    <Comment start="(427, 1)" end="(429, 1)" text="-- The arguments `a b` are explicit,&#10;-- so they can be specified to prevent `simp` repeatedly applying the lemma.&#10;"/>
    <Comment start="(514, 1)" end="(514, 20)" text="### eraseIdx -/"/>
    <Comment start="(541, 1)" end="(543, 1)" text="-- See `Init.Data.List.Nat.Erase` for `getElem?_eraseIdx` and `getElem_eraseIdx`.&#10;&#10;"/>
    <Comment start="(581, 1)" end="(582, 1)" text="-- Arguments are intentionally explicit.&#10;"/>
    <Comment start="(585, 1)" end="(586, 1)" text="-- Arguments are intentionally explicit.&#10;"/>
    <Comment start="(634, 1)" end="(637, 1)" text="-- See also `mem_eraseIdx_iff_getElem` and `mem_eraseIdx_iff_getElem?` in&#10;-- `Init/Data/List/Nat/Basic.lean`.&#10;&#10;"/>
  </Comments>
</TracedFile>
