<TracedFile path="src/lean/Init/Data/List/Find.lean" md5="ce8e7ba67e27f31a8fa286b186a75792">
  <FileNode start="(1, 1)" end="(1282, 9)">
    <ModuleHeaderNode start="(7, 1)" end="(14, 28)">
      <NullNode start="(7, 1)" end="(7, 7)">
        <OtherNode start="(7, 1)" end="(7, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(7, 1)" end="(7, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(9, 8)">
        <ModulePreludeNode start="(9, 1)" end="(9, 8)">
          <AtomNode start="(9, 1)" end="(9, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(10, 1)" end="(14, 28)">
        <ModuleImportNode start="(10, 1)" end="(10, 29)" module="Init.Data.List.Lemmas" path="src/lean/Init/Data/List/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 29)" leading="" trailing="&#10;" raw_val="Init.Data.List.Lemmas" val="Init.Data.List.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.List.Sublist" path="src/lean/Init/Data/List/Sublist.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;" raw_val="Init.Data.List.Sublist" val="Init.Data.List.Sublist"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 28)" module="Init.Data.List.Range" path="src/lean/Init/Data/List/Range.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 28)" leading="" trailing="&#10;" raw_val="Init.Data.List.Range" val="Init.Data.List.Range"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(13, 1)" end="(13, 27)" module="Init.Data.List.Impl" path="src/lean/Init/Data/List/Impl.lean">
          <NullNode/>
          <AtomNode start="(13, 1)" end="(13, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(13, 8)" end="(13, 27)" leading="" trailing="&#10;" raw_val="Init.Data.List.Impl" val="Init.Data.List.Impl"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(14, 1)" end="(14, 28)" module="Init.Data.Fin.Lemmas" path="src/lean/Init/Data/Fin/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(14, 1)" end="(14, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(14, 8)" end="(14, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Fin.Lemmas" val="Init.Data.Fin.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(16, 1)" end="(19, 3)" comment="Lemmas about `List.findSome?`, `List.find?`, `List.findIdx`, `List.findIdx?`, `List.idxOf`,&#10;and `List.lookup`.&#10;-/">
      <AtomNode start="(16, 1)" end="(16, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(17, 1)" end="(19, 3)" leading="" trailing="&#10;&#10;" val="Lemmas about `List.findSome?`, `List.find?`, `List.findIdx`, `List.findIdx?`, `List.idxOf`,&#10;and `List.lookup`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(21, 1)" end="(21, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(21, 1)" end="(21, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(21, 12)" end="(21, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(21, 33)" end="(21, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(22, 1)" end="(22, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(22, 1)" end="(22, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(22, 12)" end="(22, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(22, 34)" end="(22, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(25, 1)" end="(25, 15)" name="List">
      <AtomNode start="(25, 1)" end="(25, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(25, 11)" end="(25, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(27, 1)" end="(27, 9)">
      <AtomNode start="(27, 1)" end="(27, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(27, 6)" end="(27, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(27, 6)" end="(27, 9)">
          <IdentNode start="(27, 6)" end="(27, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(29, 1)" end="(29, 21)" comment="### findSome? -/">
      <AtomNode start="(29, 1)" end="(29, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(29, 5)" end="(29, 21)" leading="" trailing="&#10;&#10;" val="### findSome? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(31, 1)" end="(33, 21)" name="findSome?_cons_of_isSome" full_name="List.findSome?_cons_of_isSome">
      <CommandDeclmodifiersNode start="(31, 1)" end="(31, 8)">
        <NullNode/>
        <NullNode start="(31, 1)" end="(31, 8)">
          <OtherNode start="(31, 1)" end="(31, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(31, 1)" end="(31, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(31, 3)" end="(31, 7)">
              <OtherNode start="(31, 3)" end="(31, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(31, 3)" end="(31, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(31, 3)" end="(31, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(31, 7)" end="(31, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(31, 9)" end="(33, 21)" name="findSome?_cons_of_isSome" full_name="List.findSome?_cons_of_isSome" _is_private_decl="False">
        <AtomNode start="(31, 9)" end="(31, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(31, 17)" end="(31, 41)">
          <IdentNode start="(31, 17)" end="(31, 41)" leading="" trailing=" " raw_val="findSome?_cons_of_isSome" val="findSome?_cons_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(31, 42)" end="(31, 93)">
          <NullNode start="(31, 42)" end="(31, 64)">
            <OtherNode start="(31, 42)" end="(31, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(31, 42)" end="(31, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(31, 43)" end="(31, 44)">
                <IdentNode start="(31, 43)" end="(31, 44)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(31, 44)" end="(31, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(31, 46)" end="(31, 64)">
              <AtomNode start="(31, 46)" end="(31, 47)" leading="" trailing="" val="("/>
              <NullNode start="(31, 47)" end="(31, 48)">
                <IdentNode start="(31, 47)" end="(31, 48)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(31, 49)" end="(31, 63)">
                <AtomNode start="(31, 49)" end="(31, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(31, 51)" end="(31, 63)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(31, 51)" end="(31, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(31, 51)" end="(31, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(31, 52)" end="(31, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(31, 52)" end="(31, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(31, 54)" end="(31, 55)">
                        <IdentNode start="(31, 54)" end="(31, 55)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(31, 55)" end="(31, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(31, 56)" end="(31, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(31, 57)" end="(31, 63)" leading="" trailing="" raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(31, 63)" end="(31, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(31, 65)" end="(31, 93)">
            <AtomNode start="(31, 65)" end="(31, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(31, 67)" end="(31, 93)" kind="«term_=_»">
              <OtherNode start="(31, 67)" end="(31, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(31, 67)" end="(31, 76)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(31, 77)" end="(31, 87)">
                  <IdentNode start="(31, 77)" end="(31, 78)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(31, 79)" end="(31, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(31, 79)" end="(31, 80)" leading="" trailing="" val="("/>
                    <OtherNode start="(31, 80)" end="(31, 86)" kind="«term_::_»">
                      <IdentNode start="(31, 80)" end="(31, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(31, 82)" end="(31, 84)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(31, 85)" end="(31, 86)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(31, 86)" end="(31, 87)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(31, 88)" end="(31, 89)" leading="" trailing=" " val="="/>
              <OtherNode start="(31, 90)" end="(31, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(31, 90)" end="(31, 91)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(31, 92)" end="(31, 93)">
                  <IdentNode start="(31, 92)" end="(31, 93)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(31, 94)" end="(33, 21)">
          <AtomNode start="(31, 94)" end="(31, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(31, 97)" end="(33, 21)">
            <AtomNode start="(31, 97)" end="(31, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(32, 3)" end="(33, 21)">
              <TacticTacticseq1IndentedNode start="(32, 3)" end="(33, 21)">
                <NullNode start="(32, 3)" end="(33, 21)">
                  <OtherNode start="(32, 3)" end="(32, 24)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;l : List α✝¹&#10;h : (f a).isSome = true&#10;⊢ findSome? f (a :: l) = f a" state_after="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;l : List α✝¹&#10;h : (f a).isSome = true&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f l) =&#10;    f a" tactic="simp only [findSome?]">
                    <AtomNode start="(32, 3)" end="(32, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(32, 8)" end="(32, 12)">
                      <AtomNode start="(32, 8)" end="(32, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(32, 13)" end="(32, 24)">
                      <AtomNode start="(32, 13)" end="(32, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(32, 14)" end="(32, 23)">
                        <OtherNode start="(32, 14)" end="(32, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(32, 14)" end="(32, 23)" leading="" trailing="" raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(32, 23)" end="(32, 24)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(33, 3)" end="(33, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;l : List α✝¹&#10;h : (f a).isSome = true&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f l) =&#10;    f a" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(33, 3)" end="(33, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(33, 3)" end="(33, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(33, 9)" end="(33, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(33, 13)" end="(33, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(33, 13)" end="(33, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(35, 1)" end="(37, 21)" name="findSome?_cons_of_isNone" full_name="List.findSome?_cons_of_isNone">
      <CommandDeclmodifiersNode start="(35, 1)" end="(35, 8)">
        <NullNode/>
        <NullNode start="(35, 1)" end="(35, 8)">
          <OtherNode start="(35, 1)" end="(35, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(35, 1)" end="(35, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(35, 3)" end="(35, 7)">
              <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(35, 3)" end="(35, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(35, 7)" end="(35, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(35, 9)" end="(37, 21)" name="findSome?_cons_of_isNone" full_name="List.findSome?_cons_of_isNone" _is_private_decl="False">
        <AtomNode start="(35, 9)" end="(35, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(35, 17)" end="(35, 41)">
          <IdentNode start="(35, 17)" end="(35, 41)" leading="" trailing=" " raw_val="findSome?_cons_of_isNone" val="findSome?_cons_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(35, 42)" end="(35, 103)">
          <NullNode start="(35, 42)" end="(35, 64)">
            <OtherNode start="(35, 42)" end="(35, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(35, 42)" end="(35, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(35, 43)" end="(35, 44)">
                <IdentNode start="(35, 43)" end="(35, 44)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(35, 44)" end="(35, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(35, 46)" end="(35, 64)">
              <AtomNode start="(35, 46)" end="(35, 47)" leading="" trailing="" val="("/>
              <NullNode start="(35, 47)" end="(35, 48)">
                <IdentNode start="(35, 47)" end="(35, 48)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(35, 49)" end="(35, 63)">
                <AtomNode start="(35, 49)" end="(35, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 51)" end="(35, 63)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(35, 51)" end="(35, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(35, 51)" end="(35, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(35, 52)" end="(35, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(35, 52)" end="(35, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(35, 54)" end="(35, 55)">
                        <IdentNode start="(35, 54)" end="(35, 55)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(35, 55)" end="(35, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(35, 56)" end="(35, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(35, 57)" end="(35, 63)" leading="" trailing="" raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(35, 63)" end="(35, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(35, 65)" end="(35, 103)">
            <AtomNode start="(35, 65)" end="(35, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(35, 67)" end="(35, 103)" kind="«term_=_»">
              <OtherNode start="(35, 67)" end="(35, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(35, 67)" end="(35, 76)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(35, 77)" end="(35, 87)">
                  <IdentNode start="(35, 77)" end="(35, 78)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(35, 79)" end="(35, 87)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(35, 79)" end="(35, 80)" leading="" trailing="" val="("/>
                    <OtherNode start="(35, 80)" end="(35, 86)" kind="«term_::_»">
                      <IdentNode start="(35, 80)" end="(35, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(35, 82)" end="(35, 84)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(35, 85)" end="(35, 86)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(35, 86)" end="(35, 87)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(35, 88)" end="(35, 89)" leading="" trailing=" " val="="/>
              <OtherNode start="(35, 90)" end="(35, 103)" kind="Lean.Parser.Term.app">
                <IdentNode start="(35, 90)" end="(35, 99)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(35, 100)" end="(35, 103)">
                  <IdentNode start="(35, 100)" end="(35, 101)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(35, 102)" end="(35, 103)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(35, 104)" end="(37, 21)">
          <AtomNode start="(35, 104)" end="(35, 106)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(35, 107)" end="(37, 21)">
            <AtomNode start="(35, 107)" end="(35, 109)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(36, 3)" end="(37, 21)">
              <TacticTacticseq1IndentedNode start="(36, 3)" end="(37, 21)">
                <NullNode start="(36, 3)" end="(37, 21)">
                  <OtherNode start="(36, 3)" end="(36, 24)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;l : List α✝¹&#10;h : (f a).isNone = true&#10;⊢ findSome? f (a :: l) = findSome? f l" state_after="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;l : List α✝¹&#10;h : (f a).isNone = true&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f l) =&#10;    findSome? f l" tactic="simp only [findSome?]">
                    <AtomNode start="(36, 3)" end="(36, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(36, 8)" end="(36, 12)">
                      <AtomNode start="(36, 8)" end="(36, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(36, 13)" end="(36, 24)">
                      <AtomNode start="(36, 13)" end="(36, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(36, 14)" end="(36, 23)">
                        <OtherNode start="(36, 14)" end="(36, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(36, 14)" end="(36, 23)" leading="" trailing="" raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(36, 23)" end="(36, 24)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(37, 3)" end="(37, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;l : List α✝¹&#10;h : (f a).isNone = true&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f l) =&#10;    findSome? f l" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(37, 3)" end="(37, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(37, 3)" end="(37, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(37, 9)" end="(37, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(37, 13)" end="(37, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(37, 13)" end="(37, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(39, 1)" end="(45, 28)" name="exists_of_findSome?_eq_some" full_name="List.exists_of_findSome?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(39, 1)" end="(45, 28)" name="exists_of_findSome?_eq_some" full_name="List.exists_of_findSome?_eq_some" _is_private_decl="False">
        <AtomNode start="(39, 1)" end="(39, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(39, 9)" end="(39, 36)">
          <IdentNode start="(39, 9)" end="(39, 36)" leading="" trailing=" " raw_val="exists_of_findSome?_eq_some" val="exists_of_findSome?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(39, 37)" end="(40, 30)">
          <NullNode start="(39, 37)" end="(39, 97)">
            <OtherNode start="(39, 37)" end="(39, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 37)" end="(39, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 38)" end="(39, 39)">
                <IdentNode start="(39, 38)" end="(39, 39)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(39, 40)" end="(39, 48)">
                <AtomNode start="(39, 40)" end="(39, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 42)" end="(39, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(39, 42)" end="(39, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(39, 47)" end="(39, 48)">
                    <IdentNode start="(39, 47)" end="(39, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(39, 48)" end="(39, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(39, 50)" end="(39, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 50)" end="(39, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 51)" end="(39, 52)">
                <IdentNode start="(39, 51)" end="(39, 52)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(39, 53)" end="(39, 67)">
                <AtomNode start="(39, 53)" end="(39, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 55)" end="(39, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(39, 55)" end="(39, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(39, 57)" end="(39, 58)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(39, 59)" end="(39, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(39, 59)" end="(39, 65)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(39, 66)" end="(39, 67)">
                      <IdentNode start="(39, 66)" end="(39, 67)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(39, 67)" end="(39, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(39, 69)" end="(39, 97)">
              <AtomNode start="(39, 69)" end="(39, 70)" leading="" trailing="" val="("/>
              <NullNode start="(39, 70)" end="(39, 71)">
                <IdentNode start="(39, 70)" end="(39, 71)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(39, 72)" end="(39, 96)">
                <AtomNode start="(39, 72)" end="(39, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 74)" end="(39, 96)" kind="«term_=_»">
                  <OtherNode start="(39, 74)" end="(39, 87)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(39, 74)" end="(39, 85)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                    <NullNode start="(39, 86)" end="(39, 87)">
                      <IdentNode start="(39, 86)" end="(39, 87)" leading="" trailing=" " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(39, 88)" end="(39, 89)" leading="" trailing=" " val="="/>
                  <OtherNode start="(39, 90)" end="(39, 96)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(39, 90)" end="(39, 94)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(39, 95)" end="(39, 96)">
                      <IdentNode start="(39, 95)" end="(39, 96)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(39, 96)" end="(39, 97)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(39, 98)" end="(40, 30)">
            <AtomNode start="(39, 98)" end="(39, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(40, 5)" end="(40, 30)" kind="«term∃_,_»">
              <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(40, 7)" end="(40, 8)" kind="Lean.explicitBinders">
                <OtherNode start="(40, 7)" end="(40, 8)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(40, 7)" end="(40, 8)">
                    <LeanBinderidentNode start="(40, 7)" end="(40, 8)">
                      <IdentNode start="(40, 7)" end="(40, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(40, 8)" end="(40, 9)" leading="" trailing=" " val=","/>
              <OtherNode start="(40, 10)" end="(40, 30)" kind="«term_∧_»">
                <OtherNode start="(40, 10)" end="(40, 15)" kind="«term_∈_»">
                  <IdentNode start="(40, 10)" end="(40, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(40, 12)" end="(40, 13)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(40, 14)" end="(40, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(40, 16)" end="(40, 17)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(40, 18)" end="(40, 30)" kind="«term_=_»">
                  <OtherNode start="(40, 18)" end="(40, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 18)" end="(40, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(40, 20)" end="(40, 21)">
                      <IdentNode start="(40, 20)" end="(40, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(40, 22)" end="(40, 23)" leading="" trailing=" " val="="/>
                  <OtherNode start="(40, 24)" end="(40, 30)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 24)" end="(40, 28)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(40, 29)" end="(40, 30)">
                      <IdentNode start="(40, 29)" end="(40, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(40, 31)" end="(45, 28)">
          <AtomNode start="(40, 31)" end="(40, 33)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(40, 34)" end="(45, 28)">
            <AtomNode start="(40, 34)" end="(40, 36)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(41, 3)" end="(45, 28)">
              <TacticTacticseq1IndentedNode start="(41, 3)" end="(45, 28)">
                <NullNode start="(41, 3)" end="(45, 28)">
                  <OtherNode start="(41, 3)" end="(45, 28)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;l : List α&#10;f : α → Option β&#10;w : findSome? f l = some b&#10;⊢ ∃ a, a ∈ l ∧ f a = some b" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp_all&#10;| cons h l ih =&amp;gt;&#10;  simp_all only [findSome?_cons, mem_cons, exists_eq_or_imp]&#10;  split at w &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(41, 3)" end="(41, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(41, 13)" end="(41, 14)">
                      <OtherNode start="(41, 13)" end="(41, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(41, 13)" end="(41, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(41, 15)" end="(45, 28)">
                      <OtherNode start="(41, 15)" end="(45, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(41, 15)" end="(41, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(42, 3)" end="(45, 28)">
                          <OtherNode start="(42, 3)" end="(42, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(42, 3)" end="(42, 8)">
                              <OtherNode start="(42, 3)" end="(42, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(42, 3)" end="(42, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(42, 5)" end="(42, 8)">
                                  <NullNode/>
                                  <IdentNode start="(42, 5)" end="(42, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(42, 9)" end="(42, 20)">
                              <AtomNode start="(42, 9)" end="(42, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(42, 12)" end="(42, 20)">
                                <TacticTacticseq1IndentedNode start="(42, 12)" end="(42, 20)">
                                  <NullNode start="(42, 12)" end="(42, 20)">
                                    <OtherNode start="(42, 12)" end="(42, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;w : findSome? f [] = some b&#10;⊢ ∃ a, a ∈ [] ∧ f a = some b" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(42, 12)" end="(42, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(43, 3)" end="(45, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(43, 3)" end="(43, 16)">
                              <OtherNode start="(43, 3)" end="(43, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(43, 3)" end="(43, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(43, 5)" end="(43, 9)">
                                  <NullNode/>
                                  <IdentNode start="(43, 5)" end="(43, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(43, 10)" end="(43, 16)">
                                  <IdentNode start="(43, 10)" end="(43, 11)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(43, 12)" end="(43, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(43, 14)" end="(43, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(43, 17)" end="(45, 28)">
                              <AtomNode start="(43, 17)" end="(43, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(44, 5)" end="(45, 28)">
                                <TacticTacticseq1IndentedNode start="(44, 5)" end="(45, 28)">
                                  <NullNode start="(44, 5)" end="(45, 28)">
                                    <OtherNode start="(44, 5)" end="(44, 63)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;h : α&#10;l : List α&#10;ih : findSome? f l = some b → ∃ a, a ∈ l ∧ f a = some b&#10;w : findSome? f (h :: l) = some b&#10;⊢ ∃ a, a ∈ h :: l ∧ f a = some b" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;h : α&#10;l : List α&#10;ih : findSome? f l = some b → ∃ a, a ∈ l ∧ f a = some b&#10;w :&#10;  (match f h with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f l) =&#10;    some b&#10;⊢ f h = some b ∨ ∃ a, a ∈ l ∧ f a = some b" tactic="simp_all only [findSome?_cons, mem_cons, exists_eq_or_imp]">
                                      <AtomNode start="(44, 5)" end="(44, 13)" leading="" trailing=" " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(44, 14)" end="(44, 18)">
                                        <AtomNode start="(44, 14)" end="(44, 18)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(44, 19)" end="(44, 63)">
                                        <AtomNode start="(44, 19)" end="(44, 20)" leading="" trailing="" val="["/>
                                        <NullNode start="(44, 20)" end="(44, 62)">
                                          <OtherNode start="(44, 20)" end="(44, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(44, 20)" end="(44, 34)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(44, 34)" end="(44, 35)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(44, 36)" end="(44, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(44, 36)" end="(44, 44)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(44, 44)" end="(44, 45)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(44, 46)" end="(44, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(44, 46)" end="(44, 62)" leading="" trailing="" raw_val="exists_eq_or_imp" val="exists_eq_or_imp" full_name="exists_eq_or_imp" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(44, 62)" end="(44, 63)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(45, 5)" end="(45, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;h : α&#10;l : List α&#10;ih : findSome? f l = some b → ∃ a, a ∈ l ∧ f a = some b&#10;w :&#10;  (match f h with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f l) =&#10;    some b&#10;⊢ f h = some b ∨ ∃ a, a ∈ l ∧ f a = some b" state_after="no goals" tactic="split at w &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(45, 5)" end="(45, 15)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(45, 5)" end="(45, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode start="(45, 11)" end="(45, 15)">
                                          <OtherNode start="(45, 11)" end="(45, 15)" kind="Lean.Parser.Tactic.location">
                                            <AtomNode start="(45, 11)" end="(45, 13)" leading="" trailing=" " val="at"/>
                                            <OtherNode start="(45, 14)" end="(45, 15)" kind="Lean.Parser.Tactic.locationHyp">
                                              <NullNode start="(45, 14)" end="(45, 15)">
                                                <IdentNode start="(45, 14)" end="(45, 15)" leading="" trailing=" " raw_val="w" val="w"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(45, 16)" end="(45, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(45, 20)" end="(45, 28)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(45, 20)" end="(45, 28)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(47, 1)" end="(48, 60)" name="findSome?_eq_none_iff" full_name="List.findSome?_eq_none_iff">
      <CommandDeclmodifiersNode start="(47, 1)" end="(47, 8)">
        <NullNode/>
        <NullNode start="(47, 1)" end="(47, 8)">
          <OtherNode start="(47, 1)" end="(47, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(47, 1)" end="(47, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(47, 3)" end="(47, 7)">
              <OtherNode start="(47, 3)" end="(47, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(47, 3)" end="(47, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(47, 3)" end="(47, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(47, 7)" end="(47, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(47, 9)" end="(48, 60)" name="findSome?_eq_none_iff" full_name="List.findSome?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(47, 9)" end="(47, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(47, 17)" end="(47, 38)">
          <IdentNode start="(47, 17)" end="(47, 38)" leading="" trailing=" " raw_val="findSome?_eq_none_iff" val="findSome?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(47, 39)" end="(47, 83)">
          <NullNode/>
          <TermTypespecNode start="(47, 39)" end="(47, 83)">
            <AtomNode start="(47, 39)" end="(47, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(47, 41)" end="(47, 83)" kind="«term_↔_»">
              <OtherNode start="(47, 41)" end="(47, 61)" kind="«term_=_»">
                <OtherNode start="(47, 41)" end="(47, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(47, 41)" end="(47, 50)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(47, 51)" end="(47, 54)">
                    <IdentNode start="(47, 51)" end="(47, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(47, 53)" end="(47, 54)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(47, 55)" end="(47, 56)" leading="" trailing=" " val="="/>
                <IdentNode start="(47, 57)" end="(47, 61)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(47, 62)" end="(47, 63)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(47, 64)" end="(47, 83)" kind="Lean.«term∀__,_»">
                <AtomNode start="(47, 64)" end="(47, 65)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(47, 66)" end="(47, 67)">
                  <IdentNode start="(47, 66)" end="(47, 67)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(47, 68)" end="(47, 71)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(47, 68)" end="(47, 69)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(47, 70)" end="(47, 71)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(47, 71)" end="(47, 72)" leading="" trailing=" " val=","/>
                <OtherNode start="(47, 73)" end="(47, 83)" kind="«term_=_»">
                  <OtherNode start="(47, 73)" end="(47, 76)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(47, 73)" end="(47, 74)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(47, 75)" end="(47, 76)">
                      <IdentNode start="(47, 75)" end="(47, 76)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(47, 77)" end="(47, 78)" leading="" trailing=" " val="="/>
                  <IdentNode start="(47, 79)" end="(47, 83)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(47, 84)" end="(48, 60)">
          <AtomNode start="(47, 84)" end="(47, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(47, 87)" end="(48, 60)">
            <AtomNode start="(47, 87)" end="(47, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(48, 3)" end="(48, 60)">
              <TacticTacticseq1IndentedNode start="(48, 3)" end="(48, 60)">
                <NullNode start="(48, 3)" end="(48, 60)">
                  <OtherNode start="(48, 3)" end="(48, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;p : α✝¹ → Option α✝&#10;l : List α✝¹&#10;⊢ findSome? p l = none ↔ ∀ (x : α✝¹), x ∈ l → p x = none" state_after="case cons&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;p : α✝¹ → Option α✝&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;tail_ih✝ : findSome? p tail✝ = none ↔ ∀ (x : α✝¹), x ∈ tail✝ → p x = none&#10;⊢ (match p head✝ with&#10;      | some b =&amp;gt; some b&#10;      | none =&amp;gt; findSome? p tail✝) =&#10;      none ↔&#10;    p head✝ = none ∧ ∀ (a : α✝¹), a ∈ tail✝ → p a = none" tactic="induction l &amp;lt;;&amp;gt; simp [findSome?_cons]">
                    <OtherNode start="(48, 3)" end="(48, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(48, 3)" end="(48, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(48, 13)" end="(48, 14)">
                        <OtherNode start="(48, 13)" end="(48, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(48, 13)" end="(48, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(48, 15)" end="(48, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(48, 19)" end="(48, 40)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(48, 19)" end="(48, 23)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(48, 24)" end="(48, 40)">
                        <AtomNode start="(48, 24)" end="(48, 25)" leading="" trailing="" val="["/>
                        <NullNode start="(48, 25)" end="(48, 39)">
                          <OtherNode start="(48, 25)" end="(48, 39)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(48, 25)" end="(48, 39)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(48, 39)" end="(48, 40)" leading="" trailing="" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(48, 40)" end="(48, 41)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(48, 42)" end="(48, 60)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;p : α✝¹ → Option α✝&#10;head✝ : α✝¹&#10;tail✝ : List α✝¹&#10;tail_ih✝ : findSome? p tail✝ = none ↔ ∀ (x : α✝¹), x ∈ tail✝ → p x = none&#10;⊢ (match p head✝ with&#10;      | some b =&amp;gt; some b&#10;      | none =&amp;gt; findSome? p tail✝) =&#10;      none ↔&#10;    p head✝ = none ∧ ∀ (a : α✝¹), a ∈ tail✝ → p a = none" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(48, 42)" end="(48, 47)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(48, 42)" end="(48, 47)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(48, 48)" end="(48, 51)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(48, 52)" end="(48, 60)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(48, 52)" end="(48, 56)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(48, 57)" end="(48, 60)">
                        <AtomNode start="(48, 57)" end="(48, 58)" leading="" trailing="" val="["/>
                        <NullNode start="(48, 58)" end="(48, 59)">
                          <OtherNode start="(48, 58)" end="(48, 59)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(48, 58)" end="(48, 59)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(48, 59)" end="(48, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(50, 1)" end="(50, 111)" name="findSome?_eq_none" full_name="List.findSome?_eq_none">
      <CommandDeclmodifiersNode start="(50, 1)" end="(50, 60)">
        <NullNode/>
        <NullNode start="(50, 1)" end="(50, 60)">
          <OtherNode start="(50, 1)" end="(50, 60)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(50, 1)" end="(50, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(50, 3)" end="(50, 59)">
              <OtherNode start="(50, 3)" end="(50, 59)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(50, 3)" end="(50, 59)" kind="Lean.deprecated">
                  <AtomNode start="(50, 3)" end="(50, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(50, 14)" end="(50, 35)">
                    <IdentNode start="(50, 14)" end="(50, 35)" leading="" trailing=" " raw_val="findSome?_eq_none_iff" val="findSome?_eq_none_iff" full_name="List.findSome?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(47, 17)" def_end="(47, 38)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(50, 36)" end="(50, 59)">
                    <AtomNode start="(50, 36)" end="(50, 37)" leading="" trailing="" val="("/>
                    <AtomNode start="(50, 37)" end="(50, 42)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(50, 43)" end="(50, 45)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(50, 46)" end="(50, 58)" kind="str">
                      <AtomNode start="(50, 46)" end="(50, 58)" leading="" trailing="" val="&amp;quot;2024-09-05&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(50, 58)" end="(50, 59)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(50, 59)" end="(50, 60)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(50, 61)" end="(50, 111)" name="findSome?_eq_none">
        <AtomNode start="(50, 61)" end="(50, 67)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(50, 68)" end="(50, 85)">
          <IdentNode start="(50, 68)" end="(50, 85)" leading="" trailing=" " raw_val="findSome?_eq_none" val="findSome?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(50, 86)" end="(50, 111)">
          <AtomNode start="(50, 86)" end="(50, 88)" leading="" trailing=" " val=":="/>
          <OtherNode start="(50, 89)" end="(50, 111)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(50, 89)" end="(50, 90)" leading="" trailing="" val="@"/>
            <IdentNode start="(50, 90)" end="(50, 111)" leading="" trailing="&#10;&#10;" raw_val="findSome?_eq_none_iff" val="findSome?_eq_none_iff" full_name="List.findSome?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(47, 17)" def_end="(47, 38)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(52, 1)" end="(58, 23)" name="findSome?_isSome_iff" full_name="List.findSome?_isSome_iff">
      <CommandDeclmodifiersNode start="(52, 1)" end="(52, 8)">
        <NullNode/>
        <NullNode start="(52, 1)" end="(52, 8)">
          <OtherNode start="(52, 1)" end="(52, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(52, 1)" end="(52, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(52, 3)" end="(52, 7)">
              <OtherNode start="(52, 3)" end="(52, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(52, 3)" end="(52, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(52, 3)" end="(52, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(52, 7)" end="(52, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(52, 9)" end="(58, 23)" name="findSome?_isSome_iff" full_name="List.findSome?_isSome_iff" _is_private_decl="False">
        <AtomNode start="(52, 9)" end="(52, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(52, 17)" end="(52, 37)">
          <IdentNode start="(52, 17)" end="(52, 37)" leading="" trailing=" " raw_val="findSome?_isSome_iff" val="findSome?_isSome_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(52, 38)" end="(53, 55)">
          <NullNode start="(52, 38)" end="(52, 69)">
            <OtherNode start="(52, 38)" end="(52, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(52, 38)" end="(52, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(52, 39)" end="(52, 40)">
                <IdentNode start="(52, 39)" end="(52, 40)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(52, 41)" end="(52, 55)">
                <AtomNode start="(52, 41)" end="(52, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(52, 43)" end="(52, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(52, 43)" end="(52, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(52, 45)" end="(52, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(52, 47)" end="(52, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(52, 47)" end="(52, 53)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(52, 54)" end="(52, 55)">
                      <IdentNode start="(52, 54)" end="(52, 55)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(52, 55)" end="(52, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(52, 57)" end="(52, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(52, 57)" end="(52, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(52, 58)" end="(52, 59)">
                <IdentNode start="(52, 58)" end="(52, 59)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(52, 60)" end="(52, 68)">
                <AtomNode start="(52, 60)" end="(52, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(52, 62)" end="(52, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(52, 62)" end="(52, 66)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(52, 67)" end="(52, 68)">
                    <IdentNode start="(52, 67)" end="(52, 68)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(52, 68)" end="(52, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(52, 70)" end="(53, 55)">
            <AtomNode start="(52, 70)" end="(52, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(53, 5)" end="(53, 55)" kind="«term_↔_»">
              <OtherNode start="(53, 5)" end="(53, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(53, 5)" end="(53, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(53, 5)" end="(53, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(53, 6)" end="(53, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(53, 6)" end="(53, 17)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                    <NullNode start="(53, 18)" end="(53, 19)">
                      <IdentNode start="(53, 18)" end="(53, 19)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(53, 19)" end="(53, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(53, 20)" end="(53, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(53, 21)" end="(53, 27)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(53, 28)" end="(53, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(53, 30)" end="(53, 55)" kind="«term∃_,_»">
                <AtomNode start="(53, 30)" end="(53, 31)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(53, 32)" end="(53, 33)" kind="Lean.explicitBinders">
                  <OtherNode start="(53, 32)" end="(53, 33)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(53, 32)" end="(53, 33)">
                      <LeanBinderidentNode start="(53, 32)" end="(53, 33)">
                        <IdentNode start="(53, 32)" end="(53, 33)" leading="" trailing="" raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(53, 33)" end="(53, 34)" leading="" trailing=" " val=","/>
                <OtherNode start="(53, 35)" end="(53, 55)" kind="«term_∧_»">
                  <OtherNode start="(53, 35)" end="(53, 40)" kind="«term_∈_»">
                    <IdentNode start="(53, 35)" end="(53, 36)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(53, 37)" end="(53, 38)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(53, 39)" end="(53, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(53, 41)" end="(53, 42)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(53, 43)" end="(53, 55)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(53, 43)" end="(53, 48)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(53, 43)" end="(53, 44)" leading="" trailing="" val="("/>
                      <OtherNode start="(53, 44)" end="(53, 47)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(53, 44)" end="(53, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(53, 46)" end="(53, 47)">
                          <IdentNode start="(53, 46)" end="(53, 47)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(53, 47)" end="(53, 48)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(53, 48)" end="(53, 49)" leading="" trailing="" val="."/>
                    <IdentNode start="(53, 49)" end="(53, 55)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(53, 56)" end="(58, 23)">
          <AtomNode start="(53, 56)" end="(53, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(53, 59)" end="(58, 23)">
            <AtomNode start="(53, 59)" end="(53, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(54, 3)" end="(58, 23)">
              <TacticTacticseq1IndentedNode start="(54, 3)" end="(58, 23)">
                <NullNode start="(54, 3)" end="(58, 23)">
                  <OtherNode start="(54, 3)" end="(58, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;⊢ (findSome? f l).isSome = true ↔ ∃ x, x ∈ l ∧ (f x).isSome = true" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findSome?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(54, 3)" end="(54, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(54, 13)" end="(54, 14)">
                      <OtherNode start="(54, 13)" end="(54, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(54, 13)" end="(54, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(54, 15)" end="(58, 23)">
                      <OtherNode start="(54, 15)" end="(58, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(54, 15)" end="(54, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(55, 3)" end="(58, 23)">
                          <OtherNode start="(55, 3)" end="(55, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(55, 3)" end="(55, 8)">
                              <OtherNode start="(55, 3)" end="(55, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(55, 3)" end="(55, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(55, 5)" end="(55, 8)">
                                  <NullNode/>
                                  <IdentNode start="(55, 5)" end="(55, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(55, 9)" end="(55, 16)">
                              <AtomNode start="(55, 9)" end="(55, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(55, 12)" end="(55, 16)">
                                <TacticTacticseq1IndentedNode start="(55, 12)" end="(55, 16)">
                                  <NullNode start="(55, 12)" end="(55, 16)">
                                    <OtherNode start="(55, 12)" end="(55, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;⊢ (findSome? f []).isSome = true ↔ ∃ x, x ∈ [] ∧ (f x).isSome = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(55, 12)" end="(55, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(56, 3)" end="(58, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(56, 3)" end="(56, 17)">
                              <OtherNode start="(56, 3)" end="(56, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(56, 3)" end="(56, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(56, 5)" end="(56, 9)">
                                  <NullNode/>
                                  <IdentNode start="(56, 5)" end="(56, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(56, 10)" end="(56, 17)">
                                  <IdentNode start="(56, 10)" end="(56, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(56, 12)" end="(56, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(56, 15)" end="(56, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(56, 18)" end="(58, 23)">
                              <AtomNode start="(56, 18)" end="(56, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(57, 5)" end="(58, 23)">
                                <TacticTacticseq1IndentedNode start="(57, 5)" end="(58, 23)">
                                  <NullNode start="(57, 5)" end="(58, 23)">
                                    <OtherNode start="(57, 5)" end="(57, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (findSome? f xs).isSome = true ↔ ∃ x, x ∈ xs ∧ (f x).isSome = true&#10;⊢ (findSome? f (x :: xs)).isSome = true ↔ ∃ x_1, x_1 ∈ x :: xs ∧ (f x_1).isSome = true" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (findSome? f xs).isSome = true ↔ ∃ x, x ∈ xs ∧ (f x).isSome = true&#10;⊢ (match f x with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f xs).isSome =&#10;      true ↔&#10;    ∃ x_1, x_1 ∈ x :: xs ∧ (f x_1).isSome = true" tactic="simp only [findSome?_cons]">
                                      <AtomNode start="(57, 5)" end="(57, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(57, 10)" end="(57, 14)">
                                        <AtomNode start="(57, 10)" end="(57, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(57, 15)" end="(57, 31)">
                                        <AtomNode start="(57, 15)" end="(57, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(57, 16)" end="(57, 30)">
                                          <OtherNode start="(57, 16)" end="(57, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(57, 16)" end="(57, 30)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(57, 30)" end="(57, 31)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(58, 5)" end="(58, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (findSome? f xs).isSome = true ↔ ∃ x, x ∈ xs ∧ (f x).isSome = true&#10;⊢ (match f x with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f xs).isSome =&#10;      true ↔&#10;    ∃ x_1, x_1 ∈ x :: xs ∧ (f x_1).isSome = true" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(58, 5)" end="(58, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(58, 5)" end="(58, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(58, 11)" end="(58, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(58, 15)" end="(58, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(58, 15)" end="(58, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(60, 1)" end="(93, 78)" name="findSome?_eq_some_iff" full_name="List.findSome?_eq_some_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(60, 1)" end="(93, 78)" name="findSome?_eq_some_iff" full_name="List.findSome?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(60, 1)" end="(60, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(60, 9)" end="(60, 30)">
          <IdentNode start="(60, 9)" end="(60, 30)" leading="" trailing=" " raw_val="findSome?_eq_some_iff" val="findSome?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(60, 31)" end="(61, 96)">
          <NullNode start="(60, 31)" end="(60, 70)">
            <OtherNode start="(60, 31)" end="(60, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 31)" end="(60, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 32)" end="(60, 33)">
                <IdentNode start="(60, 32)" end="(60, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(60, 34)" end="(60, 48)">
                <AtomNode start="(60, 34)" end="(60, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 36)" end="(60, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(60, 36)" end="(60, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(60, 38)" end="(60, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(60, 40)" end="(60, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(60, 40)" end="(60, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(60, 47)" end="(60, 48)">
                      <IdentNode start="(60, 47)" end="(60, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 48)" end="(60, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(60, 50)" end="(60, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 50)" end="(60, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 51)" end="(60, 52)">
                <IdentNode start="(60, 51)" end="(60, 52)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(60, 53)" end="(60, 61)">
                <AtomNode start="(60, 53)" end="(60, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 55)" end="(60, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 55)" end="(60, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(60, 60)" end="(60, 61)">
                    <IdentNode start="(60, 60)" end="(60, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 61)" end="(60, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(60, 63)" end="(60, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 63)" end="(60, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 64)" end="(60, 65)">
                <IdentNode start="(60, 64)" end="(60, 65)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(60, 66)" end="(60, 69)">
                <AtomNode start="(60, 66)" end="(60, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(60, 68)" end="(60, 69)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(60, 69)" end="(60, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(60, 71)" end="(61, 96)">
            <AtomNode start="(60, 71)" end="(60, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(61, 5)" end="(61, 96)" kind="«term_↔_»">
              <OtherNode start="(61, 5)" end="(61, 27)" kind="«term_=_»">
                <OtherNode start="(61, 5)" end="(61, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 5)" end="(61, 16)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                  <NullNode start="(61, 17)" end="(61, 18)">
                    <IdentNode start="(61, 17)" end="(61, 18)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(61, 19)" end="(61, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(61, 21)" end="(61, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 21)" end="(61, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(61, 26)" end="(61, 27)">
                    <IdentNode start="(61, 26)" end="(61, 27)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(61, 28)" end="(61, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(61, 30)" end="(61, 96)" kind="«term∃_,_»">
                <AtomNode start="(61, 30)" end="(61, 31)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(61, 32)" end="(61, 39)" kind="Lean.explicitBinders">
                  <OtherNode start="(61, 32)" end="(61, 39)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(61, 32)" end="(61, 39)">
                      <LeanBinderidentNode start="(61, 32)" end="(61, 34)">
                        <IdentNode start="(61, 32)" end="(61, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(61, 35)" end="(61, 36)">
                        <IdentNode start="(61, 35)" end="(61, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(61, 37)" end="(61, 39)">
                        <IdentNode start="(61, 37)" end="(61, 39)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(61, 39)" end="(61, 40)" leading="" trailing=" " val=","/>
                <OtherNode start="(61, 41)" end="(61, 96)" kind="«term_∧_»">
                  <OtherNode start="(61, 41)" end="(61, 58)" kind="«term_=_»">
                    <IdentNode start="(61, 41)" end="(61, 42)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(61, 43)" end="(61, 44)" leading="" trailing=" " val="="/>
                    <OtherNode start="(61, 45)" end="(61, 58)" kind="«term_++_»">
                      <IdentNode start="(61, 45)" end="(61, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(61, 48)" end="(61, 50)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(61, 51)" end="(61, 58)" kind="«term_::_»">
                        <IdentNode start="(61, 51)" end="(61, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(61, 53)" end="(61, 55)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(61, 56)" end="(61, 58)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(61, 59)" end="(61, 60)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(61, 61)" end="(61, 96)" kind="«term_∧_»">
                    <OtherNode start="(61, 61)" end="(61, 73)" kind="«term_=_»">
                      <OtherNode start="(61, 61)" end="(61, 64)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(61, 61)" end="(61, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(61, 63)" end="(61, 64)">
                          <IdentNode start="(61, 63)" end="(61, 64)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(61, 65)" end="(61, 66)" leading="" trailing=" " val="="/>
                      <OtherNode start="(61, 67)" end="(61, 73)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(61, 67)" end="(61, 71)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(61, 72)" end="(61, 73)">
                          <IdentNode start="(61, 72)" end="(61, 73)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(61, 74)" end="(61, 75)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(61, 76)" end="(61, 96)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(61, 76)" end="(61, 77)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(61, 78)" end="(61, 79)">
                        <IdentNode start="(61, 78)" end="(61, 79)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(61, 80)" end="(61, 84)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(61, 80)" end="(61, 81)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(61, 82)" end="(61, 84)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(61, 84)" end="(61, 85)" leading="" trailing=" " val=","/>
                      <OtherNode start="(61, 86)" end="(61, 96)" kind="«term_=_»">
                        <OtherNode start="(61, 86)" end="(61, 89)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(61, 86)" end="(61, 87)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(61, 88)" end="(61, 89)">
                            <IdentNode start="(61, 88)" end="(61, 89)" leading="" trailing=" " raw_val="x" val="x"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(61, 90)" end="(61, 91)" leading="" trailing=" " val="="/>
                        <IdentNode start="(61, 92)" end="(61, 96)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(61, 97)" end="(93, 78)">
          <AtomNode start="(61, 97)" end="(61, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(61, 100)" end="(93, 78)">
            <AtomNode start="(61, 100)" end="(61, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(62, 3)" end="(93, 78)">
              <TacticTacticseq1IndentedNode start="(62, 3)" end="(93, 78)">
                <NullNode start="(62, 3)" end="(93, 78)">
                  <OtherNode start="(62, 3)" end="(93, 78)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;b : β&#10;⊢ findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons p l ih =&amp;gt;&#10;  simp only [findSome?_cons]&#10;  split &amp;lt;;&amp;gt; rename_i b' h&#10;  · simp only [Option.some.injEq, exists_and_right]&#10;    constructor&#10;    · rintro rfl&#10;      exact ⟨[], p, ⟨l, rfl⟩, h, by simp⟩&#10;    · rintro ⟨(⟨⟩ | ⟨p', l₁⟩), a, ⟨l₂, h₁⟩, h₂, h₃⟩&#10;      · simp only [nil_append, cons.injEq] at h₁&#10;        apply Option.some.inj&#10;        simp [← h, ← h₂, h₁.1]&#10;      · simp only [cons_append, cons.injEq] at h₁&#10;        obtain ⟨rfl, rfl⟩ := h₁&#10;        specialize h₃ p&#10;        simp_all&#10;  · rw [ih]&#10;    constructor&#10;    · rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩&#10;      refine ⟨p :: l₁, a, l₂, rfl, h₁, ?_⟩&#10;      intro a w&#10;      simp at w&#10;      rcases w with rfl | w&#10;      · exact h&#10;      · exact h₂ _ w&#10;    · rintro ⟨l₁, a, l₂, h₁, h₂, h₃⟩&#10;      rcases l₁ with (⟨⟩ | ⟨a', l₁⟩)&#10;      · simp_all&#10;      · simp only [cons_append, cons.injEq] at h₁&#10;        obtain ⟨⟨rfl, rfl⟩, rfl⟩ := h₁&#10;        exact ⟨l₁, a, l₂, rfl, h₂, fun a' w =&amp;gt; h₃ a' (mem_cons_of_mem p w)⟩">
                    <AtomNode start="(62, 3)" end="(62, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(62, 13)" end="(62, 14)">
                      <OtherNode start="(62, 13)" end="(62, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(62, 13)" end="(62, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(62, 15)" end="(93, 78)">
                      <OtherNode start="(62, 15)" end="(93, 78)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(62, 15)" end="(62, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(63, 3)" end="(93, 78)">
                          <OtherNode start="(63, 3)" end="(63, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(63, 3)" end="(63, 8)">
                              <OtherNode start="(63, 3)" end="(63, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(63, 3)" end="(63, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(63, 5)" end="(63, 8)">
                                  <NullNode/>
                                  <IdentNode start="(63, 5)" end="(63, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(63, 9)" end="(63, 16)">
                              <AtomNode start="(63, 9)" end="(63, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(63, 12)" end="(63, 16)">
                                <TacticTacticseq1IndentedNode start="(63, 12)" end="(63, 16)">
                                  <NullNode start="(63, 12)" end="(63, 16)">
                                    <OtherNode start="(63, 12)" end="(63, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;⊢ findSome? f [] = some b ↔ ∃ l₁ a l₂, [] = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="simp">
                                      <AtomNode start="(63, 12)" end="(63, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(64, 3)" end="(93, 78)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(64, 3)" end="(64, 16)">
                              <OtherNode start="(64, 3)" end="(64, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(64, 3)" end="(64, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(64, 5)" end="(64, 9)">
                                  <NullNode/>
                                  <IdentNode start="(64, 5)" end="(64, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(64, 10)" end="(64, 16)">
                                  <IdentNode start="(64, 10)" end="(64, 11)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <IdentNode start="(64, 12)" end="(64, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(64, 14)" end="(64, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(64, 17)" end="(93, 78)">
                              <AtomNode start="(64, 17)" end="(64, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(65, 5)" end="(93, 78)">
                                <TacticTacticseq1IndentedNode start="(65, 5)" end="(93, 78)">
                                  <NullNode start="(65, 5)" end="(93, 78)">
                                    <OtherNode start="(65, 5)" end="(65, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ findSome? f (p :: l) = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ (match f p with&#10;      | some b =&amp;gt; some b&#10;      | none =&amp;gt; findSome? f l) =&#10;      some b ↔&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="simp only [findSome?_cons]">
                                      <AtomNode start="(65, 5)" end="(65, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(65, 10)" end="(65, 14)">
                                        <AtomNode start="(65, 10)" end="(65, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(65, 15)" end="(65, 31)">
                                        <AtomNode start="(65, 15)" end="(65, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(65, 16)" end="(65, 30)">
                                          <OtherNode start="(65, 16)" end="(65, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(65, 16)" end="(65, 30)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(65, 30)" end="(65, 31)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(66, 5)" end="(66, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ (match f p with&#10;      | some b =&amp;gt; some b&#10;      | none =&amp;gt; findSome? f l) =&#10;      some b ↔&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ some b' = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ findSome? f l = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="split &amp;lt;;&amp;gt; rename_i b' h">
                                      <OtherNode start="(66, 5)" end="(66, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(66, 5)" end="(66, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(66, 11)" end="(66, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(66, 15)" end="(66, 28)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(66, 15)" end="(66, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(66, 24)" end="(66, 28)">
                                          <LeanBinderidentNode start="(66, 24)" end="(66, 26)">
                                            <IdentNode start="(66, 24)" end="(66, 26)" leading="" trailing=" " raw_val="b'" val="b'"/>
                                          </LeanBinderidentNode>
                                          <LeanBinderidentNode start="(66, 27)" end="(66, 28)">
                                            <IdentNode start="(66, 27)" end="(66, 28)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(67, 5)" end="(78, 19)" kind="Lean.cdot" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ some b' = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ findSome? f l = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ findSome? f l = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="· simp only [Option.some.injEq, exists_and_right]&#10;  constructor&#10;  · rintro rfl&#10;    exact ⟨[], p, ⟨l, rfl⟩, h, by simp⟩&#10;  · rintro ⟨(⟨⟩ | ⟨p', l₁⟩), a, ⟨l₂, h₁⟩, h₂, h₃⟩&#10;    · simp only [nil_append, cons.injEq] at h₁&#10;      apply Option.some.inj&#10;      simp [← h, ← h₂, h₁.1]&#10;    · simp only [cons_append, cons.injEq] at h₁&#10;      obtain ⟨rfl, rfl⟩ := h₁&#10;      specialize h₃ p&#10;      simp_all">
                                      <OtherNode start="(67, 5)" end="(67, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(67, 5)" end="(67, 6)" kind="patternIgnore">
                                          <OtherNode start="(67, 5)" end="(67, 6)" kind="token.«· »">
                                            <AtomNode start="(67, 5)" end="(67, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(67, 7)" end="(78, 19)">
                                        <TacticTacticseq1IndentedNode start="(67, 7)" end="(78, 19)">
                                          <NullNode start="(67, 7)" end="(78, 19)">
                                            <OtherNode start="(67, 7)" end="(67, 54)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ some b' = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ b' = b ↔ ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="simp only [Option.some.injEq, exists_and_right]">
                                              <AtomNode start="(67, 7)" end="(67, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(67, 12)" end="(67, 16)">
                                                <AtomNode start="(67, 12)" end="(67, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(67, 17)" end="(67, 54)">
                                                <AtomNode start="(67, 17)" end="(67, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(67, 18)" end="(67, 53)">
                                                  <OtherNode start="(67, 18)" end="(67, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(67, 18)" end="(67, 35)" leading="" trailing="" raw_val="Option.some.injEq" val="Option.some.injEq" full_name="Option.some.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(67, 35)" end="(67, 36)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(67, 37)" end="(67, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(67, 37)" end="(67, 53)" leading="" trailing="" raw_val="exists_and_right" val="exists_and_right" full_name="exists_and_right" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(67, 53)" end="(67, 54)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(68, 7)" end="(68, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.h_1&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ b' = b ↔ ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_1.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ b' = b → ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_1.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ (∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) → b' = b" tactic="constructor">
                                              <AtomNode start="(68, 7)" end="(68, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(69, 7)" end="(70, 44)" kind="Lean.cdot" state_before="case cons.h_1.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ b' = b → ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_1.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ (∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) → b' = b" state_after="case cons.h_1.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ (∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) → b' = b" tactic="· rintro rfl&#10;  exact ⟨[], p, ⟨l, rfl⟩, h, by simp⟩">
                                              <OtherNode start="(69, 7)" end="(69, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(69, 7)" end="(69, 8)" kind="patternIgnore">
                                                  <OtherNode start="(69, 7)" end="(69, 8)" kind="token.«· »">
                                                    <AtomNode start="(69, 7)" end="(69, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(69, 9)" end="(70, 44)">
                                                <TacticTacticseq1IndentedNode start="(69, 9)" end="(70, 44)">
                                                  <NullNode start="(69, 9)" end="(70, 44)">
                                                    <OtherNode start="(69, 9)" end="(69, 19)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_1.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ b' = b → ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_1.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : α&#10;l : List α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;ih : findSome? f l = some b' ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b' ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b' ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="rintro rfl">
                                                      <AtomNode start="(69, 9)" end="(69, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(69, 16)" end="(69, 19)">
                                                        <OtherNode start="(69, 16)" end="(69, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(69, 16)" end="(69, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(69, 16)" end="(69, 19)" leading="" trailing="&#10;        " raw_val="rfl" val="rfl"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(70, 9)" end="(70, 44)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_1.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : α&#10;l : List α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;ih : findSome? f l = some b' ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b' ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b' ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="exact ⟨[], p, ⟨l, rfl⟩, h, by simp⟩">
                                                      <AtomNode start="(70, 9)" end="(70, 14)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(70, 15)" end="(70, 44)" kind="Lean.Parser.Term.anonymousCtor">
                                                        <AtomNode start="(70, 15)" end="(70, 16)" leading="" trailing="" val="⟨"/>
                                                        <NullNode start="(70, 16)" end="(70, 43)">
                                                          <OtherNode start="(70, 16)" end="(70, 18)" kind="«term[_]»">
                                                            <AtomNode start="(70, 16)" end="(70, 17)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(70, 17)" end="(70, 18)" leading="" trailing="" val="]"/>
                                                          </OtherNode>
                                                          <AtomNode start="(70, 18)" end="(70, 19)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(70, 20)" end="(70, 21)" leading="" trailing="" raw_val="p" val="p"/>
                                                          <AtomNode start="(70, 21)" end="(70, 22)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(70, 23)" end="(70, 31)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(70, 23)" end="(70, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(70, 24)" end="(70, 30)">
                                                            <IdentNode start="(70, 24)" end="(70, 25)" leading="" trailing="" raw_val="l" val="l"/>
                                                            <AtomNode start="(70, 25)" end="(70, 26)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(70, 27)" end="(70, 30)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            <AtomNode start="(70, 30)" end="(70, 31)" leading="" trailing="" val="⟩"/>
                                                          </OtherNode>
                                                          <AtomNode start="(70, 31)" end="(70, 32)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(70, 33)" end="(70, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                                          <AtomNode start="(70, 34)" end="(70, 35)" leading="" trailing=" " val=","/>
                                                          <TermBytacticNode start="(70, 36)" end="(70, 43)">
                                                            <AtomNode start="(70, 36)" end="(70, 38)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(70, 39)" end="(70, 43)">
                                                            <TacticTacticseq1IndentedNode start="(70, 39)" end="(70, 43)">
                                                            <NullNode start="(70, 39)" end="(70, 43)">
                                                            <OtherNode start="(70, 39)" end="(70, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : α&#10;l : List α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;ih : findSome? f l = some b' ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b' ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∀ (x : α), x ∈ [] → f x = none" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(70, 39)" end="(70, 43)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                        </NullNode>
                                                        <AtomNode start="(70, 43)" end="(70, 44)" leading="" trailing="&#10;      " val="⟩"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(71, 7)" end="(78, 19)" kind="Lean.cdot" state_before="case cons.h_1.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ (∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) → b' = b" state_after="no goals" tactic="· rintro ⟨(⟨⟩ | ⟨p', l₁⟩), a, ⟨l₂, h₁⟩, h₂, h₃⟩&#10;  · simp only [nil_append, cons.injEq] at h₁&#10;    apply Option.some.inj&#10;    simp [← h, ← h₂, h₁.1]&#10;  · simp only [cons_append, cons.injEq] at h₁&#10;    obtain ⟨rfl, rfl⟩ := h₁&#10;    specialize h₃ p&#10;    simp_all">
                                              <OtherNode start="(71, 7)" end="(71, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(71, 7)" end="(71, 8)" kind="patternIgnore">
                                                  <OtherNode start="(71, 7)" end="(71, 8)" kind="token.«· »">
                                                    <AtomNode start="(71, 7)" end="(71, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(71, 9)" end="(78, 19)">
                                                <TacticTacticseq1IndentedNode start="(71, 9)" end="(78, 19)">
                                                  <NullNode start="(71, 9)" end="(78, 19)">
                                                    <OtherNode start="(71, 9)" end="(71, 54)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_1.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;⊢ (∃ l₁ a, (∃ x, p :: l = l₁ ++ a :: x) ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) → b' = b" state_after="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = [] ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;⊢ b' = b&#10;&#10;case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = p' :: l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;⊢ b' = b" tactic="rintro ⟨(⟨⟩ | ⟨p', l₁⟩), a, ⟨l₂, h₁⟩, h₂, h₃⟩">
                                                      <AtomNode start="(71, 9)" end="(71, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(71, 16)" end="(71, 54)">
                                                        <OtherNode start="(71, 16)" end="(71, 54)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(71, 16)" end="(71, 54)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(71, 16)" end="(71, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(71, 17)" end="(71, 53)">
                                                            <OtherNode start="(71, 17)" end="(71, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 17)" end="(71, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 17)" end="(71, 32)">
                                                            <OtherNode start="(71, 17)" end="(71, 32)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(71, 17)" end="(71, 18)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(71, 18)" end="(71, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 18)" end="(71, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 18)" end="(71, 31)">
                                                            <OtherNode start="(71, 18)" end="(71, 20)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(71, 18)" end="(71, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode/>
                                                            <AtomNode start="(71, 19)" end="(71, 20)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 21)" end="(71, 22)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(71, 23)" end="(71, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(71, 23)" end="(71, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(71, 24)" end="(71, 30)">
                                                            <OtherNode start="(71, 24)" end="(71, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 24)" end="(71, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 24)" end="(71, 26)">
                                                            <OtherNode start="(71, 24)" end="(71, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 24)" end="(71, 26)" leading="" trailing="" raw_val="p'" val="p'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 26)" end="(71, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(71, 28)" end="(71, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 28)" end="(71, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 28)" end="(71, 30)">
                                                            <OtherNode start="(71, 28)" end="(71, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 28)" end="(71, 30)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(71, 30)" end="(71, 31)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 31)" end="(71, 32)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 32)" end="(71, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(71, 34)" end="(71, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 34)" end="(71, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 34)" end="(71, 35)">
                                                            <OtherNode start="(71, 34)" end="(71, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 34)" end="(71, 35)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 35)" end="(71, 36)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(71, 37)" end="(71, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 37)" end="(71, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 37)" end="(71, 45)">
                                                            <OtherNode start="(71, 37)" end="(71, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(71, 37)" end="(71, 38)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(71, 38)" end="(71, 44)">
                                                            <OtherNode start="(71, 38)" end="(71, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 38)" end="(71, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 38)" end="(71, 40)">
                                                            <OtherNode start="(71, 38)" end="(71, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 38)" end="(71, 40)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 40)" end="(71, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(71, 42)" end="(71, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 42)" end="(71, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 42)" end="(71, 44)">
                                                            <OtherNode start="(71, 42)" end="(71, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 42)" end="(71, 44)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(71, 44)" end="(71, 45)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 45)" end="(71, 46)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(71, 47)" end="(71, 49)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 47)" end="(71, 49)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 47)" end="(71, 49)">
                                                            <OtherNode start="(71, 47)" end="(71, 49)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 47)" end="(71, 49)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(71, 49)" end="(71, 50)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(71, 51)" end="(71, 53)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(71, 51)" end="(71, 53)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(71, 51)" end="(71, 53)">
                                                            <OtherNode start="(71, 51)" end="(71, 53)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(71, 51)" end="(71, 53)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(71, 53)" end="(71, 54)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(72, 9)" end="(74, 33)" kind="Lean.cdot" state_before="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = [] ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;⊢ b' = b&#10;&#10;case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = p' :: l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;⊢ b' = b" state_after="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = p' :: l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;⊢ b' = b" tactic="· simp only [nil_append, cons.injEq] at h₁&#10;  apply Option.some.inj&#10;  simp [← h, ← h₂, h₁.1]">
                                                      <OtherNode start="(72, 9)" end="(72, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(72, 9)" end="(72, 10)" kind="patternIgnore">
                                                          <OtherNode start="(72, 9)" end="(72, 10)" kind="token.«· »">
                                                            <AtomNode start="(72, 9)" end="(72, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(72, 11)" end="(74, 33)">
                                                        <TacticTacticseq1IndentedNode start="(72, 11)" end="(74, 33)">
                                                          <NullNode start="(72, 11)" end="(74, 33)">
                                                            <OtherNode start="(72, 11)" end="(72, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = [] ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;⊢ b' = b" state_after="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;h₁ : p = a ∧ l = l₂&#10;⊢ b' = b" tactic="simp only [nil_append, cons.injEq] at h₁">
                                                            <AtomNode start="(72, 11)" end="(72, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(72, 16)" end="(72, 20)">
                                                            <AtomNode start="(72, 16)" end="(72, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(72, 21)" end="(72, 45)">
                                                            <AtomNode start="(72, 21)" end="(72, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(72, 22)" end="(72, 44)">
                                                            <OtherNode start="(72, 22)" end="(72, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(72, 22)" end="(72, 32)" leading="" trailing="" raw_val="nil_append" val="nil_append" full_name="List.nil_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(72, 32)" end="(72, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(72, 34)" end="(72, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(72, 34)" end="(72, 44)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(72, 44)" end="(72, 45)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(72, 46)" end="(72, 51)">
                                                            <OtherNode start="(72, 46)" end="(72, 51)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(72, 46)" end="(72, 48)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(72, 49)" end="(72, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(72, 49)" end="(72, 51)">
                                                            <IdentNode start="(72, 49)" end="(72, 51)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(73, 11)" end="(73, 32)" kind="Lean.Parser.Tactic.apply" state_before="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;h₁ : p = a ∧ l = l₂&#10;⊢ b' = b" state_after="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro.x&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;h₁ : p = a ∧ l = l₂&#10;⊢ some b' = some b" tactic="apply Option.some.inj">
                                                            <AtomNode start="(73, 11)" end="(73, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(73, 17)" end="(73, 32)" leading="" trailing="&#10;          " raw_val="Option.some.inj" val="Option.some.inj" full_name="Option.some.inj" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(74, 11)" end="(74, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1.mpr.intro.nil.intro.intro.intro.intro.x&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;h₁ : p = a ∧ l = l₂&#10;⊢ some b' = some b" state_after="no goals" tactic="simp [← h, ← h₂, h₁.1]">
                                                            <AtomNode start="(74, 11)" end="(74, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(74, 16)" end="(74, 33)">
                                                            <AtomNode start="(74, 16)" end="(74, 17)" leading="" trailing="" val="["/>
                                                            <NullNode start="(74, 17)" end="(74, 32)">
                                                            <OtherNode start="(74, 17)" end="(74, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode start="(74, 17)" end="(74, 18)">
                                                            <OtherNode start="(74, 17)" end="(74, 18)" kind="patternIgnore">
                                                            <OtherNode start="(74, 17)" end="(74, 18)" kind="token.«← »">
                                                            <AtomNode start="(74, 17)" end="(74, 18)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(74, 19)" end="(74, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            <AtomNode start="(74, 20)" end="(74, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(74, 22)" end="(74, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode start="(74, 22)" end="(74, 23)">
                                                            <OtherNode start="(74, 22)" end="(74, 23)" kind="patternIgnore">
                                                            <OtherNode start="(74, 22)" end="(74, 23)" kind="token.«← »">
                                                            <AtomNode start="(74, 22)" end="(74, 23)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(74, 24)" end="(74, 26)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            <AtomNode start="(74, 26)" end="(74, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(74, 28)" end="(74, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(74, 28)" end="(74, 32)" kind="Lean.Parser.Term.proj">
                                                            <IdentNode start="(74, 28)" end="(74, 30)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            <AtomNode start="(74, 30)" end="(74, 31)" leading="" trailing="" val="."/>
                                                            <OtherNode start="(74, 31)" end="(74, 32)" kind="fieldIdx">
                                                            <AtomNode start="(74, 31)" end="(74, 32)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(74, 32)" end="(74, 33)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(75, 9)" end="(78, 19)" kind="Lean.cdot" state_before="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = p' :: l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;⊢ b' = b" state_after="no goals" tactic="· simp only [cons_append, cons.injEq] at h₁&#10;  obtain ⟨rfl, rfl⟩ := h₁&#10;  specialize h₃ p&#10;  simp_all">
                                                      <OtherNode start="(75, 9)" end="(75, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(75, 9)" end="(75, 10)" kind="patternIgnore">
                                                          <OtherNode start="(75, 9)" end="(75, 10)" kind="token.«· »">
                                                            <AtomNode start="(75, 9)" end="(75, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(75, 11)" end="(78, 19)">
                                                        <TacticTacticseq1IndentedNode start="(75, 11)" end="(78, 19)">
                                                          <NullNode start="(75, 11)" end="(78, 19)">
                                                            <OtherNode start="(75, 11)" end="(75, 52)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = p' :: l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;⊢ b' = b" state_after="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;h₁ : p = p' ∧ l = l₁ ++ a :: l₂&#10;⊢ b' = b" tactic="simp only [cons_append, cons.injEq] at h₁">
                                                            <AtomNode start="(75, 11)" end="(75, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(75, 16)" end="(75, 20)">
                                                            <AtomNode start="(75, 16)" end="(75, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(75, 21)" end="(75, 46)">
                                                            <AtomNode start="(75, 21)" end="(75, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(75, 22)" end="(75, 45)">
                                                            <OtherNode start="(75, 22)" end="(75, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(75, 22)" end="(75, 33)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(75, 33)" end="(75, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(75, 35)" end="(75, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(75, 35)" end="(75, 45)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(75, 45)" end="(75, 46)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(75, 47)" end="(75, 52)">
                                                            <OtherNode start="(75, 47)" end="(75, 52)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(75, 47)" end="(75, 49)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(75, 50)" end="(75, 52)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(75, 50)" end="(75, 52)">
                                                            <IdentNode start="(75, 50)" end="(75, 52)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(76, 11)" end="(76, 34)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;p' : α&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p' :: l₁ → f x = none&#10;h₁ : p = p' ∧ l = l₁ ++ a :: l₂&#10;⊢ b' = b" state_after="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p :: l₁ → f x = none&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;⊢ b' = b" tactic="obtain ⟨rfl, rfl⟩ := h₁">
                                                            <AtomNode start="(76, 11)" end="(76, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(76, 18)" end="(76, 28)">
                                                            <OtherNode start="(76, 18)" end="(76, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(76, 18)" end="(76, 28)">
                                                            <OtherNode start="(76, 18)" end="(76, 28)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(76, 18)" end="(76, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(76, 19)" end="(76, 27)">
                                                            <OtherNode start="(76, 19)" end="(76, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(76, 19)" end="(76, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(76, 19)" end="(76, 22)">
                                                            <OtherNode start="(76, 19)" end="(76, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(76, 19)" end="(76, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(76, 22)" end="(76, 23)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(76, 24)" end="(76, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(76, 24)" end="(76, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(76, 24)" end="(76, 27)">
                                                            <OtherNode start="(76, 24)" end="(76, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(76, 24)" end="(76, 27)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(76, 27)" end="(76, 28)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(76, 29)" end="(76, 34)">
                                                            <AtomNode start="(76, 29)" end="(76, 31)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(76, 32)" end="(76, 34)">
                                                            <IdentNode start="(76, 32)" end="(76, 34)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(77, 11)" end="(77, 26)" kind="Lean.Parser.Tactic.specialize" state_before="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ p :: l₁ → f x = none&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;⊢ b' = b" state_after="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₃ : p ∈ p :: l₁ → f p = none&#10;⊢ b' = b" tactic="specialize h₃ p">
                                                            <AtomNode start="(77, 11)" end="(77, 21)" leading="" trailing=" " val="specialize"/>
                                                            <OtherNode start="(77, 22)" end="(77, 26)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(77, 22)" end="(77, 24)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                            <NullNode start="(77, 25)" end="(77, 26)">
                                                            <IdentNode start="(77, 25)" end="(77, 26)" leading="" trailing="&#10;          " raw_val="p" val="p"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(78, 11)" end="(78, 19)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_1.mpr.intro.cons.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;x✝ : Option β&#10;b' : β&#10;h : f p = some b'&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₃ : p ∈ p :: l₁ → f p = none&#10;⊢ b' = b" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(78, 11)" end="(78, 19)" leading="" trailing="&#10;    " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(79, 5)" end="(93, 78)" kind="Lean.cdot" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ findSome? f l = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="· rw [ih]&#10;  constructor&#10;  · rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩&#10;    refine ⟨p :: l₁, a, l₂, rfl, h₁, ?_⟩&#10;    intro a w&#10;    simp at w&#10;    rcases w with rfl | w&#10;    · exact h&#10;    · exact h₂ _ w&#10;  · rintro ⟨l₁, a, l₂, h₁, h₂, h₃⟩&#10;    rcases l₁ with (⟨⟩ | ⟨a', l₁⟩)&#10;    · simp_all&#10;    · simp only [cons_append, cons.injEq] at h₁&#10;      obtain ⟨⟨rfl, rfl⟩, rfl⟩ := h₁&#10;      exact ⟨l₁, a, l₂, rfl, h₂, fun a' w =&amp;gt; h₃ a' (mem_cons_of_mem p w)⟩">
                                      <OtherNode start="(79, 5)" end="(79, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(79, 5)" end="(79, 6)" kind="patternIgnore">
                                          <OtherNode start="(79, 5)" end="(79, 6)" kind="token.«· »">
                                            <AtomNode start="(79, 5)" end="(79, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(79, 7)" end="(93, 78)">
                                        <TacticTacticseq1IndentedNode start="(79, 7)" end="(93, 78)">
                                          <NullNode start="(79, 7)" end="(93, 78)">
                                            <OtherNode start="(79, 7)" end="(79, 14)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ findSome? f l = some b ↔ ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) ↔&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="rw [ih]">
                                              <AtomNode start="(79, 7)" end="(79, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(79, 10)" end="(79, 14)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(79, 10)" end="(79, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(79, 11)" end="(79, 13)">
                                                  <OtherNode start="(79, 11)" end="(79, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(79, 11)" end="(79, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(79, 13)" end="(79, 14)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(80, 7)" end="(80, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) ↔&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_2.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="constructor">
                                              <AtomNode start="(80, 7)" end="(80, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(81, 7)" end="(87, 23)" kind="Lean.cdot" state_before="case cons.h_2.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_2.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="· rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩&#10;  refine ⟨p :: l₁, a, l₂, rfl, h₁, ?_⟩&#10;  intro a w&#10;  simp at w&#10;  rcases w with rfl | w&#10;  · exact h&#10;  · exact h₂ _ w">
                                              <OtherNode start="(81, 7)" end="(81, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(81, 7)" end="(81, 8)" kind="patternIgnore">
                                                  <OtherNode start="(81, 7)" end="(81, 8)" kind="token.«· »">
                                                    <AtomNode start="(81, 7)" end="(81, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(81, 9)" end="(87, 23)">
                                                <TacticTacticseq1IndentedNode start="(81, 9)" end="(87, 23)">
                                                  <NullNode start="(81, 9)" end="(87, 23)">
                                                    <OtherNode start="(81, 9)" end="(81, 40)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_2.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ l₁_1 a_1 l₂_1, p :: (l₁ ++ a :: l₂) = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none" tactic="rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩">
                                                      <AtomNode start="(81, 9)" end="(81, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(81, 16)" end="(81, 40)">
                                                        <OtherNode start="(81, 16)" end="(81, 40)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(81, 16)" end="(81, 40)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(81, 16)" end="(81, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(81, 17)" end="(81, 39)">
                                                            <OtherNode start="(81, 17)" end="(81, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(81, 17)" end="(81, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(81, 17)" end="(81, 19)">
                                                            <OtherNode start="(81, 17)" end="(81, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(81, 17)" end="(81, 19)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(81, 19)" end="(81, 20)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(81, 21)" end="(81, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(81, 21)" end="(81, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(81, 21)" end="(81, 22)">
                                                            <OtherNode start="(81, 21)" end="(81, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(81, 21)" end="(81, 22)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(81, 22)" end="(81, 23)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(81, 24)" end="(81, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(81, 24)" end="(81, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(81, 24)" end="(81, 26)">
                                                            <OtherNode start="(81, 24)" end="(81, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(81, 24)" end="(81, 26)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(81, 26)" end="(81, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(81, 28)" end="(81, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(81, 28)" end="(81, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(81, 28)" end="(81, 31)">
                                                            <OtherNode start="(81, 28)" end="(81, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(81, 28)" end="(81, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(81, 31)" end="(81, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(81, 33)" end="(81, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(81, 33)" end="(81, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(81, 33)" end="(81, 35)">
                                                            <OtherNode start="(81, 33)" end="(81, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(81, 33)" end="(81, 35)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(81, 35)" end="(81, 36)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(81, 37)" end="(81, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(81, 37)" end="(81, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(81, 37)" end="(81, 39)">
                                                            <OtherNode start="(81, 37)" end="(81, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(81, 37)" end="(81, 39)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(81, 39)" end="(81, 40)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(82, 9)" end="(82, 45)" kind="Lean.Parser.Tactic.refine" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ l₁_1 a_1 l₂_1, p :: (l₁ ++ a :: l₂) = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none" state_after="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∀ (x : α), x ∈ p :: l₁ → f x = none" tactic="refine ⟨p :: l₁, a, l₂, rfl, h₁, ?_⟩">
                                                      <AtomNode start="(82, 9)" end="(82, 15)" leading="" trailing=" " val="refine"/>
                                                      <OtherNode start="(82, 16)" end="(82, 45)" kind="Lean.Parser.Term.anonymousCtor">
                                                        <AtomNode start="(82, 16)" end="(82, 17)" leading="" trailing="" val="⟨"/>
                                                        <NullNode start="(82, 17)" end="(82, 44)">
                                                          <OtherNode start="(82, 17)" end="(82, 24)" kind="«term_::_»">
                                                            <IdentNode start="(82, 17)" end="(82, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <AtomNode start="(82, 19)" end="(82, 21)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(82, 22)" end="(82, 24)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                          </OtherNode>
                                                          <AtomNode start="(82, 24)" end="(82, 25)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(82, 26)" end="(82, 27)" leading="" trailing="" raw_val="a" val="a"/>
                                                          <AtomNode start="(82, 27)" end="(82, 28)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(82, 29)" end="(82, 31)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                          <AtomNode start="(82, 31)" end="(82, 32)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(82, 33)" end="(82, 36)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          <AtomNode start="(82, 36)" end="(82, 37)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(82, 38)" end="(82, 40)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                          <AtomNode start="(82, 40)" end="(82, 41)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(82, 42)" end="(82, 44)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(82, 42)" end="(82, 43)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(82, 43)" end="(82, 44)" leading="" trailing="" val="_"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(82, 44)" end="(82, 45)" leading="" trailing="&#10;        " val="⟩"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(83, 9)" end="(83, 18)" kind="Lean.Parser.Tactic.intro" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∀ (x : α), x ∈ p :: l₁ → f x = none" state_after="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ p :: l₁&#10;⊢ f a = none" tactic="intro a w">
                                                      <AtomNode start="(83, 9)" end="(83, 14)" leading="" trailing=" " val="intro"/>
                                                      <NullNode start="(83, 15)" end="(83, 18)">
                                                        <IdentNode start="(83, 15)" end="(83, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <IdentNode start="(83, 17)" end="(83, 18)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(84, 9)" end="(84, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ p :: l₁&#10;⊢ f a = none" state_after="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a = p ∨ a ∈ l₁&#10;⊢ f a = none" tactic="simp at w">
                                                      <AtomNode start="(84, 9)" end="(84, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(84, 14)" end="(84, 18)">
                                                        <OtherNode start="(84, 14)" end="(84, 18)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(84, 14)" end="(84, 16)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(84, 17)" end="(84, 18)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(84, 17)" end="(84, 18)">
                                                            <IdentNode start="(84, 17)" end="(84, 18)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(85, 9)" end="(85, 30)" kind="Lean.Parser.Tactic.rcases" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a = p ∨ a ∈ l₁&#10;⊢ f a = none" state_after="case cons.h_2.mp.intro.intro.intro.intro.intro.inl&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;b' : Option β&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;h : f a = none&#10;⊢ f a = none&#10;&#10;case cons.h_2.mp.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ l₁&#10;⊢ f a = none" tactic="rcases w with rfl | w">
                                                      <AtomNode start="(85, 9)" end="(85, 15)" leading="" trailing=" " val="rcases"/>
                                                      <NullNode start="(85, 16)" end="(85, 17)">
                                                        <OtherNode start="(85, 16)" end="(85, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(85, 16)" end="(85, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(85, 18)" end="(85, 30)">
                                                        <AtomNode start="(85, 18)" end="(85, 22)" leading="" trailing=" " val="with"/>
                                                        <OtherNode start="(85, 23)" end="(85, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(85, 23)" end="(85, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(85, 23)" end="(85, 30)">
                                                            <OtherNode start="(85, 23)" end="(85, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(85, 23)" end="(85, 26)" leading="" trailing=" " raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            <AtomNode start="(85, 27)" end="(85, 28)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(85, 29)" end="(85, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(85, 29)" end="(85, 30)" leading="" trailing="&#10;        " raw_val="w" val="w"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(86, 9)" end="(86, 18)" kind="Lean.cdot" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro.inl&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;b' : Option β&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;h : f a = none&#10;⊢ f a = none&#10;&#10;case cons.h_2.mp.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ l₁&#10;⊢ f a = none" state_after="case cons.h_2.mp.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ l₁&#10;⊢ f a = none" tactic="· exact h">
                                                      <OtherNode start="(86, 9)" end="(86, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(86, 9)" end="(86, 10)" kind="patternIgnore">
                                                          <OtherNode start="(86, 9)" end="(86, 10)" kind="token.«· »">
                                                            <AtomNode start="(86, 9)" end="(86, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(86, 11)" end="(86, 18)">
                                                        <TacticTacticseq1IndentedNode start="(86, 11)" end="(86, 18)">
                                                          <NullNode start="(86, 11)" end="(86, 18)">
                                                            <OtherNode start="(86, 11)" end="(86, 18)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro.inl&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;b' : Option β&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;h : f a = none&#10;⊢ f a = none" state_after="no goals" tactic="exact h">
                                                            <AtomNode start="(86, 11)" end="(86, 16)" leading="" trailing=" " val="exact"/>
                                                            <IdentNode start="(86, 17)" end="(86, 18)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(87, 9)" end="(87, 23)" kind="Lean.cdot" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ l₁&#10;⊢ f a = none" state_after="no goals" tactic="· exact h₂ _ w">
                                                      <OtherNode start="(87, 9)" end="(87, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(87, 9)" end="(87, 10)" kind="patternIgnore">
                                                          <OtherNode start="(87, 9)" end="(87, 10)" kind="token.«· »">
                                                            <AtomNode start="(87, 9)" end="(87, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(87, 11)" end="(87, 23)">
                                                        <TacticTacticseq1IndentedNode start="(87, 11)" end="(87, 23)">
                                                          <NullNode start="(87, 11)" end="(87, 23)">
                                                            <OtherNode start="(87, 11)" end="(87, 23)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_2.mp.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a✝ : α&#10;l₂ : List α&#10;ih :&#10;  findSome? f (l₁ ++ a✝ :: l₂) = some b ↔&#10;    ∃ l₁_1 a l₂_1, l₁ ++ a✝ :: l₂ = l₁_1 ++ a :: l₂_1 ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;h₁ : f a✝ = some b&#10;h₂ : ∀ (x : α), x ∈ l₁ → f x = none&#10;a : α&#10;w : a ∈ l₁&#10;⊢ f a = none" state_after="no goals" tactic="exact h₂ _ w">
                                                            <AtomNode start="(87, 11)" end="(87, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(87, 17)" end="(87, 23)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(87, 17)" end="(87, 19)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            <NullNode start="(87, 20)" end="(87, 23)">
                                                            <TermHoleNode start="(87, 20)" end="(87, 21)">
                                                            <AtomNode start="(87, 20)" end="(87, 21)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(87, 22)" end="(87, 23)" leading="" trailing="&#10;      " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(88, 7)" end="(93, 78)" kind="Lean.cdot" state_before="case cons.h_2.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="· rintro ⟨l₁, a, l₂, h₁, h₂, h₃⟩&#10;  rcases l₁ with (⟨⟩ | ⟨a', l₁⟩)&#10;  · simp_all&#10;  · simp only [cons_append, cons.injEq] at h₁&#10;    obtain ⟨⟨rfl, rfl⟩, rfl⟩ := h₁&#10;    exact ⟨l₁, a, l₂, rfl, h₂, fun a' w =&amp;gt; h₃ a' (mem_cons_of_mem p w)⟩">
                                              <OtherNode start="(88, 7)" end="(88, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(88, 7)" end="(88, 8)" kind="patternIgnore">
                                                  <OtherNode start="(88, 7)" end="(88, 8)" kind="token.«· »">
                                                    <AtomNode start="(88, 7)" end="(88, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(88, 9)" end="(93, 78)">
                                                <TacticTacticseq1IndentedNode start="(88, 9)" end="(93, 78)">
                                                  <NullNode start="(88, 9)" end="(93, 78)">
                                                    <OtherNode start="(88, 9)" end="(88, 39)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_2.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;⊢ (∃ l₁ a l₂, p :: l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none) →&#10;    ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mpr.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="rintro ⟨l₁, a, l₂, h₁, h₂, h₃⟩">
                                                      <AtomNode start="(88, 9)" end="(88, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(88, 16)" end="(88, 39)">
                                                        <OtherNode start="(88, 16)" end="(88, 39)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(88, 16)" end="(88, 39)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(88, 16)" end="(88, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(88, 17)" end="(88, 38)">
                                                            <OtherNode start="(88, 17)" end="(88, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(88, 17)" end="(88, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(88, 17)" end="(88, 19)">
                                                            <OtherNode start="(88, 17)" end="(88, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(88, 17)" end="(88, 19)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(88, 19)" end="(88, 20)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(88, 21)" end="(88, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(88, 21)" end="(88, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(88, 21)" end="(88, 22)">
                                                            <OtherNode start="(88, 21)" end="(88, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(88, 21)" end="(88, 22)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(88, 22)" end="(88, 23)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(88, 24)" end="(88, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(88, 24)" end="(88, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(88, 24)" end="(88, 26)">
                                                            <OtherNode start="(88, 24)" end="(88, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(88, 24)" end="(88, 26)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(88, 26)" end="(88, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(88, 28)" end="(88, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(88, 28)" end="(88, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(88, 28)" end="(88, 30)">
                                                            <OtherNode start="(88, 28)" end="(88, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(88, 28)" end="(88, 30)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(88, 30)" end="(88, 31)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(88, 32)" end="(88, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(88, 32)" end="(88, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(88, 32)" end="(88, 34)">
                                                            <OtherNode start="(88, 32)" end="(88, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(88, 32)" end="(88, 34)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(88, 34)" end="(88, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(88, 36)" end="(88, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(88, 36)" end="(88, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(88, 36)" end="(88, 38)">
                                                            <OtherNode start="(88, 36)" end="(88, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(88, 36)" end="(88, 38)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(88, 38)" end="(88, 39)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(89, 9)" end="(89, 39)" kind="Lean.Parser.Tactic.rcases" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;l₁ : List α&#10;a : α&#10;l₂ : List α&#10;h₁ : p :: l = l₁ ++ a :: l₂&#10;h₂ : f a = some b&#10;h₃ : ∀ (x : α), x ∈ l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mpr.intro.intro.intro.intro.intro.nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₁ : p :: l = [] ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₁ : p :: l = a' :: l₁ ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="rcases l₁ with (⟨⟩ | ⟨a', l₁⟩)">
                                                      <AtomNode start="(89, 9)" end="(89, 15)" leading="" trailing=" " val="rcases"/>
                                                      <NullNode start="(89, 16)" end="(89, 18)">
                                                        <OtherNode start="(89, 16)" end="(89, 18)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(89, 16)" end="(89, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(89, 19)" end="(89, 39)">
                                                        <AtomNode start="(89, 19)" end="(89, 23)" leading="" trailing=" " val="with"/>
                                                        <OtherNode start="(89, 24)" end="(89, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(89, 24)" end="(89, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(89, 24)" end="(89, 39)">
                                                            <OtherNode start="(89, 24)" end="(89, 39)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(89, 24)" end="(89, 25)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(89, 25)" end="(89, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(89, 25)" end="(89, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(89, 25)" end="(89, 38)">
                                                            <OtherNode start="(89, 25)" end="(89, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(89, 25)" end="(89, 26)" leading="" trailing="" val="⟨"/>
                                                            <NullNode/>
                                                            <AtomNode start="(89, 26)" end="(89, 27)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(89, 28)" end="(89, 29)" leading="" trailing=" " val="|"/>
                                                            <OtherNode start="(89, 30)" end="(89, 38)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(89, 30)" end="(89, 31)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(89, 31)" end="(89, 37)">
                                                            <OtherNode start="(89, 31)" end="(89, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(89, 31)" end="(89, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(89, 31)" end="(89, 33)">
                                                            <OtherNode start="(89, 31)" end="(89, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(89, 31)" end="(89, 33)" leading="" trailing="" raw_val="a'" val="a'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(89, 33)" end="(89, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(89, 35)" end="(89, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(89, 35)" end="(89, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(89, 35)" end="(89, 37)">
                                                            <OtherNode start="(89, 35)" end="(89, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(89, 35)" end="(89, 37)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(89, 37)" end="(89, 38)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(89, 38)" end="(89, 39)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(90, 9)" end="(90, 19)" kind="Lean.cdot" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro.nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₁ : p :: l = [] ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;&#10;case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₁ : p :: l = a' :: l₁ ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₁ : p :: l = a' :: l₁ ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="· simp_all">
                                                      <OtherNode start="(90, 9)" end="(90, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(90, 9)" end="(90, 10)" kind="patternIgnore">
                                                          <OtherNode start="(90, 9)" end="(90, 10)" kind="token.«· »">
                                                            <AtomNode start="(90, 9)" end="(90, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(90, 11)" end="(90, 19)">
                                                        <TacticTacticseq1IndentedNode start="(90, 11)" end="(90, 19)">
                                                          <NullNode start="(90, 11)" end="(90, 19)">
                                                            <OtherNode start="(90, 11)" end="(90, 19)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro.nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;h₁ : p :: l = [] ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ [] → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(90, 11)" end="(90, 19)" leading="" trailing="&#10;        " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(91, 9)" end="(93, 78)" kind="Lean.cdot" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₁ : p :: l = a' :: l₁ ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="· simp only [cons_append, cons.injEq] at h₁&#10;  obtain ⟨⟨rfl, rfl⟩, rfl⟩ := h₁&#10;  exact ⟨l₁, a, l₂, rfl, h₂, fun a' w =&amp;gt; h₃ a' (mem_cons_of_mem p w)⟩">
                                                      <OtherNode start="(91, 9)" end="(91, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(91, 9)" end="(91, 10)" kind="patternIgnore">
                                                          <OtherNode start="(91, 9)" end="(91, 10)" kind="token.«· »">
                                                            <AtomNode start="(91, 9)" end="(91, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(91, 11)" end="(93, 78)">
                                                        <TacticTacticseq1IndentedNode start="(91, 11)" end="(93, 78)">
                                                          <NullNode start="(91, 11)" end="(93, 78)">
                                                            <OtherNode start="(91, 11)" end="(91, 52)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₁ : p :: l = a' :: l₁ ++ a :: l₂&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;h₁ : p = a' ∧ l = l₁ ++ a :: l₂&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" tactic="simp only [cons_append, cons.injEq] at h₁">
                                                            <AtomNode start="(91, 11)" end="(91, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(91, 16)" end="(91, 20)">
                                                            <AtomNode start="(91, 16)" end="(91, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(91, 21)" end="(91, 46)">
                                                            <AtomNode start="(91, 21)" end="(91, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(91, 22)" end="(91, 45)">
                                                            <OtherNode start="(91, 22)" end="(91, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(91, 22)" end="(91, 33)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(91, 33)" end="(91, 34)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(91, 35)" end="(91, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(91, 35)" end="(91, 45)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(91, 45)" end="(91, 46)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(91, 47)" end="(91, 52)">
                                                            <OtherNode start="(91, 47)" end="(91, 52)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(91, 47)" end="(91, 49)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(91, 50)" end="(91, 52)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(91, 50)" end="(91, 52)">
                                                            <IdentNode start="(91, 50)" end="(91, 52)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(92, 11)" end="(92, 41)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;l : List α&#10;ih : findSome? f l = some b ↔ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;a' : α&#10;l₁ : List α&#10;h₃ : ∀ (x : α), x ∈ a' :: l₁ → f x = none&#10;h₁ : p = a' ∧ l = l₁ ++ a :: l₂&#10;⊢ ∃ l₁ a l₂, l = l₁ ++ a :: l₂ ∧ f a = some b ∧ ∀ (x : α), x ∈ l₁ → f x = none" state_after="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons.intro.refl&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;l₁ : List α&#10;h₃ : ∀ (x : α), x ∈ p :: l₁ → f x = none&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;⊢ ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none" tactic="obtain ⟨⟨rfl, rfl⟩, rfl⟩ := h₁">
                                                            <AtomNode start="(92, 11)" end="(92, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(92, 18)" end="(92, 35)">
                                                            <OtherNode start="(92, 18)" end="(92, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(92, 18)" end="(92, 35)">
                                                            <OtherNode start="(92, 18)" end="(92, 35)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(92, 18)" end="(92, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(92, 19)" end="(92, 34)">
                                                            <OtherNode start="(92, 19)" end="(92, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(92, 19)" end="(92, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(92, 19)" end="(92, 29)">
                                                            <OtherNode start="(92, 19)" end="(92, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(92, 19)" end="(92, 20)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(92, 20)" end="(92, 28)">
                                                            <OtherNode start="(92, 20)" end="(92, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(92, 20)" end="(92, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(92, 20)" end="(92, 23)">
                                                            <OtherNode start="(92, 20)" end="(92, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(92, 20)" end="(92, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 23)" end="(92, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(92, 25)" end="(92, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(92, 25)" end="(92, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(92, 25)" end="(92, 28)">
                                                            <OtherNode start="(92, 25)" end="(92, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(92, 25)" end="(92, 28)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(92, 28)" end="(92, 29)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 29)" end="(92, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(92, 31)" end="(92, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(92, 31)" end="(92, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(92, 31)" end="(92, 34)">
                                                            <OtherNode start="(92, 31)" end="(92, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(92, 31)" end="(92, 34)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(92, 34)" end="(92, 35)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(92, 36)" end="(92, 41)">
                                                            <AtomNode start="(92, 36)" end="(92, 38)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(92, 39)" end="(92, 41)">
                                                            <IdentNode start="(92, 39)" end="(92, 41)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(93, 11)" end="(93, 78)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_2.mpr.intro.intro.intro.intro.intro.cons.intro.refl&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;p : α&#10;b' : Option β&#10;h : f p = none&#10;a : α&#10;l₂ : List α&#10;h₂ : f a = some b&#10;l₁ : List α&#10;h₃ : ∀ (x : α), x ∈ p :: l₁ → f x = none&#10;ih :&#10;  findSome? f (l₁ ++ a :: l₂) = some b ↔&#10;    ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none&#10;⊢ ∃ l₁_1 a_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ a_1 :: l₂_1 ∧ f a_1 = some b ∧ ∀ (x : α), x ∈ l₁_1 → f x = none" state_after="no goals" tactic="exact ⟨l₁, a, l₂, rfl, h₂, fun a' w =&amp;gt; h₃ a' (mem_cons_of_mem p w)⟩">
                                                            <AtomNode start="(93, 11)" end="(93, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(93, 17)" end="(93, 78)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(93, 17)" end="(93, 18)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(93, 18)" end="(93, 77)">
                                                            <IdentNode start="(93, 18)" end="(93, 20)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                                            <AtomNode start="(93, 20)" end="(93, 21)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(93, 22)" end="(93, 23)" leading="" trailing="" raw_val="a" val="a"/>
                                                            <AtomNode start="(93, 23)" end="(93, 24)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(93, 25)" end="(93, 27)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                            <AtomNode start="(93, 27)" end="(93, 28)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(93, 29)" end="(93, 32)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            <AtomNode start="(93, 32)" end="(93, 33)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(93, 34)" end="(93, 36)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            <AtomNode start="(93, 36)" end="(93, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(93, 38)" end="(93, 77)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(93, 38)" end="(93, 41)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(93, 42)" end="(93, 77)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(93, 42)" end="(93, 46)">
                                                            <IdentNode start="(93, 42)" end="(93, 44)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                                            <IdentNode start="(93, 45)" end="(93, 46)" leading="" trailing=" " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(93, 47)" end="(93, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(93, 50)" end="(93, 77)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(93, 50)" end="(93, 52)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                            <NullNode start="(93, 53)" end="(93, 77)">
                                                            <IdentNode start="(93, 53)" end="(93, 55)" leading="" trailing=" " raw_val="a'" val="a'"/>
                                                            <OtherNode start="(93, 56)" end="(93, 77)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(93, 56)" end="(93, 57)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(93, 57)" end="(93, 76)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(93, 57)" end="(93, 72)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(93, 73)" end="(93, 76)">
                                                            <IdentNode start="(93, 73)" end="(93, 74)" leading="" trailing=" " raw_val="p" val="p"/>
                                                            <IdentNode start="(93, 75)" end="(93, 76)" leading="" trailing="" raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(93, 76)" end="(93, 77)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(93, 77)" end="(93, 78)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(95, 1)" end="(105, 19)" name="findSome?_guard" full_name="List.findSome?_guard">
      <CommandDeclmodifiersNode start="(95, 1)" end="(95, 8)">
        <NullNode/>
        <NullNode start="(95, 1)" end="(95, 8)">
          <OtherNode start="(95, 1)" end="(95, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(95, 1)" end="(95, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(95, 3)" end="(95, 7)">
              <OtherNode start="(95, 3)" end="(95, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(95, 3)" end="(95, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(95, 3)" end="(95, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(95, 7)" end="(95, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(95, 9)" end="(105, 19)" name="findSome?_guard" full_name="List.findSome?_guard" _is_private_decl="False">
        <AtomNode start="(95, 9)" end="(95, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(95, 17)" end="(95, 32)">
          <IdentNode start="(95, 17)" end="(95, 32)" leading="" trailing=" " raw_val="findSome?_guard" val="findSome?_guard"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(95, 33)" end="(95, 99)">
          <NullNode start="(95, 33)" end="(95, 45)">
            <OtherNode start="(95, 33)" end="(95, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(95, 33)" end="(95, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(95, 34)" end="(95, 35)">
                <IdentNode start="(95, 34)" end="(95, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(95, 36)" end="(95, 44)">
                <AtomNode start="(95, 36)" end="(95, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 38)" end="(95, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(95, 38)" end="(95, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(95, 43)" end="(95, 44)">
                    <IdentNode start="(95, 43)" end="(95, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(95, 44)" end="(95, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(95, 46)" end="(95, 99)">
            <AtomNode start="(95, 46)" end="(95, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(95, 48)" end="(95, 99)" kind="«term_=_»">
              <OtherNode start="(95, 48)" end="(95, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(95, 48)" end="(95, 57)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(95, 58)" end="(95, 87)">
                  <OtherNode start="(95, 58)" end="(95, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(95, 58)" end="(95, 59)" leading="" trailing="" val="("/>
                    <OtherNode start="(95, 59)" end="(95, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(95, 59)" end="(95, 71)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(95, 72)" end="(95, 84)">
                        <OtherNode start="(95, 72)" end="(95, 84)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(95, 72)" end="(95, 75)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(95, 76)" end="(95, 84)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(95, 76)" end="(95, 77)">
                              <IdentNode start="(95, 76)" end="(95, 77)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(95, 78)" end="(95, 80)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(95, 81)" end="(95, 84)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(95, 81)" end="(95, 82)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(95, 83)" end="(95, 84)">
                                <IdentNode start="(95, 83)" end="(95, 84)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(95, 84)" end="(95, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(95, 86)" end="(95, 87)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(95, 88)" end="(95, 89)" leading="" trailing=" " val="="/>
              <OtherNode start="(95, 90)" end="(95, 99)" kind="Lean.Parser.Term.app">
                <IdentNode start="(95, 90)" end="(95, 95)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(95, 96)" end="(95, 99)">
                  <IdentNode start="(95, 96)" end="(95, 97)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(95, 98)" end="(95, 99)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(95, 100)" end="(105, 19)">
          <AtomNode start="(95, 100)" end="(95, 102)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(95, 103)" end="(105, 19)">
            <AtomNode start="(95, 103)" end="(95, 105)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(96, 3)" end="(105, 19)">
              <TacticTacticseq1IndentedNode start="(96, 3)" end="(105, 19)">
                <NullNode start="(96, 3)" end="(105, 19)">
                  <OtherNode start="(96, 3)" end="(105, 19)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) l = find? p l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp [guard, findSome?, find?]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · simp only [Option.guard_eq_some_iff] at h&#10;    obtain ⟨rfl, h⟩ := h&#10;    simp [h]&#10;  · simp only [Option.guard_eq_none_iff] at h&#10;    simp [ih, h]">
                    <AtomNode start="(96, 3)" end="(96, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(96, 13)" end="(96, 14)">
                      <OtherNode start="(96, 13)" end="(96, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(96, 13)" end="(96, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(96, 15)" end="(105, 19)">
                      <OtherNode start="(96, 15)" end="(105, 19)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(96, 15)" end="(96, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(97, 3)" end="(105, 19)">
                          <OtherNode start="(97, 3)" end="(97, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(97, 3)" end="(97, 8)">
                              <OtherNode start="(97, 3)" end="(97, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(97, 3)" end="(97, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(97, 5)" end="(97, 8)">
                                  <NullNode/>
                                  <IdentNode start="(97, 5)" end="(97, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(97, 9)" end="(97, 16)">
                              <AtomNode start="(97, 9)" end="(97, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(97, 12)" end="(97, 16)">
                                <TacticTacticseq1IndentedNode start="(97, 12)" end="(97, 16)">
                                  <NullNode start="(97, 12)" end="(97, 16)">
                                    <OtherNode start="(97, 12)" end="(97, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) [] = find? p []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(97, 12)" end="(97, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(98, 3)" end="(105, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(98, 3)" end="(98, 17)">
                              <OtherNode start="(98, 3)" end="(98, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(98, 3)" end="(98, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(98, 5)" end="(98, 9)">
                                  <NullNode/>
                                  <IdentNode start="(98, 5)" end="(98, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(98, 10)" end="(98, 17)">
                                  <IdentNode start="(98, 10)" end="(98, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(98, 12)" end="(98, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(98, 15)" end="(98, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(98, 18)" end="(105, 19)">
                              <AtomNode start="(98, 18)" end="(98, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(99, 5)" end="(105, 19)">
                                <TacticTacticseq1IndentedNode start="(99, 5)" end="(105, 19)">
                                  <NullNode start="(99, 5)" end="(105, 19)">
                                    <OtherNode start="(99, 5)" end="(99, 35)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) (x :: xs) = find? p (x :: xs)" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;⊢ (match Option.guard (fun x =&amp;gt; p x) x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (Option.guard fun x =&amp;gt; p x) xs) =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" tactic="simp [guard, findSome?, find?]">
                                      <AtomNode start="(99, 5)" end="(99, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(99, 10)" end="(99, 35)">
                                        <AtomNode start="(99, 10)" end="(99, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(99, 11)" end="(99, 34)">
                                          <OtherNode start="(99, 11)" end="(99, 16)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(99, 11)" end="(99, 16)" leading="" trailing="" raw_val="guard" val="guard" full_name="guard" mod_name="Init.Control.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Control/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(99, 16)" end="(99, 17)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(99, 18)" end="(99, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(99, 18)" end="(99, 27)" leading="" trailing="" raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(99, 27)" end="(99, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(99, 29)" end="(99, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(99, 29)" end="(99, 34)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(99, 34)" end="(99, 35)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(100, 5)" end="(100, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;⊢ (match Option.guard (fun x =&amp;gt; p x) x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (Option.guard fun x =&amp;gt; p x) xs) =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="case cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;b✝ : α&#10;h : Option.guard (fun x =&amp;gt; p x) x = some b✝&#10;⊢ some b✝ =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : Option.guard (fun x =&amp;gt; p x) x = none&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                      <OtherNode start="(100, 5)" end="(100, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(100, 5)" end="(100, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(100, 11)" end="(100, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(100, 15)" end="(100, 25)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(100, 15)" end="(100, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(100, 24)" end="(100, 25)">
                                          <LeanBinderidentNode start="(100, 24)" end="(100, 25)">
                                            <IdentNode start="(100, 24)" end="(100, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(101, 5)" end="(103, 15)" kind="Lean.cdot" state_before="case cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;b✝ : α&#10;h : Option.guard (fun x =&amp;gt; p x) x = some b✝&#10;⊢ some b✝ =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs&#10;&#10;case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : Option.guard (fun x =&amp;gt; p x) x = none&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : Option.guard (fun x =&amp;gt; p x) x = none&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" tactic="· simp only [Option.guard_eq_some_iff] at h&#10;  obtain ⟨rfl, h⟩ := h&#10;  simp [h]">
                                      <OtherNode start="(101, 5)" end="(101, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(101, 5)" end="(101, 6)" kind="patternIgnore">
                                          <OtherNode start="(101, 5)" end="(101, 6)" kind="token.«· »">
                                            <AtomNode start="(101, 5)" end="(101, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(101, 7)" end="(103, 15)">
                                        <TacticTacticseq1IndentedNode start="(101, 7)" end="(103, 15)">
                                          <NullNode start="(101, 7)" end="(103, 15)">
                                            <OtherNode start="(101, 7)" end="(101, 48)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;b✝ : α&#10;h : Option.guard (fun x =&amp;gt; p x) x = some b✝&#10;⊢ some b✝ =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="case cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;b✝ : α&#10;h : x = b✝ ∧ p x = true&#10;⊢ some b✝ =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" tactic="simp only [Option.guard_eq_some_iff] at h">
                                              <AtomNode start="(101, 7)" end="(101, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(101, 12)" end="(101, 16)">
                                                <AtomNode start="(101, 12)" end="(101, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(101, 17)" end="(101, 43)">
                                                <AtomNode start="(101, 17)" end="(101, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(101, 18)" end="(101, 42)">
                                                  <OtherNode start="(101, 18)" end="(101, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(101, 18)" end="(101, 42)" leading="" trailing="" raw_val="Option.guard_eq_some_iff" val="Option.guard_eq_some_iff" full_name="Option.guard_eq_some_iff" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(101, 42)" end="(101, 43)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(101, 44)" end="(101, 48)">
                                                <OtherNode start="(101, 44)" end="(101, 48)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(101, 44)" end="(101, 46)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(101, 47)" end="(101, 48)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(101, 47)" end="(101, 48)">
                                                      <IdentNode start="(101, 47)" end="(101, 48)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(102, 7)" end="(102, 27)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;b✝ : α&#10;h : x = b✝ ∧ p x = true&#10;⊢ some b✝ =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="case cons.h_1.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : p x = true&#10;⊢ some x =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" tactic="obtain ⟨rfl, h⟩ := h">
                                              <AtomNode start="(102, 7)" end="(102, 13)" leading="" trailing=" " val="obtain"/>
                                              <NullNode start="(102, 14)" end="(102, 22)">
                                                <OtherNode start="(102, 14)" end="(102, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(102, 14)" end="(102, 22)">
                                                    <OtherNode start="(102, 14)" end="(102, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(102, 14)" end="(102, 15)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(102, 15)" end="(102, 21)">
                                                        <OtherNode start="(102, 15)" end="(102, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(102, 15)" end="(102, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(102, 15)" end="(102, 18)">
                                                            <OtherNode start="(102, 15)" end="(102, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(102, 15)" end="(102, 18)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(102, 18)" end="(102, 19)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(102, 20)" end="(102, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(102, 20)" end="(102, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(102, 20)" end="(102, 21)">
                                                            <OtherNode start="(102, 20)" end="(102, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(102, 20)" end="(102, 21)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(102, 21)" end="(102, 22)" leading="" trailing=" " val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(102, 23)" end="(102, 27)">
                                                <AtomNode start="(102, 23)" end="(102, 25)" leading="" trailing=" " val=":="/>
                                                <NullNode start="(102, 26)" end="(102, 27)">
                                                  <IdentNode start="(102, 26)" end="(102, 27)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                </NullNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(103, 7)" end="(103, 15)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : p x = true&#10;⊢ some x =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="no goals" tactic="simp [h]">
                                              <AtomNode start="(103, 7)" end="(103, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(103, 12)" end="(103, 15)">
                                                <AtomNode start="(103, 12)" end="(103, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(103, 13)" end="(103, 14)">
                                                  <OtherNode start="(103, 13)" end="(103, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(103, 13)" end="(103, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(103, 14)" end="(103, 15)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(104, 5)" end="(105, 19)" kind="Lean.cdot" state_before="case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : Option.guard (fun x =&amp;gt; p x) x = none&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="no goals" tactic="· simp only [Option.guard_eq_none_iff] at h&#10;  simp [ih, h]">
                                      <OtherNode start="(104, 5)" end="(104, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(104, 5)" end="(104, 6)" kind="patternIgnore">
                                          <OtherNode start="(104, 5)" end="(104, 6)" kind="token.«· »">
                                            <AtomNode start="(104, 5)" end="(104, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(104, 7)" end="(105, 19)">
                                        <TacticTacticseq1IndentedNode start="(104, 7)" end="(105, 19)">
                                          <NullNode start="(104, 7)" end="(105, 19)">
                                            <OtherNode start="(104, 7)" end="(104, 48)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : Option.guard (fun x =&amp;gt; p x) x = none&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : p x = false&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" tactic="simp only [Option.guard_eq_none_iff] at h">
                                              <AtomNode start="(104, 7)" end="(104, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(104, 12)" end="(104, 16)">
                                                <AtomNode start="(104, 12)" end="(104, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(104, 17)" end="(104, 43)">
                                                <AtomNode start="(104, 17)" end="(104, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(104, 18)" end="(104, 42)">
                                                  <OtherNode start="(104, 18)" end="(104, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(104, 18)" end="(104, 42)" leading="" trailing="" raw_val="Option.guard_eq_none_iff" val="Option.guard_eq_none_iff" full_name="Option.guard_eq_none_iff" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(104, 42)" end="(104, 43)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(104, 44)" end="(104, 48)">
                                                <OtherNode start="(104, 44)" end="(104, 48)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(104, 44)" end="(104, 46)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(104, 47)" end="(104, 48)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(104, 47)" end="(104, 48)">
                                                      <IdentNode start="(104, 47)" end="(104, 48)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(105, 7)" end="(105, 19)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs&#10;x✝ : Option α&#10;h : p x = false&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs =&#10;    match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? p xs" state_after="no goals" tactic="simp [ih, h]">
                                              <AtomNode start="(105, 7)" end="(105, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(105, 12)" end="(105, 19)">
                                                <AtomNode start="(105, 12)" end="(105, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(105, 13)" end="(105, 18)">
                                                  <OtherNode start="(105, 13)" end="(105, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(105, 13)" end="(105, 15)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(105, 15)" end="(105, 16)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(105, 17)" end="(105, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(105, 17)" end="(105, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(105, 18)" end="(105, 19)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(107, 1)" end="(108, 23)" name="find?_eq_findSome?_guard" full_name="List.find?_eq_findSome?_guard">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(107, 1)" end="(108, 23)" name="find?_eq_findSome?_guard" full_name="List.find?_eq_findSome?_guard" _is_private_decl="False">
        <AtomNode start="(107, 1)" end="(107, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(107, 9)" end="(107, 33)">
          <IdentNode start="(107, 9)" end="(107, 33)" leading="" trailing=" " raw_val="find?_eq_findSome?_guard" val="find?_eq_findSome?_guard"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(107, 34)" end="(107, 100)">
          <NullNode start="(107, 34)" end="(107, 46)">
            <OtherNode start="(107, 34)" end="(107, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(107, 34)" end="(107, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(107, 35)" end="(107, 36)">
                <IdentNode start="(107, 35)" end="(107, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(107, 37)" end="(107, 45)">
                <AtomNode start="(107, 37)" end="(107, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(107, 39)" end="(107, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(107, 39)" end="(107, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(107, 44)" end="(107, 45)">
                    <IdentNode start="(107, 44)" end="(107, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(107, 45)" end="(107, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(107, 47)" end="(107, 100)">
            <AtomNode start="(107, 47)" end="(107, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(107, 49)" end="(107, 100)" kind="«term_=_»">
              <OtherNode start="(107, 49)" end="(107, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(107, 49)" end="(107, 54)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(107, 55)" end="(107, 58)">
                  <IdentNode start="(107, 55)" end="(107, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(107, 57)" end="(107, 58)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(107, 59)" end="(107, 60)" leading="" trailing=" " val="="/>
              <OtherNode start="(107, 61)" end="(107, 100)" kind="Lean.Parser.Term.app">
                <IdentNode start="(107, 61)" end="(107, 70)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(107, 71)" end="(107, 100)">
                  <OtherNode start="(107, 71)" end="(107, 98)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(107, 71)" end="(107, 72)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 72)" end="(107, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(107, 72)" end="(107, 84)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(107, 85)" end="(107, 97)">
                        <OtherNode start="(107, 85)" end="(107, 97)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(107, 85)" end="(107, 88)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(107, 89)" end="(107, 97)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(107, 89)" end="(107, 90)">
                              <IdentNode start="(107, 89)" end="(107, 90)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(107, 91)" end="(107, 93)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(107, 94)" end="(107, 97)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(107, 94)" end="(107, 95)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(107, 96)" end="(107, 97)">
                                <IdentNode start="(107, 96)" end="(107, 97)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(107, 97)" end="(107, 98)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(107, 99)" end="(107, 100)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(107, 101)" end="(108, 23)">
          <AtomNode start="(107, 101)" end="(107, 103)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(108, 3)" end="(108, 23)" leading="" trailing="&#10;&#10;" raw_val="findSome?_guard.symm" val="findSome?_guard.symm"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(110, 1)" end="(115, 23)" name="head?_filterMap" full_name="List.head?_filterMap">
      <CommandDeclmodifiersNode start="(110, 1)" end="(110, 8)">
        <NullNode/>
        <NullNode start="(110, 1)" end="(110, 8)">
          <OtherNode start="(110, 1)" end="(110, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(110, 1)" end="(110, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(110, 3)" end="(110, 7)">
              <OtherNode start="(110, 3)" end="(110, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(110, 3)" end="(110, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(110, 3)" end="(110, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(110, 7)" end="(110, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(110, 9)" end="(115, 23)" name="head?_filterMap" full_name="List.head?_filterMap" _is_private_decl="False">
        <AtomNode start="(110, 9)" end="(110, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(110, 17)" end="(110, 32)">
          <IdentNode start="(110, 17)" end="(110, 32)" leading="" trailing=" " raw_val="head?_filterMap" val="head?_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(110, 33)" end="(110, 104)">
          <NullNode start="(110, 33)" end="(110, 64)">
            <OtherNode start="(110, 33)" end="(110, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(110, 33)" end="(110, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(110, 34)" end="(110, 35)">
                <IdentNode start="(110, 34)" end="(110, 35)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(110, 36)" end="(110, 50)">
                <AtomNode start="(110, 36)" end="(110, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(110, 38)" end="(110, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(110, 38)" end="(110, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(110, 40)" end="(110, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(110, 42)" end="(110, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(110, 42)" end="(110, 48)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(110, 49)" end="(110, 50)">
                      <IdentNode start="(110, 49)" end="(110, 50)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(110, 50)" end="(110, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(110, 52)" end="(110, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(110, 52)" end="(110, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(110, 53)" end="(110, 54)">
                <IdentNode start="(110, 53)" end="(110, 54)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(110, 55)" end="(110, 63)">
                <AtomNode start="(110, 55)" end="(110, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(110, 57)" end="(110, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(110, 57)" end="(110, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(110, 62)" end="(110, 63)">
                    <IdentNode start="(110, 62)" end="(110, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(110, 63)" end="(110, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(110, 65)" end="(110, 104)">
            <AtomNode start="(110, 65)" end="(110, 66)" leading="" trailing=" " val=":"/>
            <OtherNode start="(110, 67)" end="(110, 104)" kind="«term_=_»">
              <OtherNode start="(110, 67)" end="(110, 88)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(110, 67)" end="(110, 82)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(110, 67)" end="(110, 68)" leading="" trailing="" val="("/>
                  <OtherNode start="(110, 68)" end="(110, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(110, 68)" end="(110, 79)" leading="" trailing=" " raw_val="l.filterMap" val="l.filterMap"/>
                    <NullNode start="(110, 80)" end="(110, 81)">
                      <IdentNode start="(110, 80)" end="(110, 81)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(110, 81)" end="(110, 82)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(110, 82)" end="(110, 83)" leading="" trailing="" val="."/>
                <IdentNode start="(110, 83)" end="(110, 88)" leading="" trailing=" " raw_val="head?" val="head?" full_name="List.head?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(110, 89)" end="(110, 90)" leading="" trailing=" " val="="/>
              <OtherNode start="(110, 91)" end="(110, 104)" kind="Lean.Parser.Term.app">
                <IdentNode start="(110, 91)" end="(110, 102)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                <NullNode start="(110, 103)" end="(110, 104)">
                  <IdentNode start="(110, 103)" end="(110, 104)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(110, 105)" end="(115, 23)">
          <AtomNode start="(110, 105)" end="(110, 107)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(110, 108)" end="(115, 23)">
            <AtomNode start="(110, 108)" end="(110, 110)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(111, 3)" end="(115, 23)">
              <TacticTacticseq1IndentedNode start="(111, 3)" end="(115, 23)">
                <NullNode start="(111, 3)" end="(115, 23)">
                  <OtherNode start="(111, 3)" end="(115, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;⊢ (filterMap f l).head? = findSome? f l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [filterMap_cons, findSome?_cons]&#10;  split &amp;lt;;&amp;gt; simp [*]">
                    <AtomNode start="(111, 3)" end="(111, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(111, 13)" end="(111, 14)">
                      <OtherNode start="(111, 13)" end="(111, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(111, 13)" end="(111, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(111, 15)" end="(115, 23)">
                      <OtherNode start="(111, 15)" end="(115, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(111, 15)" end="(111, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(112, 3)" end="(115, 23)">
                          <OtherNode start="(112, 3)" end="(112, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(112, 3)" end="(112, 8)">
                              <OtherNode start="(112, 3)" end="(112, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(112, 3)" end="(112, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(112, 5)" end="(112, 8)">
                                  <NullNode/>
                                  <IdentNode start="(112, 5)" end="(112, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(112, 9)" end="(112, 16)">
                              <AtomNode start="(112, 9)" end="(112, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(112, 12)" end="(112, 16)">
                                <TacticTacticseq1IndentedNode start="(112, 12)" end="(112, 16)">
                                  <NullNode start="(112, 12)" end="(112, 16)">
                                    <OtherNode start="(112, 12)" end="(112, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;⊢ (filterMap f []).head? = findSome? f []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(112, 12)" end="(112, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(113, 3)" end="(115, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(113, 3)" end="(113, 17)">
                              <OtherNode start="(113, 3)" end="(113, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(113, 3)" end="(113, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(113, 5)" end="(113, 9)">
                                  <NullNode/>
                                  <IdentNode start="(113, 5)" end="(113, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(113, 10)" end="(113, 17)">
                                  <IdentNode start="(113, 10)" end="(113, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(113, 12)" end="(113, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(113, 15)" end="(113, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(113, 18)" end="(115, 23)">
                              <AtomNode start="(113, 18)" end="(113, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(114, 5)" end="(115, 23)">
                                <TacticTacticseq1IndentedNode start="(114, 5)" end="(115, 23)">
                                  <NullNode start="(114, 5)" end="(115, 23)">
                                    <OtherNode start="(114, 5)" end="(114, 47)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).head? = findSome? f xs&#10;⊢ (filterMap f (x :: xs)).head? = findSome? f (x :: xs)" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).head? = findSome? f xs&#10;⊢ (match f x with&#10;      | none =&amp;gt; filterMap f xs&#10;      | some b =&amp;gt; b :: filterMap f xs).head? =&#10;    match f x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f xs" tactic="simp only [filterMap_cons, findSome?_cons]">
                                      <AtomNode start="(114, 5)" end="(114, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(114, 10)" end="(114, 14)">
                                        <AtomNode start="(114, 10)" end="(114, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(114, 15)" end="(114, 47)">
                                        <AtomNode start="(114, 15)" end="(114, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(114, 16)" end="(114, 46)">
                                          <OtherNode start="(114, 16)" end="(114, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(114, 16)" end="(114, 30)" leading="" trailing="" raw_val="filterMap_cons" val="filterMap_cons" full_name="List.filterMap_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(114, 30)" end="(114, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(114, 32)" end="(114, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(114, 32)" end="(114, 46)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(114, 46)" end="(114, 47)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(115, 5)" end="(115, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;x : α&#10;xs : List α&#10;ih : (filterMap f xs).head? = findSome? f xs&#10;⊢ (match f x with&#10;      | none =&amp;gt; filterMap f xs&#10;      | some b =&amp;gt; b :: filterMap f xs).head? =&#10;    match f x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                                      <OtherNode start="(115, 5)" end="(115, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(115, 5)" end="(115, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(115, 11)" end="(115, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(115, 15)" end="(115, 23)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(115, 15)" end="(115, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(115, 20)" end="(115, 23)">
                                          <AtomNode start="(115, 20)" end="(115, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(115, 21)" end="(115, 22)">
                                            <OtherNode start="(115, 21)" end="(115, 22)" kind="Lean.Parser.Tactic.simpStar">
                                              <AtomNode start="(115, 21)" end="(115, 22)" leading="" trailing="" val="*"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(115, 22)" end="(115, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(117, 1)" end="(119, 35)" name="head_filterMap" full_name="List.head_filterMap">
      <CommandDeclmodifiersNode start="(117, 1)" end="(117, 8)">
        <NullNode/>
        <NullNode start="(117, 1)" end="(117, 8)">
          <OtherNode start="(117, 1)" end="(117, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(117, 1)" end="(117, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(117, 3)" end="(117, 7)">
              <OtherNode start="(117, 3)" end="(117, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(117, 3)" end="(117, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(117, 3)" end="(117, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(117, 7)" end="(117, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(117, 9)" end="(119, 35)" name="head_filterMap" full_name="List.head_filterMap" _is_private_decl="False">
        <AtomNode start="(117, 9)" end="(117, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(117, 17)" end="(117, 31)">
          <IdentNode start="(117, 17)" end="(117, 31)" leading="" trailing=" " raw_val="head_filterMap" val="head_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(117, 32)" end="(118, 91)">
          <NullNode start="(117, 32)" end="(117, 67)">
            <OtherNode start="(117, 32)" end="(117, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(117, 32)" end="(117, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(117, 33)" end="(117, 34)">
                <IdentNode start="(117, 33)" end="(117, 34)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(117, 35)" end="(117, 49)">
                <AtomNode start="(117, 35)" end="(117, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(117, 37)" end="(117, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(117, 37)" end="(117, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(117, 39)" end="(117, 40)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(117, 41)" end="(117, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(117, 41)" end="(117, 47)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(117, 48)" end="(117, 49)">
                      <IdentNode start="(117, 48)" end="(117, 49)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(117, 49)" end="(117, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(117, 51)" end="(117, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(117, 51)" end="(117, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(117, 52)" end="(117, 53)">
                <IdentNode start="(117, 52)" end="(117, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(117, 54)" end="(117, 62)">
                <AtomNode start="(117, 54)" end="(117, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(117, 56)" end="(117, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(117, 56)" end="(117, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(117, 61)" end="(117, 62)">
                    <IdentNode start="(117, 61)" end="(117, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(117, 62)" end="(117, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(117, 64)" end="(117, 67)">
              <AtomNode start="(117, 64)" end="(117, 65)" leading="" trailing="" val="("/>
              <NullNode start="(117, 65)" end="(117, 66)">
                <IdentNode start="(117, 65)" end="(117, 66)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(117, 66)" end="(117, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(117, 68)" end="(118, 91)">
            <AtomNode start="(117, 68)" end="(117, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(118, 5)" end="(118, 91)" kind="«term_=_»">
              <OtherNode start="(118, 5)" end="(118, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(118, 5)" end="(118, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(118, 5)" end="(118, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(118, 5)" end="(118, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(118, 6)" end="(118, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(118, 6)" end="(118, 17)" leading="" trailing=" " raw_val="l.filterMap" val="l.filterMap"/>
                      <NullNode start="(118, 18)" end="(118, 19)">
                        <IdentNode start="(118, 18)" end="(118, 19)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(118, 19)" end="(118, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(118, 20)" end="(118, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(118, 21)" end="(118, 25)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(118, 26)" end="(118, 27)">
                  <IdentNode start="(118, 26)" end="(118, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(118, 28)" end="(118, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(118, 30)" end="(118, 91)" kind="Lean.Parser.Term.app">
                <OtherNode start="(118, 30)" end="(118, 49)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(118, 30)" end="(118, 45)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(118, 30)" end="(118, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(118, 31)" end="(118, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(118, 31)" end="(118, 42)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                      <NullNode start="(118, 43)" end="(118, 44)">
                        <IdentNode start="(118, 43)" end="(118, 44)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(118, 44)" end="(118, 45)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(118, 45)" end="(118, 46)" leading="" trailing="" val="."/>
                  <IdentNode start="(118, 46)" end="(118, 49)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(118, 50)" end="(118, 91)">
                  <OtherNode start="(118, 50)" end="(118, 91)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(118, 50)" end="(118, 51)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(118, 51)" end="(118, 90)">
                      <AtomNode start="(118, 51)" end="(118, 53)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(118, 54)" end="(118, 90)">
                        <TacticTacticseq1IndentedNode start="(118, 54)" end="(118, 90)">
                          <NullNode start="(118, 54)" end="(118, 90)">
                            <OtherNode start="(118, 54)" end="(118, 90)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type ?u.22726&#10;β : Type ?u.22723&#10;f : α → Option β&#10;l : List α&#10;h : filterMap f l ≠ []&#10;⊢ (findSome? f l).isSome = true" state_after="no goals" tactic="simp_all [Option.isSome_iff_ne_none]">
                              <AtomNode start="(118, 54)" end="(118, 62)" leading="" trailing=" " val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(118, 63)" end="(118, 90)">
                                <AtomNode start="(118, 63)" end="(118, 64)" leading="" trailing="" val="["/>
                                <NullNode start="(118, 64)" end="(118, 89)">
                                  <OtherNode start="(118, 64)" end="(118, 89)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(118, 64)" end="(118, 89)" leading="" trailing="" raw_val="Option.isSome_iff_ne_none" val="Option.isSome_iff_ne_none" full_name="Option.isSome_iff_ne_none" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(118, 89)" end="(118, 90)" leading="" trailing="" val="]"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(118, 90)" end="(118, 91)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(118, 92)" end="(119, 35)">
          <AtomNode start="(118, 92)" end="(118, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(118, 95)" end="(119, 35)">
            <AtomNode start="(118, 95)" end="(118, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(119, 3)" end="(119, 35)">
              <TacticTacticseq1IndentedNode start="(119, 3)" end="(119, 35)">
                <NullNode start="(119, 3)" end="(119, 35)">
                  <OtherNode start="(119, 3)" end="(119, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;h : filterMap f l ≠ []&#10;⊢ (filterMap f l).head h = (findSome? f l).get ⋯" state_after="no goals" tactic="simp [head_eq_iff_head?_eq_some]">
                    <AtomNode start="(119, 3)" end="(119, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(119, 8)" end="(119, 35)">
                      <AtomNode start="(119, 8)" end="(119, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(119, 9)" end="(119, 34)">
                        <OtherNode start="(119, 9)" end="(119, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(119, 9)" end="(119, 34)" leading="" trailing="" raw_val="head_eq_iff_head?_eq_some" val="head_eq_iff_head?_eq_some" full_name="List.head_eq_iff_head?_eq_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(119, 34)" end="(119, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(121, 1)" end="(123, 29)" name="getLast?_filterMap" full_name="List.getLast?_filterMap">
      <CommandDeclmodifiersNode start="(121, 1)" end="(121, 8)">
        <NullNode/>
        <NullNode start="(121, 1)" end="(121, 8)">
          <OtherNode start="(121, 1)" end="(121, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(121, 1)" end="(121, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(121, 3)" end="(121, 7)">
              <OtherNode start="(121, 3)" end="(121, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(121, 3)" end="(121, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(121, 3)" end="(121, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(121, 7)" end="(121, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(121, 9)" end="(123, 29)" name="getLast?_filterMap" full_name="List.getLast?_filterMap" _is_private_decl="False">
        <AtomNode start="(121, 9)" end="(121, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(121, 17)" end="(121, 35)">
          <IdentNode start="(121, 17)" end="(121, 35)" leading="" trailing=" " raw_val="getLast?_filterMap" val="getLast?_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(121, 36)" end="(121, 118)">
          <NullNode start="(121, 36)" end="(121, 67)">
            <OtherNode start="(121, 36)" end="(121, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 36)" end="(121, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 37)" end="(121, 38)">
                <IdentNode start="(121, 37)" end="(121, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(121, 39)" end="(121, 53)">
                <AtomNode start="(121, 39)" end="(121, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 41)" end="(121, 53)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(121, 41)" end="(121, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(121, 43)" end="(121, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(121, 45)" end="(121, 53)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(121, 45)" end="(121, 51)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(121, 52)" end="(121, 53)">
                      <IdentNode start="(121, 52)" end="(121, 53)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 53)" end="(121, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(121, 55)" end="(121, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(121, 55)" end="(121, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(121, 56)" end="(121, 57)">
                <IdentNode start="(121, 56)" end="(121, 57)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(121, 58)" end="(121, 66)">
                <AtomNode start="(121, 58)" end="(121, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(121, 60)" end="(121, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(121, 60)" end="(121, 64)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(121, 65)" end="(121, 66)">
                    <IdentNode start="(121, 65)" end="(121, 66)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(121, 66)" end="(121, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(121, 68)" end="(121, 118)">
            <AtomNode start="(121, 68)" end="(121, 69)" leading="" trailing=" " val=":"/>
            <OtherNode start="(121, 70)" end="(121, 118)" kind="«term_=_»">
              <OtherNode start="(121, 70)" end="(121, 94)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(121, 70)" end="(121, 85)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(121, 70)" end="(121, 71)" leading="" trailing="" val="("/>
                  <OtherNode start="(121, 71)" end="(121, 84)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(121, 71)" end="(121, 82)" leading="" trailing=" " raw_val="l.filterMap" val="l.filterMap"/>
                    <NullNode start="(121, 83)" end="(121, 84)">
                      <IdentNode start="(121, 83)" end="(121, 84)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(121, 84)" end="(121, 85)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(121, 85)" end="(121, 86)" leading="" trailing="" val="."/>
                <IdentNode start="(121, 86)" end="(121, 94)" leading="" trailing=" " raw_val="getLast?" val="getLast?" full_name="List.getLast?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(121, 95)" end="(121, 96)" leading="" trailing=" " val="="/>
              <OtherNode start="(121, 97)" end="(121, 118)" kind="Lean.Parser.Term.app">
                <IdentNode start="(121, 97)" end="(121, 116)" leading="" trailing=" " raw_val="l.reverse.findSome?" val="l.reverse.findSome?"/>
                <NullNode start="(121, 117)" end="(121, 118)">
                  <IdentNode start="(121, 117)" end="(121, 118)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(121, 119)" end="(123, 29)">
          <AtomNode start="(121, 119)" end="(121, 121)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(121, 122)" end="(123, 29)">
            <AtomNode start="(121, 122)" end="(121, 124)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(122, 3)" end="(123, 29)">
              <TacticTacticseq1IndentedNode start="(122, 3)" end="(123, 29)">
                <NullNode start="(122, 3)" end="(123, 29)">
                  <OtherNode start="(122, 3)" end="(122, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;⊢ (filterMap f l).getLast? = findSome? f l.reverse" state_after="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;⊢ (filterMap f l).reverse.head? = findSome? f l.reverse" tactic="rw [getLast?_eq_head?_reverse]">
                    <AtomNode start="(122, 3)" end="(122, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(122, 6)" end="(122, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(122, 6)" end="(122, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(122, 7)" end="(122, 32)">
                        <OtherNode start="(122, 7)" end="(122, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(122, 7)" end="(122, 32)" leading="" trailing="" raw_val="getLast?_eq_head?_reverse" val="getLast?_eq_head?_reverse" full_name="List.getLast?_eq_head?_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(122, 32)" end="(122, 33)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(123, 3)" end="(123, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;⊢ (filterMap f l).reverse.head? = findSome? f l.reverse" state_after="no goals" tactic="simp [← filterMap_reverse]">
                    <AtomNode start="(123, 3)" end="(123, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(123, 8)" end="(123, 29)">
                      <AtomNode start="(123, 8)" end="(123, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(123, 9)" end="(123, 28)">
                        <OtherNode start="(123, 9)" end="(123, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(123, 9)" end="(123, 10)">
                            <OtherNode start="(123, 9)" end="(123, 10)" kind="patternIgnore">
                              <OtherNode start="(123, 9)" end="(123, 10)" kind="token.«← »">
                                <AtomNode start="(123, 9)" end="(123, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(123, 11)" end="(123, 28)" leading="" trailing="" raw_val="filterMap_reverse" val="filterMap_reverse" full_name="List.filterMap_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(123, 28)" end="(123, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(125, 1)" end="(127, 41)" name="getLast_filterMap" full_name="List.getLast_filterMap">
      <CommandDeclmodifiersNode start="(125, 1)" end="(125, 8)">
        <NullNode/>
        <NullNode start="(125, 1)" end="(125, 8)">
          <OtherNode start="(125, 1)" end="(125, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(125, 1)" end="(125, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(125, 3)" end="(125, 7)">
              <OtherNode start="(125, 3)" end="(125, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(125, 3)" end="(125, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(125, 3)" end="(125, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(125, 7)" end="(125, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(125, 9)" end="(127, 41)" name="getLast_filterMap" full_name="List.getLast_filterMap" _is_private_decl="False">
        <AtomNode start="(125, 9)" end="(125, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(125, 17)" end="(125, 34)">
          <IdentNode start="(125, 17)" end="(125, 34)" leading="" trailing=" " raw_val="getLast_filterMap" val="getLast_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(125, 35)" end="(126, 102)">
          <NullNode start="(125, 35)" end="(125, 70)">
            <OtherNode start="(125, 35)" end="(125, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 35)" end="(125, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 36)" end="(125, 37)">
                <IdentNode start="(125, 36)" end="(125, 37)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(125, 38)" end="(125, 52)">
                <AtomNode start="(125, 38)" end="(125, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(125, 40)" end="(125, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(125, 40)" end="(125, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(125, 42)" end="(125, 43)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(125, 44)" end="(125, 52)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(125, 44)" end="(125, 50)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(125, 51)" end="(125, 52)">
                      <IdentNode start="(125, 51)" end="(125, 52)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(125, 52)" end="(125, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(125, 54)" end="(125, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(125, 54)" end="(125, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(125, 55)" end="(125, 56)">
                <IdentNode start="(125, 55)" end="(125, 56)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(125, 57)" end="(125, 65)">
                <AtomNode start="(125, 57)" end="(125, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(125, 59)" end="(125, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(125, 59)" end="(125, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(125, 64)" end="(125, 65)">
                    <IdentNode start="(125, 64)" end="(125, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(125, 65)" end="(125, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(125, 67)" end="(125, 70)">
              <AtomNode start="(125, 67)" end="(125, 68)" leading="" trailing="" val="("/>
              <NullNode start="(125, 68)" end="(125, 69)">
                <IdentNode start="(125, 68)" end="(125, 69)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(125, 69)" end="(125, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(125, 71)" end="(126, 102)">
            <AtomNode start="(125, 71)" end="(125, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(126, 5)" end="(126, 102)" kind="«term_=_»">
              <OtherNode start="(126, 5)" end="(126, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(126, 5)" end="(126, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(126, 5)" end="(126, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(126, 5)" end="(126, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(126, 6)" end="(126, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(126, 6)" end="(126, 17)" leading="" trailing=" " raw_val="l.filterMap" val="l.filterMap"/>
                      <NullNode start="(126, 18)" end="(126, 19)">
                        <IdentNode start="(126, 18)" end="(126, 19)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(126, 19)" end="(126, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(126, 20)" end="(126, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(126, 21)" end="(126, 28)" leading="" trailing=" " raw_val="getLast" val="getLast" full_name="List.getLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(126, 29)" end="(126, 30)">
                  <IdentNode start="(126, 29)" end="(126, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(126, 31)" end="(126, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(126, 33)" end="(126, 102)" kind="Lean.Parser.Term.app">
                <OtherNode start="(126, 33)" end="(126, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(126, 33)" end="(126, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(126, 33)" end="(126, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(126, 34)" end="(126, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(126, 34)" end="(126, 53)" leading="" trailing=" " raw_val="l.reverse.findSome?" val="l.reverse.findSome?"/>
                      <NullNode start="(126, 54)" end="(126, 55)">
                        <IdentNode start="(126, 54)" end="(126, 55)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(126, 55)" end="(126, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(126, 56)" end="(126, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(126, 57)" end="(126, 60)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(126, 61)" end="(126, 102)">
                  <OtherNode start="(126, 61)" end="(126, 102)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(126, 61)" end="(126, 62)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(126, 62)" end="(126, 101)">
                      <AtomNode start="(126, 62)" end="(126, 64)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(126, 65)" end="(126, 101)">
                        <TacticTacticseq1IndentedNode start="(126, 65)" end="(126, 101)">
                          <NullNode start="(126, 65)" end="(126, 101)">
                            <OtherNode start="(126, 65)" end="(126, 101)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type ?u.24511&#10;β : Type ?u.24508&#10;f : α → Option β&#10;l : List α&#10;h : filterMap f l ≠ []&#10;⊢ (findSome? f l.reverse).isSome = true" state_after="no goals" tactic="simp_all [Option.isSome_iff_ne_none]">
                              <AtomNode start="(126, 65)" end="(126, 73)" leading="" trailing=" " val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(126, 74)" end="(126, 101)">
                                <AtomNode start="(126, 74)" end="(126, 75)" leading="" trailing="" val="["/>
                                <NullNode start="(126, 75)" end="(126, 100)">
                                  <OtherNode start="(126, 75)" end="(126, 100)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(126, 75)" end="(126, 100)" leading="" trailing="" raw_val="Option.isSome_iff_ne_none" val="Option.isSome_iff_ne_none" full_name="Option.isSome_iff_ne_none" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(126, 100)" end="(126, 101)" leading="" trailing="" val="]"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(126, 101)" end="(126, 102)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(126, 103)" end="(127, 41)">
          <AtomNode start="(126, 103)" end="(126, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(126, 106)" end="(127, 41)">
            <AtomNode start="(126, 106)" end="(126, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(127, 3)" end="(127, 41)">
              <TacticTacticseq1IndentedNode start="(127, 3)" end="(127, 41)">
                <NullNode start="(127, 3)" end="(127, 41)">
                  <OtherNode start="(127, 3)" end="(127, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;l : List α&#10;h : filterMap f l ≠ []&#10;⊢ (filterMap f l).getLast h = (findSome? f l.reverse).get ⋯" state_after="no goals" tactic="simp [getLast_eq_iff_getLast?_eq_some]">
                    <AtomNode start="(127, 3)" end="(127, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(127, 8)" end="(127, 41)">
                      <AtomNode start="(127, 8)" end="(127, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(127, 9)" end="(127, 40)">
                        <OtherNode start="(127, 9)" end="(127, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(127, 9)" end="(127, 40)" leading="" trailing="" raw_val="getLast_eq_iff_getLast?_eq_some" val="getLast_eq_iff_getLast?_eq_some" full_name="List.getLast_eq_iff_getLast?_eq_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(127, 40)" end="(127, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(129, 1)" end="(131, 60)" name="map_findSome?" full_name="List.map_findSome?">
      <CommandDeclmodifiersNode start="(129, 1)" end="(129, 8)">
        <NullNode/>
        <NullNode start="(129, 1)" end="(129, 8)">
          <OtherNode start="(129, 1)" end="(129, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(129, 1)" end="(129, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(129, 3)" end="(129, 7)">
              <OtherNode start="(129, 3)" end="(129, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(129, 3)" end="(129, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(129, 3)" end="(129, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(129, 7)" end="(129, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(129, 9)" end="(131, 60)" name="map_findSome?" full_name="List.map_findSome?" _is_private_decl="False">
        <AtomNode start="(129, 9)" end="(129, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(129, 17)" end="(129, 30)">
          <IdentNode start="(129, 17)" end="(129, 30)" leading="" trailing=" " raw_val="map_findSome?" val="map_findSome?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(129, 31)" end="(130, 59)">
          <NullNode start="(129, 31)" end="(129, 74)">
            <OtherNode start="(129, 31)" end="(129, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(129, 31)" end="(129, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(129, 32)" end="(129, 33)">
                <IdentNode start="(129, 32)" end="(129, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(129, 34)" end="(129, 48)">
                <AtomNode start="(129, 34)" end="(129, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 36)" end="(129, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(129, 36)" end="(129, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(129, 38)" end="(129, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(129, 40)" end="(129, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(129, 40)" end="(129, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(129, 47)" end="(129, 48)">
                      <IdentNode start="(129, 47)" end="(129, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(129, 48)" end="(129, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(129, 50)" end="(129, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(129, 50)" end="(129, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(129, 51)" end="(129, 52)">
                <IdentNode start="(129, 51)" end="(129, 52)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(129, 53)" end="(129, 60)">
                <AtomNode start="(129, 53)" end="(129, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 55)" end="(129, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(129, 55)" end="(129, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(129, 57)" end="(129, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(129, 59)" end="(129, 60)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(129, 60)" end="(129, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(129, 62)" end="(129, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(129, 62)" end="(129, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(129, 63)" end="(129, 64)">
                <IdentNode start="(129, 63)" end="(129, 64)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(129, 65)" end="(129, 73)">
                <AtomNode start="(129, 65)" end="(129, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 67)" end="(129, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 67)" end="(129, 71)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(129, 72)" end="(129, 73)">
                    <IdentNode start="(129, 72)" end="(129, 73)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(129, 73)" end="(129, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(129, 75)" end="(130, 59)">
            <AtomNode start="(129, 75)" end="(129, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(130, 5)" end="(130, 59)" kind="«term_=_»">
              <OtherNode start="(130, 5)" end="(130, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(130, 5)" end="(130, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(130, 5)" end="(130, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(130, 5)" end="(130, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(130, 6)" end="(130, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(130, 6)" end="(130, 17)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                      <NullNode start="(130, 18)" end="(130, 19)">
                        <IdentNode start="(130, 18)" end="(130, 19)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(130, 19)" end="(130, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(130, 20)" end="(130, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(130, 21)" end="(130, 24)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(130, 25)" end="(130, 26)">
                  <IdentNode start="(130, 25)" end="(130, 26)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(130, 27)" end="(130, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(130, 29)" end="(130, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(130, 29)" end="(130, 40)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                <NullNode start="(130, 41)" end="(130, 59)">
                  <OtherNode start="(130, 41)" end="(130, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(130, 41)" end="(130, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(130, 42)" end="(130, 58)" kind="«term_∘_»">
                      <OtherNode start="(130, 42)" end="(130, 54)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(130, 42)" end="(130, 52)" leading="" trailing=" " raw_val="Option.map" val="Option.map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(130, 53)" end="(130, 54)">
                          <IdentNode start="(130, 53)" end="(130, 54)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(130, 55)" end="(130, 56)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(130, 57)" end="(130, 58)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(130, 58)" end="(130, 59)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(130, 60)" end="(131, 60)">
          <AtomNode start="(130, 60)" end="(130, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(130, 63)" end="(131, 60)">
            <AtomNode start="(130, 63)" end="(130, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(131, 3)" end="(131, 60)">
              <TacticTacticseq1IndentedNode start="(131, 3)" end="(131, 60)">
                <NullNode start="(131, 3)" end="(131, 60)">
                  <OtherNode start="(131, 3)" end="(131, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → Option β&#10;g : β → γ&#10;l : List α&#10;⊢ Option.map g (findSome? f l) = findSome? (Option.map g ∘ f) l" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → Option β&#10;g : β → γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : Option.map g (findSome? f tail✝) = findSome? (Option.map g ∘ f) tail✝&#10;⊢ Option.map g&#10;      (match f head✝ with&#10;      | some b =&amp;gt; some b&#10;      | none =&amp;gt; findSome? f tail✝) =&#10;    match Option.map g (f head✝) with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (Option.map g ∘ f) tail✝" tactic="induction l &amp;lt;;&amp;gt; simp [findSome?_cons]">
                    <OtherNode start="(131, 3)" end="(131, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(131, 3)" end="(131, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(131, 13)" end="(131, 14)">
                        <OtherNode start="(131, 13)" end="(131, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(131, 13)" end="(131, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(131, 15)" end="(131, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(131, 19)" end="(131, 40)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(131, 19)" end="(131, 23)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(131, 24)" end="(131, 40)">
                        <AtomNode start="(131, 24)" end="(131, 25)" leading="" trailing="" val="["/>
                        <NullNode start="(131, 25)" end="(131, 39)">
                          <OtherNode start="(131, 25)" end="(131, 39)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(131, 25)" end="(131, 39)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(131, 39)" end="(131, 40)" leading="" trailing="" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(131, 40)" end="(131, 41)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(131, 42)" end="(131, 60)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → Option β&#10;g : β → γ&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : Option.map g (findSome? f tail✝) = findSome? (Option.map g ∘ f) tail✝&#10;⊢ Option.map g&#10;      (match f head✝ with&#10;      | some b =&amp;gt; some b&#10;      | none =&amp;gt; findSome? f tail✝) =&#10;    match Option.map g (f head✝) with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (Option.map g ∘ f) tail✝" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(131, 42)" end="(131, 47)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(131, 42)" end="(131, 47)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(131, 48)" end="(131, 51)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(131, 52)" end="(131, 60)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(131, 52)" end="(131, 56)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(131, 57)" end="(131, 60)">
                        <AtomNode start="(131, 57)" end="(131, 58)" leading="" trailing="" val="["/>
                        <NullNode start="(131, 58)" end="(131, 59)">
                          <OtherNode start="(131, 58)" end="(131, 59)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(131, 58)" end="(131, 59)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(131, 59)" end="(131, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(133, 1)" end="(138, 23)" name="findSome?_map" full_name="List.findSome?_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(133, 1)" end="(138, 23)" name="findSome?_map" full_name="List.findSome?_map" _is_private_decl="False">
        <AtomNode start="(133, 1)" end="(133, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(133, 9)" end="(133, 22)">
          <IdentNode start="(133, 9)" end="(133, 22)" leading="" trailing=" " raw_val="findSome?_map" val="findSome?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(133, 23)" end="(133, 93)">
          <NullNode start="(133, 23)" end="(133, 47)">
            <OtherNode start="(133, 23)" end="(133, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(133, 23)" end="(133, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(133, 24)" end="(133, 25)">
                <IdentNode start="(133, 24)" end="(133, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(133, 26)" end="(133, 33)">
                <AtomNode start="(133, 26)" end="(133, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(133, 28)" end="(133, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(133, 28)" end="(133, 29)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(133, 30)" end="(133, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(133, 32)" end="(133, 33)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(133, 33)" end="(133, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(133, 35)" end="(133, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(133, 35)" end="(133, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(133, 36)" end="(133, 37)">
                <IdentNode start="(133, 36)" end="(133, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(133, 38)" end="(133, 46)">
                <AtomNode start="(133, 38)" end="(133, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(133, 40)" end="(133, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(133, 40)" end="(133, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(133, 45)" end="(133, 46)">
                    <IdentNode start="(133, 45)" end="(133, 46)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(133, 46)" end="(133, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(133, 48)" end="(133, 93)">
            <AtomNode start="(133, 48)" end="(133, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(133, 50)" end="(133, 93)" kind="«term_=_»">
              <OtherNode start="(133, 50)" end="(133, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(133, 50)" end="(133, 59)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(133, 60)" end="(133, 71)">
                  <IdentNode start="(133, 60)" end="(133, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(133, 62)" end="(133, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(133, 62)" end="(133, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(133, 63)" end="(133, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(133, 63)" end="(133, 68)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(133, 69)" end="(133, 70)">
                        <IdentNode start="(133, 69)" end="(133, 70)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(133, 70)" end="(133, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(133, 72)" end="(133, 73)" leading="" trailing=" " val="="/>
              <OtherNode start="(133, 74)" end="(133, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(133, 74)" end="(133, 85)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                <NullNode start="(133, 86)" end="(133, 93)">
                  <OtherNode start="(133, 86)" end="(133, 93)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(133, 86)" end="(133, 87)" leading="" trailing="" val="("/>
                    <OtherNode start="(133, 87)" end="(133, 92)" kind="«term_∘_»">
                      <IdentNode start="(133, 87)" end="(133, 88)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(133, 89)" end="(133, 90)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(133, 91)" end="(133, 92)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(133, 92)" end="(133, 93)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(133, 94)" end="(138, 23)">
          <AtomNode start="(133, 94)" end="(133, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(133, 97)" end="(138, 23)">
            <AtomNode start="(133, 97)" end="(133, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(134, 3)" end="(138, 23)">
              <TacticTacticseq1IndentedNode start="(134, 3)" end="(138, 23)">
                <NullNode start="(134, 3)" end="(138, 23)">
                  <OtherNode start="(134, 3)" end="(138, 23)" kind="Lean.Parser.Tactic.induction" state_before="β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;l : List β&#10;⊢ findSome? p (map f l) = findSome? (p ∘ f) l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [map_cons, findSome?]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(134, 3)" end="(134, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(134, 13)" end="(134, 14)">
                      <OtherNode start="(134, 13)" end="(134, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(134, 13)" end="(134, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(134, 15)" end="(138, 23)">
                      <OtherNode start="(134, 15)" end="(138, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(134, 15)" end="(134, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(135, 3)" end="(138, 23)">
                          <OtherNode start="(135, 3)" end="(135, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(135, 3)" end="(135, 8)">
                              <OtherNode start="(135, 3)" end="(135, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(135, 3)" end="(135, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(135, 5)" end="(135, 8)">
                                  <NullNode/>
                                  <IdentNode start="(135, 5)" end="(135, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(135, 9)" end="(135, 16)">
                              <AtomNode start="(135, 9)" end="(135, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(135, 12)" end="(135, 16)">
                                <TacticTacticseq1IndentedNode start="(135, 12)" end="(135, 16)">
                                  <NullNode start="(135, 12)" end="(135, 16)">
                                    <OtherNode start="(135, 12)" end="(135, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;⊢ findSome? p (map f []) = findSome? (p ∘ f) []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(135, 12)" end="(135, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(136, 3)" end="(138, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(136, 3)" end="(136, 17)">
                              <OtherNode start="(136, 3)" end="(136, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(136, 3)" end="(136, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(136, 5)" end="(136, 9)">
                                  <NullNode/>
                                  <IdentNode start="(136, 5)" end="(136, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(136, 10)" end="(136, 17)">
                                  <IdentNode start="(136, 10)" end="(136, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(136, 12)" end="(136, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(136, 15)" end="(136, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(136, 18)" end="(138, 23)">
                              <AtomNode start="(136, 18)" end="(136, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(137, 5)" end="(138, 23)">
                                <TacticTacticseq1IndentedNode start="(137, 5)" end="(138, 23)">
                                  <NullNode start="(137, 5)" end="(138, 23)">
                                    <OtherNode start="(137, 5)" end="(137, 36)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;x : β&#10;xs : List β&#10;ih : findSome? p (map f xs) = findSome? (p ∘ f) xs&#10;⊢ findSome? p (map f (x :: xs)) = findSome? (p ∘ f) (x :: xs)" state_after="case cons&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;x : β&#10;xs : List β&#10;ih : findSome? p (map f xs) = findSome? (p ∘ f) xs&#10;⊢ (match p (f x) with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? p (map f xs)) =&#10;    match (p ∘ f) x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (p ∘ f) xs" tactic="simp only [map_cons, findSome?]">
                                      <AtomNode start="(137, 5)" end="(137, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(137, 10)" end="(137, 14)">
                                        <AtomNode start="(137, 10)" end="(137, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(137, 15)" end="(137, 36)">
                                        <AtomNode start="(137, 15)" end="(137, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(137, 16)" end="(137, 35)">
                                          <OtherNode start="(137, 16)" end="(137, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(137, 16)" end="(137, 24)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(137, 24)" end="(137, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(137, 26)" end="(137, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(137, 26)" end="(137, 35)" leading="" trailing="" raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(137, 35)" end="(137, 36)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(138, 5)" end="(138, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;x : β&#10;xs : List β&#10;ih : findSome? p (map f xs) = findSome? (p ∘ f) xs&#10;⊢ (match p (f x) with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? p (map f xs)) =&#10;    match (p ∘ f) x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (p ∘ f) xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(138, 5)" end="(138, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(138, 5)" end="(138, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(138, 11)" end="(138, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(138, 15)" end="(138, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(138, 15)" end="(138, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(140, 1)" end="(142, 50)" name="head_flatten" full_name="List.head_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(140, 1)" end="(142, 50)" name="head_flatten" full_name="List.head_flatten" _is_private_decl="False">
        <AtomNode start="(140, 1)" end="(140, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(140, 9)" end="(140, 21)">
          <IdentNode start="(140, 9)" end="(140, 21)" leading="" trailing=" " raw_val="head_flatten" val="head_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(140, 22)" end="(141, 96)">
          <NullNode start="(140, 22)" end="(140, 67)">
            <OtherNode start="(140, 22)" end="(140, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(140, 22)" end="(140, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(140, 23)" end="(140, 24)">
                <IdentNode start="(140, 23)" end="(140, 24)" leading="" trailing=" " raw_val="L" val="L"/>
              </NullNode>
              <NullNode start="(140, 25)" end="(140, 40)">
                <AtomNode start="(140, 25)" end="(140, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(140, 27)" end="(140, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(140, 27)" end="(140, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(140, 32)" end="(140, 40)">
                    <OtherNode start="(140, 32)" end="(140, 40)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(140, 32)" end="(140, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(140, 33)" end="(140, 39)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(140, 33)" end="(140, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(140, 38)" end="(140, 39)">
                          <IdentNode start="(140, 38)" end="(140, 39)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(140, 39)" end="(140, 40)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(140, 40)" end="(140, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(140, 42)" end="(140, 67)">
              <AtomNode start="(140, 42)" end="(140, 43)" leading="" trailing="" val="("/>
              <NullNode start="(140, 43)" end="(140, 44)">
                <IdentNode start="(140, 43)" end="(140, 44)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(140, 45)" end="(140, 66)">
                <AtomNode start="(140, 45)" end="(140, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(140, 47)" end="(140, 66)" kind="«term∃_,_»">
                  <AtomNode start="(140, 47)" end="(140, 48)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(140, 49)" end="(140, 50)" kind="Lean.explicitBinders">
                    <OtherNode start="(140, 49)" end="(140, 50)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(140, 49)" end="(140, 50)">
                        <LeanBinderidentNode start="(140, 49)" end="(140, 50)">
                          <IdentNode start="(140, 49)" end="(140, 50)" leading="" trailing="" raw_val="l" val="l"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(140, 50)" end="(140, 51)" leading="" trailing=" " val=","/>
                  <OtherNode start="(140, 52)" end="(140, 66)" kind="«term_∧_»">
                    <OtherNode start="(140, 52)" end="(140, 57)" kind="«term_∈_»">
                      <IdentNode start="(140, 52)" end="(140, 53)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(140, 54)" end="(140, 55)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(140, 56)" end="(140, 57)" leading="" trailing=" " raw_val="L" val="L"/>
                    </OtherNode>
                    <AtomNode start="(140, 58)" end="(140, 59)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(140, 60)" end="(140, 66)" kind="«term_≠_»">
                      <IdentNode start="(140, 60)" end="(140, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(140, 62)" end="(140, 63)" leading="" trailing=" " val="≠"/>
                      <OtherNode start="(140, 64)" end="(140, 66)" kind="«term[_]»">
                        <AtomNode start="(140, 64)" end="(140, 65)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(140, 65)" end="(140, 66)" leading="" trailing="" val="]"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(140, 66)" end="(140, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(140, 68)" end="(141, 96)">
            <AtomNode start="(140, 68)" end="(140, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(141, 5)" end="(141, 96)" kind="«term_=_»">
              <OtherNode start="(141, 5)" end="(141, 40)" kind="Lean.Parser.Term.app">
                <OtherNode start="(141, 5)" end="(141, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(141, 5)" end="(141, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(141, 5)" end="(141, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(141, 6)" end="(141, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(141, 6)" end="(141, 13)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="List.flatten" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(141, 14)" end="(141, 15)">
                        <IdentNode start="(141, 14)" end="(141, 15)" leading="" trailing="" raw_val="L" val="L"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(141, 15)" end="(141, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(141, 16)" end="(141, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(141, 17)" end="(141, 21)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(141, 22)" end="(141, 40)">
                  <OtherNode start="(141, 22)" end="(141, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(141, 22)" end="(141, 23)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(141, 23)" end="(141, 39)">
                      <AtomNode start="(141, 23)" end="(141, 25)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(141, 26)" end="(141, 39)">
                        <TacticTacticseq1IndentedNode start="(141, 26)" end="(141, 39)">
                          <NullNode start="(141, 26)" end="(141, 39)">
                            <OtherNode start="(141, 26)" end="(141, 39)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.29082&#10;L : List (List α)&#10;h : ∃ l, l ∈ L ∧ l ≠ []&#10;⊢ L.flatten ≠ []" state_after="no goals" tactic="simpa using h">
                              <AtomNode start="(141, 26)" end="(141, 31)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(141, 32)" end="(141, 39)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(141, 32)" end="(141, 39)">
                                  <AtomNode start="(141, 32)" end="(141, 37)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(141, 38)" end="(141, 39)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(141, 39)" end="(141, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(141, 41)" end="(141, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(141, 43)" end="(141, 96)" kind="Lean.Parser.Term.app">
                <OtherNode start="(141, 43)" end="(141, 77)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(141, 43)" end="(141, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(141, 43)" end="(141, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(141, 44)" end="(141, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(141, 44)" end="(141, 55)" leading="" trailing=" " raw_val="L.findSome?" val="L.findSome?"/>
                      <NullNode start="(141, 56)" end="(141, 72)">
                        <OtherNode start="(141, 56)" end="(141, 72)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(141, 56)" end="(141, 59)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(141, 60)" end="(141, 72)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(141, 60)" end="(141, 61)">
                              <IdentNode start="(141, 60)" end="(141, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(141, 62)" end="(141, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(141, 65)" end="(141, 72)" leading="" trailing="" raw_val="l.head?" val="l.head?"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(141, 72)" end="(141, 73)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(141, 73)" end="(141, 74)" leading="" trailing="" val="."/>
                  <IdentNode start="(141, 74)" end="(141, 77)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(141, 78)" end="(141, 96)">
                  <OtherNode start="(141, 78)" end="(141, 96)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(141, 78)" end="(141, 79)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(141, 79)" end="(141, 95)">
                      <AtomNode start="(141, 79)" end="(141, 81)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(141, 82)" end="(141, 95)">
                        <TacticTacticseq1IndentedNode start="(141, 82)" end="(141, 95)">
                          <NullNode start="(141, 82)" end="(141, 95)">
                            <OtherNode start="(141, 82)" end="(141, 95)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.29082&#10;L : List (List α)&#10;h : ∃ l, l ∈ L ∧ l ≠ []&#10;⊢ (findSome? (fun l =&amp;gt; l.head?) L).isSome = true" state_after="no goals" tactic="simpa using h">
                              <AtomNode start="(141, 82)" end="(141, 87)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(141, 88)" end="(141, 95)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(141, 88)" end="(141, 95)">
                                  <AtomNode start="(141, 88)" end="(141, 93)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(141, 94)" end="(141, 95)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(141, 95)" end="(141, 96)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(141, 97)" end="(142, 50)">
          <AtomNode start="(141, 97)" end="(141, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(141, 100)" end="(142, 50)">
            <AtomNode start="(141, 100)" end="(141, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(142, 3)" end="(142, 50)">
              <TacticTacticseq1IndentedNode start="(142, 3)" end="(142, 50)">
                <NullNode start="(142, 3)" end="(142, 50)">
                  <OtherNode start="(142, 3)" end="(142, 50)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;L : List (List α)&#10;h : ∃ l, l ∈ L ∧ l ≠ []&#10;⊢ L.flatten.head ⋯ = (findSome? (fun l =&amp;gt; l.head?) L).get ⋯" state_after="no goals" tactic="simp [head_eq_iff_head?_eq_some, head?_flatten]">
                    <AtomNode start="(142, 3)" end="(142, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(142, 8)" end="(142, 50)">
                      <AtomNode start="(142, 8)" end="(142, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(142, 9)" end="(142, 49)">
                        <OtherNode start="(142, 9)" end="(142, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(142, 9)" end="(142, 34)" leading="" trailing="" raw_val="head_eq_iff_head?_eq_some" val="head_eq_iff_head?_eq_some" full_name="List.head_eq_iff_head?_eq_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(142, 34)" end="(142, 35)" leading="" trailing=" " val=","/>
                        <OtherNode start="(142, 36)" end="(142, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(142, 36)" end="(142, 49)" leading="" trailing="" raw_val="head?_flatten" val="head?_flatten" full_name="List.head?_flatten" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(142, 49)" end="(142, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(147, 59)" name="getLast_flatten" full_name="List.getLast_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 1)" end="(147, 59)" name="getLast_flatten" full_name="List.getLast_flatten" _is_private_decl="False">
        <AtomNode start="(144, 1)" end="(144, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 9)" end="(144, 24)">
          <IdentNode start="(144, 9)" end="(144, 24)" leading="" trailing=" " raw_val="getLast_flatten" val="getLast_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 25)" end="(146, 71)">
          <NullNode start="(144, 25)" end="(144, 70)">
            <OtherNode start="(144, 25)" end="(144, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(144, 25)" end="(144, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(144, 26)" end="(144, 27)">
                <IdentNode start="(144, 26)" end="(144, 27)" leading="" trailing=" " raw_val="L" val="L"/>
              </NullNode>
              <NullNode start="(144, 28)" end="(144, 43)">
                <AtomNode start="(144, 28)" end="(144, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 30)" end="(144, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(144, 30)" end="(144, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(144, 35)" end="(144, 43)">
                    <OtherNode start="(144, 35)" end="(144, 43)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(144, 35)" end="(144, 36)" leading="" trailing="" val="("/>
                      <OtherNode start="(144, 36)" end="(144, 42)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(144, 36)" end="(144, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(144, 41)" end="(144, 42)">
                          <IdentNode start="(144, 41)" end="(144, 42)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(144, 42)" end="(144, 43)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(144, 43)" end="(144, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(144, 45)" end="(144, 70)">
              <AtomNode start="(144, 45)" end="(144, 46)" leading="" trailing="" val="("/>
              <NullNode start="(144, 46)" end="(144, 47)">
                <IdentNode start="(144, 46)" end="(144, 47)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(144, 48)" end="(144, 69)">
                <AtomNode start="(144, 48)" end="(144, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 50)" end="(144, 69)" kind="«term∃_,_»">
                  <AtomNode start="(144, 50)" end="(144, 51)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(144, 52)" end="(144, 53)" kind="Lean.explicitBinders">
                    <OtherNode start="(144, 52)" end="(144, 53)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(144, 52)" end="(144, 53)">
                        <LeanBinderidentNode start="(144, 52)" end="(144, 53)">
                          <IdentNode start="(144, 52)" end="(144, 53)" leading="" trailing="" raw_val="l" val="l"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(144, 53)" end="(144, 54)" leading="" trailing=" " val=","/>
                  <OtherNode start="(144, 55)" end="(144, 69)" kind="«term_∧_»">
                    <OtherNode start="(144, 55)" end="(144, 60)" kind="«term_∈_»">
                      <IdentNode start="(144, 55)" end="(144, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(144, 57)" end="(144, 58)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(144, 59)" end="(144, 60)" leading="" trailing=" " raw_val="L" val="L"/>
                    </OtherNode>
                    <AtomNode start="(144, 61)" end="(144, 62)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(144, 63)" end="(144, 69)" kind="«term_≠_»">
                      <IdentNode start="(144, 63)" end="(144, 64)" leading="" trailing=" " raw_val="l" val="l"/>
                      <AtomNode start="(144, 65)" end="(144, 66)" leading="" trailing=" " val="≠"/>
                      <OtherNode start="(144, 67)" end="(144, 69)" kind="«term[_]»">
                        <AtomNode start="(144, 67)" end="(144, 68)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(144, 68)" end="(144, 69)" leading="" trailing="" val="]"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 69)" end="(144, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(144, 71)" end="(146, 71)">
            <AtomNode start="(144, 71)" end="(144, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(146, 71)" kind="«term_=_»">
              <OtherNode start="(145, 5)" end="(145, 43)" kind="Lean.Parser.Term.app">
                <OtherNode start="(145, 5)" end="(145, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(145, 5)" end="(145, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 5)" end="(145, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 6)" end="(145, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(145, 6)" end="(145, 13)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="List.flatten" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(145, 14)" end="(145, 15)">
                        <IdentNode start="(145, 14)" end="(145, 15)" leading="" trailing="" raw_val="L" val="L"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(145, 15)" end="(145, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(145, 16)" end="(145, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(145, 17)" end="(145, 24)" leading="" trailing=" " raw_val="getLast" val="getLast" full_name="List.getLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(145, 25)" end="(145, 43)">
                  <OtherNode start="(145, 25)" end="(145, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 25)" end="(145, 26)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(145, 26)" end="(145, 42)">
                      <AtomNode start="(145, 26)" end="(145, 28)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(145, 29)" end="(145, 42)">
                        <TacticTacticseq1IndentedNode start="(145, 29)" end="(145, 42)">
                          <NullNode start="(145, 29)" end="(145, 42)">
                            <OtherNode start="(145, 29)" end="(145, 42)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.31281&#10;L : List (List α)&#10;h : ∃ l, l ∈ L ∧ l ≠ []&#10;⊢ L.flatten ≠ []" state_after="no goals" tactic="simpa using h">
                              <AtomNode start="(145, 29)" end="(145, 34)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(145, 35)" end="(145, 42)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(145, 35)" end="(145, 42)">
                                  <AtomNode start="(145, 35)" end="(145, 40)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(145, 41)" end="(145, 42)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(145, 42)" end="(145, 43)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 44)" end="(145, 45)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(146, 7)" end="(146, 71)" kind="Lean.Parser.Term.app">
                <OtherNode start="(146, 7)" end="(146, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(146, 7)" end="(146, 48)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(146, 7)" end="(146, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(146, 8)" end="(146, 47)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(146, 8)" end="(146, 27)" leading="" trailing=" " raw_val="L.reverse.findSome?" val="L.reverse.findSome?"/>
                      <NullNode start="(146, 28)" end="(146, 47)">
                        <OtherNode start="(146, 28)" end="(146, 47)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(146, 28)" end="(146, 31)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(146, 32)" end="(146, 47)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(146, 32)" end="(146, 33)">
                              <IdentNode start="(146, 32)" end="(146, 33)" leading="" trailing=" " raw_val="l" val="l"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(146, 34)" end="(146, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(146, 37)" end="(146, 47)" leading="" trailing="" raw_val="l.getLast?" val="l.getLast?"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(146, 47)" end="(146, 48)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(146, 48)" end="(146, 49)" leading="" trailing="" val="."/>
                  <IdentNode start="(146, 49)" end="(146, 52)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(146, 53)" end="(146, 71)">
                  <OtherNode start="(146, 53)" end="(146, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(146, 53)" end="(146, 54)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(146, 54)" end="(146, 70)">
                      <AtomNode start="(146, 54)" end="(146, 56)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(146, 57)" end="(146, 70)">
                        <TacticTacticseq1IndentedNode start="(146, 57)" end="(146, 70)">
                          <NullNode start="(146, 57)" end="(146, 70)">
                            <OtherNode start="(146, 57)" end="(146, 70)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.31281&#10;L : List (List α)&#10;h : ∃ l, l ∈ L ∧ l ≠ []&#10;⊢ (findSome? (fun l =&amp;gt; l.getLast?) L.reverse).isSome = true" state_after="no goals" tactic="simpa using h">
                              <AtomNode start="(146, 57)" end="(146, 62)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(146, 63)" end="(146, 70)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(146, 63)" end="(146, 70)">
                                  <AtomNode start="(146, 63)" end="(146, 68)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(146, 69)" end="(146, 70)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(146, 70)" end="(146, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(146, 72)" end="(147, 59)">
          <AtomNode start="(146, 72)" end="(146, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(146, 75)" end="(147, 59)">
            <AtomNode start="(146, 75)" end="(146, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(147, 3)" end="(147, 59)">
              <TacticTacticseq1IndentedNode start="(147, 3)" end="(147, 59)">
                <NullNode start="(147, 3)" end="(147, 59)">
                  <OtherNode start="(147, 3)" end="(147, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;L : List (List α)&#10;h : ∃ l, l ∈ L ∧ l ≠ []&#10;⊢ L.flatten.getLast ⋯ = (findSome? (fun l =&amp;gt; l.getLast?) L.reverse).get ⋯" state_after="no goals" tactic="simp [getLast_eq_iff_getLast?_eq_some, getLast?_flatten]">
                    <AtomNode start="(147, 3)" end="(147, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(147, 8)" end="(147, 59)">
                      <AtomNode start="(147, 8)" end="(147, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(147, 9)" end="(147, 58)">
                        <OtherNode start="(147, 9)" end="(147, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(147, 9)" end="(147, 40)" leading="" trailing="" raw_val="getLast_eq_iff_getLast?_eq_some" val="getLast_eq_iff_getLast?_eq_some" full_name="List.getLast_eq_iff_getLast?_eq_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(147, 40)" end="(147, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(147, 42)" end="(147, 58)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(147, 42)" end="(147, 58)" leading="" trailing="" raw_val="getLast?_flatten" val="getLast?_flatten" full_name="List.getLast?_flatten" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(147, 58)" end="(147, 59)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(149, 1)" end="(154, 23)" name="findSome?_replicate" full_name="List.findSome?_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(149, 1)" end="(154, 23)" name="findSome?_replicate" full_name="List.findSome?_replicate" _is_private_decl="False">
        <AtomNode start="(149, 1)" end="(149, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(149, 9)" end="(149, 28)">
          <IdentNode start="(149, 9)" end="(149, 28)" leading="" trailing=" " raw_val="findSome?_replicate" val="findSome?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(149, 29)" end="(149, 88)">
          <NullNode/>
          <TermTypespecNode start="(149, 29)" end="(149, 88)">
            <AtomNode start="(149, 29)" end="(149, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(149, 31)" end="(149, 88)" kind="«term_=_»">
              <OtherNode start="(149, 31)" end="(149, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 31)" end="(149, 40)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(149, 41)" end="(149, 58)">
                  <IdentNode start="(149, 41)" end="(149, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(149, 43)" end="(149, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 43)" end="(149, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 44)" end="(149, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(149, 44)" end="(149, 53)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(149, 54)" end="(149, 57)">
                        <IdentNode start="(149, 54)" end="(149, 55)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(149, 56)" end="(149, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(149, 57)" end="(149, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(149, 59)" end="(149, 60)" leading="" trailing=" " val="="/>
              <OtherNode start="(149, 61)" end="(149, 88)" kind="termIfThenElse">
                <AtomNode start="(149, 61)" end="(149, 63)" leading="" trailing=" " val="if"/>
                <OtherNode start="(149, 64)" end="(149, 69)" kind="«term_=_»">
                  <IdentNode start="(149, 64)" end="(149, 65)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(149, 66)" end="(149, 67)" leading="" trailing=" " val="="/>
                  <OtherNode start="(149, 68)" end="(149, 69)" kind="num">
                    <AtomNode start="(149, 68)" end="(149, 69)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(149, 70)" end="(149, 74)" leading="" trailing=" " val="then"/>
                <IdentNode start="(149, 75)" end="(149, 79)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(149, 80)" end="(149, 84)" leading="" trailing=" " val="else"/>
                <OtherNode start="(149, 85)" end="(149, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(149, 85)" end="(149, 86)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(149, 87)" end="(149, 88)">
                    <IdentNode start="(149, 87)" end="(149, 88)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(149, 89)" end="(154, 23)">
          <AtomNode start="(149, 89)" end="(149, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(149, 92)" end="(154, 23)">
            <AtomNode start="(149, 92)" end="(149, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(150, 3)" end="(154, 23)">
              <TacticTacticseq1IndentedNode start="(150, 3)" end="(154, 23)">
                <NullNode start="(150, 3)" end="(154, 23)">
                  <OtherNode start="(150, 3)" end="(154, 23)" kind="Lean.Parser.Tactic.cases" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;⊢ findSome? f (replicate n a) = if n = 0 then none else f a" state_after="no goals" tactic="cases n with&#10;| zero =&amp;gt; simp&#10;| succ n =&amp;gt;&#10;  simp only [replicate_succ, findSome?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(150, 3)" end="(150, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(150, 9)" end="(150, 10)">
                      <OtherNode start="(150, 9)" end="(150, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(150, 9)" end="(150, 10)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(150, 11)" end="(154, 23)">
                      <OtherNode start="(150, 11)" end="(154, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(150, 11)" end="(150, 15)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(151, 3)" end="(154, 23)">
                          <OtherNode start="(151, 3)" end="(151, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(151, 3)" end="(151, 9)">
                              <OtherNode start="(151, 3)" end="(151, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(151, 3)" end="(151, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(151, 5)" end="(151, 9)">
                                  <NullNode/>
                                  <IdentNode start="(151, 5)" end="(151, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(151, 10)" end="(151, 17)">
                              <AtomNode start="(151, 10)" end="(151, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(151, 13)" end="(151, 17)">
                                <TacticTacticseq1IndentedNode start="(151, 13)" end="(151, 17)">
                                  <NullNode start="(151, 13)" end="(151, 17)">
                                    <OtherNode start="(151, 13)" end="(151, 17)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;⊢ findSome? f (replicate 0 a) = if 0 = 0 then none else f a" state_after="no goals" tactic="simp">
                                      <AtomNode start="(151, 13)" end="(151, 17)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(152, 3)" end="(154, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(152, 3)" end="(152, 11)">
                              <OtherNode start="(152, 3)" end="(152, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(152, 3)" end="(152, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(152, 5)" end="(152, 9)">
                                  <NullNode/>
                                  <IdentNode start="(152, 5)" end="(152, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(152, 10)" end="(152, 11)">
                                  <IdentNode start="(152, 10)" end="(152, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(152, 12)" end="(154, 23)">
                              <AtomNode start="(152, 12)" end="(152, 14)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(153, 5)" end="(154, 23)">
                                <TacticTacticseq1IndentedNode start="(153, 5)" end="(154, 23)">
                                  <NullNode start="(153, 5)" end="(154, 23)">
                                    <OtherNode start="(153, 5)" end="(153, 47)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;n : Nat&#10;⊢ findSome? f (replicate (n + 1) a) = if n + 1 = 0 then none else f a" state_after="case succ&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;n : Nat&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f (replicate n a)) =&#10;    if n + 1 = 0 then none else f a" tactic="simp only [replicate_succ, findSome?_cons]">
                                      <AtomNode start="(153, 5)" end="(153, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(153, 10)" end="(153, 14)">
                                        <AtomNode start="(153, 10)" end="(153, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(153, 15)" end="(153, 47)">
                                        <AtomNode start="(153, 15)" end="(153, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(153, 16)" end="(153, 46)">
                                          <OtherNode start="(153, 16)" end="(153, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(153, 16)" end="(153, 30)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(153, 30)" end="(153, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(153, 32)" end="(153, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(153, 32)" end="(153, 46)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(153, 46)" end="(153, 47)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(154, 5)" end="(154, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;n : Nat&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? f (replicate n a)) =&#10;    if n + 1 = 0 then none else f a" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(154, 5)" end="(154, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(154, 5)" end="(154, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(154, 11)" end="(154, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(154, 15)" end="(154, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(154, 15)" end="(154, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(156, 1)" end="(157, 45)" name="findSome?_replicate_of_pos" full_name="List.findSome?_replicate_of_pos">
      <CommandDeclmodifiersNode start="(156, 1)" end="(156, 8)">
        <NullNode/>
        <NullNode start="(156, 1)" end="(156, 8)">
          <OtherNode start="(156, 1)" end="(156, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(156, 1)" end="(156, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(156, 3)" end="(156, 7)">
              <OtherNode start="(156, 3)" end="(156, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(156, 3)" end="(156, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(156, 3)" end="(156, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(156, 7)" end="(156, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(156, 9)" end="(157, 45)" name="findSome?_replicate_of_pos" full_name="List.findSome?_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(156, 9)" end="(156, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(156, 17)" end="(156, 43)">
          <IdentNode start="(156, 17)" end="(156, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(156, 44)" end="(156, 91)">
          <NullNode start="(156, 44)" end="(156, 55)">
            <TermExplicitbinderNode start="(156, 44)" end="(156, 55)">
              <AtomNode start="(156, 44)" end="(156, 45)" leading="" trailing="" val="("/>
              <NullNode start="(156, 45)" end="(156, 46)">
                <IdentNode start="(156, 45)" end="(156, 46)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(156, 47)" end="(156, 54)">
                <AtomNode start="(156, 47)" end="(156, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(156, 49)" end="(156, 54)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(156, 49)" end="(156, 50)" kind="num">
                    <AtomNode start="(156, 49)" end="(156, 50)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(156, 51)" end="(156, 52)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(156, 53)" end="(156, 54)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(156, 54)" end="(156, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(156, 56)" end="(156, 91)">
            <AtomNode start="(156, 56)" end="(156, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(156, 58)" end="(156, 91)" kind="«term_=_»">
              <OtherNode start="(156, 58)" end="(156, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(156, 58)" end="(156, 67)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(156, 68)" end="(156, 85)">
                  <IdentNode start="(156, 68)" end="(156, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(156, 70)" end="(156, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(156, 70)" end="(156, 71)" leading="" trailing="" val="("/>
                    <OtherNode start="(156, 71)" end="(156, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(156, 71)" end="(156, 80)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(156, 81)" end="(156, 84)">
                        <IdentNode start="(156, 81)" end="(156, 82)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(156, 83)" end="(156, 84)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(156, 84)" end="(156, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(156, 86)" end="(156, 87)" leading="" trailing=" " val="="/>
              <OtherNode start="(156, 88)" end="(156, 91)" kind="Lean.Parser.Term.app">
                <IdentNode start="(156, 88)" end="(156, 89)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(156, 90)" end="(156, 91)">
                  <IdentNode start="(156, 90)" end="(156, 91)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(156, 92)" end="(157, 45)">
          <AtomNode start="(156, 92)" end="(156, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(156, 95)" end="(157, 45)">
            <AtomNode start="(156, 95)" end="(156, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(157, 3)" end="(157, 45)">
              <TacticTacticseq1IndentedNode start="(157, 3)" end="(157, 45)">
                <NullNode start="(157, 3)" end="(157, 45)">
                  <OtherNode start="(157, 3)" end="(157, 45)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;h : 0 &amp;lt; n&#10;⊢ findSome? f (replicate n a) = f a" state_after="no goals" tactic="simp [findSome?_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(157, 3)" end="(157, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(157, 8)" end="(157, 45)">
                      <AtomNode start="(157, 8)" end="(157, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(157, 9)" end="(157, 44)">
                        <OtherNode start="(157, 9)" end="(157, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(157, 9)" end="(157, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="List.findSome?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(149, 9)" def_end="(149, 28)"/>
                        </OtherNode>
                        <AtomNode start="(157, 28)" end="(157, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(157, 30)" end="(157, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(157, 30)" end="(157, 44)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(157, 30)" end="(157, 42)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(157, 43)" end="(157, 44)">
                              <IdentNode start="(157, 43)" end="(157, 44)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(157, 44)" end="(157, 45)" leading="" trailing="&#10;&#10;-- Argument is unused, but used to decide whether `simp` should unfold.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(160, 1)" end="(161, 29)" name="findSome?_replicate_of_isSome" full_name="List.findSome?_replicate_of_isSome">
      <CommandDeclmodifiersNode start="(160, 1)" end="(160, 8)">
        <NullNode/>
        <NullNode start="(160, 1)" end="(160, 8)">
          <OtherNode start="(160, 1)" end="(160, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(160, 1)" end="(160, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(160, 3)" end="(160, 7)">
              <OtherNode start="(160, 3)" end="(160, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(160, 3)" end="(160, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(160, 3)" end="(160, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(160, 7)" end="(160, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(160, 9)" end="(161, 29)" name="findSome?_replicate_of_isSome" full_name="List.findSome?_replicate_of_isSome" _is_private_decl="False">
        <AtomNode start="(160, 9)" end="(160, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(160, 17)" end="(160, 46)">
          <IdentNode start="(160, 17)" end="(160, 46)" leading="" trailing=" " raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(160, 47)" end="(160, 125)">
          <NullNode start="(160, 47)" end="(160, 65)">
            <TermExplicitbinderNode start="(160, 47)" end="(160, 65)">
              <AtomNode start="(160, 47)" end="(160, 48)" leading="" trailing="" val="("/>
              <NullNode start="(160, 48)" end="(160, 49)">
                <TermHoleNode start="(160, 48)" end="(160, 49)">
                  <AtomNode start="(160, 48)" end="(160, 49)" leading="" trailing=" " val="_"/>
                </TermHoleNode>
              </NullNode>
              <NullNode start="(160, 50)" end="(160, 64)">
                <AtomNode start="(160, 50)" end="(160, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(160, 52)" end="(160, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(160, 52)" end="(160, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(160, 52)" end="(160, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(160, 53)" end="(160, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(160, 53)" end="(160, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(160, 55)" end="(160, 56)">
                        <IdentNode start="(160, 55)" end="(160, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(160, 56)" end="(160, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(160, 57)" end="(160, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(160, 58)" end="(160, 64)" leading="" trailing="" raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(160, 64)" end="(160, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(160, 66)" end="(160, 125)">
            <AtomNode start="(160, 66)" end="(160, 67)" leading="" trailing=" " val=":"/>
            <OtherNode start="(160, 68)" end="(160, 125)" kind="«term_=_»">
              <OtherNode start="(160, 68)" end="(160, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(160, 68)" end="(160, 77)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(160, 78)" end="(160, 95)">
                  <IdentNode start="(160, 78)" end="(160, 79)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(160, 80)" end="(160, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(160, 80)" end="(160, 81)" leading="" trailing="" val="("/>
                    <OtherNode start="(160, 81)" end="(160, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(160, 81)" end="(160, 90)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(160, 91)" end="(160, 94)">
                        <IdentNode start="(160, 91)" end="(160, 92)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(160, 93)" end="(160, 94)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(160, 94)" end="(160, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(160, 96)" end="(160, 97)" leading="" trailing=" " val="="/>
              <OtherNode start="(160, 98)" end="(160, 125)" kind="termIfThenElse">
                <AtomNode start="(160, 98)" end="(160, 100)" leading="" trailing=" " val="if"/>
                <OtherNode start="(160, 101)" end="(160, 106)" kind="«term_=_»">
                  <IdentNode start="(160, 101)" end="(160, 102)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(160, 103)" end="(160, 104)" leading="" trailing=" " val="="/>
                  <OtherNode start="(160, 105)" end="(160, 106)" kind="num">
                    <AtomNode start="(160, 105)" end="(160, 106)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(160, 107)" end="(160, 111)" leading="" trailing=" " val="then"/>
                <IdentNode start="(160, 112)" end="(160, 116)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(160, 117)" end="(160, 121)" leading="" trailing=" " val="else"/>
                <OtherNode start="(160, 122)" end="(160, 125)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(160, 122)" end="(160, 123)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(160, 124)" end="(160, 125)">
                    <IdentNode start="(160, 124)" end="(160, 125)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(160, 126)" end="(161, 29)">
          <AtomNode start="(160, 126)" end="(160, 128)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(160, 129)" end="(161, 29)">
            <AtomNode start="(160, 129)" end="(160, 131)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(161, 3)" end="(161, 29)">
              <TacticTacticseq1IndentedNode start="(161, 3)" end="(161, 29)">
                <NullNode start="(161, 3)" end="(161, 29)">
                  <OtherNode start="(161, 3)" end="(161, 29)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;x✝ : (f a).isSome = true&#10;⊢ findSome? f (replicate n a) = if n = 0 then none else f a" state_after="no goals" tactic="simp [findSome?_replicate]">
                    <AtomNode start="(161, 3)" end="(161, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(161, 8)" end="(161, 29)">
                      <AtomNode start="(161, 8)" end="(161, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(161, 9)" end="(161, 28)">
                        <OtherNode start="(161, 9)" end="(161, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(161, 9)" end="(161, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="List.findSome?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(149, 9)" def_end="(149, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(161, 28)" end="(161, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(163, 1)" end="(165, 32)" name="findSome?_replicate_of_isNone" full_name="List.findSome?_replicate_of_isNone">
      <CommandDeclmodifiersNode start="(163, 1)" end="(163, 8)">
        <NullNode/>
        <NullNode start="(163, 1)" end="(163, 8)">
          <OtherNode start="(163, 1)" end="(163, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(163, 1)" end="(163, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(163, 3)" end="(163, 7)">
              <OtherNode start="(163, 3)" end="(163, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(163, 3)" end="(163, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(163, 3)" end="(163, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(163, 7)" end="(163, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(163, 9)" end="(165, 32)" name="findSome?_replicate_of_isNone" full_name="List.findSome?_replicate_of_isNone" _is_private_decl="False">
        <AtomNode start="(163, 9)" end="(163, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(163, 17)" end="(163, 46)">
          <IdentNode start="(163, 17)" end="(163, 46)" leading="" trailing=" " raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(163, 47)" end="(163, 102)">
          <NullNode start="(163, 47)" end="(163, 65)">
            <TermExplicitbinderNode start="(163, 47)" end="(163, 65)">
              <AtomNode start="(163, 47)" end="(163, 48)" leading="" trailing="" val="("/>
              <NullNode start="(163, 48)" end="(163, 49)">
                <IdentNode start="(163, 48)" end="(163, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(163, 50)" end="(163, 64)">
                <AtomNode start="(163, 50)" end="(163, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(163, 52)" end="(163, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(163, 52)" end="(163, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(163, 52)" end="(163, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(163, 53)" end="(163, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(163, 53)" end="(163, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(163, 55)" end="(163, 56)">
                        <IdentNode start="(163, 55)" end="(163, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(163, 56)" end="(163, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(163, 57)" end="(163, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(163, 58)" end="(163, 64)" leading="" trailing="" raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(163, 64)" end="(163, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(163, 66)" end="(163, 102)">
            <AtomNode start="(163, 66)" end="(163, 67)" leading="" trailing=" " val=":"/>
            <OtherNode start="(163, 68)" end="(163, 102)" kind="«term_=_»">
              <OtherNode start="(163, 68)" end="(163, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(163, 68)" end="(163, 77)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(163, 78)" end="(163, 95)">
                  <IdentNode start="(163, 78)" end="(163, 79)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(163, 80)" end="(163, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(163, 80)" end="(163, 81)" leading="" trailing="" val="("/>
                    <OtherNode start="(163, 81)" end="(163, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(163, 81)" end="(163, 90)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(163, 91)" end="(163, 94)">
                        <IdentNode start="(163, 91)" end="(163, 92)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(163, 93)" end="(163, 94)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(163, 94)" end="(163, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(163, 96)" end="(163, 97)" leading="" trailing=" " val="="/>
              <IdentNode start="(163, 98)" end="(163, 102)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(163, 103)" end="(165, 32)">
          <AtomNode start="(163, 103)" end="(163, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(163, 106)" end="(165, 32)">
            <AtomNode start="(163, 106)" end="(163, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(164, 3)" end="(165, 32)">
              <TacticTacticseq1IndentedNode start="(164, 3)" end="(165, 32)">
                <NullNode start="(164, 3)" end="(165, 32)">
                  <OtherNode start="(164, 3)" end="(164, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : (f a).isNone = true&#10;⊢ findSome? f (replicate n a) = none" state_after="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : f a = none&#10;⊢ findSome? f (replicate n a) = none" tactic="rw [Option.isNone_iff_eq_none] at h">
                    <AtomNode start="(164, 3)" end="(164, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(164, 6)" end="(164, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(164, 6)" end="(164, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(164, 7)" end="(164, 32)">
                        <OtherNode start="(164, 7)" end="(164, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(164, 7)" end="(164, 32)" leading="" trailing="" raw_val="Option.isNone_iff_eq_none" val="Option.isNone_iff_eq_none" full_name="Option.isNone_iff_eq_none" mod_name="Init.Data.Option.Instances" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Instances.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(164, 32)" end="(164, 33)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(164, 34)" end="(164, 38)">
                      <OtherNode start="(164, 34)" end="(164, 38)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(164, 34)" end="(164, 36)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(164, 37)" end="(164, 38)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(164, 37)" end="(164, 38)">
                            <IdentNode start="(164, 37)" end="(164, 38)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(165, 3)" end="(165, 32)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : f a = none&#10;⊢ findSome? f (replicate n a) = none" state_after="no goals" tactic="simp [findSome?_replicate, h]">
                    <AtomNode start="(165, 3)" end="(165, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(165, 8)" end="(165, 32)">
                      <AtomNode start="(165, 8)" end="(165, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(165, 9)" end="(165, 31)">
                        <OtherNode start="(165, 9)" end="(165, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(165, 9)" end="(165, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="List.findSome?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(149, 9)" def_end="(149, 28)"/>
                        </OtherNode>
                        <AtomNode start="(165, 28)" end="(165, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(165, 30)" end="(165, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(165, 30)" end="(165, 31)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(165, 31)" end="(165, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(167, 1)" end="(176, 15)" name="Sublist.findSome?_isSome" full_name="List.Sublist.findSome?_isSome">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(167, 1)" end="(176, 15)" name="Sublist.findSome?_isSome" full_name="List.Sublist.findSome?_isSome" _is_private_decl="False">
        <AtomNode start="(167, 1)" end="(167, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(167, 9)" end="(167, 33)">
          <IdentNode start="(167, 9)" end="(167, 33)" leading="" trailing=" " raw_val="Sublist.findSome?_isSome" val="Sublist.findSome?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(167, 34)" end="(168, 54)">
          <NullNode start="(167, 34)" end="(167, 65)">
            <OtherNode start="(167, 34)" end="(167, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 34)" end="(167, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 35)" end="(167, 40)">
                <IdentNode start="(167, 35)" end="(167, 37)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(167, 38)" end="(167, 40)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(167, 41)" end="(167, 49)">
                <AtomNode start="(167, 41)" end="(167, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 43)" end="(167, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(167, 43)" end="(167, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(167, 48)" end="(167, 49)">
                    <IdentNode start="(167, 48)" end="(167, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(167, 49)" end="(167, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(167, 51)" end="(167, 65)">
              <AtomNode start="(167, 51)" end="(167, 52)" leading="" trailing="" val="("/>
              <NullNode start="(167, 52)" end="(167, 53)">
                <IdentNode start="(167, 52)" end="(167, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(167, 54)" end="(167, 64)">
                <AtomNode start="(167, 54)" end="(167, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 56)" end="(167, 64)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(167, 56)" end="(167, 58)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(167, 59)" end="(167, 61)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(167, 62)" end="(167, 64)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(167, 64)" end="(167, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(167, 66)" end="(168, 54)">
            <AtomNode start="(167, 66)" end="(167, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(168, 5)" end="(168, 54)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(168, 5)" end="(168, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(168, 5)" end="(168, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(168, 5)" end="(168, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(168, 6)" end="(168, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(168, 6)" end="(168, 18)" leading="" trailing=" " raw_val="l₁.findSome?" val="l₁.findSome?"/>
                    <NullNode start="(168, 19)" end="(168, 20)">
                      <IdentNode start="(168, 19)" end="(168, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(168, 20)" end="(168, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(168, 21)" end="(168, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(168, 22)" end="(168, 28)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(168, 29)" end="(168, 30)" leading="" trailing=" " val="→"/>
              <OtherNode start="(168, 31)" end="(168, 54)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(168, 31)" end="(168, 47)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(168, 31)" end="(168, 32)" leading="" trailing="" val="("/>
                  <OtherNode start="(168, 32)" end="(168, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(168, 32)" end="(168, 44)" leading="" trailing=" " raw_val="l₂.findSome?" val="l₂.findSome?"/>
                    <NullNode start="(168, 45)" end="(168, 46)">
                      <IdentNode start="(168, 45)" end="(168, 46)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(168, 46)" end="(168, 47)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(168, 47)" end="(168, 48)" leading="" trailing="" val="."/>
                <IdentNode start="(168, 48)" end="(168, 54)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(168, 55)" end="(176, 15)">
          <AtomNode start="(168, 55)" end="(168, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(168, 58)" end="(176, 15)">
            <AtomNode start="(168, 58)" end="(168, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(169, 3)" end="(176, 15)">
              <TacticTacticseq1IndentedNode start="(169, 3)" end="(176, 15)">
                <NullNode start="(169, 3)" end="(176, 15)">
                  <OtherNode start="(169, 3)" end="(176, 15)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (findSome? f l₁).isSome = true → (findSome? f l₂).isSome = true" state_after="no goals" tactic="induction h with&#10;| slnil =&amp;gt; simp&#10;| cons a h ih&#10;| cons₂ a h ih =&amp;gt;&#10;  simp only [findSome?]&#10;  split&#10;  · simp_all&#10;  · exact ih">
                    <AtomNode start="(169, 3)" end="(169, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(169, 13)" end="(169, 14)">
                      <OtherNode start="(169, 13)" end="(169, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(169, 13)" end="(169, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(169, 15)" end="(176, 15)">
                      <OtherNode start="(169, 15)" end="(176, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(169, 15)" end="(169, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(170, 3)" end="(176, 15)">
                          <OtherNode start="(170, 3)" end="(170, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(170, 3)" end="(170, 10)">
                              <OtherNode start="(170, 3)" end="(170, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(170, 3)" end="(170, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(170, 5)" end="(170, 10)">
                                  <NullNode/>
                                  <IdentNode start="(170, 5)" end="(170, 10)" leading="" trailing=" " raw_val="slnil" val="slnil" full_name="List.Sublist.slnil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(170, 11)" end="(170, 18)">
                              <AtomNode start="(170, 11)" end="(170, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(170, 14)" end="(170, 18)">
                                <TacticTacticseq1IndentedNode start="(170, 14)" end="(170, 18)">
                                  <NullNode start="(170, 14)" end="(170, 18)">
                                    <OtherNode start="(170, 14)" end="(170, 18)" kind="Lean.Parser.Tactic.simp" state_before="case slnil&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ : List α&#10;⊢ (findSome? f []).isSome = true → (findSome? f []).isSome = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(170, 14)" end="(170, 18)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(171, 3)" end="(176, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(171, 3)" end="(172, 17)">
                              <OtherNode start="(171, 3)" end="(171, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(171, 3)" end="(171, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(171, 5)" end="(171, 9)">
                                  <NullNode/>
                                  <IdentNode start="(171, 5)" end="(171, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.Sublist.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(171, 10)" end="(171, 16)">
                                  <IdentNode start="(171, 10)" end="(171, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(171, 12)" end="(171, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(171, 14)" end="(171, 16)" leading="" trailing="&#10;  " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                              <OtherNode start="(172, 3)" end="(172, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(172, 3)" end="(172, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(172, 5)" end="(172, 10)">
                                  <NullNode/>
                                  <IdentNode start="(172, 5)" end="(172, 10)" leading="" trailing=" " raw_val="cons₂" val="cons₂" full_name="List.Sublist.cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(172, 11)" end="(172, 17)">
                                  <IdentNode start="(172, 11)" end="(172, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(172, 13)" end="(172, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(172, 15)" end="(172, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(172, 18)" end="(176, 15)">
                              <AtomNode start="(172, 18)" end="(172, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(173, 5)" end="(176, 15)">
                                <TacticTacticseq1IndentedNode start="(173, 5)" end="(176, 15)">
                                  <NullNode start="(173, 5)" end="(176, 15)">
                                    <OtherNode start="(173, 5)" end="(173, 26)" kind="Lean.Parser.Tactic.simp" state_before="case cons₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;⊢ (findSome? f (a :: l₁✝)).isSome = true → (findSome? f (a :: l₂✝)).isSome = true" state_after="case cons₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;⊢ (match f a with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f l₁✝).isSome =&#10;      true →&#10;    (match f a with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f l₂✝).isSome =&#10;      true" tactic="simp only [findSome?]">
                                      <AtomNode start="(173, 5)" end="(173, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(173, 10)" end="(173, 14)">
                                        <AtomNode start="(173, 10)" end="(173, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(173, 15)" end="(173, 26)">
                                        <AtomNode start="(173, 15)" end="(173, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(173, 16)" end="(173, 25)">
                                          <OtherNode start="(173, 16)" end="(173, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(173, 16)" end="(173, 25)" leading="" trailing="" raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(173, 25)" end="(173, 26)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(174, 5)" end="(174, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons₂&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;⊢ (match f a with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f l₁✝).isSome =&#10;      true →&#10;    (match f a with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f l₂✝).isSome =&#10;      true" state_after="case cons₂.h_1&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;b✝ : α✝&#10;heq✝ : f a = some b✝&#10;⊢ (some b✝).isSome = true → (some b✝).isSome = true&#10;&#10;case cons₂.h_2&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;heq✝ : f a = none&#10;⊢ (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true" tactic="split">
                                      <AtomNode start="(174, 5)" end="(174, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(175, 5)" end="(175, 15)" kind="Lean.cdot" state_before="case cons₂.h_1&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;b✝ : α✝&#10;heq✝ : f a = some b✝&#10;⊢ (some b✝).isSome = true → (some b✝).isSome = true&#10;&#10;case cons₂.h_2&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;heq✝ : f a = none&#10;⊢ (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true" state_after="case cons₂.h_2&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;heq✝ : f a = none&#10;⊢ (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true" tactic="· simp_all">
                                      <OtherNode start="(175, 5)" end="(175, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(175, 5)" end="(175, 6)" kind="patternIgnore">
                                          <OtherNode start="(175, 5)" end="(175, 6)" kind="token.«· »">
                                            <AtomNode start="(175, 5)" end="(175, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(175, 7)" end="(175, 15)">
                                        <TacticTacticseq1IndentedNode start="(175, 7)" end="(175, 15)">
                                          <NullNode start="(175, 7)" end="(175, 15)">
                                            <OtherNode start="(175, 7)" end="(175, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons₂.h_1&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;b✝ : α✝&#10;heq✝ : f a = some b✝&#10;⊢ (some b✝).isSome = true → (some b✝).isSome = true" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(175, 7)" end="(175, 15)" leading="" trailing="&#10;    " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(176, 5)" end="(176, 15)" kind="Lean.cdot" state_before="case cons₂.h_2&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;heq✝ : f a = none&#10;⊢ (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true" state_after="no goals" tactic="· exact ih">
                                      <OtherNode start="(176, 5)" end="(176, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(176, 5)" end="(176, 6)" kind="patternIgnore">
                                          <OtherNode start="(176, 5)" end="(176, 6)" kind="token.«· »">
                                            <AtomNode start="(176, 5)" end="(176, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(176, 7)" end="(176, 15)">
                                        <TacticTacticseq1IndentedNode start="(176, 7)" end="(176, 15)">
                                          <NullNode start="(176, 7)" end="(176, 15)">
                                            <OtherNode start="(176, 7)" end="(176, 15)" kind="Lean.Parser.Tactic.exact" state_before="case cons₂.h_2&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true&#10;x✝ : Option α✝&#10;heq✝ : f a = none&#10;⊢ (findSome? f l₁✝).isSome = true → (findSome? f l₂✝).isSome = true" state_after="no goals" tactic="exact ih">
                                              <AtomNode start="(176, 7)" end="(176, 12)" leading="" trailing=" " val="exact"/>
                                              <IdentNode start="(176, 13)" end="(176, 15)" leading="" trailing="&#10;&#10;" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(178, 1)" end="(181, 43)" name="Sublist.findSome?_eq_none" full_name="List.Sublist.findSome?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(178, 1)" end="(181, 43)" name="Sublist.findSome?_eq_none" full_name="List.Sublist.findSome?_eq_none" _is_private_decl="False">
        <AtomNode start="(178, 1)" end="(178, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(178, 9)" end="(178, 34)">
          <IdentNode start="(178, 9)" end="(178, 34)" leading="" trailing=" " raw_val="Sublist.findSome?_eq_none" val="Sublist.findSome?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(178, 35)" end="(179, 50)">
          <NullNode start="(178, 35)" end="(178, 66)">
            <OtherNode start="(178, 35)" end="(178, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(178, 35)" end="(178, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(178, 36)" end="(178, 41)">
                <IdentNode start="(178, 36)" end="(178, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(178, 39)" end="(178, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(178, 42)" end="(178, 50)">
                <AtomNode start="(178, 42)" end="(178, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(178, 44)" end="(178, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(178, 44)" end="(178, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(178, 49)" end="(178, 50)">
                    <IdentNode start="(178, 49)" end="(178, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(178, 50)" end="(178, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(178, 52)" end="(178, 66)">
              <AtomNode start="(178, 52)" end="(178, 53)" leading="" trailing="" val="("/>
              <NullNode start="(178, 53)" end="(178, 54)">
                <IdentNode start="(178, 53)" end="(178, 54)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(178, 55)" end="(178, 65)">
                <AtomNode start="(178, 55)" end="(178, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(178, 57)" end="(178, 65)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(178, 57)" end="(178, 59)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(178, 60)" end="(178, 62)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(178, 63)" end="(178, 65)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(178, 65)" end="(178, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(178, 67)" end="(179, 50)">
            <AtomNode start="(178, 67)" end="(178, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(179, 5)" end="(179, 50)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(179, 5)" end="(179, 26)" kind="«term_=_»">
                <OtherNode start="(179, 5)" end="(179, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(179, 5)" end="(179, 17)" leading="" trailing=" " raw_val="l₂.findSome?" val="l₂.findSome?"/>
                  <NullNode start="(179, 18)" end="(179, 19)">
                    <IdentNode start="(179, 18)" end="(179, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(179, 20)" end="(179, 21)" leading="" trailing=" " val="="/>
                <IdentNode start="(179, 22)" end="(179, 26)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(179, 27)" end="(179, 28)" leading="" trailing=" " val="→"/>
              <OtherNode start="(179, 29)" end="(179, 50)" kind="«term_=_»">
                <OtherNode start="(179, 29)" end="(179, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(179, 29)" end="(179, 41)" leading="" trailing=" " raw_val="l₁.findSome?" val="l₁.findSome?"/>
                  <NullNode start="(179, 42)" end="(179, 43)">
                    <IdentNode start="(179, 42)" end="(179, 43)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(179, 44)" end="(179, 45)" leading="" trailing=" " val="="/>
                <IdentNode start="(179, 46)" end="(179, 50)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(179, 51)" end="(181, 43)">
          <AtomNode start="(179, 51)" end="(179, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(179, 54)" end="(181, 43)">
            <AtomNode start="(179, 54)" end="(179, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(180, 3)" end="(181, 43)">
              <TacticTacticseq1IndentedNode start="(180, 3)" end="(181, 43)">
                <NullNode start="(180, 3)" end="(181, 43)">
                  <OtherNode start="(180, 3)" end="(180, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ findSome? f l₂ = none → findSome? f l₁ = none" state_after="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∀ (x : α), x ∈ l₂ → f x = none) → ∀ (x : α), x ∈ l₁ → f x = none" tactic="simp only [List.findSome?_eq_none_iff, Bool.not_eq_true]">
                    <AtomNode start="(180, 3)" end="(180, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(180, 8)" end="(180, 12)">
                      <AtomNode start="(180, 8)" end="(180, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(180, 13)" end="(180, 59)">
                      <AtomNode start="(180, 13)" end="(180, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(180, 14)" end="(180, 58)">
                        <OtherNode start="(180, 14)" end="(180, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(180, 14)" end="(180, 40)" leading="" trailing="" raw_val="List.findSome?_eq_none_iff" val="List.findSome?_eq_none_iff" full_name="List.findSome?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(47, 17)" def_end="(47, 38)"/>
                        </OtherNode>
                        <AtomNode start="(180, 40)" end="(180, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(180, 42)" end="(180, 58)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(180, 42)" end="(180, 58)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(180, 58)" end="(180, 59)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(181, 3)" end="(181, 43)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∀ (x : α), x ∈ l₂ → f x = none) → ∀ (x : α), x ∈ l₁ → f x = none" state_after="no goals" tactic="exact fun w x m =&amp;gt; w x (Sublist.mem m h)">
                    <AtomNode start="(181, 3)" end="(181, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(181, 9)" end="(181, 43)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(181, 9)" end="(181, 12)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(181, 13)" end="(181, 43)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(181, 13)" end="(181, 18)">
                          <IdentNode start="(181, 13)" end="(181, 14)" leading="" trailing=" " raw_val="w" val="w"/>
                          <IdentNode start="(181, 15)" end="(181, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(181, 17)" end="(181, 18)" leading="" trailing=" " raw_val="m" val="m"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(181, 19)" end="(181, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(181, 22)" end="(181, 43)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(181, 22)" end="(181, 23)" leading="" trailing=" " raw_val="w" val="w"/>
                          <NullNode start="(181, 24)" end="(181, 43)">
                            <IdentNode start="(181, 24)" end="(181, 25)" leading="" trailing=" " raw_val="x" val="x"/>
                            <OtherNode start="(181, 26)" end="(181, 43)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(181, 26)" end="(181, 27)" leading="" trailing="" val="("/>
                              <OtherNode start="(181, 27)" end="(181, 42)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(181, 27)" end="(181, 38)" leading="" trailing=" " raw_val="Sublist.mem" val="Sublist.mem" full_name="List.Sublist.mem" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                <NullNode start="(181, 39)" end="(181, 42)">
                                  <IdentNode start="(181, 39)" end="(181, 40)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(181, 41)" end="(181, 42)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(181, 42)" end="(181, 43)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(183, 1)" end="(187, 38)" name="IsPrefix.findSome?_eq_some" full_name="List.IsPrefix.findSome?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(183, 1)" end="(187, 38)" name="IsPrefix.findSome?_eq_some" full_name="List.IsPrefix.findSome?_eq_some" _is_private_decl="False">
        <AtomNode start="(183, 1)" end="(183, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(183, 9)" end="(183, 35)">
          <IdentNode start="(183, 9)" end="(183, 35)" leading="" trailing=" " raw_val="IsPrefix.findSome?_eq_some" val="IsPrefix.findSome?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(183, 36)" end="(184, 64)">
          <NullNode start="(183, 36)" end="(183, 87)">
            <OtherNode start="(183, 36)" end="(183, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 36)" end="(183, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 37)" end="(183, 42)">
                <IdentNode start="(183, 37)" end="(183, 39)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(183, 40)" end="(183, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(183, 43)" end="(183, 51)">
                <AtomNode start="(183, 43)" end="(183, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 45)" end="(183, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(183, 45)" end="(183, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(183, 50)" end="(183, 51)">
                    <IdentNode start="(183, 50)" end="(183, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 51)" end="(183, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(183, 53)" end="(183, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(183, 53)" end="(183, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(183, 54)" end="(183, 55)">
                <IdentNode start="(183, 54)" end="(183, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(183, 56)" end="(183, 70)">
                <AtomNode start="(183, 56)" end="(183, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 58)" end="(183, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(183, 58)" end="(183, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(183, 60)" end="(183, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(183, 62)" end="(183, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(183, 62)" end="(183, 68)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(183, 69)" end="(183, 70)">
                      <IdentNode start="(183, 69)" end="(183, 70)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(183, 70)" end="(183, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(183, 72)" end="(183, 87)">
              <AtomNode start="(183, 72)" end="(183, 73)" leading="" trailing="" val="("/>
              <NullNode start="(183, 73)" end="(183, 74)">
                <IdentNode start="(183, 73)" end="(183, 74)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(183, 75)" end="(183, 86)">
                <AtomNode start="(183, 75)" end="(183, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(183, 77)" end="(183, 86)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(183, 77)" end="(183, 79)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(183, 80)" end="(183, 83)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(183, 84)" end="(183, 86)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(183, 86)" end="(183, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(183, 88)" end="(184, 64)">
            <AtomNode start="(183, 88)" end="(183, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(184, 5)" end="(184, 64)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(184, 5)" end="(184, 33)" kind="«term_=_»">
                <OtherNode start="(184, 5)" end="(184, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(184, 5)" end="(184, 19)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(184, 20)" end="(184, 24)">
                    <IdentNode start="(184, 20)" end="(184, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(184, 22)" end="(184, 24)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(184, 25)" end="(184, 26)" leading="" trailing=" " val="="/>
                <OtherNode start="(184, 27)" end="(184, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(184, 27)" end="(184, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(184, 32)" end="(184, 33)">
                    <IdentNode start="(184, 32)" end="(184, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(184, 34)" end="(184, 35)" leading="" trailing=" " val="→"/>
              <OtherNode start="(184, 36)" end="(184, 64)" kind="«term_=_»">
                <OtherNode start="(184, 36)" end="(184, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(184, 36)" end="(184, 50)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(184, 51)" end="(184, 55)">
                    <IdentNode start="(184, 51)" end="(184, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(184, 53)" end="(184, 55)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(184, 56)" end="(184, 57)" leading="" trailing=" " val="="/>
                <OtherNode start="(184, 58)" end="(184, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(184, 58)" end="(184, 62)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(184, 63)" end="(184, 64)">
                    <IdentNode start="(184, 63)" end="(184, 64)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(184, 65)" end="(187, 38)">
          <AtomNode start="(184, 65)" end="(184, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(184, 68)" end="(187, 38)">
            <AtomNode start="(184, 68)" end="(184, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(185, 3)" end="(187, 38)">
              <TacticTacticseq1IndentedNode start="(185, 3)" end="(187, 38)">
                <NullNode start="(185, 3)" end="(187, 38)">
                  <OtherNode start="(185, 3)" end="(185, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;l₁ l₂ : List α&#10;f : α → Option β&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ findSome? f l₁ = some b → findSome? f l₂ = some b" state_after="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;l₁ l₂ : List α&#10;f : α → Option β&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ findSome? f l₁ = some b → findSome? f l₂ = some b" tactic="rw [IsPrefix] at h">
                    <AtomNode start="(185, 3)" end="(185, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(185, 6)" end="(185, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(185, 6)" end="(185, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(185, 7)" end="(185, 15)">
                        <OtherNode start="(185, 7)" end="(185, 15)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(185, 7)" end="(185, 15)" leading="" trailing="" raw_val="IsPrefix" val="IsPrefix" full_name="List.IsPrefix" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(185, 15)" end="(185, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(185, 17)" end="(185, 21)">
                      <OtherNode start="(185, 17)" end="(185, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(185, 17)" end="(185, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(185, 20)" end="(185, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(185, 20)" end="(185, 21)">
                            <IdentNode start="(185, 20)" end="(185, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(186, 3)" end="(186, 23)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;l₁ l₂ : List α&#10;f : α → Option β&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ findSome? f l₁ = some b → findSome? f l₂ = some b" state_after="case intro&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;l₁ : List α&#10;f : α → Option β&#10;t : List α&#10;⊢ findSome? f l₁ = some b → findSome? f (l₁ ++ t) = some b" tactic="obtain ⟨t, rfl⟩ := h">
                    <AtomNode start="(186, 3)" end="(186, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(186, 10)" end="(186, 18)">
                      <OtherNode start="(186, 10)" end="(186, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(186, 10)" end="(186, 18)">
                          <OtherNode start="(186, 10)" end="(186, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(186, 10)" end="(186, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(186, 11)" end="(186, 17)">
                              <OtherNode start="(186, 11)" end="(186, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(186, 11)" end="(186, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(186, 11)" end="(186, 12)">
                                    <OtherNode start="(186, 11)" end="(186, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(186, 11)" end="(186, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(186, 12)" end="(186, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(186, 14)" end="(186, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(186, 14)" end="(186, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(186, 14)" end="(186, 17)">
                                    <OtherNode start="(186, 14)" end="(186, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(186, 14)" end="(186, 17)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(186, 17)" end="(186, 18)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(186, 19)" end="(186, 23)">
                      <AtomNode start="(186, 19)" end="(186, 21)" leading="" trailing=" " val=":="/>
                      <NullNode start="(186, 22)" end="(186, 23)">
                        <IdentNode start="(186, 22)" end="(186, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(187, 3)" end="(187, 38)" kind="Lean.Parser.Tactic.simp" state_before="case intro&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;l₁ : List α&#10;f : α → Option β&#10;t : List α&#10;⊢ findSome? f l₁ = some b → findSome? f (l₁ ++ t) = some b" state_after="no goals" tactic="simp +contextual [findSome?_append]">
                    <AtomNode start="(187, 3)" end="(187, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode start="(187, 8)" end="(187, 19)" kind="Lean.Parser.Tactic.optConfig">
                      <NullNode start="(187, 8)" end="(187, 19)">
                        <OtherNode start="(187, 8)" end="(187, 19)" kind="Lean.Parser.Tactic.configItem">
                          <OtherNode start="(187, 8)" end="(187, 19)" kind="Lean.Parser.Tactic.posConfigItem">
                            <AtomNode start="(187, 8)" end="(187, 9)" leading="" trailing="" val="+"/>
                            <IdentNode start="(187, 9)" end="(187, 19)" leading="" trailing=" " raw_val="contextual" val="contextual"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(187, 20)" end="(187, 38)">
                      <AtomNode start="(187, 20)" end="(187, 21)" leading="" trailing="" val="["/>
                      <NullNode start="(187, 21)" end="(187, 37)">
                        <OtherNode start="(187, 21)" end="(187, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(187, 21)" end="(187, 37)" leading="" trailing="" raw_val="findSome?_append" val="findSome?_append" full_name="List.findSome?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(187, 37)" end="(187, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(189, 1)" end="(191, 30)" name="IsPrefix.findSome?_eq_none" full_name="List.IsPrefix.findSome?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(189, 1)" end="(191, 30)" name="IsPrefix.findSome?_eq_none" full_name="List.IsPrefix.findSome?_eq_none" _is_private_decl="False">
        <AtomNode start="(189, 1)" end="(189, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(189, 9)" end="(189, 35)">
          <IdentNode start="(189, 9)" end="(189, 35)" leading="" trailing=" " raw_val="IsPrefix.findSome?_eq_none" val="IsPrefix.findSome?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(189, 36)" end="(190, 60)">
          <NullNode start="(189, 36)" end="(189, 87)">
            <OtherNode start="(189, 36)" end="(189, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(189, 36)" end="(189, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(189, 37)" end="(189, 42)">
                <IdentNode start="(189, 37)" end="(189, 39)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(189, 40)" end="(189, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(189, 43)" end="(189, 51)">
                <AtomNode start="(189, 43)" end="(189, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(189, 45)" end="(189, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(189, 45)" end="(189, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(189, 50)" end="(189, 51)">
                    <IdentNode start="(189, 50)" end="(189, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(189, 51)" end="(189, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(189, 53)" end="(189, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(189, 53)" end="(189, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(189, 54)" end="(189, 55)">
                <IdentNode start="(189, 54)" end="(189, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(189, 56)" end="(189, 70)">
                <AtomNode start="(189, 56)" end="(189, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(189, 58)" end="(189, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(189, 58)" end="(189, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(189, 60)" end="(189, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(189, 62)" end="(189, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(189, 62)" end="(189, 68)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(189, 69)" end="(189, 70)">
                      <IdentNode start="(189, 69)" end="(189, 70)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(189, 70)" end="(189, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(189, 72)" end="(189, 87)">
              <AtomNode start="(189, 72)" end="(189, 73)" leading="" trailing="" val="("/>
              <NullNode start="(189, 73)" end="(189, 74)">
                <IdentNode start="(189, 73)" end="(189, 74)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(189, 75)" end="(189, 86)">
                <AtomNode start="(189, 75)" end="(189, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(189, 77)" end="(189, 86)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(189, 77)" end="(189, 79)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(189, 80)" end="(189, 83)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(189, 84)" end="(189, 86)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(189, 86)" end="(189, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(189, 88)" end="(190, 60)">
            <AtomNode start="(189, 88)" end="(189, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(190, 5)" end="(190, 60)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(190, 5)" end="(190, 31)" kind="«term_=_»">
                <OtherNode start="(190, 5)" end="(190, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 5)" end="(190, 19)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(190, 20)" end="(190, 24)">
                    <IdentNode start="(190, 20)" end="(190, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(190, 22)" end="(190, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(190, 25)" end="(190, 26)" leading="" trailing=" " val="="/>
                <IdentNode start="(190, 27)" end="(190, 31)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(190, 32)" end="(190, 33)" leading="" trailing=" " val="→"/>
              <OtherNode start="(190, 34)" end="(190, 60)" kind="«term_=_»">
                <OtherNode start="(190, 34)" end="(190, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 34)" end="(190, 48)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(190, 49)" end="(190, 53)">
                    <IdentNode start="(190, 49)" end="(190, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(190, 51)" end="(190, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(190, 54)" end="(190, 55)" leading="" trailing=" " val="="/>
                <IdentNode start="(190, 56)" end="(190, 60)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(190, 61)" end="(191, 30)">
          <AtomNode start="(190, 61)" end="(190, 63)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(191, 3)" end="(191, 30)" leading="" trailing="&#10;" raw_val="h.sublist.findSome?_eq_none" val="h.sublist.findSome?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(192, 1)" end="(194, 30)" name="IsSuffix.findSome?_eq_none" full_name="List.IsSuffix.findSome?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(192, 1)" end="(194, 30)" name="IsSuffix.findSome?_eq_none" full_name="List.IsSuffix.findSome?_eq_none" _is_private_decl="False">
        <AtomNode start="(192, 1)" end="(192, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(192, 9)" end="(192, 35)">
          <IdentNode start="(192, 9)" end="(192, 35)" leading="" trailing=" " raw_val="IsSuffix.findSome?_eq_none" val="IsSuffix.findSome?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(192, 36)" end="(193, 60)">
          <NullNode start="(192, 36)" end="(192, 87)">
            <OtherNode start="(192, 36)" end="(192, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(192, 36)" end="(192, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(192, 37)" end="(192, 42)">
                <IdentNode start="(192, 37)" end="(192, 39)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(192, 40)" end="(192, 42)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(192, 43)" end="(192, 51)">
                <AtomNode start="(192, 43)" end="(192, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 45)" end="(192, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(192, 45)" end="(192, 49)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(192, 50)" end="(192, 51)">
                    <IdentNode start="(192, 50)" end="(192, 51)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(192, 51)" end="(192, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(192, 53)" end="(192, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(192, 53)" end="(192, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(192, 54)" end="(192, 55)">
                <IdentNode start="(192, 54)" end="(192, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(192, 56)" end="(192, 70)">
                <AtomNode start="(192, 56)" end="(192, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 58)" end="(192, 70)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(192, 58)" end="(192, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(192, 60)" end="(192, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(192, 62)" end="(192, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(192, 62)" end="(192, 68)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(192, 69)" end="(192, 70)">
                      <IdentNode start="(192, 69)" end="(192, 70)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(192, 70)" end="(192, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(192, 72)" end="(192, 87)">
              <AtomNode start="(192, 72)" end="(192, 73)" leading="" trailing="" val="("/>
              <NullNode start="(192, 73)" end="(192, 74)">
                <IdentNode start="(192, 73)" end="(192, 74)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(192, 75)" end="(192, 86)">
                <AtomNode start="(192, 75)" end="(192, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 77)" end="(192, 86)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(192, 77)" end="(192, 79)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(192, 80)" end="(192, 83)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(192, 84)" end="(192, 86)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(192, 86)" end="(192, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(192, 88)" end="(193, 60)">
            <AtomNode start="(192, 88)" end="(192, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(193, 5)" end="(193, 60)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(193, 5)" end="(193, 31)" kind="«term_=_»">
                <OtherNode start="(193, 5)" end="(193, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(193, 5)" end="(193, 19)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(193, 20)" end="(193, 24)">
                    <IdentNode start="(193, 20)" end="(193, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(193, 22)" end="(193, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(193, 25)" end="(193, 26)" leading="" trailing=" " val="="/>
                <IdentNode start="(193, 27)" end="(193, 31)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(193, 32)" end="(193, 33)" leading="" trailing=" " val="→"/>
              <OtherNode start="(193, 34)" end="(193, 60)" kind="«term_=_»">
                <OtherNode start="(193, 34)" end="(193, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(193, 34)" end="(193, 48)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(193, 49)" end="(193, 53)">
                    <IdentNode start="(193, 49)" end="(193, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(193, 51)" end="(193, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(193, 54)" end="(193, 55)" leading="" trailing=" " val="="/>
                <IdentNode start="(193, 56)" end="(193, 60)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(193, 61)" end="(194, 30)">
          <AtomNode start="(193, 61)" end="(193, 63)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(194, 3)" end="(194, 30)" leading="" trailing="&#10;" raw_val="h.sublist.findSome?_eq_none" val="h.sublist.findSome?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(195, 1)" end="(197, 30)" name="IsInfix.findSome?_eq_none" full_name="List.IsInfix.findSome?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(195, 1)" end="(197, 30)" name="IsInfix.findSome?_eq_none" full_name="List.IsInfix.findSome?_eq_none" _is_private_decl="False">
        <AtomNode start="(195, 1)" end="(195, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(195, 9)" end="(195, 34)">
          <IdentNode start="(195, 9)" end="(195, 34)" leading="" trailing=" " raw_val="IsInfix.findSome?_eq_none" val="IsInfix.findSome?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(195, 35)" end="(196, 60)">
          <NullNode start="(195, 35)" end="(195, 87)">
            <OtherNode start="(195, 35)" end="(195, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(195, 35)" end="(195, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(195, 36)" end="(195, 41)">
                <IdentNode start="(195, 36)" end="(195, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(195, 39)" end="(195, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(195, 42)" end="(195, 50)">
                <AtomNode start="(195, 42)" end="(195, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 44)" end="(195, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(195, 44)" end="(195, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(195, 49)" end="(195, 50)">
                    <IdentNode start="(195, 49)" end="(195, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(195, 50)" end="(195, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(195, 52)" end="(195, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(195, 52)" end="(195, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(195, 53)" end="(195, 54)">
                <IdentNode start="(195, 53)" end="(195, 54)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(195, 55)" end="(195, 69)">
                <AtomNode start="(195, 55)" end="(195, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 57)" end="(195, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(195, 57)" end="(195, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(195, 59)" end="(195, 60)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(195, 61)" end="(195, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(195, 61)" end="(195, 67)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(195, 68)" end="(195, 69)">
                      <IdentNode start="(195, 68)" end="(195, 69)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(195, 69)" end="(195, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(195, 71)" end="(195, 87)">
              <AtomNode start="(195, 71)" end="(195, 72)" leading="" trailing="" val="("/>
              <NullNode start="(195, 72)" end="(195, 73)">
                <IdentNode start="(195, 72)" end="(195, 73)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(195, 74)" end="(195, 86)">
                <AtomNode start="(195, 74)" end="(195, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 76)" end="(195, 86)" kind="List.«term_&amp;lt;:+:_»">
                  <IdentNode start="(195, 76)" end="(195, 78)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(195, 79)" end="(195, 83)" leading="" trailing=" " val="&amp;lt;:+:"/>
                  <IdentNode start="(195, 84)" end="(195, 86)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(195, 86)" end="(195, 87)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(195, 88)" end="(196, 60)">
            <AtomNode start="(195, 88)" end="(195, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(196, 5)" end="(196, 60)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(196, 5)" end="(196, 31)" kind="«term_=_»">
                <OtherNode start="(196, 5)" end="(196, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(196, 5)" end="(196, 19)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(196, 20)" end="(196, 24)">
                    <IdentNode start="(196, 20)" end="(196, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(196, 22)" end="(196, 24)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(196, 25)" end="(196, 26)" leading="" trailing=" " val="="/>
                <IdentNode start="(196, 27)" end="(196, 31)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(196, 32)" end="(196, 33)" leading="" trailing=" " val="→"/>
              <OtherNode start="(196, 34)" end="(196, 60)" kind="«term_=_»">
                <OtherNode start="(196, 34)" end="(196, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(196, 34)" end="(196, 48)" leading="" trailing=" " raw_val="List.findSome?" val="List.findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(196, 49)" end="(196, 53)">
                    <IdentNode start="(196, 49)" end="(196, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(196, 51)" end="(196, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(196, 54)" end="(196, 55)" leading="" trailing=" " val="="/>
                <IdentNode start="(196, 56)" end="(196, 60)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(196, 61)" end="(197, 30)">
          <AtomNode start="(196, 61)" end="(196, 63)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(197, 3)" end="(197, 30)" leading="" trailing="&#10;&#10;" raw_val="h.sublist.findSome?_eq_none" val="h.sublist.findSome?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(199, 1)" end="(199, 17)" comment="### find? -/">
      <AtomNode start="(199, 1)" end="(199, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(199, 5)" end="(199, 17)" leading="" trailing="&#10;&#10;" val="### find? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(201, 1)" end="(202, 18)" name="find?_cons_of_pos" full_name="List.find?_cons_of_pos">
      <CommandDeclmodifiersNode start="(201, 1)" end="(201, 8)">
        <NullNode/>
        <NullNode start="(201, 1)" end="(201, 8)">
          <OtherNode start="(201, 1)" end="(201, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(201, 1)" end="(201, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(201, 3)" end="(201, 7)">
              <OtherNode start="(201, 3)" end="(201, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(201, 3)" end="(201, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(201, 3)" end="(201, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(201, 7)" end="(201, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(201, 9)" end="(202, 18)" name="find?_cons_of_pos" full_name="List.find?_cons_of_pos" _is_private_decl="False">
        <AtomNode start="(201, 9)" end="(201, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(201, 17)" end="(201, 34)">
          <IdentNode start="(201, 17)" end="(201, 34)" leading="" trailing=" " raw_val="find?_cons_of_pos" val="find?_cons_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(201, 35)" end="(201, 76)">
          <NullNode start="(201, 35)" end="(201, 48)">
            <OtherNode start="(201, 35)" end="(201, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(201, 35)" end="(201, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(201, 36)" end="(201, 37)">
                <IdentNode start="(201, 36)" end="(201, 37)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 37)" end="(201, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(201, 39)" end="(201, 48)">
              <AtomNode start="(201, 39)" end="(201, 40)" leading="" trailing="" val="("/>
              <NullNode start="(201, 40)" end="(201, 41)">
                <IdentNode start="(201, 40)" end="(201, 41)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(201, 42)" end="(201, 47)">
                <AtomNode start="(201, 42)" end="(201, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(201, 44)" end="(201, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(201, 44)" end="(201, 45)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(201, 46)" end="(201, 47)">
                    <IdentNode start="(201, 46)" end="(201, 47)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(201, 47)" end="(201, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(201, 49)" end="(201, 76)">
            <AtomNode start="(201, 49)" end="(201, 50)" leading="" trailing=" " val=":"/>
            <OtherNode start="(201, 51)" end="(201, 76)" kind="«term_=_»">
              <OtherNode start="(201, 51)" end="(201, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(201, 51)" end="(201, 56)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(201, 57)" end="(201, 67)">
                  <IdentNode start="(201, 57)" end="(201, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(201, 59)" end="(201, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(201, 59)" end="(201, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(201, 60)" end="(201, 66)" kind="«term_::_»">
                      <IdentNode start="(201, 60)" end="(201, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(201, 62)" end="(201, 64)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(201, 65)" end="(201, 66)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(201, 66)" end="(201, 67)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(201, 68)" end="(201, 69)" leading="" trailing=" " val="="/>
              <OtherNode start="(201, 70)" end="(201, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(201, 70)" end="(201, 74)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(201, 75)" end="(201, 76)">
                  <IdentNode start="(201, 75)" end="(201, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(201, 77)" end="(202, 18)">
          <AtomNode start="(201, 77)" end="(201, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(201, 80)" end="(202, 18)">
            <AtomNode start="(201, 80)" end="(201, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(202, 3)" end="(202, 18)">
              <TacticTacticseq1IndentedNode start="(202, 3)" end="(202, 18)">
                <NullNode start="(202, 3)" end="(202, 18)">
                  <OtherNode start="(202, 3)" end="(202, 18)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;l : List α✝&#10;h : p a = true&#10;⊢ find? p (a :: l) = some a" state_after="no goals" tactic="simp [find?, h]">
                    <AtomNode start="(202, 3)" end="(202, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(202, 8)" end="(202, 18)">
                      <AtomNode start="(202, 8)" end="(202, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(202, 9)" end="(202, 17)">
                        <OtherNode start="(202, 9)" end="(202, 14)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(202, 9)" end="(202, 14)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(202, 14)" end="(202, 15)" leading="" trailing=" " val=","/>
                        <OtherNode start="(202, 16)" end="(202, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(202, 16)" end="(202, 17)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(202, 17)" end="(202, 18)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(204, 1)" end="(205, 18)" name="find?_cons_of_neg" full_name="List.find?_cons_of_neg">
      <CommandDeclmodifiersNode start="(204, 1)" end="(204, 8)">
        <NullNode/>
        <NullNode start="(204, 1)" end="(204, 8)">
          <OtherNode start="(204, 1)" end="(204, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(204, 1)" end="(204, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(204, 3)" end="(204, 7)">
              <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(204, 3)" end="(204, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(204, 3)" end="(204, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(204, 7)" end="(204, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(204, 9)" end="(205, 18)" name="find?_cons_of_neg" full_name="List.find?_cons_of_neg" _is_private_decl="False">
        <AtomNode start="(204, 9)" end="(204, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(204, 17)" end="(204, 34)">
          <IdentNode start="(204, 17)" end="(204, 34)" leading="" trailing=" " raw_val="find?_cons_of_neg" val="find?_cons_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(204, 35)" end="(204, 80)">
          <NullNode start="(204, 35)" end="(204, 49)">
            <OtherNode start="(204, 35)" end="(204, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(204, 35)" end="(204, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(204, 36)" end="(204, 37)">
                <IdentNode start="(204, 36)" end="(204, 37)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(204, 37)" end="(204, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(204, 39)" end="(204, 49)">
              <AtomNode start="(204, 39)" end="(204, 40)" leading="" trailing="" val="("/>
              <NullNode start="(204, 40)" end="(204, 41)">
                <IdentNode start="(204, 40)" end="(204, 41)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(204, 42)" end="(204, 48)">
                <AtomNode start="(204, 42)" end="(204, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(204, 44)" end="(204, 48)" kind="«term¬_»">
                  <AtomNode start="(204, 44)" end="(204, 45)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(204, 45)" end="(204, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(204, 45)" end="(204, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(204, 47)" end="(204, 48)">
                      <IdentNode start="(204, 47)" end="(204, 48)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(204, 48)" end="(204, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(204, 50)" end="(204, 80)">
            <AtomNode start="(204, 50)" end="(204, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(204, 52)" end="(204, 80)" kind="«term_=_»">
              <OtherNode start="(204, 52)" end="(204, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 52)" end="(204, 57)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(204, 58)" end="(204, 68)">
                  <IdentNode start="(204, 58)" end="(204, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(204, 60)" end="(204, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(204, 60)" end="(204, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(204, 61)" end="(204, 67)" kind="«term_::_»">
                      <IdentNode start="(204, 61)" end="(204, 62)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(204, 63)" end="(204, 65)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(204, 66)" end="(204, 67)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(204, 67)" end="(204, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(204, 69)" end="(204, 70)" leading="" trailing=" " val="="/>
              <OtherNode start="(204, 71)" end="(204, 80)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 71)" end="(204, 76)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(204, 77)" end="(204, 80)">
                  <IdentNode start="(204, 77)" end="(204, 78)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(204, 79)" end="(204, 80)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(204, 81)" end="(205, 18)">
          <AtomNode start="(204, 81)" end="(204, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(204, 84)" end="(205, 18)">
            <AtomNode start="(204, 84)" end="(204, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(205, 3)" end="(205, 18)">
              <TacticTacticseq1IndentedNode start="(205, 3)" end="(205, 18)">
                <NullNode start="(205, 3)" end="(205, 18)">
                  <OtherNode start="(205, 3)" end="(205, 18)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;l : List α✝&#10;h : ¬p a = true&#10;⊢ find? p (a :: l) = find? p l" state_after="no goals" tactic="simp [find?, h]">
                    <AtomNode start="(205, 3)" end="(205, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(205, 8)" end="(205, 18)">
                      <AtomNode start="(205, 8)" end="(205, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(205, 9)" end="(205, 17)">
                        <OtherNode start="(205, 9)" end="(205, 14)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(205, 9)" end="(205, 14)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(205, 14)" end="(205, 15)" leading="" trailing=" " val=","/>
                        <OtherNode start="(205, 16)" end="(205, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(205, 16)" end="(205, 17)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(205, 17)" end="(205, 18)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(207, 1)" end="(208, 56)" name="find?_eq_none" full_name="List.find?_eq_none">
      <CommandDeclmodifiersNode start="(207, 1)" end="(207, 8)">
        <NullNode/>
        <NullNode start="(207, 1)" end="(207, 8)">
          <OtherNode start="(207, 1)" end="(207, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(207, 1)" end="(207, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(207, 3)" end="(207, 7)">
              <OtherNode start="(207, 3)" end="(207, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(207, 3)" end="(207, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(207, 3)" end="(207, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(207, 7)" end="(207, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(207, 9)" end="(208, 56)" name="find?_eq_none" full_name="List.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(207, 9)" end="(207, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(207, 17)" end="(207, 30)">
          <IdentNode start="(207, 17)" end="(207, 30)" leading="" trailing=" " raw_val="find?_eq_none" val="find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(207, 31)" end="(207, 66)">
          <NullNode/>
          <TermTypespecNode start="(207, 31)" end="(207, 66)">
            <AtomNode start="(207, 31)" end="(207, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(207, 33)" end="(207, 66)" kind="«term_↔_»">
              <OtherNode start="(207, 33)" end="(207, 49)" kind="«term_=_»">
                <OtherNode start="(207, 33)" end="(207, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(207, 33)" end="(207, 38)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(207, 39)" end="(207, 42)">
                    <IdentNode start="(207, 39)" end="(207, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(207, 41)" end="(207, 42)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(207, 43)" end="(207, 44)" leading="" trailing=" " val="="/>
                <IdentNode start="(207, 45)" end="(207, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(207, 50)" end="(207, 51)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(207, 52)" end="(207, 66)" kind="Lean.«term∀__,_»">
                <AtomNode start="(207, 52)" end="(207, 53)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(207, 54)" end="(207, 55)">
                  <IdentNode start="(207, 54)" end="(207, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(207, 56)" end="(207, 59)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(207, 56)" end="(207, 57)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(207, 58)" end="(207, 59)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(207, 59)" end="(207, 60)" leading="" trailing=" " val=","/>
                <OtherNode start="(207, 61)" end="(207, 66)" kind="«term¬_»">
                  <AtomNode start="(207, 61)" end="(207, 62)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(207, 63)" end="(207, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(207, 63)" end="(207, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(207, 65)" end="(207, 66)">
                      <IdentNode start="(207, 65)" end="(207, 66)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(207, 67)" end="(208, 56)">
          <AtomNode start="(207, 67)" end="(207, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(207, 70)" end="(208, 56)">
            <AtomNode start="(207, 70)" end="(207, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(208, 3)" end="(208, 56)">
              <TacticTacticseq1IndentedNode start="(208, 3)" end="(208, 56)">
                <NullNode start="(208, 3)" end="(208, 56)">
                  <OtherNode start="(208, 3)" end="(208, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;l : List α✝&#10;⊢ find? p l = none ↔ ∀ (x : α✝), x ∈ l → ¬p x = true" state_after="case cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;head✝ : α✝&#10;tail✝ : List α✝&#10;tail_ih✝ : find? p tail✝ = none ↔ ∀ (x : α✝), x ∈ tail✝ → ¬p x = true&#10;⊢ (match p head✝ with&#10;      | true =&amp;gt; some head✝&#10;      | false =&amp;gt; find? p tail✝) =&#10;      none ↔&#10;    p head✝ = false ∧ ∀ (a : α✝), a ∈ tail✝ → p a = false" tactic="induction l &amp;lt;;&amp;gt; simp [find?_cons]">
                    <OtherNode start="(208, 3)" end="(208, 14)" kind="Lean.Parser.Tactic.induction">
                      <AtomNode start="(208, 3)" end="(208, 12)" leading="" trailing=" " val="induction"/>
                      <NullNode start="(208, 13)" end="(208, 14)">
                        <OtherNode start="(208, 13)" end="(208, 14)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(208, 13)" end="(208, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(208, 15)" end="(208, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(208, 19)" end="(208, 36)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(208, 19)" end="(208, 23)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(208, 24)" end="(208, 36)">
                        <AtomNode start="(208, 24)" end="(208, 25)" leading="" trailing="" val="["/>
                        <NullNode start="(208, 25)" end="(208, 35)">
                          <OtherNode start="(208, 25)" end="(208, 35)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(208, 25)" end="(208, 35)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(208, 35)" end="(208, 36)" leading="" trailing="" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(208, 36)" end="(208, 37)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(208, 38)" end="(208, 56)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;head✝ : α✝&#10;tail✝ : List α✝&#10;tail_ih✝ : find? p tail✝ = none ↔ ∀ (x : α✝), x ∈ tail✝ → ¬p x = true&#10;⊢ (match p head✝ with&#10;      | true =&amp;gt; some head✝&#10;      | false =&amp;gt; find? p tail✝) =&#10;      none ↔&#10;    p head✝ = false ∧ ∀ (a : α✝), a ∈ tail✝ → p a = false" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                    <OtherNode start="(208, 38)" end="(208, 43)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(208, 38)" end="(208, 43)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(208, 44)" end="(208, 47)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(208, 48)" end="(208, 56)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(208, 48)" end="(208, 52)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(208, 53)" end="(208, 56)">
                        <AtomNode start="(208, 53)" end="(208, 54)" leading="" trailing="" val="["/>
                        <NullNode start="(208, 54)" end="(208, 55)">
                          <OtherNode start="(208, 54)" end="(208, 55)" kind="Lean.Parser.Tactic.simpStar">
                            <AtomNode start="(208, 54)" end="(208, 55)" leading="" trailing="" val="*"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(208, 55)" end="(208, 56)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(210, 1)" end="(245, 15)" name="find?_eq_some_iff_append" full_name="List.find?_eq_some_iff_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(210, 1)" end="(245, 15)" name="find?_eq_some_iff_append" full_name="List.find?_eq_some_iff_append" _is_private_decl="False">
        <AtomNode start="(210, 1)" end="(210, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(210, 9)" end="(210, 33)">
          <IdentNode start="(210, 9)" end="(210, 33)" leading="" trailing=" " raw_val="find?_eq_some_iff_append" val="find?_eq_some_iff_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(210, 34)" end="(211, 77)">
          <NullNode/>
          <TermTypespecNode start="(210, 34)" end="(211, 77)">
            <AtomNode start="(210, 34)" end="(210, 35)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(211, 5)" end="(211, 77)" kind="«term_↔_»">
              <OtherNode start="(211, 5)" end="(211, 24)" kind="«term_=_»">
                <OtherNode start="(211, 5)" end="(211, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 5)" end="(211, 13)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                  <NullNode start="(211, 14)" end="(211, 15)">
                    <IdentNode start="(211, 14)" end="(211, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(211, 16)" end="(211, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(211, 18)" end="(211, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 18)" end="(211, 22)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(211, 23)" end="(211, 24)">
                    <IdentNode start="(211, 23)" end="(211, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(211, 25)" end="(211, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(211, 27)" end="(211, 77)" kind="«term_∧_»">
                <OtherNode start="(211, 27)" end="(211, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 27)" end="(211, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(211, 29)" end="(211, 30)">
                    <IdentNode start="(211, 29)" end="(211, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(211, 31)" end="(211, 32)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(211, 33)" end="(211, 77)" kind="«term∃_,_»">
                  <AtomNode start="(211, 33)" end="(211, 34)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(211, 35)" end="(211, 40)" kind="Lean.explicitBinders">
                    <OtherNode start="(211, 35)" end="(211, 40)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(211, 35)" end="(211, 40)">
                        <LeanBinderidentNode start="(211, 35)" end="(211, 37)">
                          <IdentNode start="(211, 35)" end="(211, 37)" leading="" trailing=" " raw_val="as" val="as"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(211, 38)" end="(211, 40)">
                          <IdentNode start="(211, 38)" end="(211, 40)" leading="" trailing="" raw_val="bs" val="bs"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(211, 40)" end="(211, 41)" leading="" trailing=" " val=","/>
                  <OtherNode start="(211, 42)" end="(211, 77)" kind="«term_∧_»">
                    <OtherNode start="(211, 42)" end="(211, 60)" kind="«term_=_»">
                      <IdentNode start="(211, 42)" end="(211, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(211, 45)" end="(211, 46)" leading="" trailing=" " val="="/>
                      <OtherNode start="(211, 47)" end="(211, 60)" kind="«term_++_»">
                        <IdentNode start="(211, 47)" end="(211, 49)" leading="" trailing=" " raw_val="as" val="as"/>
                        <AtomNode start="(211, 50)" end="(211, 52)" leading="" trailing=" " val="++"/>
                        <OtherNode start="(211, 53)" end="(211, 60)" kind="«term_::_»">
                          <IdentNode start="(211, 53)" end="(211, 54)" leading="" trailing=" " raw_val="b" val="b"/>
                          <AtomNode start="(211, 55)" end="(211, 57)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(211, 58)" end="(211, 60)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(211, 61)" end="(211, 62)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(211, 63)" end="(211, 77)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(211, 63)" end="(211, 64)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(211, 65)" end="(211, 66)">
                        <IdentNode start="(211, 65)" end="(211, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(211, 67)" end="(211, 71)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(211, 67)" end="(211, 68)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(211, 69)" end="(211, 71)" leading="" trailing="" raw_val="as" val="as"/>
                      </OtherNode>
                      <AtomNode start="(211, 71)" end="(211, 72)" leading="" trailing=" " val=","/>
                      <OtherNode start="(211, 73)" end="(211, 77)" kind="term!_">
                        <AtomNode start="(211, 73)" end="(211, 74)" leading="" trailing="" val="!"/>
                        <OtherNode start="(211, 74)" end="(211, 77)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(211, 74)" end="(211, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(211, 76)" end="(211, 77)">
                            <IdentNode start="(211, 76)" end="(211, 77)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(211, 78)" end="(245, 15)">
          <AtomNode start="(211, 78)" end="(211, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(211, 81)" end="(245, 15)">
            <AtomNode start="(211, 81)" end="(211, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(212, 3)" end="(245, 15)">
              <TacticTacticseq1IndentedNode start="(212, 3)" end="(245, 15)">
                <NullNode start="(212, 3)" end="(245, 15)">
                  <OtherNode start="(212, 3)" end="(245, 15)" kind="Lean.Parser.Tactic.induction" state_before="α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;xs : List α✝&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [find?_cons, exists_and_right]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · simp only [Option.some.injEq]&#10;    constructor&#10;    · rintro rfl&#10;      exact ⟨h, [], ⟨xs, rfl⟩, by simp⟩&#10;    · rintro ⟨-, ⟨as, ⟨⟨bs, h₁⟩, h₂⟩⟩⟩&#10;      cases as with&#10;      | nil =&amp;gt; simp_all&#10;      | cons a as =&amp;gt;&#10;        specialize h₂ a mem_cons_self&#10;        simp only [cons_append] at h₁&#10;        obtain ⟨rfl, -⟩ := h₁&#10;        simp_all&#10;  · simp only [ih, Bool.not_eq_eq_eq_not, Bool.not_true, exists_and_right, and_congr_right_iff]&#10;    intro pb&#10;    constructor&#10;    · rintro ⟨as, ⟨⟨bs, rfl⟩, h₁⟩⟩&#10;      refine ⟨x :: as, ⟨⟨bs, rfl⟩, ?_⟩⟩&#10;      intro a m&#10;      simp at m&#10;      obtain (rfl|m) := m&#10;      · exact h&#10;      · exact h₁ a m&#10;    · rintro ⟨as, ⟨bs, h₁⟩, h₂⟩&#10;      cases as with&#10;      | nil =&amp;gt; simp_all&#10;      | cons a as =&amp;gt;&#10;        refine ⟨as, ⟨⟨bs, ?_⟩, fun a m =&amp;gt; h₂ a (mem_cons_of_mem _ m)⟩⟩&#10;        cases h₁&#10;        simp">
                    <AtomNode start="(212, 3)" end="(212, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(212, 13)" end="(212, 15)">
                      <OtherNode start="(212, 13)" end="(212, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(212, 13)" end="(212, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(212, 16)" end="(245, 15)">
                      <OtherNode start="(212, 16)" end="(245, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(212, 16)" end="(212, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(213, 3)" end="(245, 15)">
                          <OtherNode start="(213, 3)" end="(213, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(213, 3)" end="(213, 8)">
                              <OtherNode start="(213, 3)" end="(213, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(213, 3)" end="(213, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(213, 5)" end="(213, 8)">
                                  <NullNode/>
                                  <IdentNode start="(213, 5)" end="(213, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(213, 9)" end="(213, 16)">
                              <AtomNode start="(213, 9)" end="(213, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(213, 12)" end="(213, 16)">
                                <TacticTacticseq1IndentedNode start="(213, 12)" end="(213, 16)">
                                  <NullNode start="(213, 12)" end="(213, 16)">
                                    <OtherNode start="(213, 12)" end="(213, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;⊢ find? p [] = some b ↔ p b = true ∧ ∃ as bs, [] = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(213, 12)" end="(213, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(214, 3)" end="(245, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(214, 3)" end="(214, 17)">
                              <OtherNode start="(214, 3)" end="(214, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(214, 3)" end="(214, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(214, 5)" end="(214, 9)">
                                  <NullNode/>
                                  <IdentNode start="(214, 5)" end="(214, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(214, 10)" end="(214, 17)">
                                  <IdentNode start="(214, 10)" end="(214, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(214, 12)" end="(214, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(214, 15)" end="(214, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(214, 18)" end="(245, 15)">
                              <AtomNode start="(214, 18)" end="(214, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(215, 5)" end="(245, 15)">
                                <TacticTacticseq1IndentedNode start="(215, 5)" end="(245, 15)">
                                  <NullNode start="(215, 5)" end="(245, 15)">
                                    <OtherNode start="(215, 5)" end="(215, 45)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;⊢ find? p (x :: xs) = some b ↔ p b = true ∧ ∃ as bs, x :: xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;⊢ (match p x with&#10;      | true =&amp;gt; some x&#10;      | false =&amp;gt; find? p xs) =&#10;      some b ↔&#10;    p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" tactic="simp only [find?_cons, exists_and_right]">
                                      <AtomNode start="(215, 5)" end="(215, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(215, 10)" end="(215, 14)">
                                        <AtomNode start="(215, 10)" end="(215, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(215, 15)" end="(215, 45)">
                                        <AtomNode start="(215, 15)" end="(215, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(215, 16)" end="(215, 44)">
                                          <OtherNode start="(215, 16)" end="(215, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(215, 16)" end="(215, 26)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(215, 26)" end="(215, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(215, 28)" end="(215, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(215, 28)" end="(215, 44)" leading="" trailing="" raw_val="exists_and_right" val="exists_and_right" full_name="exists_and_right" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(215, 44)" end="(215, 45)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(216, 5)" end="(216, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;⊢ (match p x with&#10;      | true =&amp;gt; some x&#10;      | false =&amp;gt; find? p xs) =&#10;      some b ↔&#10;    p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons.h_1&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ some x = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;&#10;case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                      <OtherNode start="(216, 5)" end="(216, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(216, 5)" end="(216, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(216, 11)" end="(216, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(216, 15)" end="(216, 25)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(216, 15)" end="(216, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(216, 24)" end="(216, 25)">
                                          <LeanBinderidentNode start="(216, 24)" end="(216, 25)">
                                            <IdentNode start="(216, 24)" end="(216, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(217, 5)" end="(228, 19)" kind="Lean.cdot" state_before="case cons.h_1&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ some x = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;&#10;case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" tactic="· simp only [Option.some.injEq]&#10;  constructor&#10;  · rintro rfl&#10;    exact ⟨h, [], ⟨xs, rfl⟩, by simp⟩&#10;  · rintro ⟨-, ⟨as, ⟨⟨bs, h₁⟩, h₂⟩⟩⟩&#10;    cases as with&#10;    | nil =&amp;gt; simp_all&#10;    | cons a as =&amp;gt;&#10;      specialize h₂ a mem_cons_self&#10;      simp only [cons_append] at h₁&#10;      obtain ⟨rfl, -⟩ := h₁&#10;      simp_all">
                                      <OtherNode start="(217, 5)" end="(217, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(217, 5)" end="(217, 6)" kind="patternIgnore">
                                          <OtherNode start="(217, 5)" end="(217, 6)" kind="token.«· »">
                                            <AtomNode start="(217, 5)" end="(217, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(217, 7)" end="(228, 19)">
                                        <TacticTacticseq1IndentedNode start="(217, 7)" end="(228, 19)">
                                          <NullNode start="(217, 7)" end="(228, 19)">
                                            <OtherNode start="(217, 7)" end="(217, 36)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ some x = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons.h_1&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ x = b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" tactic="simp only [Option.some.injEq]">
                                              <AtomNode start="(217, 7)" end="(217, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(217, 12)" end="(217, 16)">
                                                <AtomNode start="(217, 12)" end="(217, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(217, 17)" end="(217, 36)">
                                                <AtomNode start="(217, 17)" end="(217, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(217, 18)" end="(217, 35)">
                                                  <OtherNode start="(217, 18)" end="(217, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(217, 18)" end="(217, 35)" leading="" trailing="" raw_val="Option.some.injEq" val="Option.some.injEq" full_name="Option.some.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(217, 35)" end="(217, 36)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(218, 7)" end="(218, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.h_1&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ x = b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons.h_1.mp&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ x = b → p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;&#10;case cons.h_1.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ (p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true) → x = b" tactic="constructor">
                                              <AtomNode start="(218, 7)" end="(218, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(219, 7)" end="(220, 42)" kind="Lean.cdot" state_before="case cons.h_1.mp&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ x = b → p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;&#10;case cons.h_1.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ (p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true) → x = b" state_after="case cons.h_1.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ (p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true) → x = b" tactic="· rintro rfl&#10;  exact ⟨h, [], ⟨xs, rfl⟩, by simp⟩">
                                              <OtherNode start="(219, 7)" end="(219, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(219, 7)" end="(219, 8)" kind="patternIgnore">
                                                  <OtherNode start="(219, 7)" end="(219, 8)" kind="token.«· »">
                                                    <AtomNode start="(219, 7)" end="(219, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(219, 9)" end="(220, 42)">
                                                <TacticTacticseq1IndentedNode start="(219, 9)" end="(220, 42)">
                                                  <NullNode start="(219, 9)" end="(220, 42)">
                                                    <OtherNode start="(219, 9)" end="(219, 19)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_1.mp&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ x = b → p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons.h_1.mp&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;x✝ : Bool&#10;h : p x = true&#10;ih : find? p xs = some x ↔ p x = true ∧ ∃ as bs, xs = as ++ x :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;⊢ p x = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ x :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" tactic="rintro rfl">
                                                      <AtomNode start="(219, 9)" end="(219, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(219, 16)" end="(219, 19)">
                                                        <OtherNode start="(219, 16)" end="(219, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(219, 16)" end="(219, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(219, 16)" end="(219, 19)" leading="" trailing="&#10;        " raw_val="rfl" val="rfl"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(220, 9)" end="(220, 42)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_1.mp&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;x✝ : Bool&#10;h : p x = true&#10;ih : find? p xs = some x ↔ p x = true ∧ ∃ as bs, xs = as ++ x :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;⊢ p x = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ x :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="no goals" tactic="exact ⟨h, [], ⟨xs, rfl⟩, by simp⟩">
                                                      <AtomNode start="(220, 9)" end="(220, 14)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(220, 15)" end="(220, 42)" kind="Lean.Parser.Term.anonymousCtor">
                                                        <AtomNode start="(220, 15)" end="(220, 16)" leading="" trailing="" val="⟨"/>
                                                        <NullNode start="(220, 16)" end="(220, 41)">
                                                          <IdentNode start="(220, 16)" end="(220, 17)" leading="" trailing="" raw_val="h" val="h"/>
                                                          <AtomNode start="(220, 17)" end="(220, 18)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(220, 19)" end="(220, 21)" kind="«term[_]»">
                                                            <AtomNode start="(220, 19)" end="(220, 20)" leading="" trailing="" val="["/>
                                                            <NullNode/>
                                                            <AtomNode start="(220, 20)" end="(220, 21)" leading="" trailing="" val="]"/>
                                                          </OtherNode>
                                                          <AtomNode start="(220, 21)" end="(220, 22)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(220, 23)" end="(220, 32)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(220, 23)" end="(220, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(220, 24)" end="(220, 31)">
                                                            <IdentNode start="(220, 24)" end="(220, 26)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            <AtomNode start="(220, 26)" end="(220, 27)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(220, 28)" end="(220, 31)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            <AtomNode start="(220, 31)" end="(220, 32)" leading="" trailing="" val="⟩"/>
                                                          </OtherNode>
                                                          <AtomNode start="(220, 32)" end="(220, 33)" leading="" trailing=" " val=","/>
                                                          <TermBytacticNode start="(220, 34)" end="(220, 41)">
                                                            <AtomNode start="(220, 34)" end="(220, 36)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(220, 37)" end="(220, 41)">
                                                            <TacticTacticseq1IndentedNode start="(220, 37)" end="(220, 41)">
                                                            <NullNode start="(220, 37)" end="(220, 41)">
                                                            <OtherNode start="(220, 37)" end="(220, 41)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;x✝ : Bool&#10;h : p x = true&#10;ih : find? p xs = some x ↔ p x = true ∧ ∃ as bs, xs = as ++ x :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;⊢ ∀ (a : α✝), a ∈ [] → (!p a) = true" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(220, 37)" end="(220, 41)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                        </NullNode>
                                                        <AtomNode start="(220, 41)" end="(220, 42)" leading="" trailing="&#10;      " val="⟩"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(221, 7)" end="(228, 19)" kind="Lean.cdot" state_before="case cons.h_1.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ (p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true) → x = b" state_after="no goals" tactic="· rintro ⟨-, ⟨as, ⟨⟨bs, h₁⟩, h₂⟩⟩⟩&#10;  cases as with&#10;  | nil =&amp;gt; simp_all&#10;  | cons a as =&amp;gt;&#10;    specialize h₂ a mem_cons_self&#10;    simp only [cons_append] at h₁&#10;    obtain ⟨rfl, -⟩ := h₁&#10;    simp_all">
                                              <OtherNode start="(221, 7)" end="(221, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(221, 7)" end="(221, 8)" kind="patternIgnore">
                                                  <OtherNode start="(221, 7)" end="(221, 8)" kind="token.«· »">
                                                    <AtomNode start="(221, 7)" end="(221, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(221, 9)" end="(228, 19)">
                                                <TacticTacticseq1IndentedNode start="(221, 9)" end="(228, 19)">
                                                  <NullNode start="(221, 9)" end="(228, 19)">
                                                    <OtherNode start="(221, 9)" end="(221, 41)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_1.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;⊢ (p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true) → x = b" state_after="case cons.h_1.mpr.intro.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;as : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ as → (!p a) = true&#10;bs : List α✝&#10;h₁ : x :: xs = as ++ b :: bs&#10;⊢ x = b" tactic="rintro ⟨-, ⟨as, ⟨⟨bs, h₁⟩, h₂⟩⟩⟩">
                                                      <AtomNode start="(221, 9)" end="(221, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(221, 16)" end="(221, 41)">
                                                        <OtherNode start="(221, 16)" end="(221, 41)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(221, 16)" end="(221, 41)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(221, 16)" end="(221, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(221, 17)" end="(221, 40)">
                                                            <OtherNode start="(221, 17)" end="(221, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 17)" end="(221, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 17)" end="(221, 18)">
                                                            <OtherNode start="(221, 17)" end="(221, 18)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                                            <AtomNode start="(221, 17)" end="(221, 18)" leading="" trailing="" val="-"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(221, 18)" end="(221, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(221, 20)" end="(221, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 20)" end="(221, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 20)" end="(221, 40)">
                                                            <OtherNode start="(221, 20)" end="(221, 40)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(221, 20)" end="(221, 21)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(221, 21)" end="(221, 39)">
                                                            <OtherNode start="(221, 21)" end="(221, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 21)" end="(221, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 21)" end="(221, 23)">
                                                            <OtherNode start="(221, 21)" end="(221, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(221, 21)" end="(221, 23)" leading="" trailing="" raw_val="as" val="as"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(221, 23)" end="(221, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(221, 25)" end="(221, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 25)" end="(221, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 25)" end="(221, 39)">
                                                            <OtherNode start="(221, 25)" end="(221, 39)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(221, 25)" end="(221, 26)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(221, 26)" end="(221, 38)">
                                                            <OtherNode start="(221, 26)" end="(221, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 26)" end="(221, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 26)" end="(221, 34)">
                                                            <OtherNode start="(221, 26)" end="(221, 34)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(221, 26)" end="(221, 27)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(221, 27)" end="(221, 33)">
                                                            <OtherNode start="(221, 27)" end="(221, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 27)" end="(221, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 27)" end="(221, 29)">
                                                            <OtherNode start="(221, 27)" end="(221, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(221, 27)" end="(221, 29)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(221, 29)" end="(221, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(221, 31)" end="(221, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 31)" end="(221, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 31)" end="(221, 33)">
                                                            <OtherNode start="(221, 31)" end="(221, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(221, 31)" end="(221, 33)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(221, 33)" end="(221, 34)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(221, 34)" end="(221, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(221, 36)" end="(221, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(221, 36)" end="(221, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(221, 36)" end="(221, 38)">
                                                            <OtherNode start="(221, 36)" end="(221, 38)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(221, 36)" end="(221, 38)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(221, 38)" end="(221, 39)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(221, 39)" end="(221, 40)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(221, 40)" end="(221, 41)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(222, 9)" end="(228, 19)" kind="Lean.Parser.Tactic.cases" state_before="case cons.h_1.mpr.intro.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;as : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ as → (!p a) = true&#10;bs : List α✝&#10;h₁ : x :: xs = as ++ b :: bs&#10;⊢ x = b" state_after="no goals" tactic="cases as with&#10;| nil =&amp;gt; simp_all&#10;| cons a as =&amp;gt;&#10;  specialize h₂ a mem_cons_self&#10;  simp only [cons_append] at h₁&#10;  obtain ⟨rfl, -⟩ := h₁&#10;  simp_all">
                                                      <AtomNode start="(222, 9)" end="(222, 14)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(222, 15)" end="(222, 17)">
                                                        <OtherNode start="(222, 15)" end="(222, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(222, 15)" end="(222, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(222, 18)" end="(228, 19)">
                                                        <OtherNode start="(222, 18)" end="(228, 19)" kind="Lean.Parser.Tactic.inductionAlts">
                                                          <AtomNode start="(222, 18)" end="(222, 22)" leading="" trailing="&#10;        " val="with"/>
                                                          <NullNode/>
                                                          <NullNode start="(223, 9)" end="(228, 19)">
                                                            <OtherNode start="(223, 9)" end="(223, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(223, 9)" end="(223, 14)">
                                                            <OtherNode start="(223, 9)" end="(223, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(223, 9)" end="(223, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(223, 11)" end="(223, 14)">
                                                            <NullNode/>
                                                            <IdentNode start="(223, 11)" end="(223, 14)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(223, 15)" end="(223, 26)">
                                                            <AtomNode start="(223, 15)" end="(223, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(223, 18)" end="(223, 26)">
                                                            <TacticTacticseq1IndentedNode start="(223, 18)" end="(223, 26)">
                                                            <NullNode start="(223, 18)" end="(223, 26)">
                                                            <OtherNode start="(223, 18)" end="(223, 26)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_1.mpr.intro.intro.intro.intro.nil&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;bs : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ [] → (!p a) = true&#10;h₁ : x :: xs = [] ++ b :: bs&#10;⊢ x = b" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(223, 18)" end="(223, 26)" leading="" trailing="&#10;        " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(224, 9)" end="(228, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(224, 9)" end="(224, 20)">
                                                            <OtherNode start="(224, 9)" end="(224, 20)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(224, 9)" end="(224, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(224, 11)" end="(224, 15)">
                                                            <NullNode/>
                                                            <IdentNode start="(224, 11)" end="(224, 15)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(224, 16)" end="(224, 20)">
                                                            <IdentNode start="(224, 16)" end="(224, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(224, 18)" end="(224, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(224, 21)" end="(228, 19)">
                                                            <AtomNode start="(224, 21)" end="(224, 23)" leading="" trailing="&#10;          " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(225, 11)" end="(228, 19)">
                                                            <TacticTacticseq1IndentedNode start="(225, 11)" end="(228, 19)">
                                                            <NullNode start="(225, 11)" end="(228, 19)">
                                                            <OtherNode start="(225, 11)" end="(225, 40)" kind="Lean.Parser.Tactic.specialize" state_before="case cons.h_1.mpr.intro.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₂ : ∀ (a_1 : α✝), a_1 ∈ a :: as → (!p a_1) = true&#10;h₁ : x :: xs = a :: as ++ b :: bs&#10;⊢ x = b" state_after="case cons.h_1.mpr.intro.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₁ : x :: xs = a :: as ++ b :: bs&#10;h₂ : (!p a) = true&#10;⊢ x = b" tactic="specialize h₂ a mem_cons_self">
                                                            <AtomNode start="(225, 11)" end="(225, 21)" leading="" trailing=" " val="specialize"/>
                                                            <OtherNode start="(225, 22)" end="(225, 40)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(225, 22)" end="(225, 24)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            <NullNode start="(225, 25)" end="(225, 40)">
                                                            <IdentNode start="(225, 25)" end="(225, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(225, 27)" end="(225, 40)" leading="" trailing="&#10;          " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(226, 11)" end="(226, 40)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_1.mpr.intro.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₁ : x :: xs = a :: as ++ b :: bs&#10;h₂ : (!p a) = true&#10;⊢ x = b" state_after="case cons.h_1.mpr.intro.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₁ : x :: xs = a :: (as ++ b :: bs)&#10;h₂ : (!p a) = true&#10;⊢ x = b" tactic="simp only [cons_append] at h₁">
                                                            <AtomNode start="(226, 11)" end="(226, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(226, 16)" end="(226, 20)">
                                                            <AtomNode start="(226, 16)" end="(226, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(226, 21)" end="(226, 34)">
                                                            <AtomNode start="(226, 21)" end="(226, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(226, 22)" end="(226, 33)">
                                                            <OtherNode start="(226, 22)" end="(226, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(226, 22)" end="(226, 33)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(226, 33)" end="(226, 34)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(226, 35)" end="(226, 40)">
                                                            <OtherNode start="(226, 35)" end="(226, 40)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(226, 35)" end="(226, 37)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(226, 38)" end="(226, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(226, 38)" end="(226, 40)">
                                                            <IdentNode start="(226, 38)" end="(226, 40)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(227, 11)" end="(227, 32)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.h_1.mpr.intro.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₁ : x :: xs = a :: (as ++ b :: bs)&#10;h₂ : (!p a) = true&#10;⊢ x = b" state_after="case cons.h_1.mpr.intro.intro.intro.intro.cons.refl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = true&#10;bs as : List α✝&#10;h₂ : (!p x) = true&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ x = b" tactic="obtain ⟨rfl, -⟩ := h₁">
                                                            <AtomNode start="(227, 11)" end="(227, 17)" leading="" trailing=" " val="obtain"/>
                                                            <NullNode start="(227, 18)" end="(227, 26)">
                                                            <OtherNode start="(227, 18)" end="(227, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(227, 18)" end="(227, 26)">
                                                            <OtherNode start="(227, 18)" end="(227, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(227, 18)" end="(227, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(227, 19)" end="(227, 25)">
                                                            <OtherNode start="(227, 19)" end="(227, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(227, 19)" end="(227, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(227, 19)" end="(227, 22)">
                                                            <OtherNode start="(227, 19)" end="(227, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(227, 19)" end="(227, 22)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(227, 22)" end="(227, 23)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(227, 24)" end="(227, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(227, 24)" end="(227, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(227, 24)" end="(227, 25)">
                                                            <OtherNode start="(227, 24)" end="(227, 25)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                                            <AtomNode start="(227, 24)" end="(227, 25)" leading="" trailing="" val="-"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(227, 25)" end="(227, 26)" leading="" trailing=" " val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode start="(227, 27)" end="(227, 32)">
                                                            <AtomNode start="(227, 27)" end="(227, 29)" leading="" trailing=" " val=":="/>
                                                            <NullNode start="(227, 30)" end="(227, 32)">
                                                            <IdentNode start="(227, 30)" end="(227, 32)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </NullNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(228, 11)" end="(228, 19)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_1.mpr.intro.intro.intro.intro.cons.refl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = true&#10;bs as : List α✝&#10;h₂ : (!p x) = true&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ x = b" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(228, 11)" end="(228, 19)" leading="" trailing="&#10;    " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(229, 5)" end="(245, 15)" kind="Lean.cdot" state_before="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="no goals" tactic="· simp only [ih, Bool.not_eq_eq_eq_not, Bool.not_true, exists_and_right, and_congr_right_iff]&#10;  intro pb&#10;  constructor&#10;  · rintro ⟨as, ⟨⟨bs, rfl⟩, h₁⟩⟩&#10;    refine ⟨x :: as, ⟨⟨bs, rfl⟩, ?_⟩⟩&#10;    intro a m&#10;    simp at m&#10;    obtain (rfl|m) := m&#10;    · exact h&#10;    · exact h₁ a m&#10;  · rintro ⟨as, ⟨bs, h₁⟩, h₂⟩&#10;    cases as with&#10;    | nil =&amp;gt; simp_all&#10;    | cons a as =&amp;gt;&#10;      refine ⟨as, ⟨⟨bs, ?_⟩, fun a m =&amp;gt; h₂ a (mem_cons_of_mem _ m)⟩⟩&#10;      cases h₁&#10;      simp">
                                      <OtherNode start="(229, 5)" end="(229, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(229, 5)" end="(229, 6)" kind="patternIgnore">
                                          <OtherNode start="(229, 5)" end="(229, 6)" kind="token.«· »">
                                            <AtomNode start="(229, 5)" end="(229, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(229, 7)" end="(245, 15)">
                                        <TacticTacticseq1IndentedNode start="(229, 7)" end="(245, 15)">
                                          <NullNode start="(229, 7)" end="(245, 15)">
                                            <OtherNode start="(229, 7)" end="(229, 98)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → (!p a) = true" state_after="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ p b = true →&#10;    ((∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) ↔&#10;      ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false)" tactic="simp only [ih, Bool.not_eq_eq_eq_not, Bool.not_true, exists_and_right, and_congr_right_iff]">
                                              <AtomNode start="(229, 7)" end="(229, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(229, 12)" end="(229, 16)">
                                                <AtomNode start="(229, 12)" end="(229, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(229, 17)" end="(229, 98)">
                                                <AtomNode start="(229, 17)" end="(229, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(229, 18)" end="(229, 97)">
                                                  <OtherNode start="(229, 18)" end="(229, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(229, 18)" end="(229, 20)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(229, 20)" end="(229, 21)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(229, 22)" end="(229, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(229, 22)" end="(229, 43)" leading="" trailing="" raw_val="Bool.not_eq_eq_eq_not" val="Bool.not_eq_eq_eq_not" full_name="Bool.not_eq_eq_eq_not" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(229, 43)" end="(229, 44)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(229, 45)" end="(229, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(229, 45)" end="(229, 58)" leading="" trailing="" raw_val="Bool.not_true" val="Bool.not_true" full_name="Bool.not_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(229, 58)" end="(229, 59)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(229, 60)" end="(229, 76)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(229, 60)" end="(229, 76)" leading="" trailing="" raw_val="exists_and_right" val="exists_and_right" full_name="exists_and_right" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(229, 76)" end="(229, 77)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(229, 78)" end="(229, 97)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(229, 78)" end="(229, 97)" leading="" trailing="" raw_val="and_congr_right_iff" val="and_congr_right_iff" full_name="and_congr_right_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(229, 97)" end="(229, 98)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(230, 7)" end="(230, 15)" kind="Lean.Parser.Tactic.intro" state_before="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;⊢ p b = true →&#10;    ((∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) ↔&#10;      ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false)" state_after="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) ↔&#10;    ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false" tactic="intro pb">
                                              <AtomNode start="(230, 7)" end="(230, 12)" leading="" trailing=" " val="intro"/>
                                              <NullNode start="(230, 13)" end="(230, 15)">
                                                <IdentNode start="(230, 13)" end="(230, 15)" leading="" trailing="&#10;      " raw_val="pb" val="pb"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(231, 7)" end="(231, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.h_2&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) ↔&#10;    ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="case cons.h_2.mp&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false&#10;&#10;case cons.h_2.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" tactic="constructor">
                                              <AtomNode start="(231, 7)" end="(231, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(232, 7)" end="(238, 23)" kind="Lean.cdot" state_before="case cons.h_2.mp&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false&#10;&#10;case cons.h_2.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="case cons.h_2.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" tactic="· rintro ⟨as, ⟨⟨bs, rfl⟩, h₁⟩⟩&#10;  refine ⟨x :: as, ⟨⟨bs, rfl⟩, ?_⟩⟩&#10;  intro a m&#10;  simp at m&#10;  obtain (rfl|m) := m&#10;  · exact h&#10;  · exact h₁ a m">
                                              <OtherNode start="(232, 7)" end="(232, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(232, 7)" end="(232, 8)" kind="patternIgnore">
                                                  <OtherNode start="(232, 7)" end="(232, 8)" kind="token.«· »">
                                                    <AtomNode start="(232, 7)" end="(232, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(232, 9)" end="(238, 23)">
                                                <TacticTacticseq1IndentedNode start="(232, 9)" end="(238, 23)">
                                                  <NullNode start="(232, 9)" end="(238, 23)">
                                                    <OtherNode start="(232, 9)" end="(232, 37)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_2.mp&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ ∃ as_1, (∃ x_1, x :: (as ++ b :: bs) = as_1 ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as_1 → p a = false" tactic="rintro ⟨as, ⟨⟨bs, rfl⟩, h₁⟩⟩">
                                                      <AtomNode start="(232, 9)" end="(232, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(232, 16)" end="(232, 37)">
                                                        <OtherNode start="(232, 16)" end="(232, 37)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(232, 16)" end="(232, 37)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(232, 16)" end="(232, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(232, 17)" end="(232, 36)">
                                                            <OtherNode start="(232, 17)" end="(232, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(232, 17)" end="(232, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(232, 17)" end="(232, 19)">
                                                            <OtherNode start="(232, 17)" end="(232, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(232, 17)" end="(232, 19)" leading="" trailing="" raw_val="as" val="as"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(232, 19)" end="(232, 20)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(232, 21)" end="(232, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(232, 21)" end="(232, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(232, 21)" end="(232, 36)">
                                                            <OtherNode start="(232, 21)" end="(232, 36)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(232, 21)" end="(232, 22)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(232, 22)" end="(232, 35)">
                                                            <OtherNode start="(232, 22)" end="(232, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(232, 22)" end="(232, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(232, 22)" end="(232, 31)">
                                                            <OtherNode start="(232, 22)" end="(232, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(232, 22)" end="(232, 23)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(232, 23)" end="(232, 30)">
                                                            <OtherNode start="(232, 23)" end="(232, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(232, 23)" end="(232, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(232, 23)" end="(232, 25)">
                                                            <OtherNode start="(232, 23)" end="(232, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(232, 23)" end="(232, 25)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(232, 25)" end="(232, 26)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(232, 27)" end="(232, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(232, 27)" end="(232, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(232, 27)" end="(232, 30)">
                                                            <OtherNode start="(232, 27)" end="(232, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(232, 27)" end="(232, 30)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(232, 30)" end="(232, 31)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(232, 31)" end="(232, 32)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(232, 33)" end="(232, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(232, 33)" end="(232, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(232, 33)" end="(232, 35)">
                                                            <OtherNode start="(232, 33)" end="(232, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(232, 33)" end="(232, 35)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(232, 35)" end="(232, 36)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(232, 36)" end="(232, 37)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(233, 9)" end="(233, 42)" kind="Lean.Parser.Tactic.refine" state_before="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ ∃ as_1, (∃ x_1, x :: (as ++ b :: bs) = as_1 ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as_1 → p a = false" state_after="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ ∀ (a : α✝), a ∈ x :: as → p a = false" tactic="refine ⟨x :: as, ⟨⟨bs, rfl⟩, ?_⟩⟩">
                                                      <AtomNode start="(233, 9)" end="(233, 15)" leading="" trailing=" " val="refine"/>
                                                      <OtherNode start="(233, 16)" end="(233, 42)" kind="Lean.Parser.Term.anonymousCtor">
                                                        <AtomNode start="(233, 16)" end="(233, 17)" leading="" trailing="" val="⟨"/>
                                                        <NullNode start="(233, 17)" end="(233, 41)">
                                                          <OtherNode start="(233, 17)" end="(233, 24)" kind="«term_::_»">
                                                            <IdentNode start="(233, 17)" end="(233, 18)" leading="" trailing=" " raw_val="x" val="x"/>
                                                            <AtomNode start="(233, 19)" end="(233, 21)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(233, 22)" end="(233, 24)" leading="" trailing="" raw_val="as" val="as"/>
                                                          </OtherNode>
                                                          <AtomNode start="(233, 24)" end="(233, 25)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(233, 26)" end="(233, 41)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(233, 26)" end="(233, 27)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(233, 27)" end="(233, 40)">
                                                            <OtherNode start="(233, 27)" end="(233, 36)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(233, 27)" end="(233, 28)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(233, 28)" end="(233, 35)">
                                                            <IdentNode start="(233, 28)" end="(233, 30)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            <AtomNode start="(233, 30)" end="(233, 31)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(233, 32)" end="(233, 35)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            <AtomNode start="(233, 35)" end="(233, 36)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 36)" end="(233, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(233, 38)" end="(233, 40)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(233, 38)" end="(233, 39)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(233, 39)" end="(233, 40)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(233, 40)" end="(233, 41)" leading="" trailing="" val="⟩"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(233, 41)" end="(233, 42)" leading="" trailing="&#10;        " val="⟩"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(234, 9)" end="(234, 18)" kind="Lean.Parser.Tactic.intro" state_before="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ ∀ (a : α✝), a ∈ x :: as → p a = false" state_after="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ x :: as&#10;⊢ p a = false" tactic="intro a m">
                                                      <AtomNode start="(234, 9)" end="(234, 14)" leading="" trailing=" " val="intro"/>
                                                      <NullNode start="(234, 15)" end="(234, 18)">
                                                        <IdentNode start="(234, 15)" end="(234, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <IdentNode start="(234, 17)" end="(234, 18)" leading="" trailing="&#10;        " raw_val="m" val="m"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(235, 9)" end="(235, 18)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ x :: as&#10;⊢ p a = false" state_after="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a = x ∨ a ∈ as&#10;⊢ p a = false" tactic="simp at m">
                                                      <AtomNode start="(235, 9)" end="(235, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(235, 14)" end="(235, 18)">
                                                        <OtherNode start="(235, 14)" end="(235, 18)" kind="Lean.Parser.Tactic.location">
                                                          <AtomNode start="(235, 14)" end="(235, 16)" leading="" trailing=" " val="at"/>
                                                          <OtherNode start="(235, 17)" end="(235, 18)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(235, 17)" end="(235, 18)">
                                                            <IdentNode start="(235, 17)" end="(235, 18)" leading="" trailing="&#10;        " raw_val="m" val="m"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(236, 9)" end="(236, 28)" kind="Lean.Parser.Tactic.obtain" state_before="case cons.h_2.mp.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a = x ∨ a ∈ as&#10;⊢ p a = false" state_after="case cons.h_2.mp.intro.intro.intro.inl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x✝ : Bool&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;h : p a = false&#10;⊢ p a = false&#10;&#10;case cons.h_2.mp.intro.intro.intro.inr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ as&#10;⊢ p a = false" tactic="obtain (rfl|m) := m">
                                                      <AtomNode start="(236, 9)" end="(236, 15)" leading="" trailing=" " val="obtain"/>
                                                      <NullNode start="(236, 16)" end="(236, 23)">
                                                        <OtherNode start="(236, 16)" end="(236, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                          <NullNode start="(236, 16)" end="(236, 23)">
                                                            <OtherNode start="(236, 16)" end="(236, 23)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(236, 16)" end="(236, 17)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(236, 17)" end="(236, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(236, 17)" end="(236, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(236, 17)" end="(236, 22)">
                                                            <OtherNode start="(236, 17)" end="(236, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(236, 17)" end="(236, 20)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            <AtomNode start="(236, 20)" end="(236, 21)" leading="" trailing="" val="|"/>
                                                            <OtherNode start="(236, 21)" end="(236, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(236, 21)" end="(236, 22)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(236, 22)" end="(236, 23)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(236, 24)" end="(236, 28)">
                                                        <AtomNode start="(236, 24)" end="(236, 26)" leading="" trailing=" " val=":="/>
                                                        <NullNode start="(236, 27)" end="(236, 28)">
                                                          <IdentNode start="(236, 27)" end="(236, 28)" leading="" trailing="&#10;        " raw_val="m" val="m"/>
                                                        </NullNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(237, 9)" end="(237, 18)" kind="Lean.cdot" state_before="case cons.h_2.mp.intro.intro.intro.inl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x✝ : Bool&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;h : p a = false&#10;⊢ p a = false&#10;&#10;case cons.h_2.mp.intro.intro.intro.inr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ as&#10;⊢ p a = false" state_after="case cons.h_2.mp.intro.intro.intro.inr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ as&#10;⊢ p a = false" tactic="· exact h">
                                                      <OtherNode start="(237, 9)" end="(237, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(237, 9)" end="(237, 10)" kind="patternIgnore">
                                                          <OtherNode start="(237, 9)" end="(237, 10)" kind="token.«· »">
                                                            <AtomNode start="(237, 9)" end="(237, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(237, 11)" end="(237, 18)">
                                                        <TacticTacticseq1IndentedNode start="(237, 11)" end="(237, 18)">
                                                          <NullNode start="(237, 11)" end="(237, 18)">
                                                            <OtherNode start="(237, 11)" end="(237, 18)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_2.mp.intro.intro.intro.inl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x✝ : Bool&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;h : p a = false&#10;⊢ p a = false" state_after="no goals" tactic="exact h">
                                                            <AtomNode start="(237, 11)" end="(237, 16)" leading="" trailing=" " val="exact"/>
                                                            <IdentNode start="(237, 17)" end="(237, 18)" leading="" trailing="&#10;        " raw_val="h" val="h"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(238, 9)" end="(238, 23)" kind="Lean.cdot" state_before="case cons.h_2.mp.intro.intro.intro.inr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ as&#10;⊢ p a = false" state_after="no goals" tactic="· exact h₁ a m">
                                                      <OtherNode start="(238, 9)" end="(238, 10)" kind="Lean.cdotTk">
                                                        <OtherNode start="(238, 9)" end="(238, 10)" kind="patternIgnore">
                                                          <OtherNode start="(238, 9)" end="(238, 10)" kind="token.«· »">
                                                            <AtomNode start="(238, 9)" end="(238, 10)" leading="" trailing=" " val="·"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <TacticTacticseqNode start="(238, 11)" end="(238, 23)">
                                                        <TacticTacticseq1IndentedNode start="(238, 11)" end="(238, 23)">
                                                          <NullNode start="(238, 11)" end="(238, 23)">
                                                            <OtherNode start="(238, 11)" end="(238, 23)" kind="Lean.Parser.Tactic.exact" state_before="case cons.h_2.mp.intro.intro.intro.inr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₁ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;ih :&#10;  find? p (as ++ b :: bs) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as ++ b :: bs = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;a : α✝&#10;m : a ∈ as&#10;⊢ p a = false" state_after="no goals" tactic="exact h₁ a m">
                                                            <AtomNode start="(238, 11)" end="(238, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(238, 17)" end="(238, 23)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(238, 17)" end="(238, 19)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                            <NullNode start="(238, 20)" end="(238, 23)">
                                                            <IdentNode start="(238, 20)" end="(238, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(238, 22)" end="(238, 23)" leading="" trailing="&#10;      " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(239, 7)" end="(245, 15)" kind="Lean.cdot" state_before="case cons.h_2.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="no goals" tactic="· rintro ⟨as, ⟨bs, h₁⟩, h₂⟩&#10;  cases as with&#10;  | nil =&amp;gt; simp_all&#10;  | cons a as =&amp;gt;&#10;    refine ⟨as, ⟨⟨bs, ?_⟩, fun a m =&amp;gt; h₂ a (mem_cons_of_mem _ m)⟩⟩&#10;    cases h₁&#10;    simp">
                                              <OtherNode start="(239, 7)" end="(239, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(239, 7)" end="(239, 8)" kind="patternIgnore">
                                                  <OtherNode start="(239, 7)" end="(239, 8)" kind="token.«· »">
                                                    <AtomNode start="(239, 7)" end="(239, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(239, 9)" end="(245, 15)">
                                                <TacticTacticseq1IndentedNode start="(239, 9)" end="(245, 15)">
                                                  <NullNode start="(239, 9)" end="(245, 15)">
                                                    <OtherNode start="(239, 9)" end="(239, 34)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.h_2.mpr&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;⊢ (∃ as, (∃ x_1, x :: xs = as ++ b :: x_1) ∧ ∀ (a : α✝), a ∈ as → p a = false) →&#10;    ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="case cons.h_2.mpr.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;h₁ : x :: xs = as ++ b :: bs&#10;⊢ ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" tactic="rintro ⟨as, ⟨bs, h₁⟩, h₂⟩">
                                                      <AtomNode start="(239, 9)" end="(239, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(239, 16)" end="(239, 34)">
                                                        <OtherNode start="(239, 16)" end="(239, 34)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(239, 16)" end="(239, 34)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(239, 16)" end="(239, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(239, 17)" end="(239, 33)">
                                                            <OtherNode start="(239, 17)" end="(239, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(239, 17)" end="(239, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(239, 17)" end="(239, 19)">
                                                            <OtherNode start="(239, 17)" end="(239, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(239, 17)" end="(239, 19)" leading="" trailing="" raw_val="as" val="as"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(239, 19)" end="(239, 20)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(239, 21)" end="(239, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(239, 21)" end="(239, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(239, 21)" end="(239, 29)">
                                                            <OtherNode start="(239, 21)" end="(239, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(239, 21)" end="(239, 22)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(239, 22)" end="(239, 28)">
                                                            <OtherNode start="(239, 22)" end="(239, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(239, 22)" end="(239, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(239, 22)" end="(239, 24)">
                                                            <OtherNode start="(239, 22)" end="(239, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(239, 22)" end="(239, 24)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(239, 24)" end="(239, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(239, 26)" end="(239, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(239, 26)" end="(239, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(239, 26)" end="(239, 28)">
                                                            <OtherNode start="(239, 26)" end="(239, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(239, 26)" end="(239, 28)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(239, 28)" end="(239, 29)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(239, 29)" end="(239, 30)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(239, 31)" end="(239, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(239, 31)" end="(239, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(239, 31)" end="(239, 33)">
                                                            <OtherNode start="(239, 31)" end="(239, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(239, 31)" end="(239, 33)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(239, 33)" end="(239, 34)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(240, 9)" end="(245, 15)" kind="Lean.Parser.Tactic.cases" state_before="case cons.h_2.mpr.intro.intro.intro&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;as : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ as → p a = false&#10;bs : List α✝&#10;h₁ : x :: xs = as ++ b :: bs&#10;⊢ ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="no goals" tactic="cases as with&#10;| nil =&amp;gt; simp_all&#10;| cons a as =&amp;gt;&#10;  refine ⟨as, ⟨⟨bs, ?_⟩, fun a m =&amp;gt; h₂ a (mem_cons_of_mem _ m)⟩⟩&#10;  cases h₁&#10;  simp">
                                                      <AtomNode start="(240, 9)" end="(240, 14)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(240, 15)" end="(240, 17)">
                                                        <OtherNode start="(240, 15)" end="(240, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(240, 15)" end="(240, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(240, 18)" end="(245, 15)">
                                                        <OtherNode start="(240, 18)" end="(245, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                                                          <AtomNode start="(240, 18)" end="(240, 22)" leading="" trailing="&#10;        " val="with"/>
                                                          <NullNode/>
                                                          <NullNode start="(241, 9)" end="(245, 15)">
                                                            <OtherNode start="(241, 9)" end="(241, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(241, 9)" end="(241, 14)">
                                                            <OtherNode start="(241, 9)" end="(241, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(241, 9)" end="(241, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(241, 11)" end="(241, 14)">
                                                            <NullNode/>
                                                            <IdentNode start="(241, 11)" end="(241, 14)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(241, 15)" end="(241, 26)">
                                                            <AtomNode start="(241, 15)" end="(241, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(241, 18)" end="(241, 26)">
                                                            <TacticTacticseq1IndentedNode start="(241, 18)" end="(241, 26)">
                                                            <NullNode start="(241, 18)" end="(241, 26)">
                                                            <OtherNode start="(241, 18)" end="(241, 26)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.h_2.mpr.intro.intro.intro.nil&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;bs : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ [] → p a = false&#10;h₁ : x :: xs = [] ++ b :: bs&#10;⊢ ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(241, 18)" end="(241, 26)" leading="" trailing="&#10;        " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(242, 9)" end="(245, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(242, 9)" end="(242, 20)">
                                                            <OtherNode start="(242, 9)" end="(242, 20)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(242, 9)" end="(242, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(242, 11)" end="(242, 15)">
                                                            <NullNode/>
                                                            <IdentNode start="(242, 11)" end="(242, 15)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(242, 16)" end="(242, 20)">
                                                            <IdentNode start="(242, 16)" end="(242, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(242, 18)" end="(242, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(242, 21)" end="(245, 15)">
                                                            <AtomNode start="(242, 21)" end="(242, 23)" leading="" trailing="&#10;          " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(243, 11)" end="(245, 15)">
                                                            <TacticTacticseq1IndentedNode start="(243, 11)" end="(245, 15)">
                                                            <NullNode start="(243, 11)" end="(245, 15)">
                                                            <OtherNode start="(243, 11)" end="(243, 73)" kind="Lean.Parser.Tactic.refine" state_before="case cons.h_2.mpr.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₂ : ∀ (a_1 : α✝), a_1 ∈ a :: as → p a_1 = false&#10;h₁ : x :: xs = a :: as ++ b :: bs&#10;⊢ ∃ as, (∃ x, xs = as ++ b :: x) ∧ ∀ (a : α✝), a ∈ as → p a = false" state_after="case cons.h_2.mpr.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₂ : ∀ (a_1 : α✝), a_1 ∈ a :: as → p a_1 = false&#10;h₁ : x :: xs = a :: as ++ b :: bs&#10;⊢ xs = as ++ b :: bs" tactic="refine ⟨as, ⟨⟨bs, ?_⟩, fun a m =&amp;gt; h₂ a (mem_cons_of_mem _ m)⟩⟩">
                                                            <AtomNode start="(243, 11)" end="(243, 17)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(243, 18)" end="(243, 73)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(243, 18)" end="(243, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(243, 19)" end="(243, 72)">
                                                            <IdentNode start="(243, 19)" end="(243, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                                            <AtomNode start="(243, 21)" end="(243, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(243, 23)" end="(243, 72)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(243, 23)" end="(243, 24)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(243, 24)" end="(243, 71)">
                                                            <OtherNode start="(243, 24)" end="(243, 32)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(243, 24)" end="(243, 25)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(243, 25)" end="(243, 31)">
                                                            <IdentNode start="(243, 25)" end="(243, 27)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                            <AtomNode start="(243, 27)" end="(243, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(243, 29)" end="(243, 31)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(243, 29)" end="(243, 30)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(243, 30)" end="(243, 31)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(243, 31)" end="(243, 32)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(243, 32)" end="(243, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(243, 34)" end="(243, 71)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(243, 34)" end="(243, 37)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(243, 38)" end="(243, 71)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(243, 38)" end="(243, 41)">
                                                            <IdentNode start="(243, 38)" end="(243, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <IdentNode start="(243, 40)" end="(243, 41)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(243, 42)" end="(243, 44)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(243, 45)" end="(243, 71)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(243, 45)" end="(243, 47)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            <NullNode start="(243, 48)" end="(243, 71)">
                                                            <IdentNode start="(243, 48)" end="(243, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <OtherNode start="(243, 50)" end="(243, 71)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(243, 50)" end="(243, 51)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(243, 51)" end="(243, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(243, 51)" end="(243, 66)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(243, 67)" end="(243, 70)">
                                                            <TermHoleNode start="(243, 67)" end="(243, 68)">
                                                            <AtomNode start="(243, 67)" end="(243, 68)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(243, 69)" end="(243, 70)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(243, 70)" end="(243, 71)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(243, 71)" end="(243, 72)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(243, 72)" end="(243, 73)" leading="" trailing="&#10;          " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(244, 11)" end="(244, 19)" kind="Lean.Parser.Tactic.cases" state_before="case cons.h_2.mpr.intro.intro.intro.cons&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;xs : List α✝&#10;ih : find? p xs = some b ↔ p b = true ∧ ∃ as bs, xs = as ++ b :: bs ∧ ∀ (a : α✝), a ∈ as → (!p a) = true&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;bs : List α✝&#10;a : α✝&#10;as : List α✝&#10;h₂ : ∀ (a_1 : α✝), a_1 ∈ a :: as → p a_1 = false&#10;h₁ : x :: xs = a :: as ++ b :: bs&#10;⊢ xs = as ++ b :: bs" state_after="case cons.h_2.mpr.intro.intro.intro.cons.refl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;bs as : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ x :: as → p a = false&#10;ih :&#10;  find? p (as.append (b :: bs)) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as.append (b :: bs) = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ as.append (b :: bs) = as ++ b :: bs" tactic="cases h₁">
                                                            <AtomNode start="(244, 11)" end="(244, 16)" leading="" trailing=" " val="cases"/>
                                                            <NullNode start="(244, 17)" end="(244, 19)">
                                                            <OtherNode start="(244, 17)" end="(244, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(244, 17)" end="(244, 19)" leading="" trailing="&#10;          " raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(245, 11)" end="(245, 15)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2.mpr.intro.intro.intro.cons.refl&#10;α✝ : Type u_1&#10;b : α✝&#10;p : α✝ → Bool&#10;x : α✝&#10;x✝ : Bool&#10;h : p x = false&#10;pb : p b = true&#10;bs as : List α✝&#10;h₂ : ∀ (a : α✝), a ∈ x :: as → p a = false&#10;ih :&#10;  find? p (as.append (b :: bs)) = some b ↔&#10;    p b = true ∧ ∃ as_1 bs_1, as.append (b :: bs) = as_1 ++ b :: bs_1 ∧ ∀ (a : α✝), a ∈ as_1 → (!p a) = true&#10;⊢ as.append (b :: bs) = as ++ b :: bs" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(245, 11)" end="(245, 15)" leading="" trailing="&#10;&#10;" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(247, 1)" end="(248, 50)" name="find?_eq_some" full_name="List.find?_eq_some">
      <CommandDeclmodifiersNode start="(247, 1)" end="(247, 63)">
        <NullNode/>
        <NullNode start="(247, 1)" end="(247, 63)">
          <OtherNode start="(247, 1)" end="(247, 63)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(247, 1)" end="(247, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(247, 3)" end="(247, 62)">
              <OtherNode start="(247, 3)" end="(247, 62)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(247, 3)" end="(247, 62)" kind="Lean.deprecated">
                  <AtomNode start="(247, 3)" end="(247, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(247, 14)" end="(247, 38)">
                    <IdentNode start="(247, 14)" end="(247, 38)" leading="" trailing=" " raw_val="find?_eq_some_iff_append" val="find?_eq_some_iff_append" full_name="List.find?_eq_some_iff_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(210, 9)" def_end="(210, 33)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(247, 39)" end="(247, 62)">
                    <AtomNode start="(247, 39)" end="(247, 40)" leading="" trailing="" val="("/>
                    <AtomNode start="(247, 40)" end="(247, 45)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(247, 46)" end="(247, 48)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(247, 49)" end="(247, 61)" kind="str">
                      <AtomNode start="(247, 49)" end="(247, 61)" leading="" trailing="" val="&amp;quot;2024-11-06&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(247, 61)" end="(247, 62)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(247, 62)" end="(247, 63)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(248, 1)" end="(248, 50)" name="find?_eq_some">
        <AtomNode start="(248, 1)" end="(248, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(248, 8)" end="(248, 21)">
          <IdentNode start="(248, 8)" end="(248, 21)" leading="" trailing=" " raw_val="find?_eq_some" val="find?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(248, 22)" end="(248, 50)">
          <AtomNode start="(248, 22)" end="(248, 24)" leading="" trailing=" " val=":="/>
          <OtherNode start="(248, 25)" end="(248, 50)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(248, 25)" end="(248, 26)" leading="" trailing="" val="@"/>
            <IdentNode start="(248, 26)" end="(248, 50)" leading="" trailing="&#10;&#10;" raw_val="find?_eq_some_iff_append" val="find?_eq_some_iff_append" full_name="List.find?_eq_some_iff_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(210, 9)" def_end="(210, 33)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(250, 1)" end="(253, 21)" name="find?_cons_eq_some" full_name="List.find?_cons_eq_some">
      <CommandDeclmodifiersNode start="(250, 1)" end="(250, 8)">
        <NullNode/>
        <NullNode start="(250, 1)" end="(250, 8)">
          <OtherNode start="(250, 1)" end="(250, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(250, 1)" end="(250, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(250, 3)" end="(250, 7)">
              <OtherNode start="(250, 3)" end="(250, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(250, 3)" end="(250, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(250, 3)" end="(250, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(250, 7)" end="(250, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(251, 1)" end="(253, 21)" name="find?_cons_eq_some" full_name="List.find?_cons_eq_some" _is_private_decl="False">
        <AtomNode start="(251, 1)" end="(251, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(251, 9)" end="(251, 27)">
          <IdentNode start="(251, 9)" end="(251, 27)" leading="" trailing=" " raw_val="find?_cons_eq_some" val="find?_cons_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(251, 28)" end="(251, 103)">
          <NullNode/>
          <TermTypespecNode start="(251, 28)" end="(251, 103)">
            <AtomNode start="(251, 28)" end="(251, 29)" leading="" trailing=" " val=":"/>
            <OtherNode start="(251, 30)" end="(251, 103)" kind="«term_↔_»">
              <OtherNode start="(251, 30)" end="(251, 56)" kind="«term_=_»">
                <OtherNode start="(251, 30)" end="(251, 47)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(251, 30)" end="(251, 45)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(251, 30)" end="(251, 39)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(251, 30)" end="(251, 31)" leading="" trailing="" val="("/>
                      <OtherNode start="(251, 31)" end="(251, 38)" kind="«term_::_»">
                        <IdentNode start="(251, 31)" end="(251, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(251, 33)" end="(251, 35)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(251, 36)" end="(251, 38)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(251, 38)" end="(251, 39)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(251, 39)" end="(251, 40)" leading="" trailing="" val="."/>
                    <IdentNode start="(251, 40)" end="(251, 45)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(251, 46)" end="(251, 47)">
                    <IdentNode start="(251, 46)" end="(251, 47)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(251, 48)" end="(251, 49)" leading="" trailing=" " val="="/>
                <OtherNode start="(251, 50)" end="(251, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(251, 50)" end="(251, 54)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(251, 55)" end="(251, 56)">
                    <IdentNode start="(251, 55)" end="(251, 56)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(251, 57)" end="(251, 58)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(251, 59)" end="(251, 103)" kind="«term_∨_»">
                <OtherNode start="(251, 59)" end="(251, 72)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(251, 59)" end="(251, 60)" leading="" trailing="" val="("/>
                  <OtherNode start="(251, 60)" end="(251, 71)" kind="«term_∧_»">
                    <OtherNode start="(251, 60)" end="(251, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(251, 60)" end="(251, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(251, 62)" end="(251, 63)">
                        <IdentNode start="(251, 62)" end="(251, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(251, 64)" end="(251, 65)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(251, 66)" end="(251, 71)" kind="«term_=_»">
                      <IdentNode start="(251, 66)" end="(251, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(251, 68)" end="(251, 69)" leading="" trailing=" " val="="/>
                      <IdentNode start="(251, 70)" end="(251, 71)" leading="" trailing="" raw_val="b" val="b"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(251, 71)" end="(251, 72)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(251, 73)" end="(251, 74)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(251, 75)" end="(251, 103)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(251, 75)" end="(251, 76)" leading="" trailing="" val="("/>
                  <OtherNode start="(251, 76)" end="(251, 102)" kind="«term_∧_»">
                    <OtherNode start="(251, 76)" end="(251, 80)" kind="term!_">
                      <AtomNode start="(251, 76)" end="(251, 77)" leading="" trailing="" val="!"/>
                      <OtherNode start="(251, 77)" end="(251, 80)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(251, 77)" end="(251, 78)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(251, 79)" end="(251, 80)">
                          <IdentNode start="(251, 79)" end="(251, 80)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(251, 81)" end="(251, 82)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(251, 83)" end="(251, 102)" kind="«term_=_»">
                      <OtherNode start="(251, 83)" end="(251, 93)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(251, 83)" end="(251, 91)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                        <NullNode start="(251, 92)" end="(251, 93)">
                          <IdentNode start="(251, 92)" end="(251, 93)" leading="" trailing=" " raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(251, 94)" end="(251, 95)" leading="" trailing=" " val="="/>
                      <OtherNode start="(251, 96)" end="(251, 102)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(251, 96)" end="(251, 100)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(251, 101)" end="(251, 102)">
                          <IdentNode start="(251, 101)" end="(251, 102)" leading="" trailing="" raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(251, 102)" end="(251, 103)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(251, 104)" end="(253, 21)">
          <AtomNode start="(251, 104)" end="(251, 106)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(251, 107)" end="(253, 21)">
            <AtomNode start="(251, 107)" end="(251, 109)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(252, 3)" end="(253, 21)">
              <TacticTacticseq1IndentedNode start="(252, 3)" end="(253, 21)">
                <NullNode start="(252, 3)" end="(253, 21)">
                  <OtherNode start="(252, 3)" end="(252, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type u_1&#10;a : α✝&#10;xs : List α✝&#10;p : α✝ → Bool&#10;b : α✝&#10;⊢ find? p (a :: xs) = some b ↔ p a = true ∧ a = b ∨ (!p a) = true ∧ find? p xs = some b" state_after="α✝ : Type u_1&#10;a : α✝&#10;xs : List α✝&#10;p : α✝ → Bool&#10;b : α✝&#10;⊢ (match p a with&#10;      | true =&amp;gt; some a&#10;      | false =&amp;gt; find? p xs) =&#10;      some b ↔&#10;    p a = true ∧ a = b ∨ (!p a) = true ∧ find? p xs = some b" tactic="rw [find?_cons]">
                    <AtomNode start="(252, 3)" end="(252, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(252, 6)" end="(252, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(252, 6)" end="(252, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(252, 7)" end="(252, 17)">
                        <OtherNode start="(252, 7)" end="(252, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(252, 7)" end="(252, 17)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(252, 17)" end="(252, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(253, 3)" end="(253, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;a : α✝&#10;xs : List α✝&#10;p : α✝ → Bool&#10;b : α✝&#10;⊢ (match p a with&#10;      | true =&amp;gt; some a&#10;      | false =&amp;gt; find? p xs) =&#10;      some b ↔&#10;    p a = true ∧ a = b ∨ (!p a) = true ∧ find? p xs = some b" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(253, 3)" end="(253, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(253, 3)" end="(253, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(253, 9)" end="(253, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(253, 13)" end="(253, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(253, 13)" end="(253, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(255, 1)" end="(260, 23)" name="find?_isSome" full_name="List.find?_isSome">
      <CommandDeclmodifiersNode start="(255, 1)" end="(255, 8)">
        <NullNode/>
        <NullNode start="(255, 1)" end="(255, 8)">
          <OtherNode start="(255, 1)" end="(255, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(255, 1)" end="(255, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(255, 3)" end="(255, 7)">
              <OtherNode start="(255, 3)" end="(255, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(255, 3)" end="(255, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(255, 3)" end="(255, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(255, 7)" end="(255, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(255, 9)" end="(260, 23)" name="find?_isSome" full_name="List.find?_isSome" _is_private_decl="False">
        <AtomNode start="(255, 9)" end="(255, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(255, 17)" end="(255, 29)">
          <IdentNode start="(255, 17)" end="(255, 29)" leading="" trailing=" " raw_val="find?_isSome" val="find?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(255, 30)" end="(255, 100)">
          <NullNode start="(255, 30)" end="(255, 58)">
            <OtherNode start="(255, 30)" end="(255, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(255, 30)" end="(255, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(255, 31)" end="(255, 33)">
                <IdentNode start="(255, 31)" end="(255, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(255, 34)" end="(255, 42)">
                <AtomNode start="(255, 34)" end="(255, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(255, 36)" end="(255, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(255, 36)" end="(255, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(255, 41)" end="(255, 42)">
                    <IdentNode start="(255, 41)" end="(255, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(255, 42)" end="(255, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(255, 44)" end="(255, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(255, 44)" end="(255, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(255, 45)" end="(255, 46)">
                <IdentNode start="(255, 45)" end="(255, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(255, 47)" end="(255, 57)">
                <AtomNode start="(255, 47)" end="(255, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(255, 49)" end="(255, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(255, 49)" end="(255, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(255, 51)" end="(255, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(255, 53)" end="(255, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(255, 57)" end="(255, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(255, 59)" end="(255, 100)">
            <AtomNode start="(255, 59)" end="(255, 60)" leading="" trailing=" " val=":"/>
            <OtherNode start="(255, 61)" end="(255, 100)" kind="«term_↔_»">
              <OtherNode start="(255, 61)" end="(255, 80)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(255, 61)" end="(255, 73)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(255, 61)" end="(255, 62)" leading="" trailing="" val="("/>
                  <OtherNode start="(255, 62)" end="(255, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(255, 62)" end="(255, 70)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                    <NullNode start="(255, 71)" end="(255, 72)">
                      <IdentNode start="(255, 71)" end="(255, 72)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(255, 72)" end="(255, 73)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(255, 73)" end="(255, 74)" leading="" trailing="" val="."/>
                <IdentNode start="(255, 74)" end="(255, 80)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(255, 81)" end="(255, 82)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(255, 83)" end="(255, 100)" kind="«term∃_,_»">
                <AtomNode start="(255, 83)" end="(255, 84)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(255, 85)" end="(255, 86)" kind="Lean.explicitBinders">
                  <OtherNode start="(255, 85)" end="(255, 86)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(255, 85)" end="(255, 86)">
                      <LeanBinderidentNode start="(255, 85)" end="(255, 86)">
                        <IdentNode start="(255, 85)" end="(255, 86)" leading="" trailing="" raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(255, 86)" end="(255, 87)" leading="" trailing=" " val=","/>
                <OtherNode start="(255, 88)" end="(255, 100)" kind="«term_∧_»">
                  <OtherNode start="(255, 88)" end="(255, 94)" kind="«term_∈_»">
                    <IdentNode start="(255, 88)" end="(255, 89)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(255, 90)" end="(255, 91)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(255, 92)" end="(255, 94)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(255, 95)" end="(255, 96)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(255, 97)" end="(255, 100)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(255, 97)" end="(255, 98)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(255, 99)" end="(255, 100)">
                      <IdentNode start="(255, 99)" end="(255, 100)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(255, 101)" end="(260, 23)">
          <AtomNode start="(255, 101)" end="(255, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(255, 104)" end="(260, 23)">
            <AtomNode start="(255, 104)" end="(255, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(256, 3)" end="(260, 23)">
              <TacticTacticseq1IndentedNode start="(256, 3)" end="(260, 23)">
                <NullNode start="(256, 3)" end="(260, 23)">
                  <OtherNode start="(256, 3)" end="(260, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ (find? p xs).isSome = true ↔ ∃ x, x ∈ xs ∧ p x = true" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [find?_cons, mem_cons, exists_eq_or_imp]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(256, 3)" end="(256, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(256, 13)" end="(256, 15)">
                      <OtherNode start="(256, 13)" end="(256, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(256, 13)" end="(256, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(256, 16)" end="(260, 23)">
                      <OtherNode start="(256, 16)" end="(260, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(256, 16)" end="(256, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(257, 3)" end="(260, 23)">
                          <OtherNode start="(257, 3)" end="(257, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(257, 3)" end="(257, 8)">
                              <OtherNode start="(257, 3)" end="(257, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(257, 3)" end="(257, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(257, 5)" end="(257, 8)">
                                  <NullNode/>
                                  <IdentNode start="(257, 5)" end="(257, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(257, 9)" end="(257, 16)">
                              <AtomNode start="(257, 9)" end="(257, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(257, 12)" end="(257, 16)">
                                <TacticTacticseq1IndentedNode start="(257, 12)" end="(257, 16)">
                                  <NullNode start="(257, 12)" end="(257, 16)">
                                    <OtherNode start="(257, 12)" end="(257, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ (find? p []).isSome = true ↔ ∃ x, x ∈ [] ∧ p x = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(257, 12)" end="(257, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(258, 3)" end="(260, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(258, 3)" end="(258, 17)">
                              <OtherNode start="(258, 3)" end="(258, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(258, 3)" end="(258, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(258, 5)" end="(258, 9)">
                                  <NullNode/>
                                  <IdentNode start="(258, 5)" end="(258, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(258, 10)" end="(258, 17)">
                                  <IdentNode start="(258, 10)" end="(258, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(258, 12)" end="(258, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(258, 15)" end="(258, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(258, 18)" end="(260, 23)">
                              <AtomNode start="(258, 18)" end="(258, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(259, 5)" end="(260, 23)">
                                <TacticTacticseq1IndentedNode start="(259, 5)" end="(260, 23)">
                                  <NullNode start="(259, 5)" end="(260, 23)">
                                    <OtherNode start="(259, 5)" end="(259, 55)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (find? p xs).isSome = true ↔ ∃ x, x ∈ xs ∧ p x = true&#10;⊢ (find? p (x :: xs)).isSome = true ↔ ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (find? p xs).isSome = true ↔ ∃ x, x ∈ xs ∧ p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).isSome =&#10;      true ↔&#10;    p x = true ∨ ∃ a, a ∈ xs ∧ p a = true" tactic="simp only [find?_cons, mem_cons, exists_eq_or_imp]">
                                      <AtomNode start="(259, 5)" end="(259, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(259, 10)" end="(259, 14)">
                                        <AtomNode start="(259, 10)" end="(259, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(259, 15)" end="(259, 55)">
                                        <AtomNode start="(259, 15)" end="(259, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(259, 16)" end="(259, 54)">
                                          <OtherNode start="(259, 16)" end="(259, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(259, 16)" end="(259, 26)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(259, 26)" end="(259, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(259, 28)" end="(259, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(259, 28)" end="(259, 36)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(259, 36)" end="(259, 37)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(259, 38)" end="(259, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(259, 38)" end="(259, 54)" leading="" trailing="" raw_val="exists_eq_or_imp" val="exists_eq_or_imp" full_name="exists_eq_or_imp" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(259, 54)" end="(259, 55)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(260, 5)" end="(260, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (find? p xs).isSome = true ↔ ∃ x, x ∈ xs ∧ p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).isSome =&#10;      true ↔&#10;    p x = true ∨ ∃ a, a ∈ xs ∧ p a = true" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(260, 5)" end="(260, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(260, 5)" end="(260, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(260, 11)" end="(260, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(260, 15)" end="(260, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(260, 15)" end="(260, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(262, 1)" end="(266, 25)" name="find?_some" full_name="List.find?_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(262, 1)" end="(266, 25)" name="find?_some" full_name="List.find?_some" _is_private_decl="False">
        <AtomNode start="(262, 1)" end="(262, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(262, 9)" end="(262, 19)">
          <IdentNode start="(262, 9)" end="(262, 19)" leading="" trailing=" " raw_val="find?_some" val="find?_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(262, 20)" end="(262, 53)">
          <NullNode/>
          <TermTypespecNode start="(262, 20)" end="(262, 53)">
            <AtomNode start="(262, 20)" end="(262, 21)" leading="" trailing=" " val=":"/>
            <OtherNode start="(262, 22)" end="(262, 53)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(262, 22)" end="(262, 23)" leading="" trailing=" " val="∀"/>
              <NullNode start="(262, 24)" end="(262, 27)">
                <OtherNode start="(262, 24)" end="(262, 27)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(262, 24)" end="(262, 25)" leading="" trailing="" val="{"/>
                  <NullNode start="(262, 25)" end="(262, 26)">
                    <IdentNode start="(262, 25)" end="(262, 26)" leading="" trailing="" raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(262, 26)" end="(262, 27)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(262, 27)" end="(262, 28)" leading="" trailing=" " val=","/>
              <OtherNode start="(262, 29)" end="(262, 53)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(262, 29)" end="(262, 47)" kind="«term_=_»">
                  <OtherNode start="(262, 29)" end="(262, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(262, 29)" end="(262, 34)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(262, 35)" end="(262, 38)">
                      <IdentNode start="(262, 35)" end="(262, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(262, 37)" end="(262, 38)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(262, 39)" end="(262, 40)" leading="" trailing=" " val="="/>
                  <OtherNode start="(262, 41)" end="(262, 47)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(262, 41)" end="(262, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(262, 46)" end="(262, 47)">
                      <IdentNode start="(262, 46)" end="(262, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(262, 48)" end="(262, 49)" leading="" trailing=" " val="→"/>
                <OtherNode start="(262, 50)" end="(262, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(262, 50)" end="(262, 51)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(262, 52)" end="(262, 53)">
                    <IdentNode start="(262, 52)" end="(262, 53)" leading="" trailing="&#10;  " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(263, 3)" end="(266, 25)">
          <OtherNode start="(263, 3)" end="(266, 25)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(263, 3)" end="(266, 25)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(263, 3)" end="(266, 25)">
                <OtherNode start="(263, 3)" end="(266, 25)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(263, 3)" end="(263, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(263, 5)" end="(263, 14)">
                    <NullNode start="(263, 5)" end="(263, 14)">
                      <OtherNode start="(263, 5)" end="(263, 11)" kind="«term_::_»">
                        <IdentNode start="(263, 5)" end="(263, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(263, 7)" end="(263, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(263, 10)" end="(263, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(263, 11)" end="(263, 12)" leading="" trailing=" " val=","/>
                      <IdentNode start="(263, 13)" end="(263, 14)" leading="" trailing=" " raw_val="H" val="H"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(263, 15)" end="(263, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(263, 18)" end="(266, 25)">
                    <AtomNode start="(263, 18)" end="(263, 20)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(264, 5)" end="(266, 25)">
                      <TacticTacticseq1IndentedNode start="(264, 5)" end="(266, 25)">
                        <NullNode start="(264, 5)" end="(266, 25)">
                          <OtherNode start="(264, 5)" end="(264, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;H : find? p (b :: l) = some a&#10;⊢ p a = true" state_after="case pos&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : p b = true&#10;H : b = a&#10;⊢ p a = true&#10;&#10;case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ p a = true" tactic="by_cases h : p b &amp;lt;;&amp;gt; simp [find?, h] at H">
                            <OtherNode start="(264, 5)" end="(264, 21)" kind="«tacticBy_cases_:_»">
                              <AtomNode start="(264, 5)" end="(264, 13)" leading="" trailing=" " val="by_cases"/>
                              <NullNode start="(264, 14)" end="(264, 17)">
                                <IdentNode start="(264, 14)" end="(264, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(264, 16)" end="(264, 17)" leading="" trailing=" " val=":"/>
                              </NullNode>
                              <OtherNode start="(264, 18)" end="(264, 21)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(264, 18)" end="(264, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(264, 20)" end="(264, 21)">
                                  <IdentNode start="(264, 20)" end="(264, 21)" leading="" trailing=" " raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(264, 22)" end="(264, 25)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(264, 26)" end="(264, 46)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(264, 26)" end="(264, 30)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(264, 31)" end="(264, 41)">
                                <AtomNode start="(264, 31)" end="(264, 32)" leading="" trailing="" val="["/>
                                <NullNode start="(264, 32)" end="(264, 40)">
                                  <OtherNode start="(264, 32)" end="(264, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(264, 32)" end="(264, 37)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(264, 37)" end="(264, 38)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(264, 39)" end="(264, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(264, 39)" end="(264, 40)" leading="" trailing="" raw_val="h" val="h"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(264, 40)" end="(264, 41)" leading="" trailing=" " val="]"/>
                              </NullNode>
                              <NullNode start="(264, 42)" end="(264, 46)">
                                <OtherNode start="(264, 42)" end="(264, 46)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(264, 42)" end="(264, 44)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(264, 45)" end="(264, 46)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(264, 45)" end="(264, 46)">
                                      <IdentNode start="(264, 45)" end="(264, 46)" leading="" trailing="&#10;    " raw_val="H" val="H"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(265, 5)" end="(265, 18)" kind="Lean.cdot" state_before="case pos&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : p b = true&#10;H : b = a&#10;⊢ p a = true&#10;&#10;case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ p a = true" state_after="case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ p a = true" tactic="· exact H ▸ h">
                            <OtherNode start="(265, 5)" end="(265, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(265, 5)" end="(265, 6)" kind="patternIgnore">
                                <OtherNode start="(265, 5)" end="(265, 6)" kind="token.«· »">
                                  <AtomNode start="(265, 5)" end="(265, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(265, 7)" end="(265, 18)">
                              <TacticTacticseq1IndentedNode start="(265, 7)" end="(265, 18)">
                                <NullNode start="(265, 7)" end="(265, 18)">
                                  <OtherNode start="(265, 7)" end="(265, 18)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : p b = true&#10;H : b = a&#10;⊢ p a = true" state_after="no goals" tactic="exact H ▸ h">
                                    <AtomNode start="(265, 7)" end="(265, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(265, 13)" end="(265, 18)" kind="Lean.Parser.Term.subst">
                                      <IdentNode start="(265, 13)" end="(265, 14)" leading="" trailing=" " raw_val="H" val="H"/>
                                      <AtomNode start="(265, 15)" end="(265, 16)" leading="" trailing=" " val="▸"/>
                                      <NullNode start="(265, 17)" end="(265, 18)">
                                        <IdentNode start="(265, 17)" end="(265, 18)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(266, 5)" end="(266, 25)" kind="Lean.cdot" state_before="case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ p a = true" state_after="no goals" tactic="· exact find?_some H">
                            <OtherNode start="(266, 5)" end="(266, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(266, 5)" end="(266, 6)" kind="patternIgnore">
                                <OtherNode start="(266, 5)" end="(266, 6)" kind="token.«· »">
                                  <AtomNode start="(266, 5)" end="(266, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(266, 7)" end="(266, 25)">
                              <TacticTacticseq1IndentedNode start="(266, 7)" end="(266, 25)">
                                <NullNode start="(266, 7)" end="(266, 25)">
                                  <OtherNode start="(266, 7)" end="(266, 25)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ p a = true" state_after="no goals" tactic="exact find?_some H">
                                    <AtomNode start="(266, 7)" end="(266, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(266, 13)" end="(266, 25)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(266, 13)" end="(266, 23)" leading="" trailing=" " raw_val="find?_some" val="find?_some"/>
                                      <NullNode start="(266, 24)" end="(266, 25)">
                                        <IdentNode start="(266, 24)" end="(266, 25)" leading="" trailing="&#10;&#10;" raw_val="H" val="H"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(268, 1)" end="(272, 45)" name="mem_of_find?_eq_some" full_name="List.mem_of_find?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(268, 1)" end="(272, 45)" name="mem_of_find?_eq_some" full_name="List.mem_of_find?_eq_some" _is_private_decl="False">
        <AtomNode start="(268, 1)" end="(268, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(268, 9)" end="(268, 29)">
          <IdentNode start="(268, 9)" end="(268, 29)" leading="" trailing=" " raw_val="mem_of_find?_eq_some" val="mem_of_find?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(268, 30)" end="(268, 65)">
          <NullNode/>
          <TermTypespecNode start="(268, 30)" end="(268, 65)">
            <AtomNode start="(268, 30)" end="(268, 31)" leading="" trailing=" " val=":"/>
            <OtherNode start="(268, 32)" end="(268, 65)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(268, 32)" end="(268, 33)" leading="" trailing=" " val="∀"/>
              <NullNode start="(268, 34)" end="(268, 37)">
                <OtherNode start="(268, 34)" end="(268, 37)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(268, 34)" end="(268, 35)" leading="" trailing="" val="{"/>
                  <NullNode start="(268, 35)" end="(268, 36)">
                    <IdentNode start="(268, 35)" end="(268, 36)" leading="" trailing="" raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(268, 36)" end="(268, 37)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(268, 37)" end="(268, 38)" leading="" trailing=" " val=","/>
              <OtherNode start="(268, 39)" end="(268, 65)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(268, 39)" end="(268, 57)" kind="«term_=_»">
                  <OtherNode start="(268, 39)" end="(268, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(268, 39)" end="(268, 44)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(268, 45)" end="(268, 48)">
                      <IdentNode start="(268, 45)" end="(268, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(268, 47)" end="(268, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(268, 49)" end="(268, 50)" leading="" trailing=" " val="="/>
                  <OtherNode start="(268, 51)" end="(268, 57)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(268, 51)" end="(268, 55)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(268, 56)" end="(268, 57)">
                      <IdentNode start="(268, 56)" end="(268, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(268, 58)" end="(268, 59)" leading="" trailing=" " val="→"/>
                <OtherNode start="(268, 60)" end="(268, 65)" kind="«term_∈_»">
                  <IdentNode start="(268, 60)" end="(268, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(268, 62)" end="(268, 63)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(268, 64)" end="(268, 65)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(269, 3)" end="(272, 45)">
          <OtherNode start="(269, 3)" end="(272, 45)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(269, 3)" end="(272, 45)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(269, 3)" end="(272, 45)">
                <OtherNode start="(269, 3)" end="(272, 45)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(269, 3)" end="(269, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(269, 5)" end="(269, 14)">
                    <NullNode start="(269, 5)" end="(269, 14)">
                      <OtherNode start="(269, 5)" end="(269, 11)" kind="«term_::_»">
                        <IdentNode start="(269, 5)" end="(269, 6)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(269, 7)" end="(269, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(269, 10)" end="(269, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(269, 11)" end="(269, 12)" leading="" trailing=" " val=","/>
                      <IdentNode start="(269, 13)" end="(269, 14)" leading="" trailing=" " raw_val="H" val="H"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(269, 15)" end="(269, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(269, 18)" end="(272, 45)">
                    <AtomNode start="(269, 18)" end="(269, 20)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(270, 5)" end="(272, 45)">
                      <TacticTacticseq1IndentedNode start="(270, 5)" end="(272, 45)">
                        <NullNode start="(270, 5)" end="(272, 45)">
                          <OtherNode start="(270, 5)" end="(270, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;H : find? p (b :: l) = some a&#10;⊢ a ∈ b :: l" state_after="case pos&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : p b = true&#10;H : b = a&#10;⊢ a ∈ b :: l&#10;&#10;case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ a ∈ b :: l" tactic="by_cases h : p b &amp;lt;;&amp;gt; simp [find?, h] at H">
                            <OtherNode start="(270, 5)" end="(270, 21)" kind="«tacticBy_cases_:_»">
                              <AtomNode start="(270, 5)" end="(270, 13)" leading="" trailing=" " val="by_cases"/>
                              <NullNode start="(270, 14)" end="(270, 17)">
                                <IdentNode start="(270, 14)" end="(270, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                <AtomNode start="(270, 16)" end="(270, 17)" leading="" trailing=" " val=":"/>
                              </NullNode>
                              <OtherNode start="(270, 18)" end="(270, 21)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(270, 18)" end="(270, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(270, 20)" end="(270, 21)">
                                  <IdentNode start="(270, 20)" end="(270, 21)" leading="" trailing=" " raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(270, 22)" end="(270, 25)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(270, 26)" end="(270, 46)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(270, 26)" end="(270, 30)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(270, 31)" end="(270, 41)">
                                <AtomNode start="(270, 31)" end="(270, 32)" leading="" trailing="" val="["/>
                                <NullNode start="(270, 32)" end="(270, 40)">
                                  <OtherNode start="(270, 32)" end="(270, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(270, 32)" end="(270, 37)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(270, 37)" end="(270, 38)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(270, 39)" end="(270, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(270, 39)" end="(270, 40)" leading="" trailing="" raw_val="h" val="h"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(270, 40)" end="(270, 41)" leading="" trailing=" " val="]"/>
                              </NullNode>
                              <NullNode start="(270, 42)" end="(270, 46)">
                                <OtherNode start="(270, 42)" end="(270, 46)" kind="Lean.Parser.Tactic.location">
                                  <AtomNode start="(270, 42)" end="(270, 44)" leading="" trailing=" " val="at"/>
                                  <OtherNode start="(270, 45)" end="(270, 46)" kind="Lean.Parser.Tactic.locationHyp">
                                    <NullNode start="(270, 45)" end="(270, 46)">
                                      <IdentNode start="(270, 45)" end="(270, 46)" leading="" trailing="&#10;    " raw_val="H" val="H"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(271, 5)" end="(271, 24)" kind="Lean.cdot" state_before="case pos&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : p b = true&#10;H : b = a&#10;⊢ a ∈ b :: l&#10;&#10;case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ a ∈ b :: l" state_after="case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ a ∈ b :: l" tactic="· exact H ▸ .head _">
                            <OtherNode start="(271, 5)" end="(271, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(271, 5)" end="(271, 6)" kind="patternIgnore">
                                <OtherNode start="(271, 5)" end="(271, 6)" kind="token.«· »">
                                  <AtomNode start="(271, 5)" end="(271, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(271, 7)" end="(271, 24)">
                              <TacticTacticseq1IndentedNode start="(271, 7)" end="(271, 24)">
                                <NullNode start="(271, 7)" end="(271, 24)">
                                  <OtherNode start="(271, 7)" end="(271, 24)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : p b = true&#10;H : b = a&#10;⊢ a ∈ b :: l" state_after="no goals" tactic="exact H ▸ .head _">
                                    <AtomNode start="(271, 7)" end="(271, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(271, 13)" end="(271, 24)" kind="Lean.Parser.Term.subst">
                                      <IdentNode start="(271, 13)" end="(271, 14)" leading="" trailing=" " raw_val="H" val="H"/>
                                      <AtomNode start="(271, 15)" end="(271, 16)" leading="" trailing=" " val="▸"/>
                                      <NullNode start="(271, 17)" end="(271, 24)">
                                        <OtherNode start="(271, 17)" end="(271, 24)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(271, 17)" end="(271, 22)" kind="Lean.Parser.Term.dotIdent">
                                            <AtomNode start="(271, 17)" end="(271, 18)" leading="" trailing="" val="."/>
                                            <IdentNode start="(271, 18)" end="(271, 22)" leading="" trailing=" " raw_val="head" val="head"/>
                                          </OtherNode>
                                          <NullNode start="(271, 23)" end="(271, 24)">
                                            <TermHoleNode start="(271, 23)" end="(271, 24)">
                                              <AtomNode start="(271, 23)" end="(271, 24)" leading="" trailing="&#10;    " val="_"/>
                                            </TermHoleNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(272, 5)" end="(272, 45)" kind="Lean.cdot" state_before="case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ a ∈ b :: l" state_after="no goals" tactic="· exact .tail _ (mem_of_find?_eq_some H)">
                            <OtherNode start="(272, 5)" end="(272, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(272, 5)" end="(272, 6)" kind="patternIgnore">
                                <OtherNode start="(272, 5)" end="(272, 6)" kind="token.«· »">
                                  <AtomNode start="(272, 5)" end="(272, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(272, 7)" end="(272, 45)">
                              <TacticTacticseq1IndentedNode start="(272, 7)" end="(272, 45)">
                                <NullNode start="(272, 7)" end="(272, 45)">
                                  <OtherNode start="(272, 7)" end="(272, 45)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a b : α✝&#10;l : List α✝&#10;h : ¬p b = true&#10;H : find? p l = some a&#10;⊢ a ∈ b :: l" state_after="no goals" tactic="exact .tail _ (mem_of_find?_eq_some H)">
                                    <AtomNode start="(272, 7)" end="(272, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(272, 13)" end="(272, 45)" kind="Lean.Parser.Term.app">
                                      <OtherNode start="(272, 13)" end="(272, 18)" kind="Lean.Parser.Term.dotIdent">
                                        <AtomNode start="(272, 13)" end="(272, 14)" leading="" trailing="" val="."/>
                                        <IdentNode start="(272, 14)" end="(272, 18)" leading="" trailing=" " raw_val="tail" val="tail"/>
                                      </OtherNode>
                                      <NullNode start="(272, 19)" end="(272, 45)">
                                        <TermHoleNode start="(272, 19)" end="(272, 20)">
                                          <AtomNode start="(272, 19)" end="(272, 20)" leading="" trailing=" " val="_"/>
                                        </TermHoleNode>
                                        <OtherNode start="(272, 21)" end="(272, 45)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(272, 21)" end="(272, 22)" leading="" trailing="" val="("/>
                                          <OtherNode start="(272, 22)" end="(272, 44)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(272, 22)" end="(272, 42)" leading="" trailing=" " raw_val="mem_of_find?_eq_some" val="mem_of_find?_eq_some"/>
                                            <NullNode start="(272, 43)" end="(272, 44)">
                                              <IdentNode start="(272, 43)" end="(272, 44)" leading="" trailing="" raw_val="H" val="H"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(272, 44)" end="(272, 45)" leading="" trailing="&#10;&#10;" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(274, 1)" end="(283, 15)" name="get_find?_mem" full_name="List.get_find?_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(274, 1)" end="(283, 15)" name="get_find?_mem" full_name="List.get_find?_mem" _is_private_decl="False">
        <AtomNode start="(274, 1)" end="(274, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(274, 9)" end="(274, 22)">
          <IdentNode start="(274, 9)" end="(274, 22)" leading="" trailing=" " raw_val="get_find?_mem" val="get_find?_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(274, 23)" end="(274, 81)">
          <NullNode start="(274, 23)" end="(274, 55)">
            <OtherNode start="(274, 23)" end="(274, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(274, 23)" end="(274, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(274, 24)" end="(274, 26)">
                <IdentNode start="(274, 24)" end="(274, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(274, 27)" end="(274, 35)">
                <AtomNode start="(274, 27)" end="(274, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(274, 29)" end="(274, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(274, 29)" end="(274, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(274, 34)" end="(274, 35)">
                    <IdentNode start="(274, 34)" end="(274, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(274, 35)" end="(274, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(274, 37)" end="(274, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(274, 37)" end="(274, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(274, 38)" end="(274, 39)">
                <IdentNode start="(274, 38)" end="(274, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(274, 40)" end="(274, 50)">
                <AtomNode start="(274, 40)" end="(274, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(274, 42)" end="(274, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(274, 42)" end="(274, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(274, 44)" end="(274, 45)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(274, 46)" end="(274, 50)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(274, 50)" end="(274, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(274, 52)" end="(274, 55)">
              <AtomNode start="(274, 52)" end="(274, 53)" leading="" trailing="" val="("/>
              <NullNode start="(274, 53)" end="(274, 54)">
                <IdentNode start="(274, 53)" end="(274, 54)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(274, 54)" end="(274, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(274, 56)" end="(274, 81)">
            <AtomNode start="(274, 56)" end="(274, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(274, 58)" end="(274, 81)" kind="«term_∈_»">
              <OtherNode start="(274, 58)" end="(274, 76)" kind="Lean.Parser.Term.app">
                <OtherNode start="(274, 58)" end="(274, 74)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(274, 58)" end="(274, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(274, 58)" end="(274, 59)" leading="" trailing="" val="("/>
                    <OtherNode start="(274, 59)" end="(274, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(274, 59)" end="(274, 67)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(274, 68)" end="(274, 69)">
                        <IdentNode start="(274, 68)" end="(274, 69)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(274, 69)" end="(274, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(274, 70)" end="(274, 71)" leading="" trailing="" val="."/>
                  <IdentNode start="(274, 71)" end="(274, 74)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(274, 75)" end="(274, 76)">
                  <IdentNode start="(274, 75)" end="(274, 76)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(274, 77)" end="(274, 78)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(274, 79)" end="(274, 81)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(274, 82)" end="(283, 15)">
          <AtomNode start="(274, 82)" end="(274, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(274, 85)" end="(283, 15)">
            <AtomNode start="(274, 85)" end="(274, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(275, 3)" end="(283, 15)">
              <TacticTacticseq1IndentedNode start="(275, 3)" end="(283, 15)">
                <NullNode start="(275, 3)" end="(283, 15)">
                  <OtherNode start="(275, 3)" end="(283, 15)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : (find? p xs).isSome = true&#10;⊢ (find? p xs).get h ∈ xs" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp at h&#10;| cons x xs ih =&amp;gt;&#10;  simp only [find?_cons]&#10;  by_cases h : p x&#10;  · simp [h]&#10;  · simp only [h]&#10;    right&#10;    apply ih">
                    <AtomNode start="(275, 3)" end="(275, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(275, 13)" end="(275, 15)">
                      <OtherNode start="(275, 13)" end="(275, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(275, 13)" end="(275, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(275, 16)" end="(283, 15)">
                      <OtherNode start="(275, 16)" end="(283, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(275, 16)" end="(275, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(276, 3)" end="(283, 15)">
                          <OtherNode start="(276, 3)" end="(276, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(276, 3)" end="(276, 8)">
                              <OtherNode start="(276, 3)" end="(276, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(276, 3)" end="(276, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(276, 5)" end="(276, 8)">
                                  <NullNode/>
                                  <IdentNode start="(276, 5)" end="(276, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(276, 9)" end="(276, 21)">
                              <AtomNode start="(276, 9)" end="(276, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(276, 12)" end="(276, 21)">
                                <TacticTacticseq1IndentedNode start="(276, 12)" end="(276, 21)">
                                  <NullNode start="(276, 12)" end="(276, 21)">
                                    <OtherNode start="(276, 12)" end="(276, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;h : (find? p []).isSome = true&#10;⊢ (find? p []).get h ∈ []" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(276, 12)" end="(276, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(276, 17)" end="(276, 21)">
                                        <OtherNode start="(276, 17)" end="(276, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(276, 17)" end="(276, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(276, 20)" end="(276, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(276, 20)" end="(276, 21)">
                                              <IdentNode start="(276, 20)" end="(276, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(277, 3)" end="(283, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(277, 3)" end="(277, 17)">
                              <OtherNode start="(277, 3)" end="(277, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(277, 3)" end="(277, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(277, 5)" end="(277, 9)">
                                  <NullNode/>
                                  <IdentNode start="(277, 5)" end="(277, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(277, 10)" end="(277, 17)">
                                  <IdentNode start="(277, 10)" end="(277, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(277, 12)" end="(277, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(277, 15)" end="(277, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(277, 18)" end="(283, 15)">
                              <AtomNode start="(277, 18)" end="(277, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(278, 5)" end="(283, 15)">
                                <TacticTacticseq1IndentedNode start="(278, 5)" end="(283, 15)">
                                  <NullNode start="(278, 5)" end="(283, 15)">
                                    <OtherNode start="(278, 5)" end="(278, 27)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h : (find? p (x :: xs)).isSome = true&#10;⊢ (find? p (x :: xs)).get h ∈ x :: xs" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h : (find? p (x :: xs)).isSome = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" tactic="simp only [find?_cons]">
                                      <AtomNode start="(278, 5)" end="(278, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(278, 10)" end="(278, 14)">
                                        <AtomNode start="(278, 10)" end="(278, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(278, 15)" end="(278, 27)">
                                        <AtomNode start="(278, 15)" end="(278, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(278, 16)" end="(278, 26)">
                                          <OtherNode start="(278, 16)" end="(278, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(278, 16)" end="(278, 26)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(278, 26)" end="(278, 27)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(279, 5)" end="(279, 21)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h : (find? p (x :: xs)).isSome = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" tactic="by_cases h : p x">
                                      <AtomNode start="(279, 5)" end="(279, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(279, 14)" end="(279, 17)">
                                        <IdentNode start="(279, 14)" end="(279, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <AtomNode start="(279, 16)" end="(279, 17)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(279, 18)" end="(279, 21)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(279, 18)" end="(279, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                        <NullNode start="(279, 20)" end="(279, 21)">
                                          <IdentNode start="(279, 20)" end="(279, 21)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(280, 5)" end="(280, 15)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" tactic="· simp [h]">
                                      <OtherNode start="(280, 5)" end="(280, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(280, 5)" end="(280, 6)" kind="patternIgnore">
                                          <OtherNode start="(280, 5)" end="(280, 6)" kind="token.«· »">
                                            <AtomNode start="(280, 5)" end="(280, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(280, 7)" end="(280, 15)">
                                        <TacticTacticseq1IndentedNode start="(280, 7)" end="(280, 15)">
                                          <NullNode start="(280, 7)" end="(280, 15)">
                                            <OtherNode start="(280, 7)" end="(280, 15)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" state_after="no goals" tactic="simp [h]">
                                              <AtomNode start="(280, 7)" end="(280, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(280, 12)" end="(280, 15)">
                                                <AtomNode start="(280, 12)" end="(280, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(280, 13)" end="(280, 14)">
                                                  <OtherNode start="(280, 13)" end="(280, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(280, 13)" end="(280, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(280, 14)" end="(280, 15)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(281, 5)" end="(283, 15)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" state_after="no goals" tactic="· simp only [h]&#10;  right&#10;  apply ih">
                                      <OtherNode start="(281, 5)" end="(281, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(281, 5)" end="(281, 6)" kind="patternIgnore">
                                          <OtherNode start="(281, 5)" end="(281, 6)" kind="token.«· »">
                                            <AtomNode start="(281, 5)" end="(281, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(281, 7)" end="(283, 15)">
                                        <TacticTacticseq1IndentedNode start="(281, 7)" end="(283, 15)">
                                          <NullNode start="(281, 7)" end="(283, 15)">
                                            <OtherNode start="(281, 7)" end="(281, 20)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).get&#10;      ⋯ ∈&#10;    x :: xs" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (find? p xs).get ⋯ ∈ x :: xs" tactic="simp only [h]">
                                              <AtomNode start="(281, 7)" end="(281, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(281, 12)" end="(281, 16)">
                                                <AtomNode start="(281, 12)" end="(281, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(281, 17)" end="(281, 20)">
                                                <AtomNode start="(281, 17)" end="(281, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(281, 18)" end="(281, 19)">
                                                  <OtherNode start="(281, 18)" end="(281, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(281, 18)" end="(281, 19)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(281, 19)" end="(281, 20)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(282, 7)" end="(282, 12)" kind="Lean.Parser.Tactic.right" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ (find? p xs).get ⋯ ∈ x :: xs" state_after="case neg.a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ Mem ((find? p xs).get ⋯) xs" tactic="right">
                                              <AtomNode start="(282, 7)" end="(282, 12)" leading="" trailing="&#10;      " val="right"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(283, 7)" end="(283, 15)" kind="Lean.Parser.Tactic.apply" state_before="case neg.a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (h : (find? p xs).isSome = true), (find? p xs).get h ∈ xs&#10;h✝ : (find? p (x :: xs)).isSome = true&#10;h : ¬p x = true&#10;⊢ Mem ((find? p xs).get ⋯) xs" state_after="no goals" tactic="apply ih">
                                              <AtomNode start="(283, 7)" end="(283, 12)" leading="" trailing=" " val="apply"/>
                                              <IdentNode start="(283, 13)" end="(283, 15)" leading="" trailing="&#10;&#10;" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(285, 1)" end="(293, 25)" name="find?_filter" full_name="List.find?_filter">
      <CommandDeclmodifiersNode start="(285, 1)" end="(285, 8)">
        <NullNode/>
        <NullNode start="(285, 1)" end="(285, 8)">
          <OtherNode start="(285, 1)" end="(285, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(285, 1)" end="(285, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(285, 3)" end="(285, 7)">
              <OtherNode start="(285, 3)" end="(285, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(285, 3)" end="(285, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(285, 3)" end="(285, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(285, 7)" end="(285, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(285, 9)" end="(293, 25)" name="find?_filter" full_name="List.find?_filter" _is_private_decl="False">
        <AtomNode start="(285, 9)" end="(285, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(285, 17)" end="(285, 29)">
          <IdentNode start="(285, 17)" end="(285, 29)" leading="" trailing=" " raw_val="find?_filter" val="find?_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(285, 30)" end="(286, 58)">
          <NullNode start="(285, 30)" end="(285, 73)">
            <OtherNode start="(285, 30)" end="(285, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 30)" end="(285, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 31)" end="(285, 33)">
                <IdentNode start="(285, 31)" end="(285, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(285, 34)" end="(285, 42)">
                <AtomNode start="(285, 34)" end="(285, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(285, 36)" end="(285, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(285, 36)" end="(285, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(285, 41)" end="(285, 42)">
                    <IdentNode start="(285, 41)" end="(285, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(285, 42)" end="(285, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(285, 44)" end="(285, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 44)" end="(285, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 45)" end="(285, 46)">
                <IdentNode start="(285, 45)" end="(285, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(285, 47)" end="(285, 57)">
                <AtomNode start="(285, 47)" end="(285, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(285, 49)" end="(285, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(285, 49)" end="(285, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(285, 51)" end="(285, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(285, 53)" end="(285, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(285, 57)" end="(285, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(285, 59)" end="(285, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 59)" end="(285, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 60)" end="(285, 61)">
                <IdentNode start="(285, 60)" end="(285, 61)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(285, 62)" end="(285, 72)">
                <AtomNode start="(285, 62)" end="(285, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(285, 64)" end="(285, 72)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(285, 64)" end="(285, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(285, 66)" end="(285, 67)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(285, 68)" end="(285, 72)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(285, 72)" end="(285, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(285, 74)" end="(286, 58)">
            <AtomNode start="(285, 74)" end="(285, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(286, 5)" end="(286, 58)" kind="«term_=_»">
              <OtherNode start="(286, 5)" end="(286, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(286, 5)" end="(286, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(286, 5)" end="(286, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(286, 5)" end="(286, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(286, 6)" end="(286, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(286, 6)" end="(286, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                      <NullNode start="(286, 16)" end="(286, 17)">
                        <IdentNode start="(286, 16)" end="(286, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(286, 17)" end="(286, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(286, 18)" end="(286, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(286, 19)" end="(286, 24)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(286, 25)" end="(286, 26)">
                  <IdentNode start="(286, 25)" end="(286, 26)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(286, 27)" end="(286, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(286, 29)" end="(286, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(286, 29)" end="(286, 37)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                <NullNode start="(286, 38)" end="(286, 58)">
                  <OtherNode start="(286, 38)" end="(286, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(286, 38)" end="(286, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(286, 39)" end="(286, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(286, 39)" end="(286, 42)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(286, 43)" end="(286, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(286, 43)" end="(286, 44)">
                          <IdentNode start="(286, 43)" end="(286, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(286, 45)" end="(286, 47)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(286, 48)" end="(286, 57)" kind="«term_∧_»">
                          <OtherNode start="(286, 48)" end="(286, 51)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(286, 48)" end="(286, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(286, 50)" end="(286, 51)">
                              <IdentNode start="(286, 50)" end="(286, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(286, 52)" end="(286, 53)" leading="" trailing=" " val="∧"/>
                          <OtherNode start="(286, 54)" end="(286, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(286, 54)" end="(286, 55)" leading="" trailing=" " raw_val="q" val="q"/>
                            <NullNode start="(286, 56)" end="(286, 57)">
                              <IdentNode start="(286, 56)" end="(286, 57)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(286, 57)" end="(286, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(286, 59)" end="(293, 25)">
          <AtomNode start="(286, 59)" end="(286, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(286, 62)" end="(293, 25)">
            <AtomNode start="(286, 62)" end="(286, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(287, 3)" end="(293, 25)">
              <TacticTacticseq1IndentedNode start="(287, 3)" end="(293, 25)">
                <NullNode start="(287, 3)" end="(293, 25)">
                  <OtherNode start="(287, 3)" end="(293, 25)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;⊢ find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [filter_cons]&#10;  split &amp;lt;;&amp;gt;&#10;  · simp only [find?_cons]&#10;    split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(287, 3)" end="(287, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(287, 13)" end="(287, 15)">
                      <OtherNode start="(287, 13)" end="(287, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(287, 13)" end="(287, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(287, 16)" end="(293, 25)">
                      <OtherNode start="(287, 16)" end="(293, 25)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(287, 16)" end="(287, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(288, 3)" end="(293, 25)">
                          <OtherNode start="(288, 3)" end="(288, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(288, 3)" end="(288, 8)">
                              <OtherNode start="(288, 3)" end="(288, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(288, 3)" end="(288, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(288, 5)" end="(288, 8)">
                                  <NullNode/>
                                  <IdentNode start="(288, 5)" end="(288, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(288, 9)" end="(288, 16)">
                              <AtomNode start="(288, 9)" end="(288, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(288, 12)" end="(288, 16)">
                                <TacticTacticseq1IndentedNode start="(288, 12)" end="(288, 16)">
                                  <NullNode start="(288, 12)" end="(288, 16)">
                                    <OtherNode start="(288, 12)" end="(288, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p q : α → Bool&#10;⊢ find? q (filter p []) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(288, 12)" end="(288, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(289, 3)" end="(293, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(289, 3)" end="(289, 17)">
                              <OtherNode start="(289, 3)" end="(289, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(289, 3)" end="(289, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(289, 5)" end="(289, 9)">
                                  <NullNode/>
                                  <IdentNode start="(289, 5)" end="(289, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(289, 10)" end="(289, 17)">
                                  <IdentNode start="(289, 10)" end="(289, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(289, 12)" end="(289, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(289, 15)" end="(289, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(289, 18)" end="(293, 25)">
                              <AtomNode start="(289, 18)" end="(289, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(290, 5)" end="(293, 25)">
                                <TacticTacticseq1IndentedNode start="(290, 5)" end="(293, 25)">
                                  <NullNode start="(290, 5)" end="(293, 25)">
                                    <OtherNode start="(290, 5)" end="(290, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs&#10;⊢ find? q (filter p (x :: xs)) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) (x :: xs)" state_after="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs&#10;⊢ find? q (if p x = true then x :: filter p xs else filter p xs) =&#10;    find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) (x :: xs)" tactic="simp only [filter_cons]">
                                      <AtomNode start="(290, 5)" end="(290, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(290, 10)" end="(290, 14)">
                                        <AtomNode start="(290, 10)" end="(290, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(290, 15)" end="(290, 28)">
                                        <AtomNode start="(290, 15)" end="(290, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(290, 16)" end="(290, 27)">
                                          <OtherNode start="(290, 16)" end="(290, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(290, 16)" end="(290, 27)" leading="" trailing="" raw_val="filter_cons" val="filter_cons" full_name="List.filter_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(290, 27)" end="(290, 28)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(291, 5)" end="(293, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs&#10;⊢ find? q (if p x = true then x :: filter p xs else filter p xs) =&#10;    find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) (x :: xs)" state_after="no goals" tactic="split &amp;lt;;&amp;gt;&#10;· simp only [find?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(291, 5)" end="(291, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(291, 5)" end="(291, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(291, 11)" end="(291, 14)" leading="" trailing="&#10;    " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(292, 5)" end="(293, 25)" kind="Lean.cdot">
                                        <OtherNode start="(292, 5)" end="(292, 6)" kind="Lean.cdotTk">
                                          <OtherNode start="(292, 5)" end="(292, 6)" kind="patternIgnore">
                                            <OtherNode start="(292, 5)" end="(292, 6)" kind="token.«· »">
                                              <AtomNode start="(292, 5)" end="(292, 6)" leading="" trailing=" " val="·"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <TacticTacticseqNode start="(292, 7)" end="(293, 25)">
                                          <TacticTacticseq1IndentedNode start="(292, 7)" end="(293, 25)">
                                            <NullNode start="(292, 7)" end="(293, 25)">
                                              <OtherNode start="(292, 7)" end="(292, 29)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs&#10;h✝ : ¬p x = true&#10;⊢ find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) (x :: xs)" state_after="case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs&#10;h✝ : ¬p x = true&#10;⊢ find? q (filter p xs) =&#10;    match decide (p x = true ∧ q x = true) with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs" tactic="simp only [find?_cons]">
                                                <AtomNode start="(292, 7)" end="(292, 11)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(292, 12)" end="(292, 16)">
                                                  <AtomNode start="(292, 12)" end="(292, 16)" leading="" trailing=" " val="only"/>
                                                </NullNode>
                                                <NullNode start="(292, 17)" end="(292, 29)">
                                                  <AtomNode start="(292, 17)" end="(292, 18)" leading="" trailing="" val="["/>
                                                  <NullNode start="(292, 18)" end="(292, 28)">
                                                    <OtherNode start="(292, 18)" end="(292, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(292, 18)" end="(292, 28)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(292, 28)" end="(292, 29)" leading="" trailing="&#10;      " val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <OtherNode start="(293, 7)" end="(293, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : find? q (filter p xs) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs&#10;h✝ : ¬p x = true&#10;⊢ find? q (filter p xs) =&#10;    match decide (p x = true ∧ q x = true) with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                                <OtherNode start="(293, 7)" end="(293, 12)" kind="Lean.Parser.Tactic.split">
                                                  <AtomNode start="(293, 7)" end="(293, 12)" leading="" trailing=" " val="split"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(293, 13)" end="(293, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                <OtherNode start="(293, 17)" end="(293, 25)" kind="Lean.Parser.Tactic.simpAll">
                                                  <AtomNode start="(293, 17)" end="(293, 25)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(295, 1)" end="(296, 63)" name="head?_filter" full_name="List.head?_filter">
      <CommandDeclmodifiersNode start="(295, 1)" end="(295, 8)">
        <NullNode/>
        <NullNode start="(295, 1)" end="(295, 8)">
          <OtherNode start="(295, 1)" end="(295, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(295, 1)" end="(295, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(295, 3)" end="(295, 7)">
              <OtherNode start="(295, 3)" end="(295, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(295, 3)" end="(295, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(295, 3)" end="(295, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(295, 7)" end="(295, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(295, 9)" end="(296, 63)" name="head?_filter" full_name="List.head?_filter" _is_private_decl="False">
        <AtomNode start="(295, 9)" end="(295, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(295, 17)" end="(295, 29)">
          <IdentNode start="(295, 17)" end="(295, 29)" leading="" trailing=" " raw_val="head?_filter" val="head?_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(295, 30)" end="(295, 90)">
          <NullNode start="(295, 30)" end="(295, 57)">
            <OtherNode start="(295, 30)" end="(295, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(295, 30)" end="(295, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(295, 31)" end="(295, 32)">
                <IdentNode start="(295, 31)" end="(295, 32)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(295, 33)" end="(295, 43)">
                <AtomNode start="(295, 33)" end="(295, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(295, 35)" end="(295, 43)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(295, 35)" end="(295, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(295, 37)" end="(295, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(295, 39)" end="(295, 43)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(295, 43)" end="(295, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(295, 45)" end="(295, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(295, 45)" end="(295, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(295, 46)" end="(295, 47)">
                <IdentNode start="(295, 46)" end="(295, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(295, 48)" end="(295, 56)">
                <AtomNode start="(295, 48)" end="(295, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(295, 50)" end="(295, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(295, 50)" end="(295, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(295, 55)" end="(295, 56)">
                    <IdentNode start="(295, 55)" end="(295, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(295, 56)" end="(295, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(295, 58)" end="(295, 90)">
            <AtomNode start="(295, 58)" end="(295, 59)" leading="" trailing=" " val=":"/>
            <OtherNode start="(295, 60)" end="(295, 90)" kind="«term_=_»">
              <OtherNode start="(295, 60)" end="(295, 78)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(295, 60)" end="(295, 72)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(295, 60)" end="(295, 61)" leading="" trailing="" val="("/>
                  <OtherNode start="(295, 61)" end="(295, 71)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(295, 61)" end="(295, 69)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                    <NullNode start="(295, 70)" end="(295, 71)">
                      <IdentNode start="(295, 70)" end="(295, 71)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(295, 71)" end="(295, 72)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(295, 72)" end="(295, 73)" leading="" trailing="" val="."/>
                <IdentNode start="(295, 73)" end="(295, 78)" leading="" trailing=" " raw_val="head?" val="head?" full_name="List.head?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(295, 79)" end="(295, 80)" leading="" trailing=" " val="="/>
              <OtherNode start="(295, 81)" end="(295, 90)" kind="Lean.Parser.Term.app">
                <IdentNode start="(295, 81)" end="(295, 88)" leading="" trailing=" " raw_val="l.find?" val="l.find?"/>
                <NullNode start="(295, 89)" end="(295, 90)">
                  <IdentNode start="(295, 89)" end="(295, 90)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(295, 91)" end="(296, 63)">
          <AtomNode start="(295, 91)" end="(295, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(295, 94)" end="(296, 63)">
            <AtomNode start="(295, 94)" end="(295, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(296, 3)" end="(296, 63)">
              <TacticTacticseq1IndentedNode start="(296, 3)" end="(296, 63)">
                <NullNode start="(296, 3)" end="(296, 63)">
                  <OtherNode start="(296, 3)" end="(296, 63)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (filter p l).head? = find? p l" state_after="no goals" tactic="rw [← filterMap_eq_filter, head?_filterMap, findSome?_guard]">
                    <AtomNode start="(296, 3)" end="(296, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(296, 6)" end="(296, 63)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(296, 6)" end="(296, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(296, 7)" end="(296, 62)">
                        <OtherNode start="(296, 7)" end="(296, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(296, 7)" end="(296, 8)">
                            <OtherNode start="(296, 7)" end="(296, 8)" kind="patternIgnore">
                              <OtherNode start="(296, 7)" end="(296, 8)" kind="token.«← »">
                                <AtomNode start="(296, 7)" end="(296, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(296, 9)" end="(296, 28)" leading="" trailing="" raw_val="filterMap_eq_filter" val="filterMap_eq_filter" full_name="List.filterMap_eq_filter" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(296, 28)" end="(296, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(296, 30)" end="(296, 45)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(296, 30)" end="(296, 45)" leading="" trailing="" raw_val="head?_filterMap" val="head?_filterMap" full_name="List.head?_filterMap" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(110, 17)" def_end="(110, 32)"/>
                        </OtherNode>
                        <AtomNode start="(296, 45)" end="(296, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(296, 47)" end="(296, 62)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(296, 47)" end="(296, 62)" leading="" trailing="" raw_val="findSome?_guard" val="findSome?_guard" full_name="List.findSome?_guard" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(95, 17)" def_end="(95, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(296, 62)" end="(296, 63)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(298, 1)" end="(300, 35)" name="head_filter" full_name="List.head_filter">
      <CommandDeclmodifiersNode start="(298, 1)" end="(298, 8)">
        <NullNode/>
        <NullNode start="(298, 1)" end="(298, 8)">
          <OtherNode start="(298, 1)" end="(298, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(298, 1)" end="(298, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(298, 3)" end="(298, 7)">
              <OtherNode start="(298, 3)" end="(298, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(298, 3)" end="(298, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(298, 3)" end="(298, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(298, 7)" end="(298, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(298, 9)" end="(300, 35)" name="head_filter" full_name="List.head_filter" _is_private_decl="False">
        <AtomNode start="(298, 9)" end="(298, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(298, 17)" end="(298, 28)">
          <IdentNode start="(298, 17)" end="(298, 28)" leading="" trailing=" " raw_val="head_filter" val="head_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(298, 29)" end="(299, 84)">
          <NullNode start="(298, 29)" end="(298, 60)">
            <OtherNode start="(298, 29)" end="(298, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(298, 29)" end="(298, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(298, 30)" end="(298, 31)">
                <IdentNode start="(298, 30)" end="(298, 31)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(298, 32)" end="(298, 42)">
                <AtomNode start="(298, 32)" end="(298, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 34)" end="(298, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(298, 34)" end="(298, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(298, 36)" end="(298, 37)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(298, 38)" end="(298, 42)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(298, 42)" end="(298, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(298, 44)" end="(298, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(298, 44)" end="(298, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(298, 45)" end="(298, 46)">
                <IdentNode start="(298, 45)" end="(298, 46)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(298, 47)" end="(298, 55)">
                <AtomNode start="(298, 47)" end="(298, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 49)" end="(298, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(298, 49)" end="(298, 53)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(298, 54)" end="(298, 55)">
                    <IdentNode start="(298, 54)" end="(298, 55)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(298, 55)" end="(298, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(298, 57)" end="(298, 60)">
              <AtomNode start="(298, 57)" end="(298, 58)" leading="" trailing="" val="("/>
              <NullNode start="(298, 58)" end="(298, 59)">
                <IdentNode start="(298, 58)" end="(298, 59)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(298, 59)" end="(298, 60)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(298, 61)" end="(299, 84)">
            <AtomNode start="(298, 61)" end="(298, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(299, 5)" end="(299, 84)" kind="«term_=_»">
              <OtherNode start="(299, 5)" end="(299, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(299, 5)" end="(299, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(299, 5)" end="(299, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(299, 5)" end="(299, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(299, 6)" end="(299, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(299, 6)" end="(299, 14)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                      <NullNode start="(299, 15)" end="(299, 16)">
                        <IdentNode start="(299, 15)" end="(299, 16)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(299, 16)" end="(299, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(299, 17)" end="(299, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(299, 18)" end="(299, 22)" leading="" trailing=" " raw_val="head" val="head" full_name="List.head" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(299, 23)" end="(299, 24)">
                  <IdentNode start="(299, 23)" end="(299, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(299, 25)" end="(299, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(299, 27)" end="(299, 84)" kind="Lean.Parser.Term.app">
                <OtherNode start="(299, 27)" end="(299, 42)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(299, 27)" end="(299, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(299, 27)" end="(299, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(299, 28)" end="(299, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(299, 28)" end="(299, 35)" leading="" trailing=" " raw_val="l.find?" val="l.find?"/>
                      <NullNode start="(299, 36)" end="(299, 37)">
                        <IdentNode start="(299, 36)" end="(299, 37)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(299, 37)" end="(299, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(299, 38)" end="(299, 39)" leading="" trailing="" val="."/>
                  <IdentNode start="(299, 39)" end="(299, 42)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(299, 43)" end="(299, 84)">
                  <OtherNode start="(299, 43)" end="(299, 84)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(299, 43)" end="(299, 44)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(299, 44)" end="(299, 83)">
                      <AtomNode start="(299, 44)" end="(299, 46)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(299, 47)" end="(299, 83)">
                        <TacticTacticseq1IndentedNode start="(299, 47)" end="(299, 83)">
                          <NullNode start="(299, 47)" end="(299, 83)">
                            <OtherNode start="(299, 47)" end="(299, 83)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type ?u.67499&#10;p : α → Bool&#10;l : List α&#10;h : filter p l ≠ []&#10;⊢ (find? p l).isSome = true" state_after="no goals" tactic="simp_all [Option.isSome_iff_ne_none]">
                              <AtomNode start="(299, 47)" end="(299, 55)" leading="" trailing=" " val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(299, 56)" end="(299, 83)">
                                <AtomNode start="(299, 56)" end="(299, 57)" leading="" trailing="" val="["/>
                                <NullNode start="(299, 57)" end="(299, 82)">
                                  <OtherNode start="(299, 57)" end="(299, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(299, 57)" end="(299, 82)" leading="" trailing="" raw_val="Option.isSome_iff_ne_none" val="Option.isSome_iff_ne_none" full_name="Option.isSome_iff_ne_none" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(299, 82)" end="(299, 83)" leading="" trailing="" val="]"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(299, 83)" end="(299, 84)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(299, 85)" end="(300, 35)">
          <AtomNode start="(299, 85)" end="(299, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(299, 88)" end="(300, 35)">
            <AtomNode start="(299, 88)" end="(299, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(300, 3)" end="(300, 35)">
              <TacticTacticseq1IndentedNode start="(300, 3)" end="(300, 35)">
                <NullNode start="(300, 3)" end="(300, 35)">
                  <OtherNode start="(300, 3)" end="(300, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : filter p l ≠ []&#10;⊢ (filter p l).head h = (find? p l).get ⋯" state_after="no goals" tactic="simp [head_eq_iff_head?_eq_some]">
                    <AtomNode start="(300, 3)" end="(300, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(300, 8)" end="(300, 35)">
                      <AtomNode start="(300, 8)" end="(300, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(300, 9)" end="(300, 34)">
                        <OtherNode start="(300, 9)" end="(300, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(300, 9)" end="(300, 34)" leading="" trailing="" raw_val="head_eq_iff_head?_eq_some" val="head_eq_iff_head?_eq_some" full_name="List.head_eq_iff_head?_eq_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(300, 34)" end="(300, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(302, 1)" end="(304, 26)" name="getLast?_filter" full_name="List.getLast?_filter">
      <CommandDeclmodifiersNode start="(302, 1)" end="(302, 8)">
        <NullNode/>
        <NullNode start="(302, 1)" end="(302, 8)">
          <OtherNode start="(302, 1)" end="(302, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(302, 1)" end="(302, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(302, 3)" end="(302, 7)">
              <OtherNode start="(302, 3)" end="(302, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(302, 3)" end="(302, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(302, 3)" end="(302, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(302, 7)" end="(302, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(302, 9)" end="(304, 26)" name="getLast?_filter" full_name="List.getLast?_filter" _is_private_decl="False">
        <AtomNode start="(302, 9)" end="(302, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(302, 17)" end="(302, 32)">
          <IdentNode start="(302, 17)" end="(302, 32)" leading="" trailing=" " raw_val="getLast?_filter" val="getLast?_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(302, 33)" end="(302, 104)">
          <NullNode start="(302, 33)" end="(302, 60)">
            <OtherNode start="(302, 33)" end="(302, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(302, 33)" end="(302, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(302, 34)" end="(302, 35)">
                <IdentNode start="(302, 34)" end="(302, 35)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(302, 36)" end="(302, 46)">
                <AtomNode start="(302, 36)" end="(302, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(302, 38)" end="(302, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(302, 38)" end="(302, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(302, 40)" end="(302, 41)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(302, 42)" end="(302, 46)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(302, 46)" end="(302, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(302, 48)" end="(302, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(302, 48)" end="(302, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(302, 49)" end="(302, 50)">
                <IdentNode start="(302, 49)" end="(302, 50)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(302, 51)" end="(302, 59)">
                <AtomNode start="(302, 51)" end="(302, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(302, 53)" end="(302, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(302, 53)" end="(302, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(302, 58)" end="(302, 59)">
                    <IdentNode start="(302, 58)" end="(302, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(302, 59)" end="(302, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(302, 61)" end="(302, 104)">
            <AtomNode start="(302, 61)" end="(302, 62)" leading="" trailing=" " val=":"/>
            <OtherNode start="(302, 63)" end="(302, 104)" kind="«term_=_»">
              <OtherNode start="(302, 63)" end="(302, 84)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(302, 63)" end="(302, 75)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(302, 63)" end="(302, 64)" leading="" trailing="" val="("/>
                  <OtherNode start="(302, 64)" end="(302, 74)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(302, 64)" end="(302, 72)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                    <NullNode start="(302, 73)" end="(302, 74)">
                      <IdentNode start="(302, 73)" end="(302, 74)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(302, 74)" end="(302, 75)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(302, 75)" end="(302, 76)" leading="" trailing="" val="."/>
                <IdentNode start="(302, 76)" end="(302, 84)" leading="" trailing=" " raw_val="getLast?" val="getLast?" full_name="List.getLast?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(302, 85)" end="(302, 86)" leading="" trailing=" " val="="/>
              <OtherNode start="(302, 87)" end="(302, 104)" kind="Lean.Parser.Term.app">
                <IdentNode start="(302, 87)" end="(302, 102)" leading="" trailing=" " raw_val="l.reverse.find?" val="l.reverse.find?"/>
                <NullNode start="(302, 103)" end="(302, 104)">
                  <IdentNode start="(302, 103)" end="(302, 104)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(302, 105)" end="(304, 26)">
          <AtomNode start="(302, 105)" end="(302, 107)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(302, 108)" end="(304, 26)">
            <AtomNode start="(302, 108)" end="(302, 110)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(303, 3)" end="(304, 26)">
              <TacticTacticseq1IndentedNode start="(303, 3)" end="(304, 26)">
                <NullNode start="(303, 3)" end="(304, 26)">
                  <OtherNode start="(303, 3)" end="(303, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (filter p l).getLast? = find? p l.reverse" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (filter p l).reverse.head? = find? p l.reverse" tactic="rw [getLast?_eq_head?_reverse]">
                    <AtomNode start="(303, 3)" end="(303, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(303, 6)" end="(303, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(303, 6)" end="(303, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(303, 7)" end="(303, 32)">
                        <OtherNode start="(303, 7)" end="(303, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(303, 7)" end="(303, 32)" leading="" trailing="" raw_val="getLast?_eq_head?_reverse" val="getLast?_eq_head?_reverse" full_name="List.getLast?_eq_head?_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(303, 32)" end="(303, 33)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(304, 3)" end="(304, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ (filter p l).reverse.head? = find? p l.reverse" state_after="no goals" tactic="simp [← filter_reverse]">
                    <AtomNode start="(304, 3)" end="(304, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(304, 8)" end="(304, 26)">
                      <AtomNode start="(304, 8)" end="(304, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(304, 9)" end="(304, 25)">
                        <OtherNode start="(304, 9)" end="(304, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(304, 9)" end="(304, 10)">
                            <OtherNode start="(304, 9)" end="(304, 10)" kind="patternIgnore">
                              <OtherNode start="(304, 9)" end="(304, 10)" kind="token.«← »">
                                <AtomNode start="(304, 9)" end="(304, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(304, 11)" end="(304, 25)" leading="" trailing="" raw_val="filter_reverse" val="filter_reverse" full_name="List.filter_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(304, 25)" end="(304, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(306, 1)" end="(308, 41)" name="getLast_filter" full_name="List.getLast_filter">
      <CommandDeclmodifiersNode start="(306, 1)" end="(306, 8)">
        <NullNode/>
        <NullNode start="(306, 1)" end="(306, 8)">
          <OtherNode start="(306, 1)" end="(306, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(306, 1)" end="(306, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(306, 3)" end="(306, 7)">
              <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(306, 3)" end="(306, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(306, 7)" end="(306, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(306, 9)" end="(308, 41)" name="getLast_filter" full_name="List.getLast_filter" _is_private_decl="False">
        <AtomNode start="(306, 9)" end="(306, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(306, 17)" end="(306, 31)">
          <IdentNode start="(306, 17)" end="(306, 31)" leading="" trailing=" " raw_val="getLast_filter" val="getLast_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(306, 32)" end="(307, 95)">
          <NullNode start="(306, 32)" end="(306, 63)">
            <OtherNode start="(306, 32)" end="(306, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(306, 32)" end="(306, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(306, 33)" end="(306, 34)">
                <IdentNode start="(306, 33)" end="(306, 34)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(306, 35)" end="(306, 45)">
                <AtomNode start="(306, 35)" end="(306, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(306, 37)" end="(306, 45)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(306, 37)" end="(306, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(306, 39)" end="(306, 40)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(306, 41)" end="(306, 45)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(306, 45)" end="(306, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(306, 47)" end="(306, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(306, 47)" end="(306, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(306, 48)" end="(306, 49)">
                <IdentNode start="(306, 48)" end="(306, 49)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(306, 50)" end="(306, 58)">
                <AtomNode start="(306, 50)" end="(306, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(306, 52)" end="(306, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(306, 52)" end="(306, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(306, 57)" end="(306, 58)">
                    <IdentNode start="(306, 57)" end="(306, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(306, 58)" end="(306, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(306, 60)" end="(306, 63)">
              <AtomNode start="(306, 60)" end="(306, 61)" leading="" trailing="" val="("/>
              <NullNode start="(306, 61)" end="(306, 62)">
                <IdentNode start="(306, 61)" end="(306, 62)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(306, 62)" end="(306, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(306, 64)" end="(307, 95)">
            <AtomNode start="(306, 64)" end="(306, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(307, 5)" end="(307, 95)" kind="«term_=_»">
              <OtherNode start="(307, 5)" end="(307, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(307, 5)" end="(307, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(307, 5)" end="(307, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(307, 5)" end="(307, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(307, 6)" end="(307, 16)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(307, 6)" end="(307, 14)" leading="" trailing=" " raw_val="l.filter" val="l.filter"/>
                      <NullNode start="(307, 15)" end="(307, 16)">
                        <IdentNode start="(307, 15)" end="(307, 16)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(307, 16)" end="(307, 17)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(307, 17)" end="(307, 18)" leading="" trailing="" val="."/>
                  <IdentNode start="(307, 18)" end="(307, 25)" leading="" trailing=" " raw_val="getLast" val="getLast" full_name="List.getLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(307, 26)" end="(307, 27)">
                  <IdentNode start="(307, 26)" end="(307, 27)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(307, 28)" end="(307, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(307, 30)" end="(307, 95)" kind="Lean.Parser.Term.app">
                <OtherNode start="(307, 30)" end="(307, 53)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(307, 30)" end="(307, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(307, 30)" end="(307, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(307, 31)" end="(307, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(307, 31)" end="(307, 46)" leading="" trailing=" " raw_val="l.reverse.find?" val="l.reverse.find?"/>
                      <NullNode start="(307, 47)" end="(307, 48)">
                        <IdentNode start="(307, 47)" end="(307, 48)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(307, 48)" end="(307, 49)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(307, 49)" end="(307, 50)" leading="" trailing="" val="."/>
                  <IdentNode start="(307, 50)" end="(307, 53)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(307, 54)" end="(307, 95)">
                  <OtherNode start="(307, 54)" end="(307, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(307, 54)" end="(307, 55)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(307, 55)" end="(307, 94)">
                      <AtomNode start="(307, 55)" end="(307, 57)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(307, 58)" end="(307, 94)">
                        <TacticTacticseq1IndentedNode start="(307, 58)" end="(307, 94)">
                          <NullNode start="(307, 58)" end="(307, 94)">
                            <OtherNode start="(307, 58)" end="(307, 94)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type ?u.69899&#10;p : α → Bool&#10;l : List α&#10;h : filter p l ≠ []&#10;⊢ (find? p l.reverse).isSome = true" state_after="no goals" tactic="simp_all [Option.isSome_iff_ne_none]">
                              <AtomNode start="(307, 58)" end="(307, 66)" leading="" trailing=" " val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(307, 67)" end="(307, 94)">
                                <AtomNode start="(307, 67)" end="(307, 68)" leading="" trailing="" val="["/>
                                <NullNode start="(307, 68)" end="(307, 93)">
                                  <OtherNode start="(307, 68)" end="(307, 93)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(307, 68)" end="(307, 93)" leading="" trailing="" raw_val="Option.isSome_iff_ne_none" val="Option.isSome_iff_ne_none" full_name="Option.isSome_iff_ne_none" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(307, 93)" end="(307, 94)" leading="" trailing="" val="]"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(307, 94)" end="(307, 95)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(307, 96)" end="(308, 41)">
          <AtomNode start="(307, 96)" end="(307, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(307, 99)" end="(308, 41)">
            <AtomNode start="(307, 99)" end="(307, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(308, 3)" end="(308, 41)">
              <TacticTacticseq1IndentedNode start="(308, 3)" end="(308, 41)">
                <NullNode start="(308, 3)" end="(308, 41)">
                  <OtherNode start="(308, 3)" end="(308, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;h : filter p l ≠ []&#10;⊢ (filter p l).getLast h = (find? p l.reverse).get ⋯" state_after="no goals" tactic="simp [getLast_eq_iff_getLast?_eq_some]">
                    <AtomNode start="(308, 3)" end="(308, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(308, 8)" end="(308, 41)">
                      <AtomNode start="(308, 8)" end="(308, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(308, 9)" end="(308, 40)">
                        <OtherNode start="(308, 9)" end="(308, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(308, 9)" end="(308, 40)" leading="" trailing="" raw_val="getLast_eq_iff_getLast?_eq_some" val="getLast_eq_iff_getLast?_eq_some" full_name="List.getLast_eq_iff_getLast?_eq_some" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(308, 40)" end="(308, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(310, 1)" end="(318, 25)" name="find?_filterMap" full_name="List.find?_filterMap">
      <CommandDeclmodifiersNode start="(310, 1)" end="(310, 8)">
        <NullNode/>
        <NullNode start="(310, 1)" end="(310, 8)">
          <OtherNode start="(310, 1)" end="(310, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(310, 1)" end="(310, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(310, 3)" end="(310, 7)">
              <OtherNode start="(310, 3)" end="(310, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(310, 3)" end="(310, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(310, 3)" end="(310, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(310, 7)" end="(310, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(310, 9)" end="(318, 25)" name="find?_filterMap" full_name="List.find?_filterMap" _is_private_decl="False">
        <AtomNode start="(310, 9)" end="(310, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(310, 17)" end="(310, 32)">
          <IdentNode start="(310, 17)" end="(310, 32)" leading="" trailing=" " raw_val="find?_filterMap" val="find?_filterMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(310, 33)" end="(311, 72)">
          <NullNode start="(310, 33)" end="(310, 80)">
            <OtherNode start="(310, 33)" end="(310, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 33)" end="(310, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 34)" end="(310, 36)">
                <IdentNode start="(310, 34)" end="(310, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(310, 37)" end="(310, 45)">
                <AtomNode start="(310, 37)" end="(310, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 39)" end="(310, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(310, 39)" end="(310, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(310, 44)" end="(310, 45)">
                    <IdentNode start="(310, 44)" end="(310, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(310, 45)" end="(310, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(310, 47)" end="(310, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 47)" end="(310, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 48)" end="(310, 49)">
                <IdentNode start="(310, 48)" end="(310, 49)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(310, 50)" end="(310, 64)">
                <AtomNode start="(310, 50)" end="(310, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 52)" end="(310, 64)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(310, 52)" end="(310, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(310, 54)" end="(310, 55)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(310, 56)" end="(310, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(310, 56)" end="(310, 62)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(310, 63)" end="(310, 64)">
                      <IdentNode start="(310, 63)" end="(310, 64)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(310, 64)" end="(310, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(310, 66)" end="(310, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(310, 66)" end="(310, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(310, 67)" end="(310, 68)">
                <IdentNode start="(310, 67)" end="(310, 68)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(310, 69)" end="(310, 79)">
                <AtomNode start="(310, 69)" end="(310, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(310, 71)" end="(310, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(310, 71)" end="(310, 72)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(310, 73)" end="(310, 74)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(310, 75)" end="(310, 79)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(310, 79)" end="(310, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(310, 81)" end="(311, 72)">
            <AtomNode start="(310, 81)" end="(310, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(311, 5)" end="(311, 72)" kind="«term_=_»">
              <OtherNode start="(311, 5)" end="(311, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(311, 5)" end="(311, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(311, 5)" end="(311, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(311, 5)" end="(311, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(311, 6)" end="(311, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(311, 6)" end="(311, 18)" leading="" trailing=" " raw_val="xs.filterMap" val="xs.filterMap"/>
                      <NullNode start="(311, 19)" end="(311, 20)">
                        <IdentNode start="(311, 19)" end="(311, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(311, 20)" end="(311, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(311, 21)" end="(311, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(311, 22)" end="(311, 27)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(311, 28)" end="(311, 29)">
                  <IdentNode start="(311, 28)" end="(311, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(311, 30)" end="(311, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(311, 32)" end="(311, 72)" kind="Lean.Parser.Term.app">
                <OtherNode start="(311, 32)" end="(311, 70)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(311, 32)" end="(311, 65)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(311, 32)" end="(311, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(311, 33)" end="(311, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(311, 33)" end="(311, 41)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(311, 42)" end="(311, 64)">
                        <OtherNode start="(311, 42)" end="(311, 64)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(311, 42)" end="(311, 43)" leading="" trailing="" val="("/>
                          <OtherNode start="(311, 43)" end="(311, 63)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(311, 43)" end="(311, 46)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(311, 47)" end="(311, 63)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(311, 47)" end="(311, 48)">
                                <IdentNode start="(311, 47)" end="(311, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(311, 49)" end="(311, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(311, 52)" end="(311, 63)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(311, 52)" end="(311, 61)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(311, 52)" end="(311, 57)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(311, 52)" end="(311, 53)" leading="" trailing="" val="("/>
                                    <OtherNode start="(311, 53)" end="(311, 56)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(311, 53)" end="(311, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(311, 55)" end="(311, 56)">
                                        <IdentNode start="(311, 55)" end="(311, 56)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(311, 56)" end="(311, 57)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(311, 57)" end="(311, 58)" leading="" trailing="" val="."/>
                                  <IdentNode start="(311, 58)" end="(311, 61)" leading="" trailing=" " raw_val="any" val="any" full_name="Option.any" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                </OtherNode>
                                <NullNode start="(311, 62)" end="(311, 63)">
                                  <IdentNode start="(311, 62)" end="(311, 63)" leading="" trailing="" raw_val="p" val="p"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(311, 63)" end="(311, 64)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(311, 64)" end="(311, 65)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(311, 65)" end="(311, 66)" leading="" trailing="" val="."/>
                  <IdentNode start="(311, 66)" end="(311, 70)" leading="" trailing=" " raw_val="bind" val="bind" full_name="Option.bind" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(311, 71)" end="(311, 72)">
                  <IdentNode start="(311, 71)" end="(311, 72)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(311, 73)" end="(318, 25)">
          <AtomNode start="(311, 73)" end="(311, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(311, 76)" end="(318, 25)">
            <AtomNode start="(311, 76)" end="(311, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(312, 3)" end="(318, 25)">
              <TacticTacticseq1IndentedNode start="(312, 3)" end="(318, 25)">
                <NullNode start="(312, 3)" end="(318, 25)">
                  <OtherNode start="(312, 3)" end="(318, 25)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → Option β&#10;p : β → Bool&#10;⊢ find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [filterMap_cons]&#10;  split &amp;lt;;&amp;gt;&#10;  · simp only [find?_cons]&#10;    split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(312, 3)" end="(312, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(312, 13)" end="(312, 15)">
                      <OtherNode start="(312, 13)" end="(312, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(312, 13)" end="(312, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(312, 16)" end="(318, 25)">
                      <OtherNode start="(312, 16)" end="(318, 25)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(312, 16)" end="(312, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(313, 3)" end="(318, 25)">
                          <OtherNode start="(313, 3)" end="(313, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(313, 3)" end="(313, 8)">
                              <OtherNode start="(313, 3)" end="(313, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(313, 3)" end="(313, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(313, 5)" end="(313, 8)">
                                  <NullNode/>
                                  <IdentNode start="(313, 5)" end="(313, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(313, 9)" end="(313, 16)">
                              <AtomNode start="(313, 9)" end="(313, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(313, 12)" end="(313, 16)">
                                <TacticTacticseq1IndentedNode start="(313, 12)" end="(313, 16)">
                                  <NullNode start="(313, 12)" end="(313, 16)">
                                    <OtherNode start="(313, 12)" end="(313, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;⊢ find? p (filterMap f []) = (find? (fun a =&amp;gt; Option.any p (f a)) []).bind f" state_after="no goals" tactic="simp">
                                      <AtomNode start="(313, 12)" end="(313, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(314, 3)" end="(318, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(314, 3)" end="(314, 17)">
                              <OtherNode start="(314, 3)" end="(314, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(314, 3)" end="(314, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(314, 5)" end="(314, 9)">
                                  <NullNode/>
                                  <IdentNode start="(314, 5)" end="(314, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(314, 10)" end="(314, 17)">
                                  <IdentNode start="(314, 10)" end="(314, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(314, 12)" end="(314, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(314, 15)" end="(314, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(314, 18)" end="(318, 25)">
                              <AtomNode start="(314, 18)" end="(314, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(315, 5)" end="(318, 25)">
                                <TacticTacticseq1IndentedNode start="(315, 5)" end="(318, 25)">
                                  <NullNode start="(315, 5)" end="(318, 25)">
                                    <OtherNode start="(315, 5)" end="(315, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;x : α&#10;xs : List α&#10;ih : find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f&#10;⊢ find? p (filterMap f (x :: xs)) = (find? (fun a =&amp;gt; Option.any p (f a)) (x :: xs)).bind f" state_after="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;x : α&#10;xs : List α&#10;ih : find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f&#10;⊢ find? p&#10;      (match f x with&#10;      | none =&amp;gt; filterMap f xs&#10;      | some b =&amp;gt; b :: filterMap f xs) =&#10;    (find? (fun a =&amp;gt; Option.any p (f a)) (x :: xs)).bind f" tactic="simp only [filterMap_cons]">
                                      <AtomNode start="(315, 5)" end="(315, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(315, 10)" end="(315, 14)">
                                        <AtomNode start="(315, 10)" end="(315, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(315, 15)" end="(315, 31)">
                                        <AtomNode start="(315, 15)" end="(315, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(315, 16)" end="(315, 30)">
                                          <OtherNode start="(315, 16)" end="(315, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(315, 16)" end="(315, 30)" leading="" trailing="" raw_val="filterMap_cons" val="filterMap_cons" full_name="List.filterMap_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(315, 30)" end="(315, 31)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(316, 5)" end="(318, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;x : α&#10;xs : List α&#10;ih : find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f&#10;⊢ find? p&#10;      (match f x with&#10;      | none =&amp;gt; filterMap f xs&#10;      | some b =&amp;gt; b :: filterMap f xs) =&#10;    (find? (fun a =&amp;gt; Option.any p (f a)) (x :: xs)).bind f" state_after="no goals" tactic="split &amp;lt;;&amp;gt;&#10;· simp only [find?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(316, 5)" end="(316, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(316, 5)" end="(316, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(316, 11)" end="(316, 14)" leading="" trailing="&#10;    " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(317, 5)" end="(318, 25)" kind="Lean.cdot">
                                        <OtherNode start="(317, 5)" end="(317, 6)" kind="Lean.cdotTk">
                                          <OtherNode start="(317, 5)" end="(317, 6)" kind="patternIgnore">
                                            <OtherNode start="(317, 5)" end="(317, 6)" kind="token.«· »">
                                              <AtomNode start="(317, 5)" end="(317, 6)" leading="" trailing=" " val="·"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <TacticTacticseqNode start="(317, 7)" end="(318, 25)">
                                          <TacticTacticseq1IndentedNode start="(317, 7)" end="(318, 25)">
                                            <NullNode start="(317, 7)" end="(318, 25)">
                                              <OtherNode start="(317, 7)" end="(317, 29)" kind="Lean.Parser.Tactic.simp" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;x : α&#10;xs : List α&#10;ih : find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ find? p (b✝ :: filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) (x :: xs)).bind f" state_after="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;x : α&#10;xs : List α&#10;ih : find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (match p b✝ with&#10;    | true =&amp;gt; some b✝&#10;    | false =&amp;gt; find? p (filterMap f xs)) =&#10;    (match Option.any p (f x) with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? (fun a =&amp;gt; Option.any p (f a)) xs).bind&#10;      f" tactic="simp only [find?_cons]">
                                                <AtomNode start="(317, 7)" end="(317, 11)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode start="(317, 12)" end="(317, 16)">
                                                  <AtomNode start="(317, 12)" end="(317, 16)" leading="" trailing=" " val="only"/>
                                                </NullNode>
                                                <NullNode start="(317, 17)" end="(317, 29)">
                                                  <AtomNode start="(317, 17)" end="(317, 18)" leading="" trailing="" val="["/>
                                                  <NullNode start="(317, 18)" end="(317, 28)">
                                                    <OtherNode start="(317, 18)" end="(317, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(317, 18)" end="(317, 28)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(317, 28)" end="(317, 29)" leading="" trailing="&#10;      " val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <OtherNode start="(318, 7)" end="(318, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.h_2&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;p : β → Bool&#10;x : α&#10;xs : List α&#10;ih : find? p (filterMap f xs) = (find? (fun a =&amp;gt; Option.any p (f a)) xs).bind f&#10;x✝ : Option β&#10;b✝ : β&#10;heq✝ : f x = some b✝&#10;⊢ (match p b✝ with&#10;    | true =&amp;gt; some b✝&#10;    | false =&amp;gt; find? p (filterMap f xs)) =&#10;    (match Option.any p (f x) with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? (fun a =&amp;gt; Option.any p (f a)) xs).bind&#10;      f" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                                <OtherNode start="(318, 7)" end="(318, 12)" kind="Lean.Parser.Tactic.split">
                                                  <AtomNode start="(318, 7)" end="(318, 12)" leading="" trailing=" " val="split"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(318, 13)" end="(318, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                <OtherNode start="(318, 17)" end="(318, 25)" kind="Lean.Parser.Tactic.simpAll">
                                                  <AtomNode start="(318, 17)" end="(318, 25)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(320, 1)" end="(325, 42)" name="find?_map" full_name="List.find?_map">
      <CommandDeclmodifiersNode start="(320, 1)" end="(320, 8)">
        <NullNode/>
        <NullNode start="(320, 1)" end="(320, 8)">
          <OtherNode start="(320, 1)" end="(320, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(320, 1)" end="(320, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(320, 3)" end="(320, 7)">
              <OtherNode start="(320, 3)" end="(320, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(320, 3)" end="(320, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(320, 3)" end="(320, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(320, 7)" end="(320, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(320, 9)" end="(325, 42)" name="find?_map" full_name="List.find?_map" _is_private_decl="False">
        <AtomNode start="(320, 9)" end="(320, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(320, 17)" end="(320, 26)">
          <IdentNode start="(320, 17)" end="(320, 26)" leading="" trailing=" " raw_val="find?_map" val="find?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(320, 27)" end="(320, 97)">
          <NullNode start="(320, 27)" end="(320, 51)">
            <OtherNode start="(320, 27)" end="(320, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(320, 27)" end="(320, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(320, 28)" end="(320, 29)">
                <IdentNode start="(320, 28)" end="(320, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(320, 30)" end="(320, 37)">
                <AtomNode start="(320, 30)" end="(320, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(320, 32)" end="(320, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(320, 32)" end="(320, 33)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(320, 34)" end="(320, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(320, 36)" end="(320, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(320, 37)" end="(320, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(320, 39)" end="(320, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(320, 39)" end="(320, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(320, 40)" end="(320, 41)">
                <IdentNode start="(320, 40)" end="(320, 41)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(320, 42)" end="(320, 50)">
                <AtomNode start="(320, 42)" end="(320, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(320, 44)" end="(320, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(320, 44)" end="(320, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(320, 49)" end="(320, 50)">
                    <IdentNode start="(320, 49)" end="(320, 50)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(320, 50)" end="(320, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(320, 52)" end="(320, 97)">
            <AtomNode start="(320, 52)" end="(320, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(320, 54)" end="(320, 97)" kind="«term_=_»">
              <OtherNode start="(320, 54)" end="(320, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(320, 54)" end="(320, 59)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(320, 60)" end="(320, 71)">
                  <IdentNode start="(320, 60)" end="(320, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(320, 62)" end="(320, 71)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(320, 62)" end="(320, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(320, 63)" end="(320, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(320, 63)" end="(320, 68)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(320, 69)" end="(320, 70)">
                        <IdentNode start="(320, 69)" end="(320, 70)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(320, 70)" end="(320, 71)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(320, 72)" end="(320, 73)" leading="" trailing=" " val="="/>
              <OtherNode start="(320, 74)" end="(320, 97)" kind="Lean.Parser.Term.app">
                <OtherNode start="(320, 74)" end="(320, 95)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(320, 74)" end="(320, 91)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(320, 74)" end="(320, 75)" leading="" trailing="" val="("/>
                    <OtherNode start="(320, 75)" end="(320, 90)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(320, 75)" end="(320, 82)" leading="" trailing=" " raw_val="l.find?" val="l.find?"/>
                      <NullNode start="(320, 83)" end="(320, 90)">
                        <OtherNode start="(320, 83)" end="(320, 90)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(320, 83)" end="(320, 84)" leading="" trailing="" val="("/>
                          <OtherNode start="(320, 84)" end="(320, 89)" kind="«term_∘_»">
                            <IdentNode start="(320, 84)" end="(320, 85)" leading="" trailing=" " raw_val="p" val="p"/>
                            <AtomNode start="(320, 86)" end="(320, 87)" leading="" trailing=" " val="∘"/>
                            <IdentNode start="(320, 88)" end="(320, 89)" leading="" trailing="" raw_val="f" val="f"/>
                          </OtherNode>
                          <AtomNode start="(320, 89)" end="(320, 90)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(320, 90)" end="(320, 91)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(320, 91)" end="(320, 92)" leading="" trailing="" val="."/>
                  <IdentNode start="(320, 92)" end="(320, 95)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(320, 96)" end="(320, 97)">
                  <IdentNode start="(320, 96)" end="(320, 97)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(320, 98)" end="(325, 42)">
          <AtomNode start="(320, 98)" end="(320, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(320, 101)" end="(325, 42)">
            <AtomNode start="(320, 101)" end="(320, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(321, 3)" end="(325, 42)">
              <TacticTacticseq1IndentedNode start="(321, 3)" end="(325, 42)">
                <NullNode start="(321, 3)" end="(325, 42)">
                  <OtherNode start="(321, 3)" end="(325, 42)" kind="Lean.Parser.Tactic.induction" state_before="β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;l : List β&#10;⊢ find? p (map f l) = Option.map f (find? (p ∘ f) l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [map_cons, find?]&#10;  by_cases h : p (f x) &amp;lt;;&amp;gt; simp [h, ih]">
                    <AtomNode start="(321, 3)" end="(321, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(321, 13)" end="(321, 14)">
                      <OtherNode start="(321, 13)" end="(321, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(321, 13)" end="(321, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(321, 15)" end="(325, 42)">
                      <OtherNode start="(321, 15)" end="(325, 42)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(321, 15)" end="(321, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(322, 3)" end="(325, 42)">
                          <OtherNode start="(322, 3)" end="(322, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(322, 3)" end="(322, 8)">
                              <OtherNode start="(322, 3)" end="(322, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(322, 3)" end="(322, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(322, 5)" end="(322, 8)">
                                  <NullNode/>
                                  <IdentNode start="(322, 5)" end="(322, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(322, 9)" end="(322, 16)">
                              <AtomNode start="(322, 9)" end="(322, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(322, 12)" end="(322, 16)">
                                <TacticTacticseq1IndentedNode start="(322, 12)" end="(322, 16)">
                                  <NullNode start="(322, 12)" end="(322, 16)">
                                    <OtherNode start="(322, 12)" end="(322, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;⊢ find? p (map f []) = Option.map f (find? (p ∘ f) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(322, 12)" end="(322, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(323, 3)" end="(325, 42)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(323, 3)" end="(323, 17)">
                              <OtherNode start="(323, 3)" end="(323, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(323, 3)" end="(323, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(323, 5)" end="(323, 9)">
                                  <NullNode/>
                                  <IdentNode start="(323, 5)" end="(323, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(323, 10)" end="(323, 17)">
                                  <IdentNode start="(323, 10)" end="(323, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(323, 12)" end="(323, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(323, 15)" end="(323, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(323, 18)" end="(325, 42)">
                              <AtomNode start="(323, 18)" end="(323, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(324, 5)" end="(325, 42)">
                                <TacticTacticseq1IndentedNode start="(324, 5)" end="(325, 42)">
                                  <NullNode start="(324, 5)" end="(325, 42)">
                                    <OtherNode start="(324, 5)" end="(324, 32)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;x : β&#10;xs : List β&#10;ih : find? p (map f xs) = Option.map f (find? (p ∘ f) xs)&#10;⊢ find? p (map f (x :: xs)) = Option.map f (find? (p ∘ f) (x :: xs))" state_after="case cons&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;x : β&#10;xs : List β&#10;ih : find? p (map f xs) = Option.map f (find? (p ∘ f) xs)&#10;⊢ (match p (f x) with&#10;    | true =&amp;gt; some (f x)&#10;    | false =&amp;gt; find? p (map f xs)) =&#10;    Option.map f&#10;      (match (p ∘ f) x with&#10;      | true =&amp;gt; some x&#10;      | false =&amp;gt; find? (p ∘ f) xs)" tactic="simp only [map_cons, find?]">
                                      <AtomNode start="(324, 5)" end="(324, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(324, 10)" end="(324, 14)">
                                        <AtomNode start="(324, 10)" end="(324, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(324, 15)" end="(324, 32)">
                                        <AtomNode start="(324, 15)" end="(324, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(324, 16)" end="(324, 31)">
                                          <OtherNode start="(324, 16)" end="(324, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(324, 16)" end="(324, 24)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(324, 24)" end="(324, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(324, 26)" end="(324, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(324, 26)" end="(324, 31)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(324, 31)" end="(324, 32)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(325, 5)" end="(325, 42)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;x : β&#10;xs : List β&#10;ih : find? p (map f xs) = Option.map f (find? (p ∘ f) xs)&#10;⊢ (match p (f x) with&#10;    | true =&amp;gt; some (f x)&#10;    | false =&amp;gt; find? p (map f xs)) =&#10;    Option.map f&#10;      (match (p ∘ f) x with&#10;      | true =&amp;gt; some x&#10;      | false =&amp;gt; find? (p ∘ f) xs)" state_after="no goals" tactic="by_cases h : p (f x) &amp;lt;;&amp;gt; simp [h, ih]">
                                      <OtherNode start="(325, 5)" end="(325, 25)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(325, 5)" end="(325, 13)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode start="(325, 14)" end="(325, 17)">
                                          <IdentNode start="(325, 14)" end="(325, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <AtomNode start="(325, 16)" end="(325, 17)" leading="" trailing=" " val=":"/>
                                        </NullNode>
                                        <OtherNode start="(325, 18)" end="(325, 25)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(325, 18)" end="(325, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                          <NullNode start="(325, 20)" end="(325, 25)">
                                            <OtherNode start="(325, 20)" end="(325, 25)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(325, 20)" end="(325, 21)" leading="" trailing="" val="("/>
                                              <OtherNode start="(325, 21)" end="(325, 24)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(325, 21)" end="(325, 22)" leading="" trailing=" " raw_val="f" val="f"/>
                                                <NullNode start="(325, 23)" end="(325, 24)">
                                                  <IdentNode start="(325, 23)" end="(325, 24)" leading="" trailing="" raw_val="x" val="x"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(325, 24)" end="(325, 25)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(325, 26)" end="(325, 29)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(325, 30)" end="(325, 42)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(325, 30)" end="(325, 34)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(325, 35)" end="(325, 42)">
                                          <AtomNode start="(325, 35)" end="(325, 36)" leading="" trailing="" val="["/>
                                          <NullNode start="(325, 36)" end="(325, 41)">
                                            <OtherNode start="(325, 36)" end="(325, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(325, 36)" end="(325, 37)" leading="" trailing="" raw_val="h" val="h"/>
                                            </OtherNode>
                                            <AtomNode start="(325, 37)" end="(325, 38)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(325, 39)" end="(325, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(325, 39)" end="(325, 41)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(325, 41)" end="(325, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(327, 1)" end="(333, 23)" name="find?_flatten" full_name="List.find?_flatten">
      <CommandDeclmodifiersNode start="(327, 1)" end="(327, 8)">
        <NullNode/>
        <NullNode start="(327, 1)" end="(327, 8)">
          <OtherNode start="(327, 1)" end="(327, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(327, 1)" end="(327, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(327, 3)" end="(327, 7)">
              <OtherNode start="(327, 3)" end="(327, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(327, 3)" end="(327, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(327, 3)" end="(327, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(327, 7)" end="(327, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(327, 9)" end="(333, 23)" name="find?_flatten" full_name="List.find?_flatten" _is_private_decl="False">
        <AtomNode start="(327, 9)" end="(327, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(327, 17)" end="(327, 30)">
          <IdentNode start="(327, 17)" end="(327, 30)" leading="" trailing=" " raw_val="find?_flatten" val="find?_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(327, 31)" end="(328, 52)">
          <NullNode start="(327, 31)" end="(327, 67)">
            <OtherNode start="(327, 31)" end="(327, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(327, 31)" end="(327, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(327, 32)" end="(327, 35)">
                <IdentNode start="(327, 32)" end="(327, 35)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(327, 36)" end="(327, 51)">
                <AtomNode start="(327, 36)" end="(327, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(327, 38)" end="(327, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(327, 38)" end="(327, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(327, 43)" end="(327, 51)">
                    <OtherNode start="(327, 43)" end="(327, 51)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(327, 43)" end="(327, 44)" leading="" trailing="" val="("/>
                      <OtherNode start="(327, 44)" end="(327, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(327, 44)" end="(327, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(327, 49)" end="(327, 50)">
                          <IdentNode start="(327, 49)" end="(327, 50)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(327, 50)" end="(327, 51)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(327, 51)" end="(327, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(327, 53)" end="(327, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(327, 53)" end="(327, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(327, 54)" end="(327, 55)">
                <IdentNode start="(327, 54)" end="(327, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(327, 56)" end="(327, 66)">
                <AtomNode start="(327, 56)" end="(327, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(327, 58)" end="(327, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(327, 58)" end="(327, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(327, 60)" end="(327, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(327, 62)" end="(327, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(327, 66)" end="(327, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(327, 68)" end="(328, 52)">
            <AtomNode start="(327, 68)" end="(327, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(328, 5)" end="(328, 52)" kind="«term_=_»">
              <OtherNode start="(328, 5)" end="(328, 24)" kind="Lean.Parser.Term.app">
                <IdentNode start="(328, 5)" end="(328, 22)" leading="" trailing=" " raw_val="xss.flatten.find?" val="xss.flatten.find?"/>
                <NullNode start="(328, 23)" end="(328, 24)">
                  <IdentNode start="(328, 23)" end="(328, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(328, 25)" end="(328, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(328, 27)" end="(328, 52)" kind="Lean.Parser.Term.app">
                <IdentNode start="(328, 27)" end="(328, 40)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                <NullNode start="(328, 41)" end="(328, 52)">
                  <OtherNode start="(328, 41)" end="(328, 52)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(328, 41)" end="(328, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(328, 42)" end="(328, 51)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(328, 42)" end="(328, 49)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(328, 42)" end="(328, 43)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(328, 42)" end="(328, 43)" leading="" trailing="" val="·"/>
                        </OtherNode>
                        <AtomNode start="(328, 43)" end="(328, 44)" leading="" trailing="" val="."/>
                        <IdentNode start="(328, 44)" end="(328, 49)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(328, 50)" end="(328, 51)">
                        <IdentNode start="(328, 50)" end="(328, 51)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(328, 51)" end="(328, 52)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(328, 53)" end="(333, 23)">
          <AtomNode start="(328, 53)" end="(328, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(328, 56)" end="(333, 23)">
            <AtomNode start="(328, 56)" end="(328, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(329, 3)" end="(333, 23)">
              <TacticTacticseq1IndentedNode start="(329, 3)" end="(333, 23)">
                <NullNode start="(329, 3)" end="(333, 23)">
                  <OtherNode start="(329, 3)" end="(333, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xss : List (List α)&#10;p : α → Bool&#10;⊢ find? p xss.flatten = findSome? (fun x =&amp;gt; find? p x) xss" state_after="no goals" tactic="induction xss with&#10;| nil =&amp;gt; simp&#10;| cons _ _ ih =&amp;gt;&#10;  simp only [flatten_cons, find?_append, findSome?_cons, ih]&#10;  split &amp;lt;;&amp;gt; simp [*]">
                    <AtomNode start="(329, 3)" end="(329, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(329, 13)" end="(329, 16)">
                      <OtherNode start="(329, 13)" end="(329, 16)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(329, 13)" end="(329, 16)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(329, 17)" end="(333, 23)">
                      <OtherNode start="(329, 17)" end="(333, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(329, 17)" end="(329, 21)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(330, 3)" end="(333, 23)">
                          <OtherNode start="(330, 3)" end="(330, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(330, 3)" end="(330, 8)">
                              <OtherNode start="(330, 3)" end="(330, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(330, 3)" end="(330, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(330, 5)" end="(330, 8)">
                                  <NullNode/>
                                  <IdentNode start="(330, 5)" end="(330, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(330, 9)" end="(330, 16)">
                              <AtomNode start="(330, 9)" end="(330, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(330, 12)" end="(330, 16)">
                                <TacticTacticseq1IndentedNode start="(330, 12)" end="(330, 16)">
                                  <NullNode start="(330, 12)" end="(330, 16)">
                                    <OtherNode start="(330, 12)" end="(330, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ find? p [].flatten = findSome? (fun x =&amp;gt; find? p x) []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(330, 12)" end="(330, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(331, 3)" end="(333, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(331, 3)" end="(331, 16)">
                              <OtherNode start="(331, 3)" end="(331, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(331, 3)" end="(331, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(331, 5)" end="(331, 9)">
                                  <NullNode/>
                                  <IdentNode start="(331, 5)" end="(331, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(331, 10)" end="(331, 16)">
                                  <TermHoleNode start="(331, 10)" end="(331, 11)">
                                    <AtomNode start="(331, 10)" end="(331, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(331, 12)" end="(331, 13)">
                                    <AtomNode start="(331, 12)" end="(331, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <IdentNode start="(331, 14)" end="(331, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(331, 17)" end="(333, 23)">
                              <AtomNode start="(331, 17)" end="(331, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(332, 5)" end="(333, 23)">
                                <TacticTacticseq1IndentedNode start="(332, 5)" end="(333, 23)">
                                  <NullNode start="(332, 5)" end="(333, 23)">
                                    <OtherNode start="(332, 5)" end="(332, 63)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : List α&#10;tail✝ : List (List α)&#10;ih : find? p tail✝.flatten = findSome? (fun x =&amp;gt; find? p x) tail✝&#10;⊢ find? p (head✝ :: tail✝).flatten = findSome? (fun x =&amp;gt; find? p x) (head✝ :: tail✝)" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : List α&#10;tail✝ : List (List α)&#10;ih : find? p tail✝.flatten = findSome? (fun x =&amp;gt; find? p x) tail✝&#10;⊢ (find? p head✝).or (findSome? (fun x =&amp;gt; find? p x) tail✝) =&#10;    match find? p head✝ with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (fun x =&amp;gt; find? p x) tail✝" tactic="simp only [flatten_cons, find?_append, findSome?_cons, ih]">
                                      <AtomNode start="(332, 5)" end="(332, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(332, 10)" end="(332, 14)">
                                        <AtomNode start="(332, 10)" end="(332, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(332, 15)" end="(332, 63)">
                                        <AtomNode start="(332, 15)" end="(332, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(332, 16)" end="(332, 62)">
                                          <OtherNode start="(332, 16)" end="(332, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(332, 16)" end="(332, 28)" leading="" trailing="" raw_val="flatten_cons" val="flatten_cons" full_name="List.flatten_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(332, 28)" end="(332, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(332, 30)" end="(332, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(332, 30)" end="(332, 42)" leading="" trailing="" raw_val="find?_append" val="find?_append" full_name="List.find?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(332, 42)" end="(332, 43)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(332, 44)" end="(332, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(332, 44)" end="(332, 58)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(332, 58)" end="(332, 59)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(332, 60)" end="(332, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(332, 60)" end="(332, 62)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(332, 62)" end="(332, 63)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(333, 5)" end="(333, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : List α&#10;tail✝ : List (List α)&#10;ih : find? p tail✝.flatten = findSome? (fun x =&amp;gt; find? p x) tail✝&#10;⊢ (find? p head✝).or (findSome? (fun x =&amp;gt; find? p x) tail✝) =&#10;    match find? p head✝ with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (fun x =&amp;gt; find? p x) tail✝" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                                      <OtherNode start="(333, 5)" end="(333, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(333, 5)" end="(333, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(333, 11)" end="(333, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(333, 15)" end="(333, 23)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(333, 15)" end="(333, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(333, 20)" end="(333, 23)">
                                          <AtomNode start="(333, 20)" end="(333, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(333, 21)" end="(333, 22)">
                                            <OtherNode start="(333, 21)" end="(333, 22)" kind="Lean.Parser.Tactic.simpStar">
                                              <AtomNode start="(333, 21)" end="(333, 22)" leading="" trailing="" val="*"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(333, 22)" end="(333, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(335, 1)" end="(337, 7)" name="find?_flatten_eq_none_iff" full_name="List.find?_flatten_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(335, 1)" end="(337, 7)" name="find?_flatten_eq_none_iff" full_name="List.find?_flatten_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(335, 1)" end="(335, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(335, 9)" end="(335, 34)">
          <IdentNode start="(335, 9)" end="(335, 34)" leading="" trailing=" " raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(335, 35)" end="(336, 58)">
          <NullNode start="(335, 35)" end="(335, 70)">
            <OtherNode start="(335, 35)" end="(335, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(335, 35)" end="(335, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(335, 36)" end="(335, 38)">
                <IdentNode start="(335, 36)" end="(335, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(335, 39)" end="(335, 54)">
                <AtomNode start="(335, 39)" end="(335, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 41)" end="(335, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(335, 41)" end="(335, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(335, 46)" end="(335, 54)">
                    <OtherNode start="(335, 46)" end="(335, 54)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(335, 46)" end="(335, 47)" leading="" trailing="" val="("/>
                      <OtherNode start="(335, 47)" end="(335, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(335, 47)" end="(335, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(335, 52)" end="(335, 53)">
                          <IdentNode start="(335, 52)" end="(335, 53)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(335, 53)" end="(335, 54)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(335, 54)" end="(335, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(335, 56)" end="(335, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(335, 56)" end="(335, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(335, 57)" end="(335, 58)">
                <IdentNode start="(335, 57)" end="(335, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(335, 59)" end="(335, 69)">
                <AtomNode start="(335, 59)" end="(335, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(335, 61)" end="(335, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(335, 61)" end="(335, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(335, 63)" end="(335, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(335, 65)" end="(335, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(335, 69)" end="(335, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(335, 71)" end="(336, 58)">
            <AtomNode start="(335, 71)" end="(335, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(336, 5)" end="(336, 58)" kind="«term_↔_»">
              <OtherNode start="(336, 5)" end="(336, 30)" kind="«term_=_»">
                <OtherNode start="(336, 5)" end="(336, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(336, 5)" end="(336, 21)" leading="" trailing=" " raw_val="xs.flatten.find?" val="xs.flatten.find?"/>
                  <NullNode start="(336, 22)" end="(336, 23)">
                    <IdentNode start="(336, 22)" end="(336, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(336, 24)" end="(336, 25)" leading="" trailing=" " val="="/>
                <IdentNode start="(336, 26)" end="(336, 30)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(336, 31)" end="(336, 32)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(336, 33)" end="(336, 58)" kind="Lean.«term∀__,_»">
                <AtomNode start="(336, 33)" end="(336, 34)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(336, 35)" end="(336, 37)">
                  <IdentNode start="(336, 35)" end="(336, 37)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </LeanBinderidentNode>
                <OtherNode start="(336, 38)" end="(336, 42)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(336, 38)" end="(336, 39)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(336, 40)" end="(336, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(336, 42)" end="(336, 43)" leading="" trailing=" " val=","/>
                <OtherNode start="(336, 44)" end="(336, 58)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(336, 44)" end="(336, 45)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(336, 46)" end="(336, 47)">
                    <IdentNode start="(336, 46)" end="(336, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(336, 48)" end="(336, 52)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(336, 48)" end="(336, 49)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(336, 50)" end="(336, 52)" leading="" trailing="" raw_val="ys" val="ys"/>
                  </OtherNode>
                  <AtomNode start="(336, 52)" end="(336, 53)" leading="" trailing=" " val=","/>
                  <OtherNode start="(336, 54)" end="(336, 58)" kind="term!_">
                    <AtomNode start="(336, 54)" end="(336, 55)" leading="" trailing="" val="!"/>
                    <OtherNode start="(336, 55)" end="(336, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(336, 55)" end="(336, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(336, 57)" end="(336, 58)">
                        <IdentNode start="(336, 57)" end="(336, 58)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(336, 59)" end="(337, 7)">
          <AtomNode start="(336, 59)" end="(336, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(336, 62)" end="(337, 7)">
            <AtomNode start="(336, 62)" end="(336, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(337, 3)" end="(337, 7)">
              <TacticTacticseq1IndentedNode start="(337, 3)" end="(337, 7)">
                <NullNode start="(337, 3)" end="(337, 7)">
                  <OtherNode start="(337, 3)" end="(337, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;⊢ find? p xs.flatten = none ↔ ∀ (ys : List α), ys ∈ xs → ∀ (x : α), x ∈ ys → (!p x) = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(337, 3)" end="(337, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(339, 1)" end="(340, 59)" name="find?_flatten_eq_none" full_name="List.find?_flatten_eq_none">
      <CommandDeclmodifiersNode start="(339, 1)" end="(339, 64)">
        <NullNode/>
        <NullNode start="(339, 1)" end="(339, 64)">
          <OtherNode start="(339, 1)" end="(339, 64)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(339, 1)" end="(339, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(339, 3)" end="(339, 63)">
              <OtherNode start="(339, 3)" end="(339, 63)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(339, 3)" end="(339, 63)" kind="Lean.deprecated">
                  <AtomNode start="(339, 3)" end="(339, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(339, 14)" end="(339, 39)">
                    <IdentNode start="(339, 14)" end="(339, 39)" leading="" trailing=" " raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff" full_name="List.find?_flatten_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(335, 9)" def_end="(335, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(339, 40)" end="(339, 63)">
                    <AtomNode start="(339, 40)" end="(339, 41)" leading="" trailing="" val="("/>
                    <AtomNode start="(339, 41)" end="(339, 46)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(339, 47)" end="(339, 49)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(339, 50)" end="(339, 62)" kind="str">
                      <AtomNode start="(339, 50)" end="(339, 62)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(339, 62)" end="(339, 63)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(339, 63)" end="(339, 64)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(340, 1)" end="(340, 59)" name="find?_flatten_eq_none">
        <AtomNode start="(340, 1)" end="(340, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(340, 8)" end="(340, 29)">
          <IdentNode start="(340, 8)" end="(340, 29)" leading="" trailing=" " raw_val="find?_flatten_eq_none" val="find?_flatten_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(340, 30)" end="(340, 59)">
          <AtomNode start="(340, 30)" end="(340, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(340, 33)" end="(340, 59)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(340, 33)" end="(340, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(340, 34)" end="(340, 59)" leading="" trailing="&#10;&#10;" raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff" full_name="List.find?_flatten_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(335, 9)" def_end="(335, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(342, 1)" end="(380, 19)" name="find?_flatten_eq_some_iff" full_name="List.find?_flatten_eq_some_iff">
      <CommandDeclmodifiersNode start="(342, 1)" end="(346, 3)">
        <NullNode start="(342, 1)" end="(346, 3)">
          <CommandDoccommentNode start="(342, 1)" end="(346, 3)" comment="If `find? p` returns `some a` from `xs.flatten`, then `p a` holds, and&#10;some list in `xs` contains `a`, and no earlier element of that list satisfies `p`.&#10;Moreover, no earlier list in `xs` has an element satisfying `p`.&#10;-/">
            <AtomNode start="(342, 1)" end="(342, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(343, 1)" end="(346, 3)" leading="" trailing="&#10;" val="If `find? p` returns `some a` from `xs.flatten`, then `p a` holds, and&#10;some list in `xs` contains `a`, and no earlier element of that list satisfies `p`.&#10;Moreover, no earlier list in `xs` has an element satisfying `p`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(347, 1)" end="(380, 19)" name="find?_flatten_eq_some_iff" full_name="List.find?_flatten_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(347, 1)" end="(347, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(347, 9)" end="(347, 34)">
          <IdentNode start="(347, 9)" end="(347, 34)" leading="" trailing=" " raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(347, 35)" end="(350, 53)">
          <NullNode start="(347, 35)" end="(347, 78)">
            <OtherNode start="(347, 35)" end="(347, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 35)" end="(347, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 36)" end="(347, 38)">
                <IdentNode start="(347, 36)" end="(347, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(347, 39)" end="(347, 54)">
                <AtomNode start="(347, 39)" end="(347, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 41)" end="(347, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(347, 41)" end="(347, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(347, 46)" end="(347, 54)">
                    <OtherNode start="(347, 46)" end="(347, 54)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(347, 46)" end="(347, 47)" leading="" trailing="" val="("/>
                      <OtherNode start="(347, 47)" end="(347, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(347, 47)" end="(347, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(347, 52)" end="(347, 53)">
                          <IdentNode start="(347, 52)" end="(347, 53)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(347, 53)" end="(347, 54)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 54)" end="(347, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(347, 56)" end="(347, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 56)" end="(347, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 57)" end="(347, 58)">
                <IdentNode start="(347, 57)" end="(347, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(347, 59)" end="(347, 69)">
                <AtomNode start="(347, 59)" end="(347, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(347, 61)" end="(347, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(347, 61)" end="(347, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(347, 63)" end="(347, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(347, 65)" end="(347, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(347, 69)" end="(347, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(347, 71)" end="(347, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(347, 71)" end="(347, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(347, 72)" end="(347, 73)">
                <IdentNode start="(347, 72)" end="(347, 73)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(347, 74)" end="(347, 77)">
                <AtomNode start="(347, 74)" end="(347, 75)" leading="" trailing=" " val=":"/>
                <IdentNode start="(347, 76)" end="(347, 77)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(347, 77)" end="(347, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(347, 79)" end="(350, 53)">
            <AtomNode start="(347, 79)" end="(347, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(348, 5)" end="(350, 53)" kind="«term_↔_»">
              <OtherNode start="(348, 5)" end="(348, 32)" kind="«term_=_»">
                <OtherNode start="(348, 5)" end="(348, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(348, 5)" end="(348, 21)" leading="" trailing=" " raw_val="xs.flatten.find?" val="xs.flatten.find?"/>
                  <NullNode start="(348, 22)" end="(348, 23)">
                    <IdentNode start="(348, 22)" end="(348, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(348, 24)" end="(348, 25)" leading="" trailing=" " val="="/>
                <OtherNode start="(348, 26)" end="(348, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(348, 26)" end="(348, 30)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(348, 31)" end="(348, 32)">
                    <IdentNode start="(348, 31)" end="(348, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(348, 33)" end="(348, 34)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(349, 7)" end="(350, 53)" kind="«term_∧_»">
                <OtherNode start="(349, 7)" end="(349, 10)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(349, 7)" end="(349, 8)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(349, 9)" end="(349, 10)">
                    <IdentNode start="(349, 9)" end="(349, 10)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(349, 11)" end="(349, 12)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(349, 13)" end="(350, 53)" kind="«term∃_,_»">
                  <AtomNode start="(349, 13)" end="(349, 14)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(349, 15)" end="(349, 26)" kind="Lean.explicitBinders">
                    <OtherNode start="(349, 15)" end="(349, 26)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(349, 15)" end="(349, 26)">
                        <LeanBinderidentNode start="(349, 15)" end="(349, 17)">
                          <IdentNode start="(349, 15)" end="(349, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(349, 18)" end="(349, 20)">
                          <IdentNode start="(349, 18)" end="(349, 20)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(349, 21)" end="(349, 23)">
                          <IdentNode start="(349, 21)" end="(349, 23)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(349, 24)" end="(349, 26)">
                          <IdentNode start="(349, 24)" end="(349, 26)" leading="" trailing="" raw_val="bs" val="bs"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(349, 26)" end="(349, 27)" leading="" trailing=" " val=","/>
                  <OtherNode start="(349, 28)" end="(350, 53)" kind="«term_∧_»">
                    <OtherNode start="(349, 28)" end="(349, 60)" kind="«term_=_»">
                      <IdentNode start="(349, 28)" end="(349, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(349, 31)" end="(349, 32)" leading="" trailing=" " val="="/>
                      <OtherNode start="(349, 33)" end="(349, 60)" kind="«term_++_»">
                        <IdentNode start="(349, 33)" end="(349, 35)" leading="" trailing=" " raw_val="as" val="as"/>
                        <AtomNode start="(349, 36)" end="(349, 38)" leading="" trailing=" " val="++"/>
                        <OtherNode start="(349, 39)" end="(349, 60)" kind="«term_::_»">
                          <OtherNode start="(349, 39)" end="(349, 54)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(349, 39)" end="(349, 40)" leading="" trailing="" val="("/>
                            <OtherNode start="(349, 40)" end="(349, 53)" kind="«term_++_»">
                              <IdentNode start="(349, 40)" end="(349, 42)" leading="" trailing=" " raw_val="ys" val="ys"/>
                              <AtomNode start="(349, 43)" end="(349, 45)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(349, 46)" end="(349, 53)" kind="«term_::_»">
                                <IdentNode start="(349, 46)" end="(349, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(349, 48)" end="(349, 50)" leading="" trailing=" " val="::"/>
                                <IdentNode start="(349, 51)" end="(349, 53)" leading="" trailing="" raw_val="zs" val="zs"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(349, 53)" end="(349, 54)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <AtomNode start="(349, 55)" end="(349, 57)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(349, 58)" end="(349, 60)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(349, 61)" end="(349, 62)" leading="" trailing="&#10;        " val="∧"/>
                    <OtherNode start="(350, 9)" end="(350, 53)" kind="«term_∧_»">
                      <OtherNode start="(350, 9)" end="(350, 34)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(350, 9)" end="(350, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(350, 10)" end="(350, 33)" kind="Lean.«term∀__,_»">
                          <AtomNode start="(350, 10)" end="(350, 11)" leading="" trailing=" " val="∀"/>
                          <LeanBinderidentNode start="(350, 12)" end="(350, 13)">
                            <IdentNode start="(350, 12)" end="(350, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                          </LeanBinderidentNode>
                          <OtherNode start="(350, 14)" end="(350, 18)" kind="Lean.«binderTerm∈_»">
                            <AtomNode start="(350, 14)" end="(350, 15)" leading="" trailing=" " val="∈"/>
                            <IdentNode start="(350, 16)" end="(350, 18)" leading="" trailing="" raw_val="as" val="as"/>
                          </OtherNode>
                          <AtomNode start="(350, 18)" end="(350, 19)" leading="" trailing=" " val=","/>
                          <OtherNode start="(350, 20)" end="(350, 33)" kind="Lean.«term∀__,_»">
                            <AtomNode start="(350, 20)" end="(350, 21)" leading="" trailing=" " val="∀"/>
                            <LeanBinderidentNode start="(350, 22)" end="(350, 23)">
                              <IdentNode start="(350, 22)" end="(350, 23)" leading="" trailing=" " raw_val="x" val="x"/>
                            </LeanBinderidentNode>
                            <OtherNode start="(350, 24)" end="(350, 27)" kind="Lean.«binderTerm∈_»">
                              <AtomNode start="(350, 24)" end="(350, 25)" leading="" trailing=" " val="∈"/>
                              <IdentNode start="(350, 26)" end="(350, 27)" leading="" trailing="" raw_val="l" val="l"/>
                            </OtherNode>
                            <AtomNode start="(350, 27)" end="(350, 28)" leading="" trailing=" " val=","/>
                            <OtherNode start="(350, 29)" end="(350, 33)" kind="term!_">
                              <AtomNode start="(350, 29)" end="(350, 30)" leading="" trailing="" val="!"/>
                              <OtherNode start="(350, 30)" end="(350, 33)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(350, 30)" end="(350, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(350, 32)" end="(350, 33)">
                                  <IdentNode start="(350, 32)" end="(350, 33)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(350, 33)" end="(350, 34)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(350, 35)" end="(350, 36)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(350, 37)" end="(350, 53)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(350, 37)" end="(350, 38)" leading="" trailing="" val="("/>
                        <OtherNode start="(350, 38)" end="(350, 52)" kind="Lean.«term∀__,_»">
                          <AtomNode start="(350, 38)" end="(350, 39)" leading="" trailing=" " val="∀"/>
                          <LeanBinderidentNode start="(350, 40)" end="(350, 41)">
                            <IdentNode start="(350, 40)" end="(350, 41)" leading="" trailing=" " raw_val="x" val="x"/>
                          </LeanBinderidentNode>
                          <OtherNode start="(350, 42)" end="(350, 46)" kind="Lean.«binderTerm∈_»">
                            <AtomNode start="(350, 42)" end="(350, 43)" leading="" trailing=" " val="∈"/>
                            <IdentNode start="(350, 44)" end="(350, 46)" leading="" trailing="" raw_val="ys" val="ys"/>
                          </OtherNode>
                          <AtomNode start="(350, 46)" end="(350, 47)" leading="" trailing=" " val=","/>
                          <OtherNode start="(350, 48)" end="(350, 52)" kind="term!_">
                            <AtomNode start="(350, 48)" end="(350, 49)" leading="" trailing="" val="!"/>
                            <OtherNode start="(350, 49)" end="(350, 52)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(350, 49)" end="(350, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(350, 51)" end="(350, 52)">
                                <IdentNode start="(350, 51)" end="(350, 52)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(350, 52)" end="(350, 53)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(350, 54)" end="(380, 19)">
          <AtomNode start="(350, 54)" end="(350, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(350, 57)" end="(380, 19)">
            <AtomNode start="(350, 57)" end="(350, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(351, 3)" end="(380, 19)">
              <TacticTacticseq1IndentedNode start="(351, 3)" end="(380, 19)">
                <NullNode start="(351, 3)" end="(380, 19)">
                  <OtherNode start="(351, 3)" end="(351, 32)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ find? p xs.flatten = some a ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="rw [find?_eq_some_iff_append]">
                    <AtomNode start="(351, 3)" end="(351, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(351, 6)" end="(351, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(351, 6)" end="(351, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(351, 7)" end="(351, 31)">
                        <OtherNode start="(351, 7)" end="(351, 31)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(351, 7)" end="(351, 31)" leading="" trailing="" raw_val="find?_eq_some_iff_append" val="find?_eq_some_iff_append" full_name="List.find?_eq_some_iff_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(210, 9)" def_end="(210, 33)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(351, 31)" end="(351, 32)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(352, 3)" end="(352, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) ↔&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true&#10;&#10;case mpr&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) →&#10;    p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="constructor">
                    <AtomNode start="(352, 3)" end="(352, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(353, 3)" end="(373, 49)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true&#10;&#10;case mpr&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) →&#10;    p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mpr&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) →&#10;    p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="· rintro ⟨h, ⟨ys, zs, h₁, h₂⟩⟩&#10;  refine ⟨h, ?_⟩&#10;  rw [flatten_eq_append_iff] at h₁&#10;  obtain (⟨as, bs, rfl, rfl, h₁⟩ | ⟨as, bs, c, cs, ds, rfl, rfl, h₁⟩) := h₁&#10;  · replace h₁ := h₁.symm&#10;    rw [flatten_eq_cons_iff] at h₁&#10;    obtain ⟨bs, cs, ds, rfl, h₁, rfl⟩ := h₁&#10;    refine ⟨as ++ bs, [], cs, ds, by simp, ?_⟩&#10;    simp&#10;    rintro l (ma | mb) x m&#10;    · simpa using h₂ x (by simpa using ⟨l, ma, m⟩)&#10;    · specialize h₁ _ mb&#10;      simp_all&#10;  · simp [h₁]&#10;    refine ⟨as, bs, ?_⟩&#10;    refine ⟨?_, ?_, ?_⟩&#10;    · simp_all&#10;    · intro l ml a m&#10;      simpa using h₂ a (by simpa using .inl ⟨l, ml, m⟩)&#10;    · intro x m&#10;      simpa using h₂ x (by simpa using .inr m)">
                    <OtherNode start="(353, 3)" end="(353, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(353, 3)" end="(353, 4)" kind="patternIgnore">
                        <OtherNode start="(353, 3)" end="(353, 4)" kind="token.«· »">
                          <AtomNode start="(353, 3)" end="(353, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(353, 5)" end="(373, 49)">
                      <TacticTacticseq1IndentedNode start="(353, 5)" end="(373, 49)">
                        <NullNode start="(353, 5)" end="(373, 49)">
                          <OtherNode start="(353, 5)" end="(353, 33)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;ys zs : List α&#10;h₁ : xs.flatten = ys ++ a :: zs&#10;h₂ : ∀ (a : α), a ∈ ys → (!p a) = true&#10;⊢ p a = true ∧&#10;    ∃ as ys zs bs,&#10;      xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="rintro ⟨h, ⟨ys, zs, h₁, h₂⟩⟩">
                            <AtomNode start="(353, 5)" end="(353, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(353, 12)" end="(353, 33)">
                              <OtherNode start="(353, 12)" end="(353, 33)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(353, 12)" end="(353, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(353, 12)" end="(353, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(353, 13)" end="(353, 32)">
                                    <OtherNode start="(353, 13)" end="(353, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(353, 13)" end="(353, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(353, 13)" end="(353, 14)">
                                          <OtherNode start="(353, 13)" end="(353, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(353, 13)" end="(353, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(353, 14)" end="(353, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(353, 16)" end="(353, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(353, 16)" end="(353, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(353, 16)" end="(353, 32)">
                                          <OtherNode start="(353, 16)" end="(353, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(353, 16)" end="(353, 17)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(353, 17)" end="(353, 31)">
                                              <OtherNode start="(353, 17)" end="(353, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(353, 17)" end="(353, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(353, 17)" end="(353, 19)">
                                                    <OtherNode start="(353, 17)" end="(353, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(353, 17)" end="(353, 19)" leading="" trailing="" raw_val="ys" val="ys"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(353, 19)" end="(353, 20)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(353, 21)" end="(353, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(353, 21)" end="(353, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(353, 21)" end="(353, 23)">
                                                    <OtherNode start="(353, 21)" end="(353, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(353, 21)" end="(353, 23)" leading="" trailing="" raw_val="zs" val="zs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(353, 23)" end="(353, 24)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(353, 25)" end="(353, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(353, 25)" end="(353, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(353, 25)" end="(353, 27)">
                                                    <OtherNode start="(353, 25)" end="(353, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(353, 25)" end="(353, 27)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(353, 27)" end="(353, 28)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(353, 29)" end="(353, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(353, 29)" end="(353, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(353, 29)" end="(353, 31)">
                                                    <OtherNode start="(353, 29)" end="(353, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(353, 29)" end="(353, 31)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(353, 31)" end="(353, 32)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(353, 32)" end="(353, 33)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(354, 5)" end="(354, 19)" kind="Lean.Parser.Tactic.refine" state_before="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;ys zs : List α&#10;h₁ : xs.flatten = ys ++ a :: zs&#10;h₂ : ∀ (a : α), a ∈ ys → (!p a) = true&#10;⊢ p a = true ∧&#10;    ∃ as ys zs bs,&#10;      xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;        (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;ys zs : List α&#10;h₁ : xs.flatten = ys ++ a :: zs&#10;h₂ : ∀ (a : α), a ∈ ys → (!p a) = true&#10;⊢ ∃ as ys zs bs,&#10;    xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="refine ⟨h, ?_⟩">
                            <AtomNode start="(354, 5)" end="(354, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(354, 12)" end="(354, 19)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(354, 12)" end="(354, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(354, 13)" end="(354, 18)">
                                <IdentNode start="(354, 13)" end="(354, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                <AtomNode start="(354, 14)" end="(354, 15)" leading="" trailing=" " val=","/>
                                <OtherNode start="(354, 16)" end="(354, 18)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(354, 16)" end="(354, 17)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(354, 17)" end="(354, 18)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(354, 18)" end="(354, 19)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(355, 5)" end="(355, 37)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;ys zs : List α&#10;h₁ : xs.flatten = ys ++ a :: zs&#10;h₂ : ∀ (a : α), a ∈ ys → (!p a) = true&#10;⊢ ∃ as ys zs bs,&#10;    xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;ys zs : List α&#10;h₁ :&#10;  (∃ as bs, xs = as ++ bs ∧ ys = as.flatten ∧ a :: zs = bs.flatten) ∨&#10;    ∃ as bs c cs ds, xs = as ++ (bs ++ c :: cs) :: ds ∧ ys = as.flatten ++ bs ∧ a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ ys → (!p a) = true&#10;⊢ ∃ as ys zs bs,&#10;    xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="rw [flatten_eq_append_iff] at h₁">
                            <AtomNode start="(355, 5)" end="(355, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(355, 8)" end="(355, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(355, 8)" end="(355, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(355, 9)" end="(355, 30)">
                                <OtherNode start="(355, 9)" end="(355, 30)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(355, 9)" end="(355, 30)" leading="" trailing="" raw_val="flatten_eq_append_iff" val="flatten_eq_append_iff" full_name="List.flatten_eq_append_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(355, 30)" end="(355, 31)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(355, 32)" end="(355, 37)">
                              <OtherNode start="(355, 32)" end="(355, 37)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(355, 32)" end="(355, 34)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(355, 35)" end="(355, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(355, 35)" end="(355, 37)">
                                    <IdentNode start="(355, 35)" end="(355, 37)" leading="" trailing="&#10;    " raw_val="h₁" val="h₁"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(356, 5)" end="(356, 78)" kind="Lean.Parser.Tactic.obtain" state_before="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;ys zs : List α&#10;h₁ :&#10;  (∃ as bs, xs = as ++ bs ∧ ys = as.flatten ∧ a :: zs = bs.flatten) ∨&#10;    ∃ as bs c cs ds, xs = as ++ (bs ++ c :: cs) :: ds ∧ ys = as.flatten ++ bs ∧ a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ ys → (!p a) = true&#10;⊢ ∃ as ys zs bs,&#10;    xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;      (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₁ : a :: zs = bs.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="obtain (⟨as, bs, rfl, rfl, h₁⟩ | ⟨as, bs, c, cs, ds, rfl, rfl, h₁⟩) := h₁">
                            <AtomNode start="(356, 5)" end="(356, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(356, 12)" end="(356, 72)">
                              <OtherNode start="(356, 12)" end="(356, 72)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(356, 12)" end="(356, 72)">
                                  <OtherNode start="(356, 12)" end="(356, 72)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                    <AtomNode start="(356, 12)" end="(356, 13)" leading="" trailing="" val="("/>
                                    <OtherNode start="(356, 13)" end="(356, 71)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(356, 13)" end="(356, 71)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(356, 13)" end="(356, 71)">
                                          <OtherNode start="(356, 13)" end="(356, 35)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(356, 13)" end="(356, 14)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(356, 14)" end="(356, 34)">
                                              <OtherNode start="(356, 14)" end="(356, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 14)" end="(356, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 14)" end="(356, 16)">
                                                    <OtherNode start="(356, 14)" end="(356, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 14)" end="(356, 16)" leading="" trailing="" raw_val="as" val="as"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 16)" end="(356, 17)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 18)" end="(356, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 18)" end="(356, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 18)" end="(356, 20)">
                                                    <OtherNode start="(356, 18)" end="(356, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 18)" end="(356, 20)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 20)" end="(356, 21)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 22)" end="(356, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 22)" end="(356, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 22)" end="(356, 25)">
                                                    <OtherNode start="(356, 22)" end="(356, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 22)" end="(356, 25)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 25)" end="(356, 26)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 27)" end="(356, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 27)" end="(356, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 27)" end="(356, 30)">
                                                    <OtherNode start="(356, 27)" end="(356, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 27)" end="(356, 30)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 30)" end="(356, 31)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 32)" end="(356, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 32)" end="(356, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 32)" end="(356, 34)">
                                                    <OtherNode start="(356, 32)" end="(356, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 32)" end="(356, 34)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(356, 34)" end="(356, 35)" leading="" trailing=" " val="⟩"/>
                                          </OtherNode>
                                          <AtomNode start="(356, 36)" end="(356, 37)" leading="" trailing=" " val="|"/>
                                          <OtherNode start="(356, 38)" end="(356, 71)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(356, 38)" end="(356, 39)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(356, 39)" end="(356, 70)">
                                              <OtherNode start="(356, 39)" end="(356, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 39)" end="(356, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 39)" end="(356, 41)">
                                                    <OtherNode start="(356, 39)" end="(356, 41)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 39)" end="(356, 41)" leading="" trailing="" raw_val="as" val="as"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 41)" end="(356, 42)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 43)" end="(356, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 43)" end="(356, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 43)" end="(356, 45)">
                                                    <OtherNode start="(356, 43)" end="(356, 45)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 43)" end="(356, 45)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 45)" end="(356, 46)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 47)" end="(356, 48)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 47)" end="(356, 48)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 47)" end="(356, 48)">
                                                    <OtherNode start="(356, 47)" end="(356, 48)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 47)" end="(356, 48)" leading="" trailing="" raw_val="c" val="c"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 48)" end="(356, 49)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 50)" end="(356, 52)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 50)" end="(356, 52)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 50)" end="(356, 52)">
                                                    <OtherNode start="(356, 50)" end="(356, 52)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 50)" end="(356, 52)" leading="" trailing="" raw_val="cs" val="cs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 52)" end="(356, 53)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 54)" end="(356, 56)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 54)" end="(356, 56)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 54)" end="(356, 56)">
                                                    <OtherNode start="(356, 54)" end="(356, 56)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 54)" end="(356, 56)" leading="" trailing="" raw_val="ds" val="ds"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 56)" end="(356, 57)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 58)" end="(356, 61)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 58)" end="(356, 61)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 58)" end="(356, 61)">
                                                    <OtherNode start="(356, 58)" end="(356, 61)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 58)" end="(356, 61)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 61)" end="(356, 62)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 63)" end="(356, 66)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 63)" end="(356, 66)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 63)" end="(356, 66)">
                                                    <OtherNode start="(356, 63)" end="(356, 66)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 63)" end="(356, 66)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(356, 66)" end="(356, 67)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(356, 68)" end="(356, 70)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(356, 68)" end="(356, 70)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(356, 68)" end="(356, 70)">
                                                    <OtherNode start="(356, 68)" end="(356, 70)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(356, 68)" end="(356, 70)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(356, 70)" end="(356, 71)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(356, 71)" end="(356, 72)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(356, 73)" end="(356, 78)">
                              <AtomNode start="(356, 73)" end="(356, 75)" leading="" trailing=" " val=":="/>
                              <NullNode start="(356, 76)" end="(356, 78)">
                                <IdentNode start="(356, 76)" end="(356, 78)" leading="" trailing="&#10;    " raw_val="h₁" val="h₁"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(357, 5)" end="(365, 17)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₁ : a :: zs = bs.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="· replace h₁ := h₁.symm&#10;  rw [flatten_eq_cons_iff] at h₁&#10;  obtain ⟨bs, cs, ds, rfl, h₁, rfl⟩ := h₁&#10;  refine ⟨as ++ bs, [], cs, ds, by simp, ?_⟩&#10;  simp&#10;  rintro l (ma | mb) x m&#10;  · simpa using h₂ x (by simpa using ⟨l, ma, m⟩)&#10;  · specialize h₁ _ mb&#10;    simp_all">
                            <OtherNode start="(357, 5)" end="(357, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(357, 5)" end="(357, 6)" kind="patternIgnore">
                                <OtherNode start="(357, 5)" end="(357, 6)" kind="token.«· »">
                                  <AtomNode start="(357, 5)" end="(357, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(357, 7)" end="(365, 17)">
                              <TacticTacticseq1IndentedNode start="(357, 7)" end="(365, 17)">
                                <NullNode start="(357, 7)" end="(365, 17)">
                                  <OtherNode start="(357, 7)" end="(357, 28)" kind="Lean.Parser.Tactic.replace" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₁ : a :: zs = bs.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;h₁ : bs.flatten = a :: zs&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="replace h₁ := h₁.symm">
                                    <AtomNode start="(357, 7)" end="(357, 14)" leading="" trailing=" " val="replace"/>
                                    <OtherNode start="(357, 15)" end="(357, 28)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(357, 15)" end="(357, 28)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(357, 15)" end="(357, 17)" kind="Lean.Parser.Term.haveId">
                                          <IdentNode start="(357, 15)" end="(357, 17)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <AtomNode start="(357, 18)" end="(357, 20)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(357, 21)" end="(357, 28)" leading="" trailing="&#10;      " raw_val="h₁.symm" val="h₁.symm"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(358, 7)" end="(358, 37)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;h₁ : bs.flatten = a :: zs&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;h₁ : ∃ as bs_1 cs, bs = as ++ (a :: bs_1) :: cs ∧ (∀ (l : List α), l ∈ as → l = []) ∧ zs = bs_1 ++ cs.flatten&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="rw [flatten_eq_cons_iff] at h₁">
                                    <AtomNode start="(358, 7)" end="(358, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(358, 10)" end="(358, 31)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(358, 10)" end="(358, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(358, 11)" end="(358, 30)">
                                        <OtherNode start="(358, 11)" end="(358, 30)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(358, 11)" end="(358, 30)" leading="" trailing="" raw_val="flatten_eq_cons_iff" val="flatten_eq_cons_iff" full_name="List.flatten_eq_cons_iff" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(358, 30)" end="(358, 31)" leading="" trailing=" " val="]"/>
                                    </OtherNode>
                                    <NullNode start="(358, 32)" end="(358, 37)">
                                      <OtherNode start="(358, 32)" end="(358, 37)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(358, 32)" end="(358, 34)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(358, 35)" end="(358, 37)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(358, 35)" end="(358, 37)">
                                            <IdentNode start="(358, 35)" end="(358, 37)" leading="" trailing="&#10;      " raw_val="h₁" val="h₁"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(359, 7)" end="(359, 46)" kind="Lean.Parser.Tactic.obtain" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as bs : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;h₁ : ∃ as bs_1 cs, bs = as ++ (a :: bs_1) :: cs ∧ (∀ (l : List α), l ∈ as → l = []) ∧ zs = bs_1 ++ cs.flatten&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ bs = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ (a :: cs) :: ds) = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" tactic="obtain ⟨bs, cs, ds, rfl, h₁, rfl⟩ := h₁">
                                    <AtomNode start="(359, 7)" end="(359, 13)" leading="" trailing=" " val="obtain"/>
                                    <NullNode start="(359, 14)" end="(359, 40)">
                                      <OtherNode start="(359, 14)" end="(359, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(359, 14)" end="(359, 40)">
                                          <OtherNode start="(359, 14)" end="(359, 40)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(359, 14)" end="(359, 15)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(359, 15)" end="(359, 39)">
                                              <OtherNode start="(359, 15)" end="(359, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(359, 15)" end="(359, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(359, 15)" end="(359, 17)">
                                                    <OtherNode start="(359, 15)" end="(359, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(359, 15)" end="(359, 17)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(359, 17)" end="(359, 18)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(359, 19)" end="(359, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(359, 19)" end="(359, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(359, 19)" end="(359, 21)">
                                                    <OtherNode start="(359, 19)" end="(359, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(359, 19)" end="(359, 21)" leading="" trailing="" raw_val="cs" val="cs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(359, 21)" end="(359, 22)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(359, 23)" end="(359, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(359, 23)" end="(359, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(359, 23)" end="(359, 25)">
                                                    <OtherNode start="(359, 23)" end="(359, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(359, 23)" end="(359, 25)" leading="" trailing="" raw_val="ds" val="ds"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(359, 25)" end="(359, 26)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(359, 27)" end="(359, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(359, 27)" end="(359, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(359, 27)" end="(359, 30)">
                                                    <OtherNode start="(359, 27)" end="(359, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(359, 27)" end="(359, 30)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(359, 30)" end="(359, 31)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(359, 32)" end="(359, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(359, 32)" end="(359, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(359, 32)" end="(359, 34)">
                                                    <OtherNode start="(359, 32)" end="(359, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(359, 32)" end="(359, 34)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(359, 34)" end="(359, 35)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(359, 36)" end="(359, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(359, 36)" end="(359, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(359, 36)" end="(359, 39)">
                                                    <OtherNode start="(359, 36)" end="(359, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(359, 36)" end="(359, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(359, 39)" end="(359, 40)" leading="" trailing=" " val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode start="(359, 41)" end="(359, 46)">
                                      <AtomNode start="(359, 41)" end="(359, 43)" leading="" trailing=" " val=":="/>
                                      <NullNode start="(359, 44)" end="(359, 46)">
                                        <IdentNode start="(359, 44)" end="(359, 46)" leading="" trailing="&#10;      " raw_val="h₁" val="h₁"/>
                                      </NullNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(360, 7)" end="(360, 49)" kind="Lean.Parser.Tactic.refine" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ (a :: cs) :: ds) = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ (∀ (l : List α), l ∈ as ++ bs → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ [] → (!p x) = true" tactic="refine ⟨as ++ bs, [], cs, ds, by simp, ?_⟩">
                                    <AtomNode start="(360, 7)" end="(360, 13)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(360, 14)" end="(360, 49)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(360, 14)" end="(360, 15)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(360, 15)" end="(360, 48)">
                                        <OtherNode start="(360, 15)" end="(360, 23)" kind="«term_++_»">
                                          <IdentNode start="(360, 15)" end="(360, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <AtomNode start="(360, 18)" end="(360, 20)" leading="" trailing=" " val="++"/>
                                          <IdentNode start="(360, 21)" end="(360, 23)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        </OtherNode>
                                        <AtomNode start="(360, 23)" end="(360, 24)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(360, 25)" end="(360, 27)" kind="«term[_]»">
                                          <AtomNode start="(360, 25)" end="(360, 26)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(360, 26)" end="(360, 27)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(360, 27)" end="(360, 28)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(360, 29)" end="(360, 31)" leading="" trailing="" raw_val="cs" val="cs"/>
                                        <AtomNode start="(360, 31)" end="(360, 32)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(360, 33)" end="(360, 35)" leading="" trailing="" raw_val="ds" val="ds"/>
                                        <AtomNode start="(360, 35)" end="(360, 36)" leading="" trailing=" " val=","/>
                                        <TermBytacticNode start="(360, 37)" end="(360, 44)">
                                          <AtomNode start="(360, 37)" end="(360, 39)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(360, 40)" end="(360, 44)">
                                            <TacticTacticseq1IndentedNode start="(360, 40)" end="(360, 44)">
                                              <NullNode start="(360, 40)" end="(360, 44)">
                                                <OtherNode start="(360, 40)" end="(360, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ as ++ (bs ++ (a :: cs) :: ds) = as ++ bs ++ ([] ++ a :: cs) :: ds" state_after="no goals" tactic="simp">
                                                  <AtomNode start="(360, 40)" end="(360, 44)" leading="" trailing="" val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                        <AtomNode start="(360, 44)" end="(360, 45)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(360, 46)" end="(360, 48)" kind="Lean.Parser.Term.syntheticHole">
                                          <AtomNode start="(360, 46)" end="(360, 47)" leading="" trailing="" val="?"/>
                                          <AtomNode start="(360, 47)" end="(360, 48)" leading="" trailing="" val="_"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(360, 48)" end="(360, 49)" leading="" trailing="&#10;      " val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(361, 7)" end="(361, 11)" kind="Lean.Parser.Tactic.simp" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ (∀ (l : List α), l ∈ as ++ bs → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ [] → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ ∀ (l : List α), l ∈ as ∨ l ∈ bs → ∀ (x : α), x ∈ l → p x = false" tactic="simp">
                                    <AtomNode start="(361, 7)" end="(361, 11)" leading="" trailing="&#10;      " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(362, 7)" end="(362, 29)" kind="Lean.Parser.Tactic.rintro" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;⊢ ∀ (l : List α), l ∈ as ∨ l ∈ bs → ∀ (x : α), x ∈ l → p x = false" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inl&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;ma : l ∈ as&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false&#10;&#10;case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false" tactic="rintro l (ma | mb) x m">
                                    <AtomNode start="(362, 7)" end="(362, 13)" leading="" trailing=" " val="rintro"/>
                                    <NullNode start="(362, 14)" end="(362, 29)">
                                      <OtherNode start="(362, 14)" end="(362, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(362, 14)" end="(362, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(362, 14)" end="(362, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(362, 16)" end="(362, 25)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(362, 16)" end="(362, 25)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                          <AtomNode start="(362, 16)" end="(362, 17)" leading="" trailing="" val="("/>
                                          <OtherNode start="(362, 17)" end="(362, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                            <OtherNode start="(362, 17)" end="(362, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                              <NullNode start="(362, 17)" end="(362, 24)">
                                                <OtherNode start="(362, 17)" end="(362, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                  <IdentNode start="(362, 17)" end="(362, 19)" leading="" trailing=" " raw_val="ma" val="ma"/>
                                                </OtherNode>
                                                <AtomNode start="(362, 20)" end="(362, 21)" leading="" trailing=" " val="|"/>
                                                <OtherNode start="(362, 22)" end="(362, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                  <IdentNode start="(362, 22)" end="(362, 24)" leading="" trailing="" raw_val="mb" val="mb"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(362, 24)" end="(362, 25)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(362, 26)" end="(362, 27)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(362, 26)" end="(362, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(362, 26)" end="(362, 27)" leading="" trailing=" " raw_val="x" val="x"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(362, 28)" end="(362, 29)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(362, 28)" end="(362, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(362, 28)" end="(362, 29)" leading="" trailing="&#10;      " raw_val="m" val="m"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(363, 7)" end="(363, 53)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inl&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;ma : l ∈ as&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false&#10;&#10;case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false" tactic="· simpa using h₂ x (by simpa using ⟨l, ma, m⟩)">
                                    <OtherNode start="(363, 7)" end="(363, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(363, 7)" end="(363, 8)" kind="patternIgnore">
                                        <OtherNode start="(363, 7)" end="(363, 8)" kind="token.«· »">
                                          <AtomNode start="(363, 7)" end="(363, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(363, 9)" end="(363, 53)">
                                      <TacticTacticseq1IndentedNode start="(363, 9)" end="(363, 53)">
                                        <NullNode start="(363, 9)" end="(363, 53)">
                                          <OtherNode start="(363, 9)" end="(363, 53)" kind="Lean.Parser.Tactic.simpa" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inl&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;ma : l ∈ as&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false" state_after="no goals" tactic="simpa using h₂ x (by simpa using ⟨l, ma, m⟩)">
                                            <AtomNode start="(363, 9)" end="(363, 14)" leading="" trailing=" " val="simpa"/>
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(363, 15)" end="(363, 53)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(363, 15)" end="(363, 53)">
                                                <AtomNode start="(363, 15)" end="(363, 20)" leading="" trailing=" " val="using"/>
                                                <OtherNode start="(363, 21)" end="(363, 53)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(363, 21)" end="(363, 23)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                  <NullNode start="(363, 24)" end="(363, 53)">
                                                    <IdentNode start="(363, 24)" end="(363, 25)" leading="" trailing=" " raw_val="x" val="x"/>
                                                    <OtherNode start="(363, 26)" end="(363, 53)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(363, 26)" end="(363, 27)" leading="" trailing="" val="("/>
                                                      <TermBytacticNode start="(363, 27)" end="(363, 52)">
                                                        <AtomNode start="(363, 27)" end="(363, 29)" leading="" trailing=" " val="by"/>
                                                        <TacticTacticseqNode start="(363, 30)" end="(363, 52)">
                                                          <TacticTacticseq1IndentedNode start="(363, 30)" end="(363, 52)">
                                                            <NullNode start="(363, 30)" end="(363, 52)">
                                                            <OtherNode start="(363, 30)" end="(363, 52)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;ma : l ∈ as&#10;x : α&#10;m : x ∈ l&#10;⊢ x ∈ as.flatten" state_after="no goals" tactic="simpa using ⟨l, ma, m⟩">
                                                            <AtomNode start="(363, 30)" end="(363, 35)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(363, 36)" end="(363, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(363, 36)" end="(363, 52)">
                                                            <AtomNode start="(363, 36)" end="(363, 41)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(363, 42)" end="(363, 52)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(363, 42)" end="(363, 43)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(363, 43)" end="(363, 51)">
                                                            <IdentNode start="(363, 43)" end="(363, 44)" leading="" trailing="" raw_val="l" val="l"/>
                                                            <AtomNode start="(363, 44)" end="(363, 45)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(363, 46)" end="(363, 48)" leading="" trailing="" raw_val="ma" val="ma"/>
                                                            <AtomNode start="(363, 48)" end="(363, 49)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(363, 50)" end="(363, 51)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            <AtomNode start="(363, 51)" end="(363, 52)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </TermBytacticNode>
                                                      <AtomNode start="(363, 52)" end="(363, 53)" leading="" trailing="&#10;      " val=")"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(364, 7)" end="(365, 17)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false" state_after="no goals" tactic="· specialize h₁ _ mb&#10;  simp_all">
                                    <OtherNode start="(364, 7)" end="(364, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(364, 7)" end="(364, 8)" kind="patternIgnore">
                                        <OtherNode start="(364, 7)" end="(364, 8)" kind="token.«· »">
                                          <AtomNode start="(364, 7)" end="(364, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(364, 9)" end="(365, 17)">
                                      <TacticTacticseq1IndentedNode start="(364, 9)" end="(365, 17)">
                                        <NullNode start="(364, 9)" end="(365, 17)">
                                          <OtherNode start="(364, 9)" end="(364, 27)" kind="Lean.Parser.Tactic.specialize" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ bs → l = []&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;⊢ p x = false" state_after="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;h₁ : l = []&#10;⊢ p x = false" tactic="specialize h₁ _ mb">
                                            <AtomNode start="(364, 9)" end="(364, 19)" leading="" trailing=" " val="specialize"/>
                                            <OtherNode start="(364, 20)" end="(364, 27)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(364, 20)" end="(364, 22)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                              <NullNode start="(364, 23)" end="(364, 27)">
                                                <TermHoleNode start="(364, 23)" end="(364, 24)">
                                                  <AtomNode start="(364, 23)" end="(364, 24)" leading="" trailing=" " val="_"/>
                                                </TermHoleNode>
                                                <IdentNode start="(364, 25)" end="(364, 27)" leading="" trailing="&#10;        " raw_val="mb" val="mb"/>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(365, 9)" end="(365, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp.intro.intro.intro.intro.inl.intro.intro.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;h₂ : ∀ (a : α), a ∈ as.flatten → (!p a) = true&#10;bs : List (List α)&#10;cs : List α&#10;ds : List (List α)&#10;l : List α&#10;mb : l ∈ bs&#10;x : α&#10;m : x ∈ l&#10;h₁ : l = []&#10;⊢ p x = false" state_after="no goals" tactic="simp_all">
                                            <AtomNode start="(365, 9)" end="(365, 17)" leading="" trailing="&#10;    " val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(366, 5)" end="(373, 49)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="no goals" tactic="· simp [h₁]&#10;  refine ⟨as, bs, ?_⟩&#10;  refine ⟨?_, ?_, ?_⟩&#10;  · simp_all&#10;  · intro l ml a m&#10;    simpa using h₂ a (by simpa using .inl ⟨l, ml, m⟩)&#10;  · intro x m&#10;    simpa using h₂ x (by simpa using .inr m)">
                            <OtherNode start="(366, 5)" end="(366, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(366, 5)" end="(366, 6)" kind="patternIgnore">
                                <OtherNode start="(366, 5)" end="(366, 6)" kind="token.«· »">
                                  <AtomNode start="(366, 5)" end="(366, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(366, 7)" end="(373, 49)">
                              <TacticTacticseq1IndentedNode start="(366, 7)" end="(373, 49)">
                                <NullNode start="(366, 7)" end="(373, 49)">
                                  <OtherNode start="(366, 7)" end="(366, 16)" kind="Lean.Parser.Tactic.simp" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys zs bs_1,&#10;    as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: zs) :: bs_1 ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys,&#10;    (∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" tactic="simp [h₁]">
                                    <AtomNode start="(366, 7)" end="(366, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(366, 12)" end="(366, 16)">
                                      <AtomNode start="(366, 12)" end="(366, 13)" leading="" trailing="" val="["/>
                                      <NullNode start="(366, 13)" end="(366, 15)">
                                        <OtherNode start="(366, 13)" end="(366, 15)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(366, 13)" end="(366, 15)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(366, 15)" end="(366, 16)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(367, 7)" end="(367, 26)" kind="Lean.Parser.Tactic.refine" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ as_1 ys,&#10;    (∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as_1 ++ (ys ++ a :: x) :: x_1) ∧&#10;      (∀ (l : List α), l ∈ as_1 → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ ys → p x = false" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ (∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as ++ (bs ++ a :: x) :: x_1) ∧&#10;    (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ bs → p x = false" tactic="refine ⟨as, bs, ?_⟩">
                                    <AtomNode start="(367, 7)" end="(367, 13)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(367, 14)" end="(367, 26)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(367, 14)" end="(367, 15)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(367, 15)" end="(367, 25)">
                                        <IdentNode start="(367, 15)" end="(367, 17)" leading="" trailing="" raw_val="as" val="as"/>
                                        <AtomNode start="(367, 17)" end="(367, 18)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(367, 19)" end="(367, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        <AtomNode start="(367, 21)" end="(367, 22)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(367, 23)" end="(367, 25)" kind="Lean.Parser.Term.syntheticHole">
                                          <AtomNode start="(367, 23)" end="(367, 24)" leading="" trailing="" val="?"/>
                                          <AtomNode start="(367, 24)" end="(367, 25)" leading="" trailing="" val="_"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(367, 25)" end="(367, 26)" leading="" trailing="&#10;      " val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(368, 7)" end="(368, 26)" kind="Lean.Parser.Tactic.refine" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ (∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as ++ (bs ++ a :: x) :: x_1) ∧&#10;    (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false) ∧ ∀ (x : α), x ∈ bs → p x = false" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as ++ (bs ++ a :: x) :: x_1&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" tactic="refine ⟨?_, ?_, ?_⟩">
                                    <AtomNode start="(368, 7)" end="(368, 13)" leading="" trailing=" " val="refine"/>
                                    <OtherNode start="(368, 14)" end="(368, 26)" kind="Lean.Parser.Term.anonymousCtor">
                                      <AtomNode start="(368, 14)" end="(368, 15)" leading="" trailing="" val="⟨"/>
                                      <NullNode start="(368, 15)" end="(368, 25)">
                                        <OtherNode start="(368, 15)" end="(368, 17)" kind="Lean.Parser.Term.syntheticHole">
                                          <AtomNode start="(368, 15)" end="(368, 16)" leading="" trailing="" val="?"/>
                                          <AtomNode start="(368, 16)" end="(368, 17)" leading="" trailing="" val="_"/>
                                        </OtherNode>
                                        <AtomNode start="(368, 17)" end="(368, 18)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(368, 19)" end="(368, 21)" kind="Lean.Parser.Term.syntheticHole">
                                          <AtomNode start="(368, 19)" end="(368, 20)" leading="" trailing="" val="?"/>
                                          <AtomNode start="(368, 20)" end="(368, 21)" leading="" trailing="" val="_"/>
                                        </OtherNode>
                                        <AtomNode start="(368, 21)" end="(368, 22)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(368, 23)" end="(368, 25)" kind="Lean.Parser.Term.syntheticHole">
                                          <AtomNode start="(368, 23)" end="(368, 24)" leading="" trailing="" val="?"/>
                                          <AtomNode start="(368, 24)" end="(368, 25)" leading="" trailing="" val="_"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(368, 25)" end="(368, 26)" leading="" trailing="&#10;      " val="⟩"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(369, 7)" end="(369, 17)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as ++ (bs ++ a :: x) :: x_1&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" tactic="· simp_all">
                                    <OtherNode start="(369, 7)" end="(369, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(369, 7)" end="(369, 8)" kind="patternIgnore">
                                        <OtherNode start="(369, 7)" end="(369, 8)" kind="token.«· »">
                                          <AtomNode start="(369, 7)" end="(369, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(369, 9)" end="(369, 17)">
                                      <TacticTacticseq1IndentedNode start="(369, 9)" end="(369, 17)">
                                        <NullNode start="(369, 9)" end="(369, 17)">
                                          <OtherNode start="(369, 9)" end="(369, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_1&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∃ x x_1, as ++ (bs ++ c :: cs) :: ds = as ++ (bs ++ a :: x) :: x_1" state_after="no goals" tactic="simp_all">
                                            <AtomNode start="(369, 9)" end="(369, 17)" leading="" trailing="&#10;      " val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(370, 7)" end="(371, 58)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false&#10;&#10;case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" tactic="· intro l ml a m&#10;  simpa using h₂ a (by simpa using .inl ⟨l, ml, m⟩)">
                                    <OtherNode start="(370, 7)" end="(370, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(370, 7)" end="(370, 8)" kind="patternIgnore">
                                        <OtherNode start="(370, 7)" end="(370, 8)" kind="token.«· »">
                                          <AtomNode start="(370, 7)" end="(370, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(370, 9)" end="(371, 58)">
                                      <TacticTacticseq1IndentedNode start="(370, 9)" end="(371, 58)">
                                        <NullNode start="(370, 9)" end="(371, 58)">
                                          <OtherNode start="(370, 9)" end="(370, 23)" kind="Lean.Parser.Tactic.intro" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → p x = false" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a✝ :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;l : List α&#10;ml : l ∈ as&#10;a : α&#10;m : a ∈ l&#10;⊢ p a = false" tactic="intro l ml a m">
                                            <AtomNode start="(370, 9)" end="(370, 14)" leading="" trailing=" " val="intro"/>
                                            <NullNode start="(370, 15)" end="(370, 23)">
                                              <IdentNode start="(370, 15)" end="(370, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                                              <IdentNode start="(370, 17)" end="(370, 19)" leading="" trailing=" " raw_val="ml" val="ml"/>
                                              <IdentNode start="(370, 20)" end="(370, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(370, 22)" end="(370, 23)" leading="" trailing="&#10;        " raw_val="m" val="m"/>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(371, 9)" end="(371, 58)" kind="Lean.Parser.Tactic.simpa" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_2&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a✝ :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;l : List α&#10;ml : l ∈ as&#10;a : α&#10;m : a ∈ l&#10;⊢ p a = false" state_after="no goals" tactic="simpa using h₂ a (by simpa using .inl ⟨l, ml, m⟩)">
                                            <AtomNode start="(371, 9)" end="(371, 14)" leading="" trailing=" " val="simpa"/>
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(371, 15)" end="(371, 58)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(371, 15)" end="(371, 58)">
                                                <AtomNode start="(371, 15)" end="(371, 20)" leading="" trailing=" " val="using"/>
                                                <OtherNode start="(371, 21)" end="(371, 58)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(371, 21)" end="(371, 23)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                  <NullNode start="(371, 24)" end="(371, 58)">
                                                    <IdentNode start="(371, 24)" end="(371, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                                                    <OtherNode start="(371, 26)" end="(371, 58)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(371, 26)" end="(371, 27)" leading="" trailing="" val="("/>
                                                      <TermBytacticNode start="(371, 27)" end="(371, 57)">
                                                        <AtomNode start="(371, 27)" end="(371, 29)" leading="" trailing=" " val="by"/>
                                                        <TacticTacticseqNode start="(371, 30)" end="(371, 57)">
                                                          <TacticTacticseq1IndentedNode start="(371, 30)" end="(371, 57)">
                                                            <NullNode start="(371, 30)" end="(371, 57)">
                                                            <OtherNode start="(371, 30)" end="(371, 57)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a✝ :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;l : List α&#10;ml : l ∈ as&#10;a : α&#10;m : a ∈ l&#10;⊢ a ∈ as.flatten ++ bs" state_after="no goals" tactic="simpa using .inl ⟨l, ml, m⟩">
                                                            <AtomNode start="(371, 30)" end="(371, 35)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(371, 36)" end="(371, 57)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(371, 36)" end="(371, 57)">
                                                            <AtomNode start="(371, 36)" end="(371, 41)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(371, 42)" end="(371, 57)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(371, 42)" end="(371, 46)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(371, 42)" end="(371, 43)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(371, 43)" end="(371, 46)" leading="" trailing=" " raw_val="inl" val="inl"/>
                                                            </OtherNode>
                                                            <NullNode start="(371, 47)" end="(371, 57)">
                                                            <OtherNode start="(371, 47)" end="(371, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(371, 47)" end="(371, 48)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(371, 48)" end="(371, 56)">
                                                            <IdentNode start="(371, 48)" end="(371, 49)" leading="" trailing="" raw_val="l" val="l"/>
                                                            <AtomNode start="(371, 49)" end="(371, 50)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(371, 51)" end="(371, 53)" leading="" trailing="" raw_val="ml" val="ml"/>
                                                            <AtomNode start="(371, 53)" end="(371, 54)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(371, 55)" end="(371, 56)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            <AtomNode start="(371, 56)" end="(371, 57)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </TermBytacticNode>
                                                      <AtomNode start="(371, 57)" end="(371, 58)" leading="" trailing="&#10;      " val=")"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(372, 7)" end="(373, 49)" kind="Lean.cdot" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" state_after="no goals" tactic="· intro x m&#10;  simpa using h₂ x (by simpa using .inr m)">
                                    <OtherNode start="(372, 7)" end="(372, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(372, 7)" end="(372, 8)" kind="patternIgnore">
                                        <OtherNode start="(372, 7)" end="(372, 8)" kind="token.«· »">
                                          <AtomNode start="(372, 7)" end="(372, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(372, 9)" end="(373, 49)">
                                      <TacticTacticseq1IndentedNode start="(372, 9)" end="(373, 49)">
                                        <NullNode start="(372, 9)" end="(373, 49)">
                                          <OtherNode start="(372, 9)" end="(372, 18)" kind="Lean.Parser.Tactic.intro" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;⊢ ∀ (x : α), x ∈ bs → p x = false" state_after="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;x : α&#10;m : x ∈ bs&#10;⊢ p x = false" tactic="intro x m">
                                            <AtomNode start="(372, 9)" end="(372, 14)" leading="" trailing=" " val="intro"/>
                                            <NullNode start="(372, 15)" end="(372, 18)">
                                              <IdentNode start="(372, 15)" end="(372, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                                              <IdentNode start="(372, 17)" end="(372, 18)" leading="" trailing="&#10;        " raw_val="m" val="m"/>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(373, 9)" end="(373, 49)" kind="Lean.Parser.Tactic.simpa" state_before="case mp.intro.intro.intro.intro.inr.intro.intro.intro.intro.intro.intro.intro.refine_3&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;x : α&#10;m : x ∈ bs&#10;⊢ p x = false" state_after="no goals" tactic="simpa using h₂ x (by simpa using .inr m)">
                                            <AtomNode start="(373, 9)" end="(373, 14)" leading="" trailing=" " val="simpa"/>
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(373, 15)" end="(373, 49)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(373, 15)" end="(373, 49)">
                                                <AtomNode start="(373, 15)" end="(373, 20)" leading="" trailing=" " val="using"/>
                                                <OtherNode start="(373, 21)" end="(373, 49)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(373, 21)" end="(373, 23)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                  <NullNode start="(373, 24)" end="(373, 49)">
                                                    <IdentNode start="(373, 24)" end="(373, 25)" leading="" trailing=" " raw_val="x" val="x"/>
                                                    <OtherNode start="(373, 26)" end="(373, 49)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(373, 26)" end="(373, 27)" leading="" trailing="" val="("/>
                                                      <TermBytacticNode start="(373, 27)" end="(373, 48)">
                                                        <AtomNode start="(373, 27)" end="(373, 29)" leading="" trailing=" " val="by"/>
                                                        <TacticTacticseqNode start="(373, 30)" end="(373, 48)">
                                                          <TacticTacticseq1IndentedNode start="(373, 30)" end="(373, 48)">
                                                            <NullNode start="(373, 30)" end="(373, 48)">
                                                            <OtherNode start="(373, 30)" end="(373, 48)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;zs : List α&#10;as : List (List α)&#10;bs : List α&#10;c : α&#10;cs : List α&#10;ds : List (List α)&#10;h₁ : a :: zs = c :: cs ++ ds.flatten&#10;h₂ : ∀ (a : α), a ∈ as.flatten ++ bs → (!p a) = true&#10;x : α&#10;m : x ∈ bs&#10;⊢ x ∈ as.flatten ++ bs" state_after="no goals" tactic="simpa using .inr m">
                                                            <AtomNode start="(373, 30)" end="(373, 35)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(373, 36)" end="(373, 48)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(373, 36)" end="(373, 48)">
                                                            <AtomNode start="(373, 36)" end="(373, 41)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(373, 42)" end="(373, 48)" kind="Lean.Parser.Term.app">
                                                            <OtherNode start="(373, 42)" end="(373, 46)" kind="Lean.Parser.Term.dotIdent">
                                                            <AtomNode start="(373, 42)" end="(373, 43)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(373, 43)" end="(373, 46)" leading="" trailing=" " raw_val="inr" val="inr"/>
                                                            </OtherNode>
                                                            <NullNode start="(373, 47)" end="(373, 48)">
                                                            <IdentNode start="(373, 47)" end="(373, 48)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </TermBytacticNode>
                                                      <AtomNode start="(373, 48)" end="(373, 49)" leading="" trailing="&#10;  " val=")"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(374, 3)" end="(380, 19)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) →&#10;    p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="no goals" tactic="· rintro ⟨h, ⟨as, ys, zs, bs, rfl, h₁, h₂⟩⟩&#10;  refine ⟨h, as.flatten ++ ys, zs ++ bs.flatten, by simp, ?_⟩&#10;  intro a m&#10;  simp at m&#10;  obtain ⟨l, ml, m⟩ | m := m&#10;  · exact h₁ l ml a m&#10;  · exact h₂ a m">
                    <OtherNode start="(374, 3)" end="(374, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(374, 3)" end="(374, 4)" kind="patternIgnore">
                        <OtherNode start="(374, 3)" end="(374, 4)" kind="token.«· »">
                          <AtomNode start="(374, 3)" end="(374, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(374, 5)" end="(380, 19)">
                      <TacticTacticseq1IndentedNode start="(374, 5)" end="(380, 19)">
                        <NullNode start="(374, 5)" end="(380, 19)">
                          <OtherNode start="(374, 5)" end="(374, 46)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs : List (List α)&#10;p : α → Bool&#10;a : α&#10;⊢ (p a = true ∧&#10;      ∃ as ys zs bs,&#10;        xs = as ++ (ys ++ a :: zs) :: bs ∧&#10;          (∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true) ∧ ∀ (x : α), x ∈ ys → (!p x) = true) →&#10;    p a = true ∧ ∃ as bs, xs.flatten = as ++ a :: bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;⊢ p a = true ∧&#10;    ∃ as_1 bs_1, (as ++ (ys ++ a :: zs) :: bs).flatten = as_1 ++ a :: bs_1 ∧ ∀ (a : α), a ∈ as_1 → (!p a) = true" tactic="rintro ⟨h, ⟨as, ys, zs, bs, rfl, h₁, h₂⟩⟩">
                            <AtomNode start="(374, 5)" end="(374, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(374, 12)" end="(374, 46)">
                              <OtherNode start="(374, 12)" end="(374, 46)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(374, 12)" end="(374, 46)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(374, 12)" end="(374, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(374, 13)" end="(374, 45)">
                                    <OtherNode start="(374, 13)" end="(374, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(374, 13)" end="(374, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(374, 13)" end="(374, 14)">
                                          <OtherNode start="(374, 13)" end="(374, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(374, 13)" end="(374, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(374, 14)" end="(374, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(374, 16)" end="(374, 45)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(374, 16)" end="(374, 45)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(374, 16)" end="(374, 45)">
                                          <OtherNode start="(374, 16)" end="(374, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(374, 16)" end="(374, 17)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(374, 17)" end="(374, 44)">
                                              <OtherNode start="(374, 17)" end="(374, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 17)" end="(374, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 17)" end="(374, 19)">
                                                    <OtherNode start="(374, 17)" end="(374, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 17)" end="(374, 19)" leading="" trailing="" raw_val="as" val="as"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(374, 19)" end="(374, 20)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(374, 21)" end="(374, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 21)" end="(374, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 21)" end="(374, 23)">
                                                    <OtherNode start="(374, 21)" end="(374, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 21)" end="(374, 23)" leading="" trailing="" raw_val="ys" val="ys"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(374, 23)" end="(374, 24)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(374, 25)" end="(374, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 25)" end="(374, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 25)" end="(374, 27)">
                                                    <OtherNode start="(374, 25)" end="(374, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 25)" end="(374, 27)" leading="" trailing="" raw_val="zs" val="zs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(374, 27)" end="(374, 28)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(374, 29)" end="(374, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 29)" end="(374, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 29)" end="(374, 31)">
                                                    <OtherNode start="(374, 29)" end="(374, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 29)" end="(374, 31)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(374, 31)" end="(374, 32)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(374, 33)" end="(374, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 33)" end="(374, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 33)" end="(374, 36)">
                                                    <OtherNode start="(374, 33)" end="(374, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 33)" end="(374, 36)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(374, 36)" end="(374, 37)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(374, 38)" end="(374, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 38)" end="(374, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 38)" end="(374, 40)">
                                                    <OtherNode start="(374, 38)" end="(374, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 38)" end="(374, 40)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(374, 40)" end="(374, 41)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(374, 42)" end="(374, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(374, 42)" end="(374, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(374, 42)" end="(374, 44)">
                                                    <OtherNode start="(374, 42)" end="(374, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(374, 42)" end="(374, 44)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(374, 44)" end="(374, 45)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(374, 45)" end="(374, 46)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(375, 5)" end="(375, 64)" kind="Lean.Parser.Tactic.refine" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;⊢ p a = true ∧&#10;    ∃ as_1 bs_1, (as ++ (ys ++ a :: zs) :: bs).flatten = as_1 ++ a :: bs_1 ∧ ∀ (a : α), a ∈ as_1 → (!p a) = true" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;⊢ ∀ (a : α), a ∈ as.flatten ++ ys → (!p a) = true" tactic="refine ⟨h, as.flatten ++ ys, zs ++ bs.flatten, by simp, ?_⟩">
                            <AtomNode start="(375, 5)" end="(375, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(375, 12)" end="(375, 64)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(375, 12)" end="(375, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(375, 13)" end="(375, 63)">
                                <IdentNode start="(375, 13)" end="(375, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                <AtomNode start="(375, 14)" end="(375, 15)" leading="" trailing=" " val=","/>
                                <OtherNode start="(375, 16)" end="(375, 32)" kind="«term_++_»">
                                  <IdentNode start="(375, 16)" end="(375, 26)" leading="" trailing=" " raw_val="as.flatten" val="as.flatten"/>
                                  <AtomNode start="(375, 27)" end="(375, 29)" leading="" trailing=" " val="++"/>
                                  <IdentNode start="(375, 30)" end="(375, 32)" leading="" trailing="" raw_val="ys" val="ys"/>
                                </OtherNode>
                                <AtomNode start="(375, 32)" end="(375, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(375, 34)" end="(375, 50)" kind="«term_++_»">
                                  <IdentNode start="(375, 34)" end="(375, 36)" leading="" trailing=" " raw_val="zs" val="zs"/>
                                  <AtomNode start="(375, 37)" end="(375, 39)" leading="" trailing=" " val="++"/>
                                  <IdentNode start="(375, 40)" end="(375, 50)" leading="" trailing="" raw_val="bs.flatten" val="bs.flatten"/>
                                </OtherNode>
                                <AtomNode start="(375, 50)" end="(375, 51)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(375, 52)" end="(375, 59)">
                                  <AtomNode start="(375, 52)" end="(375, 54)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(375, 55)" end="(375, 59)">
                                    <TacticTacticseq1IndentedNode start="(375, 55)" end="(375, 59)">
                                      <NullNode start="(375, 55)" end="(375, 59)">
                                        <OtherNode start="(375, 55)" end="(375, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;⊢ (as ++ (ys ++ a :: zs) :: bs).flatten = as.flatten ++ ys ++ a :: (zs ++ bs.flatten)" state_after="no goals" tactic="simp">
                                          <AtomNode start="(375, 55)" end="(375, 59)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(375, 59)" end="(375, 60)" leading="" trailing=" " val=","/>
                                <OtherNode start="(375, 61)" end="(375, 63)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(375, 61)" end="(375, 62)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(375, 62)" end="(375, 63)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(375, 63)" end="(375, 64)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(376, 5)" end="(376, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;⊢ ∀ (a : α), a ∈ as.flatten ++ ys → (!p a) = true" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ as.flatten ++ ys&#10;⊢ (!p a) = true" tactic="intro a m">
                            <AtomNode start="(376, 5)" end="(376, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(376, 11)" end="(376, 14)">
                              <IdentNode start="(376, 11)" end="(376, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(376, 13)" end="(376, 14)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(377, 5)" end="(377, 14)" kind="Lean.Parser.Tactic.simp" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ as.flatten ++ ys&#10;⊢ (!p a) = true" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : (∃ l, l ∈ as ∧ a ∈ l) ∨ a ∈ ys&#10;⊢ (!p a) = true" tactic="simp at m">
                            <AtomNode start="(377, 5)" end="(377, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(377, 10)" end="(377, 14)">
                              <OtherNode start="(377, 10)" end="(377, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(377, 10)" end="(377, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(377, 13)" end="(377, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(377, 13)" end="(377, 14)">
                                    <IdentNode start="(377, 13)" end="(377, 14)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(378, 5)" end="(378, 31)" kind="Lean.Parser.Tactic.obtain" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : (∃ l, l ∈ as ∧ a ∈ l) ∨ a ∈ ys&#10;⊢ (!p a) = true" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro.inl.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;l : List α&#10;ml : l ∈ as&#10;m : a ∈ l&#10;⊢ (!p a) = true&#10;&#10;case mpr.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ ys&#10;⊢ (!p a) = true" tactic="obtain ⟨l, ml, m⟩ | m := m">
                            <AtomNode start="(378, 5)" end="(378, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(378, 12)" end="(378, 26)">
                              <OtherNode start="(378, 12)" end="(378, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(378, 12)" end="(378, 26)">
                                  <OtherNode start="(378, 12)" end="(378, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(378, 12)" end="(378, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(378, 13)" end="(378, 21)">
                                      <OtherNode start="(378, 13)" end="(378, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(378, 13)" end="(378, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(378, 13)" end="(378, 14)">
                                            <OtherNode start="(378, 13)" end="(378, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(378, 13)" end="(378, 14)" leading="" trailing="" raw_val="l" val="l"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(378, 14)" end="(378, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(378, 16)" end="(378, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(378, 16)" end="(378, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(378, 16)" end="(378, 18)">
                                            <OtherNode start="(378, 16)" end="(378, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(378, 16)" end="(378, 18)" leading="" trailing="" raw_val="ml" val="ml"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(378, 18)" end="(378, 19)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(378, 20)" end="(378, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(378, 20)" end="(378, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(378, 20)" end="(378, 21)">
                                            <OtherNode start="(378, 20)" end="(378, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(378, 20)" end="(378, 21)" leading="" trailing="" raw_val="m" val="m"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(378, 21)" end="(378, 22)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                  <AtomNode start="(378, 23)" end="(378, 24)" leading="" trailing=" " val="|"/>
                                  <OtherNode start="(378, 25)" end="(378, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(378, 25)" end="(378, 26)" leading="" trailing=" " raw_val="m" val="m"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(378, 27)" end="(378, 31)">
                              <AtomNode start="(378, 27)" end="(378, 29)" leading="" trailing=" " val=":="/>
                              <NullNode start="(378, 30)" end="(378, 31)">
                                <IdentNode start="(378, 30)" end="(378, 31)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(379, 5)" end="(379, 24)" kind="Lean.cdot" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro.inl.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;l : List α&#10;ml : l ∈ as&#10;m : a ∈ l&#10;⊢ (!p a) = true&#10;&#10;case mpr.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ ys&#10;⊢ (!p a) = true" state_after="case mpr.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ ys&#10;⊢ (!p a) = true" tactic="· exact h₁ l ml a m">
                            <OtherNode start="(379, 5)" end="(379, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(379, 5)" end="(379, 6)" kind="patternIgnore">
                                <OtherNode start="(379, 5)" end="(379, 6)" kind="token.«· »">
                                  <AtomNode start="(379, 5)" end="(379, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(379, 7)" end="(379, 24)">
                              <TacticTacticseq1IndentedNode start="(379, 7)" end="(379, 24)">
                                <NullNode start="(379, 7)" end="(379, 24)">
                                  <OtherNode start="(379, 7)" end="(379, 24)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro.inl.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;l : List α&#10;ml : l ∈ as&#10;m : a ∈ l&#10;⊢ (!p a) = true" state_after="no goals" tactic="exact h₁ l ml a m">
                                    <AtomNode start="(379, 7)" end="(379, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(379, 13)" end="(379, 24)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(379, 13)" end="(379, 15)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                      <NullNode start="(379, 16)" end="(379, 24)">
                                        <IdentNode start="(379, 16)" end="(379, 17)" leading="" trailing=" " raw_val="l" val="l"/>
                                        <IdentNode start="(379, 18)" end="(379, 20)" leading="" trailing=" " raw_val="ml" val="ml"/>
                                        <IdentNode start="(379, 21)" end="(379, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(379, 23)" end="(379, 24)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(380, 5)" end="(380, 19)" kind="Lean.cdot" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ ys&#10;⊢ (!p a) = true" state_after="no goals" tactic="· exact h₂ a m">
                            <OtherNode start="(380, 5)" end="(380, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(380, 5)" end="(380, 6)" kind="patternIgnore">
                                <OtherNode start="(380, 5)" end="(380, 6)" kind="token.«· »">
                                  <AtomNode start="(380, 5)" end="(380, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(380, 7)" end="(380, 19)">
                              <TacticTacticseq1IndentedNode start="(380, 7)" end="(380, 19)">
                                <NullNode start="(380, 7)" end="(380, 19)">
                                  <OtherNode start="(380, 7)" end="(380, 19)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro.intro.intro.intro.intro.intro.intro.inr&#10;α : Type u_1&#10;p : α → Bool&#10;a✝ : α&#10;h : p a✝ = true&#10;as : List (List α)&#10;ys zs : List α&#10;bs : List (List α)&#10;h₁ : ∀ (l : List α), l ∈ as → ∀ (x : α), x ∈ l → (!p x) = true&#10;h₂ : ∀ (x : α), x ∈ ys → (!p x) = true&#10;a : α&#10;m : a ∈ ys&#10;⊢ (!p a) = true" state_after="no goals" tactic="exact h₂ a m">
                                    <AtomNode start="(380, 7)" end="(380, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(380, 13)" end="(380, 19)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(380, 13)" end="(380, 15)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                      <NullNode start="(380, 16)" end="(380, 19)">
                                        <IdentNode start="(380, 16)" end="(380, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(380, 18)" end="(380, 19)" leading="" trailing="&#10;&#10;" raw_val="m" val="m"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(382, 1)" end="(383, 59)" name="find?_flatten_eq_some" full_name="List.find?_flatten_eq_some">
      <CommandDeclmodifiersNode start="(382, 1)" end="(382, 64)">
        <NullNode/>
        <NullNode start="(382, 1)" end="(382, 64)">
          <OtherNode start="(382, 1)" end="(382, 64)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(382, 1)" end="(382, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(382, 3)" end="(382, 63)">
              <OtherNode start="(382, 3)" end="(382, 63)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(382, 3)" end="(382, 63)" kind="Lean.deprecated">
                  <AtomNode start="(382, 3)" end="(382, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(382, 14)" end="(382, 39)">
                    <IdentNode start="(382, 14)" end="(382, 39)" leading="" trailing=" " raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff" full_name="List.find?_flatten_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(347, 9)" def_end="(347, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(382, 40)" end="(382, 63)">
                    <AtomNode start="(382, 40)" end="(382, 41)" leading="" trailing="" val="("/>
                    <AtomNode start="(382, 41)" end="(382, 46)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(382, 47)" end="(382, 49)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(382, 50)" end="(382, 62)" kind="str">
                      <AtomNode start="(382, 50)" end="(382, 62)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(382, 62)" end="(382, 63)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(382, 63)" end="(382, 64)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(383, 1)" end="(383, 59)" name="find?_flatten_eq_some">
        <AtomNode start="(383, 1)" end="(383, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(383, 8)" end="(383, 29)">
          <IdentNode start="(383, 8)" end="(383, 29)" leading="" trailing=" " raw_val="find?_flatten_eq_some" val="find?_flatten_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(383, 30)" end="(383, 59)">
          <AtomNode start="(383, 30)" end="(383, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(383, 33)" end="(383, 59)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(383, 33)" end="(383, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(383, 34)" end="(383, 59)" leading="" trailing="&#10;&#10;" raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff" full_name="List.find?_flatten_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(347, 9)" def_end="(347, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(385, 1)" end="(387, 41)" name="find?_flatMap" full_name="List.find?_flatMap">
      <CommandDeclmodifiersNode start="(385, 1)" end="(385, 8)">
        <NullNode/>
        <NullNode start="(385, 1)" end="(385, 8)">
          <OtherNode start="(385, 1)" end="(385, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(385, 1)" end="(385, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(385, 3)" end="(385, 7)">
              <OtherNode start="(385, 3)" end="(385, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(385, 3)" end="(385, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(385, 3)" end="(385, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(385, 7)" end="(385, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(385, 9)" end="(387, 41)" name="find?_flatMap" full_name="List.find?_flatMap" _is_private_decl="False">
        <AtomNode start="(385, 9)" end="(385, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(385, 17)" end="(385, 30)">
          <IdentNode start="(385, 17)" end="(385, 30)" leading="" trailing=" " raw_val="find?_flatMap" val="find?_flatMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(385, 31)" end="(386, 67)">
          <NullNode start="(385, 31)" end="(385, 76)">
            <OtherNode start="(385, 31)" end="(385, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 31)" end="(385, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 32)" end="(385, 34)">
                <IdentNode start="(385, 32)" end="(385, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(385, 35)" end="(385, 43)">
                <AtomNode start="(385, 35)" end="(385, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 37)" end="(385, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(385, 37)" end="(385, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(385, 42)" end="(385, 43)">
                    <IdentNode start="(385, 42)" end="(385, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 43)" end="(385, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(385, 45)" end="(385, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 45)" end="(385, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 46)" end="(385, 47)">
                <IdentNode start="(385, 46)" end="(385, 47)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(385, 48)" end="(385, 60)">
                <AtomNode start="(385, 48)" end="(385, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 50)" end="(385, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(385, 50)" end="(385, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(385, 52)" end="(385, 53)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(385, 54)" end="(385, 60)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(385, 54)" end="(385, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(385, 59)" end="(385, 60)">
                      <IdentNode start="(385, 59)" end="(385, 60)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 60)" end="(385, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(385, 62)" end="(385, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(385, 62)" end="(385, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(385, 63)" end="(385, 64)">
                <IdentNode start="(385, 63)" end="(385, 64)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(385, 65)" end="(385, 75)">
                <AtomNode start="(385, 65)" end="(385, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(385, 67)" end="(385, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(385, 67)" end="(385, 68)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(385, 69)" end="(385, 70)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(385, 71)" end="(385, 75)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(385, 75)" end="(385, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(385, 77)" end="(386, 67)">
            <AtomNode start="(385, 77)" end="(385, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(386, 5)" end="(386, 67)" kind="«term_=_»">
              <OtherNode start="(386, 5)" end="(386, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(386, 5)" end="(386, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(386, 5)" end="(386, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(386, 5)" end="(386, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(386, 6)" end="(386, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(386, 6)" end="(386, 16)" leading="" trailing=" " raw_val="xs.flatMap" val="xs.flatMap"/>
                      <NullNode start="(386, 17)" end="(386, 18)">
                        <IdentNode start="(386, 17)" end="(386, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(386, 18)" end="(386, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(386, 19)" end="(386, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(386, 20)" end="(386, 25)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(386, 26)" end="(386, 27)">
                  <IdentNode start="(386, 26)" end="(386, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(386, 28)" end="(386, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(386, 30)" end="(386, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(386, 30)" end="(386, 42)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(386, 43)" end="(386, 67)">
                  <OtherNode start="(386, 43)" end="(386, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(386, 43)" end="(386, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(386, 44)" end="(386, 66)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(386, 44)" end="(386, 47)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(386, 48)" end="(386, 66)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(386, 48)" end="(386, 49)">
                          <IdentNode start="(386, 48)" end="(386, 49)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(386, 50)" end="(386, 52)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(386, 53)" end="(386, 66)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(386, 53)" end="(386, 64)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(386, 53)" end="(386, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(386, 53)" end="(386, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(386, 54)" end="(386, 57)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(386, 54)" end="(386, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(386, 56)" end="(386, 57)">
                                  <IdentNode start="(386, 56)" end="(386, 57)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(386, 57)" end="(386, 58)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(386, 58)" end="(386, 59)" leading="" trailing="" val="."/>
                            <IdentNode start="(386, 59)" end="(386, 64)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                          <NullNode start="(386, 65)" end="(386, 66)">
                            <IdentNode start="(386, 65)" end="(386, 66)" leading="" trailing="" raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(386, 66)" end="(386, 67)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(386, 68)" end="(387, 41)">
          <AtomNode start="(386, 68)" end="(386, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(386, 71)" end="(387, 41)">
            <AtomNode start="(386, 71)" end="(386, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(387, 3)" end="(387, 41)">
              <TacticTacticseq1IndentedNode start="(387, 3)" end="(387, 41)">
                <NullNode start="(387, 3)" end="(387, 41)">
                  <OtherNode start="(387, 3)" end="(387, 36)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → List β&#10;p : β → Bool&#10;⊢ find? p (flatMap f xs) = findSome? (fun x =&amp;gt; find? p (f x)) xs" state_after="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → List β&#10;p : β → Bool&#10;⊢ findSome? ((fun x =&amp;gt; find? p x) ∘ f) xs = findSome? (fun x =&amp;gt; find? p (f x)) xs" tactic="simp [flatMap_def, findSome?_map]">
                    <AtomNode start="(387, 3)" end="(387, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(387, 8)" end="(387, 36)">
                      <AtomNode start="(387, 8)" end="(387, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(387, 9)" end="(387, 35)">
                        <OtherNode start="(387, 9)" end="(387, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(387, 9)" end="(387, 20)" leading="" trailing="" raw_val="flatMap_def" val="flatMap_def" full_name="List.flatMap_def" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(387, 20)" end="(387, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(387, 22)" end="(387, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(387, 22)" end="(387, 35)" leading="" trailing="" raw_val="findSome?_map" val="findSome?_map" full_name="List.findSome?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(133, 9)" def_end="(133, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(387, 35)" end="(387, 36)" leading="" trailing="" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(387, 36)" end="(387, 37)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(387, 38)" end="(387, 41)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → List β&#10;p : β → Bool&#10;⊢ findSome? ((fun x =&amp;gt; find? p x) ∘ f) xs = findSome? (fun x =&amp;gt; find? p (f x)) xs" state_after="no goals" tactic="rfl">
                    <AtomNode start="(387, 38)" end="(387, 41)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(389, 1)" end="(389, 88)" name="find?_bind" full_name="List.find?_bind">
      <CommandDeclmodifiersNode start="(389, 1)" end="(389, 52)">
        <NullNode/>
        <NullNode start="(389, 1)" end="(389, 52)">
          <OtherNode start="(389, 1)" end="(389, 52)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(389, 1)" end="(389, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(389, 3)" end="(389, 51)">
              <OtherNode start="(389, 3)" end="(389, 51)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(389, 3)" end="(389, 51)" kind="Lean.deprecated">
                  <AtomNode start="(389, 3)" end="(389, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(389, 14)" end="(389, 27)">
                    <IdentNode start="(389, 14)" end="(389, 27)" leading="" trailing=" " raw_val="find?_flatMap" val="find?_flatMap" full_name="List.find?_flatMap" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(385, 17)" def_end="(385, 30)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(389, 28)" end="(389, 51)">
                    <AtomNode start="(389, 28)" end="(389, 29)" leading="" trailing="" val="("/>
                    <AtomNode start="(389, 29)" end="(389, 34)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(389, 35)" end="(389, 37)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(389, 38)" end="(389, 50)" kind="str">
                      <AtomNode start="(389, 38)" end="(389, 50)" leading="" trailing="" val="&amp;quot;2024-10-16&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(389, 50)" end="(389, 51)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(389, 51)" end="(389, 52)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(389, 53)" end="(389, 88)" name="find?_bind">
        <AtomNode start="(389, 53)" end="(389, 59)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(389, 60)" end="(389, 70)">
          <IdentNode start="(389, 60)" end="(389, 70)" leading="" trailing=" " raw_val="find?_bind" val="find?_bind"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(389, 71)" end="(389, 88)">
          <AtomNode start="(389, 71)" end="(389, 73)" leading="" trailing=" " val=":="/>
          <OtherNode start="(389, 74)" end="(389, 88)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(389, 74)" end="(389, 75)" leading="" trailing="" val="@"/>
            <IdentNode start="(389, 75)" end="(389, 88)" leading="" trailing="&#10;&#10;" raw_val="find?_flatMap" val="find?_flatMap" full_name="List.find?_flatMap" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(385, 17)" def_end="(385, 30)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(391, 1)" end="(393, 7)" name="find?_flatMap_eq_none_iff" full_name="List.find?_flatMap_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(391, 1)" end="(393, 7)" name="find?_flatMap_eq_none_iff" full_name="List.find?_flatMap_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(391, 1)" end="(391, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(391, 9)" end="(391, 34)">
          <IdentNode start="(391, 9)" end="(391, 34)" leading="" trailing=" " raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(391, 35)" end="(392, 62)">
          <NullNode start="(391, 35)" end="(391, 80)">
            <OtherNode start="(391, 35)" end="(391, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 35)" end="(391, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 36)" end="(391, 38)">
                <IdentNode start="(391, 36)" end="(391, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(391, 39)" end="(391, 47)">
                <AtomNode start="(391, 39)" end="(391, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(391, 41)" end="(391, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(391, 41)" end="(391, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(391, 46)" end="(391, 47)">
                    <IdentNode start="(391, 46)" end="(391, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(391, 47)" end="(391, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(391, 49)" end="(391, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 49)" end="(391, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 50)" end="(391, 51)">
                <IdentNode start="(391, 50)" end="(391, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(391, 52)" end="(391, 64)">
                <AtomNode start="(391, 52)" end="(391, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(391, 54)" end="(391, 64)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(391, 54)" end="(391, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(391, 56)" end="(391, 57)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(391, 58)" end="(391, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(391, 58)" end="(391, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(391, 63)" end="(391, 64)">
                      <IdentNode start="(391, 63)" end="(391, 64)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(391, 64)" end="(391, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(391, 66)" end="(391, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(391, 66)" end="(391, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(391, 67)" end="(391, 68)">
                <IdentNode start="(391, 67)" end="(391, 68)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(391, 69)" end="(391, 79)">
                <AtomNode start="(391, 69)" end="(391, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(391, 71)" end="(391, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(391, 71)" end="(391, 72)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(391, 73)" end="(391, 74)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(391, 75)" end="(391, 79)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(391, 79)" end="(391, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(391, 81)" end="(392, 62)">
            <AtomNode start="(391, 81)" end="(391, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(392, 5)" end="(392, 62)" kind="«term_↔_»">
              <OtherNode start="(392, 5)" end="(392, 34)" kind="«term_=_»">
                <OtherNode start="(392, 5)" end="(392, 27)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(392, 5)" end="(392, 25)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(392, 5)" end="(392, 19)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(392, 5)" end="(392, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(392, 6)" end="(392, 18)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(392, 6)" end="(392, 16)" leading="" trailing=" " raw_val="xs.flatMap" val="xs.flatMap"/>
                        <NullNode start="(392, 17)" end="(392, 18)">
                          <IdentNode start="(392, 17)" end="(392, 18)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(392, 18)" end="(392, 19)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(392, 19)" end="(392, 20)" leading="" trailing="" val="."/>
                    <IdentNode start="(392, 20)" end="(392, 25)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(392, 26)" end="(392, 27)">
                    <IdentNode start="(392, 26)" end="(392, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(392, 28)" end="(392, 29)" leading="" trailing=" " val="="/>
                <IdentNode start="(392, 30)" end="(392, 34)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(392, 35)" end="(392, 36)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(392, 37)" end="(392, 62)" kind="Lean.«term∀__,_»">
                <AtomNode start="(392, 37)" end="(392, 38)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(392, 39)" end="(392, 40)">
                  <IdentNode start="(392, 39)" end="(392, 40)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(392, 41)" end="(392, 45)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(392, 41)" end="(392, 42)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(392, 43)" end="(392, 45)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(392, 45)" end="(392, 46)" leading="" trailing=" " val=","/>
                <OtherNode start="(392, 47)" end="(392, 62)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(392, 47)" end="(392, 48)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(392, 49)" end="(392, 50)">
                    <IdentNode start="(392, 49)" end="(392, 50)" leading="" trailing=" " raw_val="y" val="y"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(392, 51)" end="(392, 56)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(392, 51)" end="(392, 52)" leading="" trailing=" " val="∈"/>
                    <OtherNode start="(392, 53)" end="(392, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(392, 53)" end="(392, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(392, 55)" end="(392, 56)">
                        <IdentNode start="(392, 55)" end="(392, 56)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(392, 56)" end="(392, 57)" leading="" trailing=" " val=","/>
                  <OtherNode start="(392, 58)" end="(392, 62)" kind="term!_">
                    <AtomNode start="(392, 58)" end="(392, 59)" leading="" trailing="" val="!"/>
                    <OtherNode start="(392, 59)" end="(392, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(392, 59)" end="(392, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(392, 61)" end="(392, 62)">
                        <IdentNode start="(392, 61)" end="(392, 62)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(392, 63)" end="(393, 7)">
          <AtomNode start="(392, 63)" end="(392, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(392, 66)" end="(393, 7)">
            <AtomNode start="(392, 66)" end="(392, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(393, 3)" end="(393, 7)">
              <TacticTacticseq1IndentedNode start="(393, 3)" end="(393, 7)">
                <NullNode start="(393, 3)" end="(393, 7)">
                  <OtherNode start="(393, 3)" end="(393, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;xs : List α&#10;f : α → List β&#10;p : β → Bool&#10;⊢ find? p (flatMap f xs) = none ↔ ∀ (x : α), x ∈ xs → ∀ (y : β), y ∈ f x → (!p y) = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(393, 3)" end="(393, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(395, 1)" end="(396, 59)" name="find?_flatMap_eq_none" full_name="List.find?_flatMap_eq_none">
      <CommandDeclmodifiersNode start="(395, 1)" end="(395, 64)">
        <NullNode/>
        <NullNode start="(395, 1)" end="(395, 64)">
          <OtherNode start="(395, 1)" end="(395, 64)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(395, 1)" end="(395, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(395, 3)" end="(395, 63)">
              <OtherNode start="(395, 3)" end="(395, 63)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(395, 3)" end="(395, 63)" kind="Lean.deprecated">
                  <AtomNode start="(395, 3)" end="(395, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(395, 14)" end="(395, 39)">
                    <IdentNode start="(395, 14)" end="(395, 39)" leading="" trailing=" " raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff" full_name="List.find?_flatMap_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(391, 9)" def_end="(391, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(395, 40)" end="(395, 63)">
                    <AtomNode start="(395, 40)" end="(395, 41)" leading="" trailing="" val="("/>
                    <AtomNode start="(395, 41)" end="(395, 46)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(395, 47)" end="(395, 49)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(395, 50)" end="(395, 62)" kind="str">
                      <AtomNode start="(395, 50)" end="(395, 62)" leading="" trailing="" val="&amp;quot;2024-10-16&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(395, 62)" end="(395, 63)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(395, 63)" end="(395, 64)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(396, 1)" end="(396, 59)" name="find?_flatMap_eq_none">
        <AtomNode start="(396, 1)" end="(396, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(396, 8)" end="(396, 29)">
          <IdentNode start="(396, 8)" end="(396, 29)" leading="" trailing=" " raw_val="find?_flatMap_eq_none" val="find?_flatMap_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(396, 30)" end="(396, 59)">
          <AtomNode start="(396, 30)" end="(396, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(396, 33)" end="(396, 59)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(396, 33)" end="(396, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(396, 34)" end="(396, 59)" leading="" trailing="&#10;&#10;" raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff" full_name="List.find?_flatMap_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(391, 9)" def_end="(391, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(398, 1)" end="(398, 116)" name="find?_bind_eq_none" full_name="List.find?_bind_eq_none">
      <CommandDeclmodifiersNode start="(398, 1)" end="(398, 60)">
        <NullNode/>
        <NullNode start="(398, 1)" end="(398, 60)">
          <OtherNode start="(398, 1)" end="(398, 60)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(398, 1)" end="(398, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(398, 3)" end="(398, 59)">
              <OtherNode start="(398, 3)" end="(398, 59)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(398, 3)" end="(398, 59)" kind="Lean.deprecated">
                  <AtomNode start="(398, 3)" end="(398, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(398, 14)" end="(398, 35)">
                    <IdentNode start="(398, 14)" end="(398, 35)" leading="" trailing=" " raw_val="find?_flatMap_eq_none" val="find?_flatMap_eq_none" full_name="List.find?_flatMap_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(396, 8)" def_end="(396, 29)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(398, 36)" end="(398, 59)">
                    <AtomNode start="(398, 36)" end="(398, 37)" leading="" trailing="" val="("/>
                    <AtomNode start="(398, 37)" end="(398, 42)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(398, 43)" end="(398, 45)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(398, 46)" end="(398, 58)" kind="str">
                      <AtomNode start="(398, 46)" end="(398, 58)" leading="" trailing="" val="&amp;quot;2024-10-16&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(398, 58)" end="(398, 59)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(398, 59)" end="(398, 60)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(398, 61)" end="(398, 116)" name="find?_bind_eq_none">
        <AtomNode start="(398, 61)" end="(398, 67)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(398, 68)" end="(398, 86)">
          <IdentNode start="(398, 68)" end="(398, 86)" leading="" trailing=" " raw_val="find?_bind_eq_none" val="find?_bind_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(398, 87)" end="(398, 116)">
          <AtomNode start="(398, 87)" end="(398, 89)" leading="" trailing=" " val=":="/>
          <OtherNode start="(398, 90)" end="(398, 116)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(398, 90)" end="(398, 91)" leading="" trailing="" val="@"/>
            <IdentNode start="(398, 91)" end="(398, 116)" leading="" trailing="&#10;&#10;" raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff" full_name="List.find?_flatMap_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(391, 9)" def_end="(391, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(400, 1)" end="(403, 47)" name="find?_replicate" full_name="List.find?_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(400, 1)" end="(403, 47)" name="find?_replicate" full_name="List.find?_replicate" _is_private_decl="False">
        <AtomNode start="(400, 1)" end="(400, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(400, 9)" end="(400, 24)">
          <IdentNode start="(400, 9)" end="(400, 24)" leading="" trailing=" " raw_val="find?_replicate" val="find?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(400, 25)" end="(400, 105)">
          <NullNode/>
          <TermTypespecNode start="(400, 25)" end="(400, 105)">
            <AtomNode start="(400, 25)" end="(400, 26)" leading="" trailing=" " val=":"/>
            <OtherNode start="(400, 27)" end="(400, 105)" kind="«term_=_»">
              <OtherNode start="(400, 27)" end="(400, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(400, 27)" end="(400, 32)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(400, 33)" end="(400, 50)">
                  <IdentNode start="(400, 33)" end="(400, 34)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(400, 35)" end="(400, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(400, 35)" end="(400, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(400, 36)" end="(400, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(400, 36)" end="(400, 45)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(400, 46)" end="(400, 49)">
                        <IdentNode start="(400, 46)" end="(400, 47)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(400, 48)" end="(400, 49)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(400, 49)" end="(400, 50)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(400, 51)" end="(400, 52)" leading="" trailing=" " val="="/>
              <OtherNode start="(400, 53)" end="(400, 105)" kind="termIfThenElse">
                <AtomNode start="(400, 53)" end="(400, 55)" leading="" trailing=" " val="if"/>
                <OtherNode start="(400, 56)" end="(400, 61)" kind="«term_=_»">
                  <IdentNode start="(400, 56)" end="(400, 57)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(400, 58)" end="(400, 59)" leading="" trailing=" " val="="/>
                  <OtherNode start="(400, 60)" end="(400, 61)" kind="num">
                    <AtomNode start="(400, 60)" end="(400, 61)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(400, 62)" end="(400, 66)" leading="" trailing=" " val="then"/>
                <IdentNode start="(400, 67)" end="(400, 71)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(400, 72)" end="(400, 76)" leading="" trailing=" " val="else"/>
                <OtherNode start="(400, 77)" end="(400, 105)" kind="termIfThenElse">
                  <AtomNode start="(400, 77)" end="(400, 79)" leading="" trailing=" " val="if"/>
                  <OtherNode start="(400, 80)" end="(400, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(400, 80)" end="(400, 81)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(400, 82)" end="(400, 83)">
                      <IdentNode start="(400, 82)" end="(400, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(400, 84)" end="(400, 88)" leading="" trailing=" " val="then"/>
                  <OtherNode start="(400, 89)" end="(400, 95)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(400, 89)" end="(400, 93)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(400, 94)" end="(400, 95)">
                      <IdentNode start="(400, 94)" end="(400, 95)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(400, 96)" end="(400, 100)" leading="" trailing=" " val="else"/>
                  <IdentNode start="(400, 101)" end="(400, 105)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(400, 106)" end="(403, 47)">
          <AtomNode start="(400, 106)" end="(400, 108)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(400, 109)" end="(403, 47)">
            <AtomNode start="(400, 109)" end="(400, 111)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(401, 3)" end="(403, 47)">
              <TacticTacticseq1IndentedNode start="(401, 3)" end="(403, 47)">
                <NullNode start="(401, 3)" end="(403, 47)">
                  <OtherNode start="(401, 3)" end="(401, 10)" kind="Lean.Parser.Tactic.cases" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;⊢ find? p (replicate n a) = if n = 0 then none else if p a = true then some a else none" state_after="case zero&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;⊢ find? p (replicate 0 a) = if 0 = 0 then none else if p a = true then some a else none&#10;&#10;case succ&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;n✝ : Nat&#10;⊢ find? p (replicate (n✝ + 1) a) = if n✝ + 1 = 0 then none else if p a = true then some a else none" tactic="cases n">
                    <AtomNode start="(401, 3)" end="(401, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(401, 9)" end="(401, 10)">
                      <OtherNode start="(401, 9)" end="(401, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(401, 9)" end="(401, 10)" leading="" trailing="&#10;  " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(402, 3)" end="(402, 9)" kind="Lean.cdot" state_before="case zero&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;⊢ find? p (replicate 0 a) = if 0 = 0 then none else if p a = true then some a else none&#10;&#10;case succ&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;n✝ : Nat&#10;⊢ find? p (replicate (n✝ + 1) a) = if n✝ + 1 = 0 then none else if p a = true then some a else none" state_after="case succ&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;n✝ : Nat&#10;⊢ find? p (replicate (n✝ + 1) a) = if n✝ + 1 = 0 then none else if p a = true then some a else none" tactic="· simp">
                    <OtherNode start="(402, 3)" end="(402, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(402, 3)" end="(402, 4)" kind="patternIgnore">
                        <OtherNode start="(402, 3)" end="(402, 4)" kind="token.«· »">
                          <AtomNode start="(402, 3)" end="(402, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(402, 5)" end="(402, 9)">
                      <TacticTacticseq1IndentedNode start="(402, 5)" end="(402, 9)">
                        <NullNode start="(402, 5)" end="(402, 9)">
                          <OtherNode start="(402, 5)" end="(402, 9)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;⊢ find? p (replicate 0 a) = if 0 = 0 then none else if p a = true then some a else none" state_after="no goals" tactic="simp">
                            <AtomNode start="(402, 5)" end="(402, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(403, 3)" end="(403, 47)" kind="Lean.cdot" state_before="case succ&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;n✝ : Nat&#10;⊢ find? p (replicate (n✝ + 1) a) = if n✝ + 1 = 0 then none else if p a = true then some a else none" state_after="no goals" tactic="· by_cases p a &amp;lt;;&amp;gt; simp_all [replicate_succ]">
                    <OtherNode start="(403, 3)" end="(403, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(403, 3)" end="(403, 4)" kind="patternIgnore">
                        <OtherNode start="(403, 3)" end="(403, 4)" kind="token.«· »">
                          <AtomNode start="(403, 3)" end="(403, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(403, 5)" end="(403, 47)">
                      <TacticTacticseq1IndentedNode start="(403, 5)" end="(403, 47)">
                        <NullNode start="(403, 5)" end="(403, 47)">
                          <OtherNode start="(403, 5)" end="(403, 47)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;n✝ : Nat&#10;⊢ find? p (replicate (n✝ + 1) a) = if n✝ + 1 = 0 then none else if p a = true then some a else none" state_after="no goals" tactic="by_cases p a &amp;lt;;&amp;gt; simp_all [replicate_succ]">
                            <OtherNode start="(403, 5)" end="(403, 17)" kind="«tacticBy_cases_:_»">
                              <AtomNode start="(403, 5)" end="(403, 13)" leading="" trailing=" " val="by_cases"/>
                              <NullNode/>
                              <OtherNode start="(403, 14)" end="(403, 17)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(403, 14)" end="(403, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(403, 16)" end="(403, 17)">
                                  <IdentNode start="(403, 16)" end="(403, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(403, 18)" end="(403, 21)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(403, 22)" end="(403, 47)" kind="Lean.Parser.Tactic.simpAll">
                              <AtomNode start="(403, 22)" end="(403, 30)" leading="" trailing=" " val="simp_all"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(403, 31)" end="(403, 47)">
                                <AtomNode start="(403, 31)" end="(403, 32)" leading="" trailing="" val="["/>
                                <NullNode start="(403, 32)" end="(403, 46)">
                                  <OtherNode start="(403, 32)" end="(403, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(403, 32)" end="(403, 46)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(403, 46)" end="(403, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(405, 1)" end="(406, 41)" name="find?_replicate_of_length_pos" full_name="List.find?_replicate_of_length_pos">
      <CommandDeclmodifiersNode start="(405, 1)" end="(405, 8)">
        <NullNode/>
        <NullNode start="(405, 1)" end="(405, 8)">
          <OtherNode start="(405, 1)" end="(405, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(405, 1)" end="(405, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(405, 3)" end="(405, 7)">
              <OtherNode start="(405, 3)" end="(405, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(405, 3)" end="(405, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(405, 3)" end="(405, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(405, 7)" end="(405, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(405, 9)" end="(406, 41)" name="find?_replicate_of_length_pos" full_name="List.find?_replicate_of_length_pos" _is_private_decl="False">
        <AtomNode start="(405, 9)" end="(405, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(405, 17)" end="(405, 46)">
          <IdentNode start="(405, 17)" end="(405, 46)" leading="" trailing=" " raw_val="find?_replicate_of_length_pos" val="find?_replicate_of_length_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(405, 47)" end="(405, 115)">
          <NullNode start="(405, 47)" end="(405, 58)">
            <TermExplicitbinderNode start="(405, 47)" end="(405, 58)">
              <AtomNode start="(405, 47)" end="(405, 48)" leading="" trailing="" val="("/>
              <NullNode start="(405, 48)" end="(405, 49)">
                <IdentNode start="(405, 48)" end="(405, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(405, 50)" end="(405, 57)">
                <AtomNode start="(405, 50)" end="(405, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(405, 52)" end="(405, 57)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(405, 52)" end="(405, 53)" kind="num">
                    <AtomNode start="(405, 52)" end="(405, 53)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(405, 54)" end="(405, 55)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(405, 56)" end="(405, 57)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(405, 57)" end="(405, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(405, 59)" end="(405, 115)">
            <AtomNode start="(405, 59)" end="(405, 60)" leading="" trailing=" " val=":"/>
            <OtherNode start="(405, 61)" end="(405, 115)" kind="«term_=_»">
              <OtherNode start="(405, 61)" end="(405, 84)" kind="Lean.Parser.Term.app">
                <IdentNode start="(405, 61)" end="(405, 66)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(405, 67)" end="(405, 84)">
                  <IdentNode start="(405, 67)" end="(405, 68)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(405, 69)" end="(405, 84)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(405, 69)" end="(405, 70)" leading="" trailing="" val="("/>
                    <OtherNode start="(405, 70)" end="(405, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(405, 70)" end="(405, 79)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(405, 80)" end="(405, 83)">
                        <IdentNode start="(405, 80)" end="(405, 81)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(405, 82)" end="(405, 83)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(405, 83)" end="(405, 84)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(405, 85)" end="(405, 86)" leading="" trailing=" " val="="/>
              <OtherNode start="(405, 87)" end="(405, 115)" kind="termIfThenElse">
                <AtomNode start="(405, 87)" end="(405, 89)" leading="" trailing=" " val="if"/>
                <OtherNode start="(405, 90)" end="(405, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(405, 90)" end="(405, 91)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(405, 92)" end="(405, 93)">
                    <IdentNode start="(405, 92)" end="(405, 93)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(405, 94)" end="(405, 98)" leading="" trailing=" " val="then"/>
                <OtherNode start="(405, 99)" end="(405, 105)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(405, 99)" end="(405, 103)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(405, 104)" end="(405, 105)">
                    <IdentNode start="(405, 104)" end="(405, 105)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(405, 106)" end="(405, 110)" leading="" trailing=" " val="else"/>
                <IdentNode start="(405, 111)" end="(405, 115)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(405, 116)" end="(406, 41)">
          <AtomNode start="(405, 116)" end="(405, 118)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(405, 119)" end="(406, 41)">
            <AtomNode start="(405, 119)" end="(405, 121)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(406, 3)" end="(406, 41)">
              <TacticTacticseq1IndentedNode start="(406, 3)" end="(406, 41)">
                <NullNode start="(406, 3)" end="(406, 41)">
                  <OtherNode start="(406, 3)" end="(406, 41)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝ : Type u_1&#10;p : α✝ → Bool&#10;a : α✝&#10;h : 0 &amp;lt; n&#10;⊢ find? p (replicate n a) = if p a = true then some a else none" state_after="no goals" tactic="simp [find?_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(406, 3)" end="(406, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(406, 8)" end="(406, 41)">
                      <AtomNode start="(406, 8)" end="(406, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(406, 9)" end="(406, 40)">
                        <OtherNode start="(406, 9)" end="(406, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(406, 9)" end="(406, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="List.find?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(400, 9)" def_end="(400, 24)"/>
                        </OtherNode>
                        <AtomNode start="(406, 24)" end="(406, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(406, 26)" end="(406, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(406, 26)" end="(406, 40)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(406, 26)" end="(406, 38)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(406, 39)" end="(406, 40)">
                              <IdentNode start="(406, 39)" end="(406, 40)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(406, 40)" end="(406, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(408, 1)" end="(409, 28)" name="find?_replicate_of_pos" full_name="List.find?_replicate_of_pos">
      <CommandDeclmodifiersNode start="(408, 1)" end="(408, 8)">
        <NullNode/>
        <NullNode start="(408, 1)" end="(408, 8)">
          <OtherNode start="(408, 1)" end="(408, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(408, 1)" end="(408, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(408, 3)" end="(408, 7)">
              <OtherNode start="(408, 3)" end="(408, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(408, 3)" end="(408, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(408, 3)" end="(408, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(408, 7)" end="(408, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(408, 9)" end="(409, 28)" name="find?_replicate_of_pos" full_name="List.find?_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(408, 9)" end="(408, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(408, 17)" end="(408, 39)">
          <IdentNode start="(408, 17)" end="(408, 39)" leading="" trailing=" " raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(408, 40)" end="(408, 108)">
          <NullNode start="(408, 40)" end="(408, 49)">
            <TermExplicitbinderNode start="(408, 40)" end="(408, 49)">
              <AtomNode start="(408, 40)" end="(408, 41)" leading="" trailing="" val="("/>
              <NullNode start="(408, 41)" end="(408, 42)">
                <IdentNode start="(408, 41)" end="(408, 42)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(408, 43)" end="(408, 48)">
                <AtomNode start="(408, 43)" end="(408, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(408, 45)" end="(408, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(408, 45)" end="(408, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(408, 47)" end="(408, 48)">
                    <IdentNode start="(408, 47)" end="(408, 48)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(408, 48)" end="(408, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(408, 50)" end="(408, 108)">
            <AtomNode start="(408, 50)" end="(408, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(408, 52)" end="(408, 108)" kind="«term_=_»">
              <OtherNode start="(408, 52)" end="(408, 75)" kind="Lean.Parser.Term.app">
                <IdentNode start="(408, 52)" end="(408, 57)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(408, 58)" end="(408, 75)">
                  <IdentNode start="(408, 58)" end="(408, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(408, 60)" end="(408, 75)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(408, 60)" end="(408, 61)" leading="" trailing="" val="("/>
                    <OtherNode start="(408, 61)" end="(408, 74)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(408, 61)" end="(408, 70)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(408, 71)" end="(408, 74)">
                        <IdentNode start="(408, 71)" end="(408, 72)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(408, 73)" end="(408, 74)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(408, 74)" end="(408, 75)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(408, 76)" end="(408, 77)" leading="" trailing=" " val="="/>
              <OtherNode start="(408, 78)" end="(408, 108)" kind="termIfThenElse">
                <AtomNode start="(408, 78)" end="(408, 80)" leading="" trailing=" " val="if"/>
                <OtherNode start="(408, 81)" end="(408, 86)" kind="«term_=_»">
                  <IdentNode start="(408, 81)" end="(408, 82)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(408, 83)" end="(408, 84)" leading="" trailing=" " val="="/>
                  <OtherNode start="(408, 85)" end="(408, 86)" kind="num">
                    <AtomNode start="(408, 85)" end="(408, 86)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(408, 87)" end="(408, 91)" leading="" trailing=" " val="then"/>
                <IdentNode start="(408, 92)" end="(408, 96)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(408, 97)" end="(408, 101)" leading="" trailing=" " val="else"/>
                <OtherNode start="(408, 102)" end="(408, 108)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(408, 102)" end="(408, 106)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(408, 107)" end="(408, 108)">
                    <IdentNode start="(408, 107)" end="(408, 108)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(408, 109)" end="(409, 28)">
          <AtomNode start="(408, 109)" end="(408, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(408, 112)" end="(409, 28)">
            <AtomNode start="(408, 112)" end="(408, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(409, 3)" end="(409, 28)">
              <TacticTacticseq1IndentedNode start="(409, 3)" end="(409, 28)">
                <NullNode start="(409, 3)" end="(409, 28)">
                  <OtherNode start="(409, 3)" end="(409, 28)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;h : p a = true&#10;⊢ find? p (replicate n a) = if n = 0 then none else some a" state_after="no goals" tactic="simp [find?_replicate, h]">
                    <AtomNode start="(409, 3)" end="(409, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(409, 8)" end="(409, 28)">
                      <AtomNode start="(409, 8)" end="(409, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(409, 9)" end="(409, 27)">
                        <OtherNode start="(409, 9)" end="(409, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(409, 9)" end="(409, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="List.find?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(400, 9)" def_end="(400, 24)"/>
                        </OtherNode>
                        <AtomNode start="(409, 24)" end="(409, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(409, 26)" end="(409, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(409, 26)" end="(409, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(409, 27)" end="(409, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(411, 1)" end="(412, 28)" name="find?_replicate_of_neg" full_name="List.find?_replicate_of_neg">
      <CommandDeclmodifiersNode start="(411, 1)" end="(411, 8)">
        <NullNode/>
        <NullNode start="(411, 1)" end="(411, 8)">
          <OtherNode start="(411, 1)" end="(411, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(411, 1)" end="(411, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(411, 3)" end="(411, 7)">
              <OtherNode start="(411, 3)" end="(411, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(411, 3)" end="(411, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(411, 3)" end="(411, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(411, 7)" end="(411, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(411, 9)" end="(412, 28)" name="find?_replicate_of_neg" full_name="List.find?_replicate_of_neg" _is_private_decl="False">
        <AtomNode start="(411, 9)" end="(411, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(411, 17)" end="(411, 39)">
          <IdentNode start="(411, 17)" end="(411, 39)" leading="" trailing=" " raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(411, 40)" end="(411, 84)">
          <NullNode start="(411, 40)" end="(411, 51)">
            <TermExplicitbinderNode start="(411, 40)" end="(411, 51)">
              <AtomNode start="(411, 40)" end="(411, 41)" leading="" trailing="" val="("/>
              <NullNode start="(411, 41)" end="(411, 42)">
                <IdentNode start="(411, 41)" end="(411, 42)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(411, 43)" end="(411, 50)">
                <AtomNode start="(411, 43)" end="(411, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(411, 45)" end="(411, 50)" kind="«term¬_»">
                  <AtomNode start="(411, 45)" end="(411, 46)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(411, 47)" end="(411, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(411, 47)" end="(411, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(411, 49)" end="(411, 50)">
                      <IdentNode start="(411, 49)" end="(411, 50)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(411, 50)" end="(411, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(411, 52)" end="(411, 84)">
            <AtomNode start="(411, 52)" end="(411, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(411, 54)" end="(411, 84)" kind="«term_=_»">
              <OtherNode start="(411, 54)" end="(411, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(411, 54)" end="(411, 59)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(411, 60)" end="(411, 77)">
                  <IdentNode start="(411, 60)" end="(411, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(411, 62)" end="(411, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(411, 62)" end="(411, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(411, 63)" end="(411, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(411, 63)" end="(411, 72)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(411, 73)" end="(411, 76)">
                        <IdentNode start="(411, 73)" end="(411, 74)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(411, 75)" end="(411, 76)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(411, 76)" end="(411, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(411, 78)" end="(411, 79)" leading="" trailing=" " val="="/>
              <IdentNode start="(411, 80)" end="(411, 84)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(411, 85)" end="(412, 28)">
          <AtomNode start="(411, 85)" end="(411, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(411, 88)" end="(412, 28)">
            <AtomNode start="(411, 88)" end="(411, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(412, 3)" end="(412, 28)">
              <TacticTacticseq1IndentedNode start="(412, 3)" end="(412, 28)">
                <NullNode start="(412, 3)" end="(412, 28)">
                  <OtherNode start="(412, 3)" end="(412, 28)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;h : ¬p a = true&#10;⊢ find? p (replicate n a) = none" state_after="no goals" tactic="simp [find?_replicate, h]">
                    <AtomNode start="(412, 3)" end="(412, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(412, 8)" end="(412, 28)">
                      <AtomNode start="(412, 8)" end="(412, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(412, 9)" end="(412, 27)">
                        <OtherNode start="(412, 9)" end="(412, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(412, 9)" end="(412, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="List.find?_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(400, 9)" def_end="(400, 24)"/>
                        </OtherNode>
                        <AtomNode start="(412, 24)" end="(412, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(412, 26)" end="(412, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(412, 26)" end="(412, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(412, 27)" end="(412, 28)" leading="" trailing="&#10;&#10;-- This isn't a `@[simp]` lemma since there is already a lemma for `l.find? p = none` for any `l`.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(415, 1)" end="(417, 39)" name="find?_replicate_eq_none_iff" full_name="List.find?_replicate_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(415, 1)" end="(417, 39)" name="find?_replicate_eq_none_iff" full_name="List.find?_replicate_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(415, 1)" end="(415, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(415, 9)" end="(415, 36)">
          <IdentNode start="(415, 9)" end="(415, 36)" leading="" trailing=" " raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(415, 37)" end="(416, 50)">
          <NullNode start="(415, 37)" end="(415, 69)">
            <OtherNode start="(415, 37)" end="(415, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 37)" end="(415, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 38)" end="(415, 39)">
                <IdentNode start="(415, 38)" end="(415, 39)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(415, 40)" end="(415, 45)">
                <AtomNode start="(415, 40)" end="(415, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(415, 42)" end="(415, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(415, 45)" end="(415, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(415, 47)" end="(415, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 47)" end="(415, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 48)" end="(415, 49)">
                <IdentNode start="(415, 48)" end="(415, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(415, 50)" end="(415, 53)">
                <AtomNode start="(415, 50)" end="(415, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(415, 52)" end="(415, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(415, 53)" end="(415, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(415, 55)" end="(415, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(415, 55)" end="(415, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(415, 56)" end="(415, 57)">
                <IdentNode start="(415, 56)" end="(415, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(415, 58)" end="(415, 68)">
                <AtomNode start="(415, 58)" end="(415, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(415, 60)" end="(415, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(415, 60)" end="(415, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(415, 62)" end="(415, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(415, 64)" end="(415, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(415, 68)" end="(415, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(415, 70)" end="(416, 50)">
            <AtomNode start="(415, 70)" end="(415, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(416, 5)" end="(416, 50)" kind="«term_↔_»">
              <OtherNode start="(416, 5)" end="(416, 35)" kind="«term_=_»">
                <OtherNode start="(416, 5)" end="(416, 28)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(416, 5)" end="(416, 26)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(416, 5)" end="(416, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(416, 5)" end="(416, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(416, 6)" end="(416, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(416, 6)" end="(416, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(416, 16)" end="(416, 19)">
                          <IdentNode start="(416, 16)" end="(416, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          <IdentNode start="(416, 18)" end="(416, 19)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(416, 19)" end="(416, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(416, 20)" end="(416, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(416, 21)" end="(416, 26)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(416, 27)" end="(416, 28)">
                    <IdentNode start="(416, 27)" end="(416, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(416, 29)" end="(416, 30)" leading="" trailing=" " val="="/>
                <IdentNode start="(416, 31)" end="(416, 35)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(416, 36)" end="(416, 37)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(416, 38)" end="(416, 50)" kind="«term_∨_»">
                <OtherNode start="(416, 38)" end="(416, 43)" kind="«term_=_»">
                  <IdentNode start="(416, 38)" end="(416, 39)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(416, 40)" end="(416, 41)" leading="" trailing=" " val="="/>
                  <OtherNode start="(416, 42)" end="(416, 43)" kind="num">
                    <AtomNode start="(416, 42)" end="(416, 43)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(416, 44)" end="(416, 45)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(416, 46)" end="(416, 50)" kind="term!_">
                  <AtomNode start="(416, 46)" end="(416, 47)" leading="" trailing="" val="!"/>
                  <OtherNode start="(416, 47)" end="(416, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(416, 47)" end="(416, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(416, 49)" end="(416, 50)">
                      <IdentNode start="(416, 49)" end="(416, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(416, 51)" end="(417, 39)">
          <AtomNode start="(416, 51)" end="(416, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(416, 54)" end="(417, 39)">
            <AtomNode start="(416, 54)" end="(416, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(417, 3)" end="(417, 39)">
              <TacticTacticseq1IndentedNode start="(417, 3)" end="(417, 39)">
                <NullNode start="(417, 3)" end="(417, 39)">
                  <OtherNode start="(417, 3)" end="(417, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ find? p (replicate n a) = none ↔ n = 0 ∨ (!p a) = true" state_after="no goals" tactic="simp [Classical.or_iff_not_imp_left]">
                    <AtomNode start="(417, 3)" end="(417, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(417, 8)" end="(417, 39)">
                      <AtomNode start="(417, 8)" end="(417, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(417, 9)" end="(417, 38)">
                        <OtherNode start="(417, 9)" end="(417, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(417, 9)" end="(417, 38)" leading="" trailing="" raw_val="Classical.or_iff_not_imp_left" val="Classical.or_iff_not_imp_left" full_name="Classical.or_iff_not_imp_left" mod_name="Init.Classical" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Classical.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(417, 38)" end="(417, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(419, 1)" end="(420, 63)" name="find?_replicate_eq_none" full_name="List.find?_replicate_eq_none">
      <CommandDeclmodifiersNode start="(419, 1)" end="(419, 66)">
        <NullNode/>
        <NullNode start="(419, 1)" end="(419, 66)">
          <OtherNode start="(419, 1)" end="(419, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(419, 1)" end="(419, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(419, 3)" end="(419, 65)">
              <OtherNode start="(419, 3)" end="(419, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(419, 3)" end="(419, 65)" kind="Lean.deprecated">
                  <AtomNode start="(419, 3)" end="(419, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(419, 14)" end="(419, 41)">
                    <IdentNode start="(419, 14)" end="(419, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff" full_name="List.find?_replicate_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(415, 9)" def_end="(415, 36)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(419, 42)" end="(419, 65)">
                    <AtomNode start="(419, 42)" end="(419, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(419, 43)" end="(419, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(419, 49)" end="(419, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(419, 52)" end="(419, 64)" kind="str">
                      <AtomNode start="(419, 52)" end="(419, 64)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(419, 64)" end="(419, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(419, 65)" end="(419, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(420, 1)" end="(420, 63)" name="find?_replicate_eq_none">
        <AtomNode start="(420, 1)" end="(420, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(420, 8)" end="(420, 31)">
          <IdentNode start="(420, 8)" end="(420, 31)" leading="" trailing=" " raw_val="find?_replicate_eq_none" val="find?_replicate_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(420, 32)" end="(420, 63)">
          <AtomNode start="(420, 32)" end="(420, 34)" leading="" trailing=" " val=":="/>
          <OtherNode start="(420, 35)" end="(420, 63)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(420, 35)" end="(420, 36)" leading="" trailing="" val="@"/>
            <IdentNode start="(420, 36)" end="(420, 63)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff" full_name="List.find?_replicate_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(415, 9)" def_end="(415, 36)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(422, 1)" end="(424, 19)" name="find?_replicate_eq_some_iff" full_name="List.find?_replicate_eq_some_iff">
      <CommandDeclmodifiersNode start="(422, 1)" end="(422, 8)">
        <NullNode/>
        <NullNode start="(422, 1)" end="(422, 8)">
          <OtherNode start="(422, 1)" end="(422, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(422, 1)" end="(422, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(422, 3)" end="(422, 7)">
              <OtherNode start="(422, 3)" end="(422, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(422, 3)" end="(422, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(422, 3)" end="(422, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(422, 7)" end="(422, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(422, 9)" end="(424, 19)" name="find?_replicate_eq_some_iff" full_name="List.find?_replicate_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(422, 9)" end="(422, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(422, 17)" end="(422, 44)">
          <IdentNode start="(422, 17)" end="(422, 44)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(422, 45)" end="(423, 59)">
          <NullNode start="(422, 45)" end="(422, 79)">
            <OtherNode start="(422, 45)" end="(422, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(422, 45)" end="(422, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(422, 46)" end="(422, 47)">
                <IdentNode start="(422, 46)" end="(422, 47)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(422, 48)" end="(422, 53)">
                <AtomNode start="(422, 48)" end="(422, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(422, 50)" end="(422, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(422, 53)" end="(422, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(422, 55)" end="(422, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(422, 55)" end="(422, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(422, 56)" end="(422, 59)">
                <IdentNode start="(422, 56)" end="(422, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(422, 58)" end="(422, 59)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(422, 60)" end="(422, 63)">
                <AtomNode start="(422, 60)" end="(422, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(422, 62)" end="(422, 63)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(422, 63)" end="(422, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(422, 65)" end="(422, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(422, 65)" end="(422, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(422, 66)" end="(422, 67)">
                <IdentNode start="(422, 66)" end="(422, 67)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(422, 68)" end="(422, 78)">
                <AtomNode start="(422, 68)" end="(422, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(422, 70)" end="(422, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(422, 70)" end="(422, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(422, 72)" end="(422, 73)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(422, 74)" end="(422, 78)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(422, 78)" end="(422, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(422, 80)" end="(423, 59)">
            <AtomNode start="(422, 80)" end="(422, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(423, 5)" end="(423, 59)" kind="«term_↔_»">
              <OtherNode start="(423, 5)" end="(423, 37)" kind="«term_=_»">
                <OtherNode start="(423, 5)" end="(423, 28)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(423, 5)" end="(423, 26)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(423, 5)" end="(423, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(423, 5)" end="(423, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(423, 6)" end="(423, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(423, 6)" end="(423, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(423, 16)" end="(423, 19)">
                          <IdentNode start="(423, 16)" end="(423, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          <IdentNode start="(423, 18)" end="(423, 19)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(423, 19)" end="(423, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(423, 20)" end="(423, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(423, 21)" end="(423, 26)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(423, 27)" end="(423, 28)">
                    <IdentNode start="(423, 27)" end="(423, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(423, 29)" end="(423, 30)" leading="" trailing=" " val="="/>
                <OtherNode start="(423, 31)" end="(423, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(423, 31)" end="(423, 35)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(423, 36)" end="(423, 37)">
                    <IdentNode start="(423, 36)" end="(423, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(423, 38)" end="(423, 39)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(423, 40)" end="(423, 59)" kind="«term_∧_»">
                <OtherNode start="(423, 40)" end="(423, 45)" kind="«term_≠_»">
                  <IdentNode start="(423, 40)" end="(423, 41)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(423, 42)" end="(423, 43)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(423, 44)" end="(423, 45)" kind="num">
                    <AtomNode start="(423, 44)" end="(423, 45)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(423, 46)" end="(423, 47)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(423, 48)" end="(423, 59)" kind="«term_∧_»">
                  <OtherNode start="(423, 48)" end="(423, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(423, 48)" end="(423, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(423, 50)" end="(423, 51)">
                      <IdentNode start="(423, 50)" end="(423, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(423, 52)" end="(423, 53)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(423, 54)" end="(423, 59)" kind="«term_=_»">
                    <IdentNode start="(423, 54)" end="(423, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(423, 56)" end="(423, 57)" leading="" trailing=" " val="="/>
                    <IdentNode start="(423, 58)" end="(423, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(423, 60)" end="(424, 19)">
          <AtomNode start="(423, 60)" end="(423, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(423, 63)" end="(424, 19)">
            <AtomNode start="(423, 63)" end="(423, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(424, 3)" end="(424, 19)">
              <TacticTacticseq1IndentedNode start="(424, 3)" end="(424, 19)">
                <NullNode start="(424, 3)" end="(424, 19)">
                  <OtherNode start="(424, 3)" end="(424, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;n : Nat&#10;a b : α&#10;p : α → Bool&#10;⊢ find? p (replicate n a) = some b ↔ n ≠ 0 ∧ p a = true ∧ a = b" state_after="no goals" tactic="cases n &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(424, 3)" end="(424, 10)" kind="Lean.Parser.Tactic.cases">
                      <AtomNode start="(424, 3)" end="(424, 8)" leading="" trailing=" " val="cases"/>
                      <NullNode start="(424, 9)" end="(424, 10)">
                        <OtherNode start="(424, 9)" end="(424, 10)" kind="Lean.Parser.Tactic.elimTarget">
                          <NullNode/>
                          <IdentNode start="(424, 9)" end="(424, 10)" leading="" trailing=" " raw_val="n" val="n"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(424, 11)" end="(424, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(424, 15)" end="(424, 19)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(424, 15)" end="(424, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(426, 1)" end="(427, 63)" name="find?_replicate_eq_some" full_name="List.find?_replicate_eq_some">
      <CommandDeclmodifiersNode start="(426, 1)" end="(426, 66)">
        <NullNode/>
        <NullNode start="(426, 1)" end="(426, 66)">
          <OtherNode start="(426, 1)" end="(426, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(426, 1)" end="(426, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(426, 3)" end="(426, 65)">
              <OtherNode start="(426, 3)" end="(426, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(426, 3)" end="(426, 65)" kind="Lean.deprecated">
                  <AtomNode start="(426, 3)" end="(426, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(426, 14)" end="(426, 41)">
                    <IdentNode start="(426, 14)" end="(426, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="List.find?_replicate_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(422, 17)" def_end="(422, 44)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(426, 42)" end="(426, 65)">
                    <AtomNode start="(426, 42)" end="(426, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(426, 43)" end="(426, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(426, 49)" end="(426, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(426, 52)" end="(426, 64)" kind="str">
                      <AtomNode start="(426, 52)" end="(426, 64)" leading="" trailing="" val="&amp;quot;2025-02-03&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(426, 64)" end="(426, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(426, 65)" end="(426, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(427, 1)" end="(427, 63)" name="find?_replicate_eq_some">
        <AtomNode start="(427, 1)" end="(427, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(427, 8)" end="(427, 31)">
          <IdentNode start="(427, 8)" end="(427, 31)" leading="" trailing=" " raw_val="find?_replicate_eq_some" val="find?_replicate_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(427, 32)" end="(427, 63)">
          <AtomNode start="(427, 32)" end="(427, 34)" leading="" trailing=" " val=":="/>
          <OtherNode start="(427, 35)" end="(427, 63)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(427, 35)" end="(427, 36)" leading="" trailing="" val="@"/>
            <IdentNode start="(427, 36)" end="(427, 63)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="List.find?_replicate_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(422, 17)" def_end="(422, 44)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(429, 1)" end="(432, 19)" name="get_find?_replicate" full_name="List.get_find?_replicate">
      <CommandDeclmodifiersNode start="(429, 1)" end="(429, 8)">
        <NullNode/>
        <NullNode start="(429, 1)" end="(429, 8)">
          <OtherNode start="(429, 1)" end="(429, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(429, 1)" end="(429, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(429, 3)" end="(429, 7)">
              <OtherNode start="(429, 3)" end="(429, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(429, 3)" end="(429, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(429, 3)" end="(429, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(429, 7)" end="(429, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(429, 9)" end="(432, 19)" name="get_find?_replicate" full_name="List.get_find?_replicate" _is_private_decl="False">
        <AtomNode start="(429, 9)" end="(429, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(429, 17)" end="(429, 36)">
          <IdentNode start="(429, 17)" end="(429, 36)" leading="" trailing=" " raw_val="get_find?_replicate" val="get_find?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(429, 37)" end="(429, 111)">
          <NullNode start="(429, 37)" end="(429, 73)">
            <OtherNode start="(429, 37)" end="(429, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(429, 37)" end="(429, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(429, 38)" end="(429, 39)">
                <IdentNode start="(429, 38)" end="(429, 39)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(429, 40)" end="(429, 45)">
                <AtomNode start="(429, 40)" end="(429, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(429, 42)" end="(429, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(429, 45)" end="(429, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(429, 47)" end="(429, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(429, 47)" end="(429, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(429, 48)" end="(429, 49)">
                <IdentNode start="(429, 48)" end="(429, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(429, 50)" end="(429, 53)">
                <AtomNode start="(429, 50)" end="(429, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(429, 52)" end="(429, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(429, 53)" end="(429, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(429, 55)" end="(429, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(429, 55)" end="(429, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(429, 56)" end="(429, 57)">
                <IdentNode start="(429, 56)" end="(429, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(429, 58)" end="(429, 68)">
                <AtomNode start="(429, 58)" end="(429, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(429, 60)" end="(429, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(429, 60)" end="(429, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(429, 62)" end="(429, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(429, 64)" end="(429, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(429, 68)" end="(429, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(429, 70)" end="(429, 73)">
              <AtomNode start="(429, 70)" end="(429, 71)" leading="" trailing="" val="("/>
              <NullNode start="(429, 71)" end="(429, 72)">
                <IdentNode start="(429, 71)" end="(429, 72)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(429, 72)" end="(429, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(429, 74)" end="(429, 111)">
            <AtomNode start="(429, 74)" end="(429, 75)" leading="" trailing=" " val=":"/>
            <OtherNode start="(429, 76)" end="(429, 111)" kind="«term_=_»">
              <OtherNode start="(429, 76)" end="(429, 107)" kind="Lean.Parser.Term.app">
                <OtherNode start="(429, 76)" end="(429, 105)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(429, 76)" end="(429, 101)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(429, 76)" end="(429, 77)" leading="" trailing="" val="("/>
                    <OtherNode start="(429, 77)" end="(429, 100)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(429, 77)" end="(429, 98)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(429, 77)" end="(429, 92)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(429, 77)" end="(429, 78)" leading="" trailing="" val="("/>
                          <OtherNode start="(429, 78)" end="(429, 91)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(429, 78)" end="(429, 87)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            <NullNode start="(429, 88)" end="(429, 91)">
                              <IdentNode start="(429, 88)" end="(429, 89)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(429, 90)" end="(429, 91)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(429, 91)" end="(429, 92)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(429, 92)" end="(429, 93)" leading="" trailing="" val="."/>
                        <IdentNode start="(429, 93)" end="(429, 98)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(429, 99)" end="(429, 100)">
                        <IdentNode start="(429, 99)" end="(429, 100)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(429, 100)" end="(429, 101)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(429, 101)" end="(429, 102)" leading="" trailing="" val="."/>
                  <IdentNode start="(429, 102)" end="(429, 105)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(429, 106)" end="(429, 107)">
                  <IdentNode start="(429, 106)" end="(429, 107)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(429, 108)" end="(429, 109)" leading="" trailing=" " val="="/>
              <IdentNode start="(429, 110)" end="(429, 111)" leading="" trailing=" " raw_val="a" val="a"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(429, 112)" end="(432, 19)">
          <AtomNode start="(429, 112)" end="(429, 114)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(429, 115)" end="(432, 19)">
            <AtomNode start="(429, 115)" end="(429, 117)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(430, 3)" end="(432, 19)">
              <TacticTacticseq1IndentedNode start="(430, 3)" end="(432, 19)">
                <NullNode start="(430, 3)" end="(432, 19)">
                  <OtherNode start="(430, 3)" end="(432, 19)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;h : (find? p (replicate n a)).isSome = true&#10;⊢ (find? p (replicate n a)).get h = a" state_after="no goals" tactic="cases n with&#10;| zero =&amp;gt; simp at h&#10;| succ n =&amp;gt; simp">
                    <AtomNode start="(430, 3)" end="(430, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(430, 9)" end="(430, 10)">
                      <OtherNode start="(430, 9)" end="(430, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(430, 9)" end="(430, 10)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(430, 11)" end="(432, 19)">
                      <OtherNode start="(430, 11)" end="(432, 19)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(430, 11)" end="(430, 15)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(431, 3)" end="(432, 19)">
                          <OtherNode start="(431, 3)" end="(431, 22)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(431, 3)" end="(431, 9)">
                              <OtherNode start="(431, 3)" end="(431, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(431, 3)" end="(431, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(431, 5)" end="(431, 9)">
                                  <NullNode/>
                                  <IdentNode start="(431, 5)" end="(431, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(431, 10)" end="(431, 22)">
                              <AtomNode start="(431, 10)" end="(431, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(431, 13)" end="(431, 22)">
                                <TacticTacticseq1IndentedNode start="(431, 13)" end="(431, 22)">
                                  <NullNode start="(431, 13)" end="(431, 22)">
                                    <OtherNode start="(431, 13)" end="(431, 22)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;h : (find? p (replicate 0 a)).isSome = true&#10;⊢ (find? p (replicate 0 a)).get h = a" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(431, 13)" end="(431, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(431, 18)" end="(431, 22)">
                                        <OtherNode start="(431, 18)" end="(431, 22)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(431, 18)" end="(431, 20)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(431, 21)" end="(431, 22)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(431, 21)" end="(431, 22)">
                                              <IdentNode start="(431, 21)" end="(431, 22)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(432, 3)" end="(432, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(432, 3)" end="(432, 11)">
                              <OtherNode start="(432, 3)" end="(432, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(432, 3)" end="(432, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(432, 5)" end="(432, 9)">
                                  <NullNode/>
                                  <IdentNode start="(432, 5)" end="(432, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(432, 10)" end="(432, 11)">
                                  <IdentNode start="(432, 10)" end="(432, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(432, 12)" end="(432, 19)">
                              <AtomNode start="(432, 12)" end="(432, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(432, 15)" end="(432, 19)">
                                <TacticTacticseq1IndentedNode start="(432, 15)" end="(432, 19)">
                                  <NullNode start="(432, 15)" end="(432, 19)">
                                    <OtherNode start="(432, 15)" end="(432, 19)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;n : Nat&#10;h : (find? p (replicate (n + 1) a)).isSome = true&#10;⊢ (find? p (replicate (n + 1) a)).get h = a" state_after="no goals" tactic="simp">
                                      <AtomNode start="(432, 15)" end="(432, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(434, 1)" end="(442, 21)" name="Sublist.find?_isSome" full_name="List.Sublist.find?_isSome">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(434, 1)" end="(442, 21)" name="Sublist.find?_isSome" full_name="List.Sublist.find?_isSome" _is_private_decl="False">
        <AtomNode start="(434, 1)" end="(434, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(434, 9)" end="(434, 29)">
          <IdentNode start="(434, 9)" end="(434, 29)" leading="" trailing=" " raw_val="Sublist.find?_isSome" val="Sublist.find?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(434, 30)" end="(434, 105)">
          <NullNode start="(434, 30)" end="(434, 61)">
            <OtherNode start="(434, 30)" end="(434, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(434, 30)" end="(434, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(434, 31)" end="(434, 36)">
                <IdentNode start="(434, 31)" end="(434, 33)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(434, 34)" end="(434, 36)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(434, 37)" end="(434, 45)">
                <AtomNode start="(434, 37)" end="(434, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(434, 39)" end="(434, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(434, 39)" end="(434, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(434, 44)" end="(434, 45)">
                    <IdentNode start="(434, 44)" end="(434, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(434, 45)" end="(434, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(434, 47)" end="(434, 61)">
              <AtomNode start="(434, 47)" end="(434, 48)" leading="" trailing="" val="("/>
              <NullNode start="(434, 48)" end="(434, 49)">
                <IdentNode start="(434, 48)" end="(434, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(434, 50)" end="(434, 60)">
                <AtomNode start="(434, 50)" end="(434, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(434, 52)" end="(434, 60)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(434, 52)" end="(434, 54)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(434, 55)" end="(434, 57)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(434, 58)" end="(434, 60)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(434, 60)" end="(434, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(434, 62)" end="(434, 105)">
            <AtomNode start="(434, 62)" end="(434, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(434, 64)" end="(434, 105)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(434, 64)" end="(434, 83)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(434, 64)" end="(434, 76)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(434, 64)" end="(434, 65)" leading="" trailing="" val="("/>
                  <OtherNode start="(434, 65)" end="(434, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 65)" end="(434, 73)" leading="" trailing=" " raw_val="l₁.find?" val="l₁.find?"/>
                    <NullNode start="(434, 74)" end="(434, 75)">
                      <IdentNode start="(434, 74)" end="(434, 75)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(434, 75)" end="(434, 76)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(434, 76)" end="(434, 77)" leading="" trailing="" val="."/>
                <IdentNode start="(434, 77)" end="(434, 83)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(434, 84)" end="(434, 85)" leading="" trailing=" " val="→"/>
              <OtherNode start="(434, 86)" end="(434, 105)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(434, 86)" end="(434, 98)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(434, 86)" end="(434, 87)" leading="" trailing="" val="("/>
                  <OtherNode start="(434, 87)" end="(434, 97)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(434, 87)" end="(434, 95)" leading="" trailing=" " raw_val="l₂.find?" val="l₂.find?"/>
                    <NullNode start="(434, 96)" end="(434, 97)">
                      <IdentNode start="(434, 96)" end="(434, 97)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(434, 97)" end="(434, 98)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(434, 98)" end="(434, 99)" leading="" trailing="" val="."/>
                <IdentNode start="(434, 99)" end="(434, 105)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(434, 106)" end="(442, 21)">
          <AtomNode start="(434, 106)" end="(434, 108)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(434, 109)" end="(442, 21)">
            <AtomNode start="(434, 109)" end="(434, 111)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(435, 3)" end="(442, 21)">
              <TacticTacticseq1IndentedNode start="(435, 3)" end="(442, 21)">
                <NullNode start="(435, 3)" end="(442, 21)">
                  <OtherNode start="(435, 3)" end="(442, 21)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (find? p l₁).isSome = true → (find? p l₂).isSome = true" state_after="no goals" tactic="induction h with&#10;| slnil =&amp;gt; simp&#10;| cons a h ih&#10;| cons₂ a h ih =&amp;gt;&#10;  simp only [find?]&#10;  split&#10;  · simp&#10;  · simpa using ih">
                    <AtomNode start="(435, 3)" end="(435, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(435, 13)" end="(435, 14)">
                      <OtherNode start="(435, 13)" end="(435, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(435, 13)" end="(435, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(435, 15)" end="(442, 21)">
                      <OtherNode start="(435, 15)" end="(442, 21)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(435, 15)" end="(435, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(436, 3)" end="(442, 21)">
                          <OtherNode start="(436, 3)" end="(436, 18)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(436, 3)" end="(436, 10)">
                              <OtherNode start="(436, 3)" end="(436, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(436, 3)" end="(436, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(436, 5)" end="(436, 10)">
                                  <NullNode/>
                                  <IdentNode start="(436, 5)" end="(436, 10)" leading="" trailing=" " raw_val="slnil" val="slnil" full_name="List.Sublist.slnil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(436, 11)" end="(436, 18)">
                              <AtomNode start="(436, 11)" end="(436, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(436, 14)" end="(436, 18)">
                                <TacticTacticseq1IndentedNode start="(436, 14)" end="(436, 18)">
                                  <NullNode start="(436, 14)" end="(436, 18)">
                                    <OtherNode start="(436, 14)" end="(436, 18)" kind="Lean.Parser.Tactic.simp" state_before="case slnil&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;⊢ (find? p []).isSome = true → (find? p []).isSome = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(436, 14)" end="(436, 18)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(437, 3)" end="(442, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(437, 3)" end="(438, 17)">
                              <OtherNode start="(437, 3)" end="(437, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(437, 3)" end="(437, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(437, 5)" end="(437, 9)">
                                  <NullNode/>
                                  <IdentNode start="(437, 5)" end="(437, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.Sublist.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(437, 10)" end="(437, 16)">
                                  <IdentNode start="(437, 10)" end="(437, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(437, 12)" end="(437, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(437, 14)" end="(437, 16)" leading="" trailing="&#10;  " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                              <OtherNode start="(438, 3)" end="(438, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(438, 3)" end="(438, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(438, 5)" end="(438, 10)">
                                  <NullNode/>
                                  <IdentNode start="(438, 5)" end="(438, 10)" leading="" trailing=" " raw_val="cons₂" val="cons₂" full_name="List.Sublist.cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </GroupNode>
                                <NullNode start="(438, 11)" end="(438, 17)">
                                  <IdentNode start="(438, 11)" end="(438, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(438, 13)" end="(438, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                  <IdentNode start="(438, 15)" end="(438, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(438, 18)" end="(442, 21)">
                              <AtomNode start="(438, 18)" end="(438, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(439, 5)" end="(442, 21)">
                                <TacticTacticseq1IndentedNode start="(439, 5)" end="(442, 21)">
                                  <NullNode start="(439, 5)" end="(442, 21)">
                                    <OtherNode start="(439, 5)" end="(439, 22)" kind="Lean.Parser.Tactic.simp" state_before="case cons₂&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;⊢ (find? p (a :: l₁✝)).isSome = true → (find? p (a :: l₂✝)).isSome = true" state_after="case cons₂&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;⊢ (match p a with&#10;        | true =&amp;gt; some a&#10;        | false =&amp;gt; find? p l₁✝).isSome =&#10;      true →&#10;    (match p a with&#10;        | true =&amp;gt; some a&#10;        | false =&amp;gt; find? p l₂✝).isSome =&#10;      true" tactic="simp only [find?]">
                                      <AtomNode start="(439, 5)" end="(439, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(439, 10)" end="(439, 14)">
                                        <AtomNode start="(439, 10)" end="(439, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(439, 15)" end="(439, 22)">
                                        <AtomNode start="(439, 15)" end="(439, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(439, 16)" end="(439, 21)">
                                          <OtherNode start="(439, 16)" end="(439, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(439, 16)" end="(439, 21)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(439, 21)" end="(439, 22)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(440, 5)" end="(440, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons₂&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;⊢ (match p a with&#10;        | true =&amp;gt; some a&#10;        | false =&amp;gt; find? p l₁✝).isSome =&#10;      true →&#10;    (match p a with&#10;        | true =&amp;gt; some a&#10;        | false =&amp;gt; find? p l₂✝).isSome =&#10;      true" state_after="case cons₂.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = true&#10;⊢ (some a).isSome = true → (some a).isSome = true&#10;&#10;case cons₂.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = false&#10;⊢ (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true" tactic="split">
                                      <AtomNode start="(440, 5)" end="(440, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(441, 5)" end="(441, 11)" kind="Lean.cdot" state_before="case cons₂.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = true&#10;⊢ (some a).isSome = true → (some a).isSome = true&#10;&#10;case cons₂.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = false&#10;⊢ (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true" state_after="case cons₂.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = false&#10;⊢ (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true" tactic="· simp">
                                      <OtherNode start="(441, 5)" end="(441, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(441, 5)" end="(441, 6)" kind="patternIgnore">
                                          <OtherNode start="(441, 5)" end="(441, 6)" kind="token.«· »">
                                            <AtomNode start="(441, 5)" end="(441, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(441, 7)" end="(441, 11)">
                                        <TacticTacticseq1IndentedNode start="(441, 7)" end="(441, 11)">
                                          <NullNode start="(441, 7)" end="(441, 11)">
                                            <OtherNode start="(441, 7)" end="(441, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons₂.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = true&#10;⊢ (some a).isSome = true → (some a).isSome = true" state_after="no goals" tactic="simp">
                                              <AtomNode start="(441, 7)" end="(441, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(442, 5)" end="(442, 21)" kind="Lean.cdot" state_before="case cons₂.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = false&#10;⊢ (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true" state_after="no goals" tactic="· simpa using ih">
                                      <OtherNode start="(442, 5)" end="(442, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(442, 5)" end="(442, 6)" kind="patternIgnore">
                                          <OtherNode start="(442, 5)" end="(442, 6)" kind="token.«· »">
                                            <AtomNode start="(442, 5)" end="(442, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(442, 7)" end="(442, 21)">
                                        <TacticTacticseq1IndentedNode start="(442, 7)" end="(442, 21)">
                                          <NullNode start="(442, 7)" end="(442, 21)">
                                            <OtherNode start="(442, 7)" end="(442, 21)" kind="Lean.Parser.Tactic.simpa" state_before="case cons₂.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ l₁✝ l₂✝ : List α&#10;a : α&#10;h : l₁✝ &amp;lt;+ l₂✝&#10;ih : (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true&#10;x✝ : Bool&#10;heq✝ : p a = false&#10;⊢ (find? p l₁✝).isSome = true → (find? p l₂✝).isSome = true" state_after="no goals" tactic="simpa using ih">
                                              <AtomNode start="(442, 7)" end="(442, 12)" leading="" trailing=" " val="simpa"/>
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(442, 13)" end="(442, 21)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(442, 13)" end="(442, 21)">
                                                  <AtomNode start="(442, 13)" end="(442, 18)" leading="" trailing=" " val="using"/>
                                                  <IdentNode start="(442, 19)" end="(442, 21)" leading="" trailing="&#10;&#10;" raw_val="ih" val="ih"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(444, 1)" end="(446, 43)" name="Sublist.find?_eq_none" full_name="List.Sublist.find?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(444, 1)" end="(446, 43)" name="Sublist.find?_eq_none" full_name="List.Sublist.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(444, 1)" end="(444, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(444, 9)" end="(444, 30)">
          <IdentNode start="(444, 9)" end="(444, 30)" leading="" trailing=" " raw_val="Sublist.find?_eq_none" val="Sublist.find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(444, 31)" end="(444, 102)">
          <NullNode start="(444, 31)" end="(444, 62)">
            <OtherNode start="(444, 31)" end="(444, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(444, 31)" end="(444, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(444, 32)" end="(444, 37)">
                <IdentNode start="(444, 32)" end="(444, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(444, 35)" end="(444, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(444, 38)" end="(444, 46)">
                <AtomNode start="(444, 38)" end="(444, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(444, 40)" end="(444, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(444, 40)" end="(444, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(444, 45)" end="(444, 46)">
                    <IdentNode start="(444, 45)" end="(444, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(444, 46)" end="(444, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(444, 48)" end="(444, 62)">
              <AtomNode start="(444, 48)" end="(444, 49)" leading="" trailing="" val="("/>
              <NullNode start="(444, 49)" end="(444, 50)">
                <IdentNode start="(444, 49)" end="(444, 50)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(444, 51)" end="(444, 61)">
                <AtomNode start="(444, 51)" end="(444, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(444, 53)" end="(444, 61)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(444, 53)" end="(444, 55)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(444, 56)" end="(444, 58)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(444, 59)" end="(444, 61)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(444, 61)" end="(444, 62)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(444, 63)" end="(444, 102)">
            <AtomNode start="(444, 63)" end="(444, 64)" leading="" trailing=" " val=":"/>
            <OtherNode start="(444, 65)" end="(444, 102)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(444, 65)" end="(444, 82)" kind="«term_=_»">
                <OtherNode start="(444, 65)" end="(444, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(444, 65)" end="(444, 73)" leading="" trailing=" " raw_val="l₂.find?" val="l₂.find?"/>
                  <NullNode start="(444, 74)" end="(444, 75)">
                    <IdentNode start="(444, 74)" end="(444, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(444, 76)" end="(444, 77)" leading="" trailing=" " val="="/>
                <IdentNode start="(444, 78)" end="(444, 82)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(444, 83)" end="(444, 84)" leading="" trailing=" " val="→"/>
              <OtherNode start="(444, 85)" end="(444, 102)" kind="«term_=_»">
                <OtherNode start="(444, 85)" end="(444, 95)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(444, 85)" end="(444, 93)" leading="" trailing=" " raw_val="l₁.find?" val="l₁.find?"/>
                  <NullNode start="(444, 94)" end="(444, 95)">
                    <IdentNode start="(444, 94)" end="(444, 95)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(444, 96)" end="(444, 97)" leading="" trailing=" " val="="/>
                <IdentNode start="(444, 98)" end="(444, 102)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(444, 103)" end="(446, 43)">
          <AtomNode start="(444, 103)" end="(444, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(444, 106)" end="(446, 43)">
            <AtomNode start="(444, 106)" end="(444, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(445, 3)" end="(446, 43)">
              <TacticTacticseq1IndentedNode start="(445, 3)" end="(446, 43)">
                <NullNode start="(445, 3)" end="(446, 43)">
                  <OtherNode start="(445, 3)" end="(445, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ find? p l₂ = none → find? p l₁ = none" state_after="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∀ (x : α), x ∈ l₂ → p x = false) → ∀ (x : α), x ∈ l₁ → p x = false" tactic="simp only [List.find?_eq_none, Bool.not_eq_true]">
                    <AtomNode start="(445, 3)" end="(445, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(445, 8)" end="(445, 12)">
                      <AtomNode start="(445, 8)" end="(445, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(445, 13)" end="(445, 51)">
                      <AtomNode start="(445, 13)" end="(445, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(445, 14)" end="(445, 50)">
                        <OtherNode start="(445, 14)" end="(445, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(445, 14)" end="(445, 32)" leading="" trailing="" raw_val="List.find?_eq_none" val="List.find?_eq_none" full_name="List.find?_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(207, 17)" def_end="(207, 30)"/>
                        </OtherNode>
                        <AtomNode start="(445, 32)" end="(445, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(445, 34)" end="(445, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(445, 34)" end="(445, 50)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(445, 50)" end="(445, 51)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(446, 3)" end="(446, 43)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∀ (x : α), x ∈ l₂ → p x = false) → ∀ (x : α), x ∈ l₁ → p x = false" state_after="no goals" tactic="exact fun w x m =&amp;gt; w x (Sublist.mem m h)">
                    <AtomNode start="(446, 3)" end="(446, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(446, 9)" end="(446, 43)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(446, 9)" end="(446, 12)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(446, 13)" end="(446, 43)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(446, 13)" end="(446, 18)">
                          <IdentNode start="(446, 13)" end="(446, 14)" leading="" trailing=" " raw_val="w" val="w"/>
                          <IdentNode start="(446, 15)" end="(446, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(446, 17)" end="(446, 18)" leading="" trailing=" " raw_val="m" val="m"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(446, 19)" end="(446, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(446, 22)" end="(446, 43)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(446, 22)" end="(446, 23)" leading="" trailing=" " raw_val="w" val="w"/>
                          <NullNode start="(446, 24)" end="(446, 43)">
                            <IdentNode start="(446, 24)" end="(446, 25)" leading="" trailing=" " raw_val="x" val="x"/>
                            <OtherNode start="(446, 26)" end="(446, 43)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(446, 26)" end="(446, 27)" leading="" trailing="" val="("/>
                              <OtherNode start="(446, 27)" end="(446, 42)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(446, 27)" end="(446, 38)" leading="" trailing=" " raw_val="Sublist.mem" val="Sublist.mem" full_name="List.Sublist.mem" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                <NullNode start="(446, 39)" end="(446, 42)">
                                  <IdentNode start="(446, 39)" end="(446, 40)" leading="" trailing=" " raw_val="m" val="m"/>
                                  <IdentNode start="(446, 41)" end="(446, 42)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(446, 42)" end="(446, 43)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(448, 1)" end="(452, 34)" name="IsPrefix.find?_eq_some" full_name="List.IsPrefix.find?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(448, 1)" end="(452, 34)" name="IsPrefix.find?_eq_some" full_name="List.IsPrefix.find?_eq_some" _is_private_decl="False">
        <AtomNode start="(448, 1)" end="(448, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(448, 9)" end="(448, 31)">
          <IdentNode start="(448, 9)" end="(448, 31)" leading="" trailing=" " raw_val="IsPrefix.find?_eq_some" val="IsPrefix.find?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(448, 32)" end="(449, 56)">
          <NullNode start="(448, 32)" end="(448, 79)">
            <OtherNode start="(448, 32)" end="(448, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(448, 32)" end="(448, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(448, 33)" end="(448, 38)">
                <IdentNode start="(448, 33)" end="(448, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(448, 36)" end="(448, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(448, 39)" end="(448, 47)">
                <AtomNode start="(448, 39)" end="(448, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 41)" end="(448, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(448, 41)" end="(448, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(448, 46)" end="(448, 47)">
                    <IdentNode start="(448, 46)" end="(448, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(448, 47)" end="(448, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(448, 49)" end="(448, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(448, 49)" end="(448, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(448, 50)" end="(448, 51)">
                <IdentNode start="(448, 50)" end="(448, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(448, 52)" end="(448, 62)">
                <AtomNode start="(448, 52)" end="(448, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 54)" end="(448, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(448, 54)" end="(448, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(448, 56)" end="(448, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(448, 58)" end="(448, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(448, 62)" end="(448, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(448, 64)" end="(448, 79)">
              <AtomNode start="(448, 64)" end="(448, 65)" leading="" trailing="" val="("/>
              <NullNode start="(448, 65)" end="(448, 66)">
                <IdentNode start="(448, 65)" end="(448, 66)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(448, 67)" end="(448, 78)">
                <AtomNode start="(448, 67)" end="(448, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(448, 69)" end="(448, 78)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(448, 69)" end="(448, 71)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(448, 72)" end="(448, 75)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(448, 76)" end="(448, 78)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(448, 78)" end="(448, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(448, 80)" end="(449, 56)">
            <AtomNode start="(448, 80)" end="(448, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(449, 5)" end="(449, 56)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(449, 5)" end="(449, 29)" kind="«term_=_»">
                <OtherNode start="(449, 5)" end="(449, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(449, 5)" end="(449, 15)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(449, 16)" end="(449, 20)">
                    <IdentNode start="(449, 16)" end="(449, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(449, 18)" end="(449, 20)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(449, 21)" end="(449, 22)" leading="" trailing=" " val="="/>
                <OtherNode start="(449, 23)" end="(449, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(449, 23)" end="(449, 27)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(449, 28)" end="(449, 29)">
                    <IdentNode start="(449, 28)" end="(449, 29)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(449, 30)" end="(449, 31)" leading="" trailing=" " val="→"/>
              <OtherNode start="(449, 32)" end="(449, 56)" kind="«term_=_»">
                <OtherNode start="(449, 32)" end="(449, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(449, 32)" end="(449, 42)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(449, 43)" end="(449, 47)">
                    <IdentNode start="(449, 43)" end="(449, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(449, 45)" end="(449, 47)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(449, 48)" end="(449, 49)" leading="" trailing=" " val="="/>
                <OtherNode start="(449, 50)" end="(449, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(449, 50)" end="(449, 54)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(449, 55)" end="(449, 56)">
                    <IdentNode start="(449, 55)" end="(449, 56)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(449, 57)" end="(452, 34)">
          <AtomNode start="(449, 57)" end="(449, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(449, 60)" end="(452, 34)">
            <AtomNode start="(449, 60)" end="(449, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(450, 3)" end="(452, 34)">
              <TacticTacticseq1IndentedNode start="(450, 3)" end="(452, 34)">
                <NullNode start="(450, 3)" end="(452, 34)">
                  <OtherNode start="(450, 3)" end="(450, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;b : α&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ find? p l₁ = some b → find? p l₂ = some b" state_after="α : Type u_1&#10;b : α&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ find? p l₁ = some b → find? p l₂ = some b" tactic="rw [IsPrefix] at h">
                    <AtomNode start="(450, 3)" end="(450, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(450, 6)" end="(450, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(450, 6)" end="(450, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(450, 7)" end="(450, 15)">
                        <OtherNode start="(450, 7)" end="(450, 15)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(450, 7)" end="(450, 15)" leading="" trailing="" raw_val="IsPrefix" val="IsPrefix" full_name="List.IsPrefix" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(450, 15)" end="(450, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(450, 17)" end="(450, 21)">
                      <OtherNode start="(450, 17)" end="(450, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(450, 17)" end="(450, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(450, 20)" end="(450, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(450, 20)" end="(450, 21)">
                            <IdentNode start="(450, 20)" end="(450, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(451, 3)" end="(451, 23)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;b : α&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ find? p l₁ = some b → find? p l₂ = some b" state_after="case intro&#10;α : Type u_1&#10;b : α&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ find? p l₁ = some b → find? p (l₁ ++ t) = some b" tactic="obtain ⟨t, rfl⟩ := h">
                    <AtomNode start="(451, 3)" end="(451, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(451, 10)" end="(451, 18)">
                      <OtherNode start="(451, 10)" end="(451, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(451, 10)" end="(451, 18)">
                          <OtherNode start="(451, 10)" end="(451, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(451, 10)" end="(451, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(451, 11)" end="(451, 17)">
                              <OtherNode start="(451, 11)" end="(451, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(451, 11)" end="(451, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(451, 11)" end="(451, 12)">
                                    <OtherNode start="(451, 11)" end="(451, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(451, 11)" end="(451, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(451, 12)" end="(451, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(451, 14)" end="(451, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(451, 14)" end="(451, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(451, 14)" end="(451, 17)">
                                    <OtherNode start="(451, 14)" end="(451, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(451, 14)" end="(451, 17)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(451, 17)" end="(451, 18)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(451, 19)" end="(451, 23)">
                      <AtomNode start="(451, 19)" end="(451, 21)" leading="" trailing=" " val=":="/>
                      <NullNode start="(451, 22)" end="(451, 23)">
                        <IdentNode start="(451, 22)" end="(451, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(452, 3)" end="(452, 34)" kind="Lean.Parser.Tactic.simp" state_before="case intro&#10;α : Type u_1&#10;b : α&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ find? p l₁ = some b → find? p (l₁ ++ t) = some b" state_after="no goals" tactic="simp +contextual [find?_append]">
                    <AtomNode start="(452, 3)" end="(452, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode start="(452, 8)" end="(452, 19)" kind="Lean.Parser.Tactic.optConfig">
                      <NullNode start="(452, 8)" end="(452, 19)">
                        <OtherNode start="(452, 8)" end="(452, 19)" kind="Lean.Parser.Tactic.configItem">
                          <OtherNode start="(452, 8)" end="(452, 19)" kind="Lean.Parser.Tactic.posConfigItem">
                            <AtomNode start="(452, 8)" end="(452, 9)" leading="" trailing="" val="+"/>
                            <IdentNode start="(452, 9)" end="(452, 19)" leading="" trailing=" " raw_val="contextual" val="contextual"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(452, 20)" end="(452, 34)">
                      <AtomNode start="(452, 20)" end="(452, 21)" leading="" trailing="" val="["/>
                      <NullNode start="(452, 21)" end="(452, 33)">
                        <OtherNode start="(452, 21)" end="(452, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(452, 21)" end="(452, 33)" leading="" trailing="" raw_val="find?_append" val="find?_append" full_name="List.find?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(452, 33)" end="(452, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(454, 1)" end="(456, 26)" name="IsPrefix.find?_eq_none" full_name="List.IsPrefix.find?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(454, 1)" end="(456, 26)" name="IsPrefix.find?_eq_none" full_name="List.IsPrefix.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(454, 1)" end="(454, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(454, 9)" end="(454, 31)">
          <IdentNode start="(454, 9)" end="(454, 31)" leading="" trailing=" " raw_val="IsPrefix.find?_eq_none" val="IsPrefix.find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(454, 32)" end="(455, 52)">
          <NullNode start="(454, 32)" end="(454, 79)">
            <OtherNode start="(454, 32)" end="(454, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(454, 32)" end="(454, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(454, 33)" end="(454, 38)">
                <IdentNode start="(454, 33)" end="(454, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(454, 36)" end="(454, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(454, 39)" end="(454, 47)">
                <AtomNode start="(454, 39)" end="(454, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(454, 41)" end="(454, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(454, 41)" end="(454, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(454, 46)" end="(454, 47)">
                    <IdentNode start="(454, 46)" end="(454, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(454, 47)" end="(454, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(454, 49)" end="(454, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(454, 49)" end="(454, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(454, 50)" end="(454, 51)">
                <IdentNode start="(454, 50)" end="(454, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(454, 52)" end="(454, 62)">
                <AtomNode start="(454, 52)" end="(454, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(454, 54)" end="(454, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(454, 54)" end="(454, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(454, 56)" end="(454, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(454, 58)" end="(454, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(454, 62)" end="(454, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(454, 64)" end="(454, 79)">
              <AtomNode start="(454, 64)" end="(454, 65)" leading="" trailing="" val="("/>
              <NullNode start="(454, 65)" end="(454, 66)">
                <IdentNode start="(454, 65)" end="(454, 66)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(454, 67)" end="(454, 78)">
                <AtomNode start="(454, 67)" end="(454, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(454, 69)" end="(454, 78)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(454, 69)" end="(454, 71)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(454, 72)" end="(454, 75)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(454, 76)" end="(454, 78)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(454, 78)" end="(454, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(454, 80)" end="(455, 52)">
            <AtomNode start="(454, 80)" end="(454, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(455, 5)" end="(455, 52)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(455, 5)" end="(455, 27)" kind="«term_=_»">
                <OtherNode start="(455, 5)" end="(455, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(455, 5)" end="(455, 15)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(455, 16)" end="(455, 20)">
                    <IdentNode start="(455, 16)" end="(455, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(455, 18)" end="(455, 20)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(455, 21)" end="(455, 22)" leading="" trailing=" " val="="/>
                <IdentNode start="(455, 23)" end="(455, 27)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(455, 28)" end="(455, 29)" leading="" trailing=" " val="→"/>
              <OtherNode start="(455, 30)" end="(455, 52)" kind="«term_=_»">
                <OtherNode start="(455, 30)" end="(455, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(455, 30)" end="(455, 40)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(455, 41)" end="(455, 45)">
                    <IdentNode start="(455, 41)" end="(455, 42)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(455, 43)" end="(455, 45)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(455, 46)" end="(455, 47)" leading="" trailing=" " val="="/>
                <IdentNode start="(455, 48)" end="(455, 52)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(455, 53)" end="(456, 26)">
          <AtomNode start="(455, 53)" end="(455, 55)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(456, 3)" end="(456, 26)" leading="" trailing="&#10;" raw_val="h.sublist.find?_eq_none" val="h.sublist.find?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(457, 1)" end="(459, 26)" name="IsSuffix.find?_eq_none" full_name="List.IsSuffix.find?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(457, 1)" end="(459, 26)" name="IsSuffix.find?_eq_none" full_name="List.IsSuffix.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(457, 1)" end="(457, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(457, 9)" end="(457, 31)">
          <IdentNode start="(457, 9)" end="(457, 31)" leading="" trailing=" " raw_val="IsSuffix.find?_eq_none" val="IsSuffix.find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(457, 32)" end="(458, 52)">
          <NullNode start="(457, 32)" end="(457, 79)">
            <OtherNode start="(457, 32)" end="(457, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(457, 32)" end="(457, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(457, 33)" end="(457, 38)">
                <IdentNode start="(457, 33)" end="(457, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(457, 36)" end="(457, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(457, 39)" end="(457, 47)">
                <AtomNode start="(457, 39)" end="(457, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(457, 41)" end="(457, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(457, 41)" end="(457, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(457, 46)" end="(457, 47)">
                    <IdentNode start="(457, 46)" end="(457, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(457, 47)" end="(457, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(457, 49)" end="(457, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(457, 49)" end="(457, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(457, 50)" end="(457, 51)">
                <IdentNode start="(457, 50)" end="(457, 51)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(457, 52)" end="(457, 62)">
                <AtomNode start="(457, 52)" end="(457, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(457, 54)" end="(457, 62)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(457, 54)" end="(457, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(457, 56)" end="(457, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(457, 58)" end="(457, 62)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(457, 62)" end="(457, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(457, 64)" end="(457, 79)">
              <AtomNode start="(457, 64)" end="(457, 65)" leading="" trailing="" val="("/>
              <NullNode start="(457, 65)" end="(457, 66)">
                <IdentNode start="(457, 65)" end="(457, 66)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(457, 67)" end="(457, 78)">
                <AtomNode start="(457, 67)" end="(457, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(457, 69)" end="(457, 78)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(457, 69)" end="(457, 71)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(457, 72)" end="(457, 75)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(457, 76)" end="(457, 78)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(457, 78)" end="(457, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(457, 80)" end="(458, 52)">
            <AtomNode start="(457, 80)" end="(457, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(458, 5)" end="(458, 52)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(458, 5)" end="(458, 27)" kind="«term_=_»">
                <OtherNode start="(458, 5)" end="(458, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(458, 5)" end="(458, 15)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(458, 16)" end="(458, 20)">
                    <IdentNode start="(458, 16)" end="(458, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(458, 18)" end="(458, 20)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(458, 21)" end="(458, 22)" leading="" trailing=" " val="="/>
                <IdentNode start="(458, 23)" end="(458, 27)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(458, 28)" end="(458, 29)" leading="" trailing=" " val="→"/>
              <OtherNode start="(458, 30)" end="(458, 52)" kind="«term_=_»">
                <OtherNode start="(458, 30)" end="(458, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(458, 30)" end="(458, 40)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(458, 41)" end="(458, 45)">
                    <IdentNode start="(458, 41)" end="(458, 42)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(458, 43)" end="(458, 45)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(458, 46)" end="(458, 47)" leading="" trailing=" " val="="/>
                <IdentNode start="(458, 48)" end="(458, 52)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(458, 53)" end="(459, 26)">
          <AtomNode start="(458, 53)" end="(458, 55)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(459, 3)" end="(459, 26)" leading="" trailing="&#10;" raw_val="h.sublist.find?_eq_none" val="h.sublist.find?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(460, 1)" end="(462, 26)" name="IsInfix.find?_eq_none" full_name="List.IsInfix.find?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(460, 1)" end="(462, 26)" name="IsInfix.find?_eq_none" full_name="List.IsInfix.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(460, 1)" end="(460, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(460, 9)" end="(460, 30)">
          <IdentNode start="(460, 9)" end="(460, 30)" leading="" trailing=" " raw_val="IsInfix.find?_eq_none" val="IsInfix.find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(460, 31)" end="(461, 52)">
          <NullNode start="(460, 31)" end="(460, 79)">
            <OtherNode start="(460, 31)" end="(460, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(460, 31)" end="(460, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(460, 32)" end="(460, 37)">
                <IdentNode start="(460, 32)" end="(460, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(460, 35)" end="(460, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(460, 38)" end="(460, 46)">
                <AtomNode start="(460, 38)" end="(460, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(460, 40)" end="(460, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(460, 40)" end="(460, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(460, 45)" end="(460, 46)">
                    <IdentNode start="(460, 45)" end="(460, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(460, 46)" end="(460, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(460, 48)" end="(460, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(460, 48)" end="(460, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(460, 49)" end="(460, 50)">
                <IdentNode start="(460, 49)" end="(460, 50)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(460, 51)" end="(460, 61)">
                <AtomNode start="(460, 51)" end="(460, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(460, 53)" end="(460, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(460, 53)" end="(460, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(460, 55)" end="(460, 56)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(460, 57)" end="(460, 61)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(460, 61)" end="(460, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(460, 63)" end="(460, 79)">
              <AtomNode start="(460, 63)" end="(460, 64)" leading="" trailing="" val="("/>
              <NullNode start="(460, 64)" end="(460, 65)">
                <IdentNode start="(460, 64)" end="(460, 65)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(460, 66)" end="(460, 78)">
                <AtomNode start="(460, 66)" end="(460, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(460, 68)" end="(460, 78)" kind="List.«term_&amp;lt;:+:_»">
                  <IdentNode start="(460, 68)" end="(460, 70)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(460, 71)" end="(460, 75)" leading="" trailing=" " val="&amp;lt;:+:"/>
                  <IdentNode start="(460, 76)" end="(460, 78)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(460, 78)" end="(460, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(460, 80)" end="(461, 52)">
            <AtomNode start="(460, 80)" end="(460, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(461, 5)" end="(461, 52)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(461, 5)" end="(461, 27)" kind="«term_=_»">
                <OtherNode start="(461, 5)" end="(461, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(461, 5)" end="(461, 15)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(461, 16)" end="(461, 20)">
                    <IdentNode start="(461, 16)" end="(461, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(461, 18)" end="(461, 20)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(461, 21)" end="(461, 22)" leading="" trailing=" " val="="/>
                <IdentNode start="(461, 23)" end="(461, 27)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(461, 28)" end="(461, 29)" leading="" trailing=" " val="→"/>
              <OtherNode start="(461, 30)" end="(461, 52)" kind="«term_=_»">
                <OtherNode start="(461, 30)" end="(461, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(461, 30)" end="(461, 40)" leading="" trailing=" " raw_val="List.find?" val="List.find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(461, 41)" end="(461, 45)">
                    <IdentNode start="(461, 41)" end="(461, 42)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(461, 43)" end="(461, 45)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(461, 46)" end="(461, 47)" leading="" trailing=" " val="="/>
                <IdentNode start="(461, 48)" end="(461, 52)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(461, 53)" end="(462, 26)">
          <AtomNode start="(461, 53)" end="(461, 55)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(462, 3)" end="(462, 26)" leading="" trailing="&#10;&#10;" raw_val="h.sublist.find?_eq_none" val="h.sublist.find?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(464, 1)" end="(468, 6)" name="find?_pmap" full_name="List.find?_pmap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(464, 1)" end="(468, 6)" name="find?_pmap" full_name="List.find?_pmap" _is_private_decl="False">
        <AtomNode start="(464, 1)" end="(464, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(464, 9)" end="(464, 19)">
          <IdentNode start="(464, 9)" end="(464, 19)" leading="" trailing=" " raw_val="find?_pmap" val="find?_pmap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(464, 20)" end="(466, 108)">
          <NullNode start="(464, 20)" end="(465, 49)">
            <OtherNode start="(464, 20)" end="(464, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 20)" end="(464, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 21)" end="(464, 22)">
                <IdentNode start="(464, 21)" end="(464, 22)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(464, 23)" end="(464, 33)">
                <AtomNode start="(464, 23)" end="(464, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 25)" end="(464, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(464, 25)" end="(464, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(464, 27)" end="(464, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(464, 29)" end="(464, 33)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(464, 29)" end="(464, 33)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 33)" end="(464, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(464, 35)" end="(464, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 35)" end="(464, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 36)" end="(464, 37)">
                <IdentNode start="(464, 36)" end="(464, 37)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(464, 38)" end="(464, 57)">
                <AtomNode start="(464, 38)" end="(464, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 40)" end="(464, 57)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(464, 40)" end="(464, 47)">
                    <AtomNode start="(464, 40)" end="(464, 41)" leading="" trailing="" val="("/>
                    <NullNode start="(464, 41)" end="(464, 42)">
                      <IdentNode start="(464, 41)" end="(464, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(464, 43)" end="(464, 46)">
                      <AtomNode start="(464, 43)" end="(464, 44)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(464, 45)" end="(464, 46)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(464, 46)" end="(464, 47)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(464, 48)" end="(464, 49)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(464, 50)" end="(464, 57)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(464, 50)" end="(464, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(464, 50)" end="(464, 51)" leading="" trailing=" " raw_val="P" val="P"/>
                      <NullNode start="(464, 52)" end="(464, 53)">
                        <IdentNode start="(464, 52)" end="(464, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(464, 54)" end="(464, 55)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(464, 56)" end="(464, 57)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 57)" end="(464, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(464, 59)" end="(464, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 59)" end="(464, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 60)" end="(464, 62)">
                <IdentNode start="(464, 60)" end="(464, 62)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(464, 63)" end="(464, 71)">
                <AtomNode start="(464, 63)" end="(464, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 65)" end="(464, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(464, 65)" end="(464, 69)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(464, 70)" end="(464, 71)">
                    <IdentNode start="(464, 70)" end="(464, 71)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 71)" end="(464, 72)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(465, 5)" end="(465, 34)">
              <AtomNode start="(465, 5)" end="(465, 6)" leading="" trailing="" val="("/>
              <NullNode start="(465, 6)" end="(465, 7)">
                <IdentNode start="(465, 6)" end="(465, 7)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(465, 8)" end="(465, 33)">
                <AtomNode start="(465, 8)" end="(465, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(465, 10)" end="(465, 33)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(465, 10)" end="(465, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(465, 12)" end="(465, 19)">
                    <TermExplicitbinderNode start="(465, 12)" end="(465, 19)">
                      <AtomNode start="(465, 12)" end="(465, 13)" leading="" trailing="" val="("/>
                      <NullNode start="(465, 13)" end="(465, 14)">
                        <IdentNode start="(465, 13)" end="(465, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                      <NullNode start="(465, 15)" end="(465, 18)">
                        <AtomNode start="(465, 15)" end="(465, 16)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(465, 17)" end="(465, 18)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(465, 18)" end="(465, 19)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(465, 19)" end="(465, 20)" leading="" trailing=" " val=","/>
                  <OtherNode start="(465, 21)" end="(465, 33)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(465, 21)" end="(465, 27)" kind="«term_∈_»">
                      <IdentNode start="(465, 21)" end="(465, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(465, 23)" end="(465, 24)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(465, 25)" end="(465, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(465, 28)" end="(465, 29)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(465, 30)" end="(465, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(465, 30)" end="(465, 31)" leading="" trailing=" " raw_val="P" val="P"/>
                      <NullNode start="(465, 32)" end="(465, 33)">
                        <IdentNode start="(465, 32)" end="(465, 33)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(465, 33)" end="(465, 34)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(465, 35)" end="(465, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(465, 35)" end="(465, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(465, 36)" end="(465, 37)">
                <IdentNode start="(465, 36)" end="(465, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(465, 38)" end="(465, 48)">
                <AtomNode start="(465, 38)" end="(465, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(465, 40)" end="(465, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(465, 40)" end="(465, 41)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(465, 42)" end="(465, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(465, 44)" end="(465, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(465, 48)" end="(465, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(465, 50)" end="(466, 108)">
            <AtomNode start="(465, 50)" end="(465, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(466, 5)" end="(466, 108)" kind="«term_=_»">
              <OtherNode start="(466, 5)" end="(466, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(466, 5)" end="(466, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(466, 5)" end="(466, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(466, 5)" end="(466, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(466, 6)" end="(466, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(466, 6)" end="(466, 13)" leading="" trailing=" " raw_val="xs.pmap" val="xs.pmap"/>
                      <NullNode start="(466, 14)" end="(466, 17)">
                        <IdentNode start="(466, 14)" end="(466, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(466, 16)" end="(466, 17)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(466, 17)" end="(466, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(466, 18)" end="(466, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(466, 19)" end="(466, 24)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(466, 25)" end="(466, 26)">
                  <IdentNode start="(466, 25)" end="(466, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(466, 27)" end="(466, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(466, 29)" end="(466, 108)" kind="Lean.Parser.Term.app">
                <OtherNode start="(466, 29)" end="(466, 82)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(466, 29)" end="(466, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(466, 29)" end="(466, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(466, 30)" end="(466, 77)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(466, 30)" end="(466, 45)" leading="" trailing=" " raw_val="xs.attach.find?" val="xs.attach.find?"/>
                      <NullNode start="(466, 46)" end="(466, 77)">
                        <OtherNode start="(466, 46)" end="(466, 77)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(466, 46)" end="(466, 47)" leading="" trailing="" val="("/>
                          <OtherNode start="(466, 47)" end="(466, 76)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(466, 47)" end="(466, 50)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(466, 51)" end="(466, 76)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(466, 51)" end="(466, 57)">
                                <OtherNode start="(466, 51)" end="(466, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(466, 51)" end="(466, 52)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(466, 52)" end="(466, 56)">
                                    <IdentNode start="(466, 52)" end="(466, 53)" leading="" trailing="" raw_val="a" val="a"/>
                                    <AtomNode start="(466, 53)" end="(466, 54)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(466, 55)" end="(466, 56)" leading="" trailing="" raw_val="m" val="m"/>
                                  </NullNode>
                                  <AtomNode start="(466, 56)" end="(466, 57)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(466, 58)" end="(466, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(466, 61)" end="(466, 76)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(466, 61)" end="(466, 62)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(466, 63)" end="(466, 76)">
                                  <OtherNode start="(466, 63)" end="(466, 76)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(466, 63)" end="(466, 64)" leading="" trailing="" val="("/>
                                    <OtherNode start="(466, 64)" end="(466, 75)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(466, 64)" end="(466, 65)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(466, 66)" end="(466, 75)">
                                        <IdentNode start="(466, 66)" end="(466, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <OtherNode start="(466, 68)" end="(466, 75)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(466, 68)" end="(466, 69)" leading="" trailing="" val="("/>
                                          <OtherNode start="(466, 69)" end="(466, 74)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(466, 69)" end="(466, 70)" leading="" trailing=" " raw_val="H" val="H"/>
                                            <NullNode start="(466, 71)" end="(466, 74)">
                                              <IdentNode start="(466, 71)" end="(466, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(466, 73)" end="(466, 74)" leading="" trailing="" raw_val="m" val="m"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(466, 74)" end="(466, 75)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(466, 75)" end="(466, 76)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(466, 76)" end="(466, 77)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(466, 77)" end="(466, 78)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(466, 78)" end="(466, 79)" leading="" trailing="" val="."/>
                  <IdentNode start="(466, 79)" end="(466, 82)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(466, 83)" end="(466, 108)">
                  <OtherNode start="(466, 83)" end="(466, 108)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(466, 83)" end="(466, 86)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(466, 87)" end="(466, 108)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(466, 87)" end="(466, 93)">
                        <OtherNode start="(466, 87)" end="(466, 93)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(466, 87)" end="(466, 88)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(466, 88)" end="(466, 92)">
                            <IdentNode start="(466, 88)" end="(466, 89)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(466, 89)" end="(466, 90)" leading="" trailing=" " val=","/>
                            <IdentNode start="(466, 91)" end="(466, 92)" leading="" trailing="" raw_val="m" val="m"/>
                          </NullNode>
                          <AtomNode start="(466, 92)" end="(466, 93)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(466, 94)" end="(466, 96)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(466, 97)" end="(466, 108)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(466, 97)" end="(466, 98)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(466, 99)" end="(466, 108)">
                          <IdentNode start="(466, 99)" end="(466, 100)" leading="" trailing=" " raw_val="a" val="a"/>
                          <OtherNode start="(466, 101)" end="(466, 108)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(466, 101)" end="(466, 102)" leading="" trailing="" val="("/>
                            <OtherNode start="(466, 102)" end="(466, 107)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(466, 102)" end="(466, 103)" leading="" trailing=" " raw_val="H" val="H"/>
                              <NullNode start="(466, 104)" end="(466, 107)">
                                <IdentNode start="(466, 104)" end="(466, 105)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(466, 106)" end="(466, 107)" leading="" trailing="" raw_val="m" val="m"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(466, 107)" end="(466, 108)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(466, 109)" end="(468, 6)">
          <AtomNode start="(466, 109)" end="(466, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(466, 112)" end="(468, 6)">
            <AtomNode start="(466, 112)" end="(466, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(467, 3)" end="(468, 6)">
              <TacticTacticseq1IndentedNode start="(467, 3)" end="(468, 6)">
                <NullNode start="(467, 3)" end="(468, 6)">
                  <OtherNode start="(467, 3)" end="(467, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ find? p (pmap f xs H) =&#10;    Option.map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m⟩ =&amp;gt; f a ⋯)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m⟩ =&amp;gt; p (f a ⋯))&#10;        xs.attach)" state_after="α : Type u_1&#10;β : Type u_2&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ Option.map (fun x =&amp;gt; f x.val ⋯) (find? (p ∘ fun x =&amp;gt; f x.val ⋯) xs.attach) =&#10;    Option.map (fun x =&amp;gt; f x.val ⋯) (find? (fun x =&amp;gt; p (f x.val ⋯)) xs.attach)" tactic="simp only [pmap_eq_map_attach, find?_map]">
                    <AtomNode start="(467, 3)" end="(467, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(467, 8)" end="(467, 12)">
                      <AtomNode start="(467, 8)" end="(467, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(467, 13)" end="(467, 44)">
                      <AtomNode start="(467, 13)" end="(467, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(467, 14)" end="(467, 43)">
                        <OtherNode start="(467, 14)" end="(467, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(467, 14)" end="(467, 32)" leading="" trailing="" raw_val="pmap_eq_map_attach" val="pmap_eq_map_attach" full_name="List.pmap_eq_map_attach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                        </OtherNode>
                        <AtomNode start="(467, 32)" end="(467, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(467, 34)" end="(467, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(467, 34)" end="(467, 43)" leading="" trailing="" raw_val="find?_map" val="find?_map" full_name="List.find?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(320, 17)" def_end="(320, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(467, 43)" end="(467, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(468, 3)" end="(468, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;β : Type u_2&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : List α&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ Option.map (fun x =&amp;gt; f x.val ⋯) (find? (p ∘ fun x =&amp;gt; f x.val ⋯) xs.attach) =&#10;    Option.map (fun x =&amp;gt; f x.val ⋯) (find? (fun x =&amp;gt; p (f x.val ⋯)) xs.attach)" state_after="no goals" tactic="rfl">
                    <AtomNode start="(468, 3)" end="(468, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(470, 1)" end="(470, 41)" comment="### findIdx? (preliminary lemmas) -/">
      <AtomNode start="(470, 1)" end="(470, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(470, 5)" end="(470, 41)" leading="" trailing="&#10;&#10;" val="### findIdx? (preliminary lemmas) -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(472, 1)" end="(473, 37)" name="findIdx?_go_nil" full_name="List.findIdx?_go_nil">
      <CommandDeclmodifiersNode start="(472, 1)" end="(472, 22)">
        <NullNode/>
        <NullNode start="(472, 1)" end="(472, 14)">
          <OtherNode start="(472, 1)" end="(472, 14)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(472, 1)" end="(472, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(472, 3)" end="(472, 13)">
              <OtherNode start="(472, 3)" end="(472, 13)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode start="(472, 3)" end="(472, 8)">
                  <NullNode start="(472, 3)" end="(472, 8)">
                    <OtherNode start="(472, 3)" end="(472, 8)" kind="Lean.Parser.Term.local">
                      <AtomNode start="(472, 3)" end="(472, 8)" leading="" trailing=" " val="local"/>
                    </OtherNode>
                  </NullNode>
                </TermAttrkindNode>
                <OtherNode start="(472, 9)" end="(472, 13)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(472, 9)" end="(472, 13)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(472, 13)" end="(472, 14)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode start="(472, 15)" end="(472, 22)">
          <CommandPrivateNode start="(472, 15)" end="(472, 22)">
            <AtomNode start="(472, 15)" end="(472, 22)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(472, 23)" end="(473, 37)" name="findIdx?_go_nil" full_name="List.findIdx?_go_nil" _is_private_decl="True">
        <AtomNode start="(472, 23)" end="(472, 30)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(472, 31)" end="(472, 46)">
          <IdentNode start="(472, 31)" end="(472, 46)" leading="" trailing=" " raw_val="findIdx?_go_nil" val="findIdx?_go_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(472, 47)" end="(473, 30)">
          <NullNode start="(472, 47)" end="(472, 71)">
            <OtherNode start="(472, 47)" end="(472, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(472, 47)" end="(472, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(472, 48)" end="(472, 49)">
                <IdentNode start="(472, 48)" end="(472, 49)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(472, 50)" end="(472, 60)">
                <AtomNode start="(472, 50)" end="(472, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(472, 52)" end="(472, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(472, 52)" end="(472, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(472, 54)" end="(472, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(472, 56)" end="(472, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(472, 60)" end="(472, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(472, 62)" end="(472, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(472, 62)" end="(472, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(472, 63)" end="(472, 64)">
                <IdentNode start="(472, 63)" end="(472, 64)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(472, 65)" end="(472, 70)">
                <AtomNode start="(472, 65)" end="(472, 66)" leading="" trailing=" " val=":"/>
                <IdentNode start="(472, 67)" end="(472, 70)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(472, 70)" end="(472, 71)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(472, 72)" end="(473, 30)">
            <AtomNode start="(472, 72)" end="(472, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(473, 5)" end="(473, 30)" kind="«term_=_»">
              <OtherNode start="(473, 5)" end="(473, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(473, 5)" end="(473, 16)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(473, 17)" end="(473, 23)">
                  <IdentNode start="(473, 17)" end="(473, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(473, 19)" end="(473, 21)" kind="«term[_]»">
                    <AtomNode start="(473, 19)" end="(473, 20)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(473, 20)" end="(473, 21)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <IdentNode start="(473, 22)" end="(473, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(473, 24)" end="(473, 25)" leading="" trailing=" " val="="/>
              <IdentNode start="(473, 26)" end="(473, 30)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(473, 31)" end="(473, 37)">
          <AtomNode start="(473, 31)" end="(473, 33)" leading="" trailing=" " val=":="/>
          <IdentNode start="(473, 34)" end="(473, 37)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(475, 1)" end="(476, 88)" name="findIdx?_go_cons" full_name="List.findIdx?_go_cons">
      <CommandDeclmodifiersNode start="(475, 1)" end="(475, 22)">
        <NullNode/>
        <NullNode start="(475, 1)" end="(475, 14)">
          <OtherNode start="(475, 1)" end="(475, 14)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(475, 1)" end="(475, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(475, 3)" end="(475, 13)">
              <OtherNode start="(475, 3)" end="(475, 13)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode start="(475, 3)" end="(475, 8)">
                  <NullNode start="(475, 3)" end="(475, 8)">
                    <OtherNode start="(475, 3)" end="(475, 8)" kind="Lean.Parser.Term.local">
                      <AtomNode start="(475, 3)" end="(475, 8)" leading="" trailing=" " val="local"/>
                    </OtherNode>
                  </NullNode>
                </TermAttrkindNode>
                <OtherNode start="(475, 9)" end="(475, 13)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(475, 9)" end="(475, 13)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(475, 13)" end="(475, 14)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode start="(475, 15)" end="(475, 22)">
          <CommandPrivateNode start="(475, 15)" end="(475, 22)">
            <AtomNode start="(475, 15)" end="(475, 22)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(475, 23)" end="(476, 88)" name="findIdx?_go_cons" full_name="List.findIdx?_go_cons" _is_private_decl="True">
        <AtomNode start="(475, 23)" end="(475, 30)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(475, 31)" end="(475, 47)">
          <IdentNode start="(475, 31)" end="(475, 47)" leading="" trailing=" " raw_val="findIdx?_go_cons" val="findIdx?_go_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(475, 48)" end="(476, 81)">
          <NullNode/>
          <TermTypespecNode start="(475, 48)" end="(476, 81)">
            <AtomNode start="(475, 48)" end="(475, 49)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(476, 5)" end="(476, 81)" kind="«term_=_»">
              <OtherNode start="(476, 5)" end="(476, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(476, 5)" end="(476, 16)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(476, 17)" end="(476, 30)">
                  <IdentNode start="(476, 17)" end="(476, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(476, 19)" end="(476, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(476, 19)" end="(476, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(476, 20)" end="(476, 27)" kind="«term_::_»">
                      <IdentNode start="(476, 20)" end="(476, 21)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(476, 22)" end="(476, 24)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(476, 25)" end="(476, 27)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(476, 27)" end="(476, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(476, 29)" end="(476, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(476, 31)" end="(476, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(476, 33)" end="(476, 81)" kind="termIfThenElse">
                <AtomNode start="(476, 33)" end="(476, 35)" leading="" trailing=" " val="if"/>
                <OtherNode start="(476, 36)" end="(476, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(476, 36)" end="(476, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(476, 38)" end="(476, 39)">
                    <IdentNode start="(476, 38)" end="(476, 39)" leading="" trailing=" " raw_val="x" val="x"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(476, 40)" end="(476, 44)" leading="" trailing=" " val="then"/>
                <OtherNode start="(476, 45)" end="(476, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(476, 45)" end="(476, 49)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(476, 50)" end="(476, 51)">
                    <IdentNode start="(476, 50)" end="(476, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(476, 52)" end="(476, 56)" leading="" trailing=" " val="else"/>
                <OtherNode start="(476, 57)" end="(476, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(476, 57)" end="(476, 68)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(476, 69)" end="(476, 81)">
                    <IdentNode start="(476, 69)" end="(476, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(476, 71)" end="(476, 73)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <OtherNode start="(476, 74)" end="(476, 81)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(476, 74)" end="(476, 75)" leading="" trailing="" val="("/>
                      <OtherNode start="(476, 75)" end="(476, 80)" kind="«term_+_»">
                        <IdentNode start="(476, 75)" end="(476, 76)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(476, 77)" end="(476, 78)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(476, 79)" end="(476, 80)" kind="num">
                          <AtomNode start="(476, 79)" end="(476, 80)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(476, 80)" end="(476, 81)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(476, 82)" end="(476, 88)">
          <AtomNode start="(476, 82)" end="(476, 84)" leading="" trailing=" " val=":="/>
          <IdentNode start="(476, 85)" end="(476, 88)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(478, 1)" end="(481, 37)" name="findIdx?_go_succ" full_name="List.findIdx?_go_succ">
      <CommandDeclmodifiersNode start="(478, 1)" end="(478, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(478, 1)" end="(478, 8)">
          <CommandPrivateNode start="(478, 1)" end="(478, 8)">
            <AtomNode start="(478, 1)" end="(478, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(478, 9)" end="(481, 37)" name="findIdx?_go_succ" full_name="List.findIdx?_go_succ" _is_private_decl="True">
        <AtomNode start="(478, 9)" end="(478, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(478, 17)" end="(478, 33)">
          <IdentNode start="(478, 17)" end="(478, 33)" leading="" trailing=" " raw_val="findIdx?_go_succ" val="findIdx?_go_succ"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(478, 34)" end="(479, 69)">
          <NullNode start="(478, 34)" end="(478, 72)">
            <OtherNode start="(478, 34)" end="(478, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(478, 34)" end="(478, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(478, 35)" end="(478, 36)">
                <IdentNode start="(478, 35)" end="(478, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(478, 37)" end="(478, 47)">
                <AtomNode start="(478, 37)" end="(478, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(478, 39)" end="(478, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(478, 39)" end="(478, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(478, 41)" end="(478, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(478, 43)" end="(478, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(478, 47)" end="(478, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(478, 49)" end="(478, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(478, 49)" end="(478, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(478, 50)" end="(478, 52)">
                <IdentNode start="(478, 50)" end="(478, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(478, 53)" end="(478, 61)">
                <AtomNode start="(478, 53)" end="(478, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(478, 55)" end="(478, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(478, 55)" end="(478, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(478, 60)" end="(478, 61)">
                    <IdentNode start="(478, 60)" end="(478, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(478, 61)" end="(478, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(478, 63)" end="(478, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(478, 63)" end="(478, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(478, 64)" end="(478, 65)">
                <IdentNode start="(478, 64)" end="(478, 65)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(478, 66)" end="(478, 71)">
                <AtomNode start="(478, 66)" end="(478, 67)" leading="" trailing=" " val=":"/>
                <IdentNode start="(478, 68)" end="(478, 71)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(478, 71)" end="(478, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(478, 73)" end="(479, 69)">
            <AtomNode start="(478, 73)" end="(478, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(479, 5)" end="(479, 69)" kind="«term_=_»">
              <OtherNode start="(479, 5)" end="(479, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(479, 5)" end="(479, 16)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(479, 17)" end="(479, 27)">
                  <IdentNode start="(479, 17)" end="(479, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(479, 19)" end="(479, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <OtherNode start="(479, 22)" end="(479, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(479, 22)" end="(479, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(479, 23)" end="(479, 26)" kind="«term_+_»">
                      <IdentNode start="(479, 23)" end="(479, 24)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(479, 24)" end="(479, 25)" leading="" trailing="" val="+"/>
                      <OtherNode start="(479, 25)" end="(479, 26)" kind="num">
                        <AtomNode start="(479, 25)" end="(479, 26)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(479, 26)" end="(479, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(479, 28)" end="(479, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(479, 30)" end="(479, 69)" kind="Lean.Parser.Term.app">
                <OtherNode start="(479, 30)" end="(479, 54)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(479, 30)" end="(479, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(479, 30)" end="(479, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(479, 31)" end="(479, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(479, 31)" end="(479, 42)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(479, 43)" end="(479, 49)">
                        <IdentNode start="(479, 43)" end="(479, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(479, 45)" end="(479, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <IdentNode start="(479, 48)" end="(479, 49)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(479, 49)" end="(479, 50)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(479, 50)" end="(479, 51)" leading="" trailing="" val="."/>
                  <IdentNode start="(479, 51)" end="(479, 54)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(479, 55)" end="(479, 69)">
                  <OtherNode start="(479, 55)" end="(479, 69)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(479, 55)" end="(479, 58)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(479, 59)" end="(479, 69)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(479, 59)" end="(479, 60)">
                        <IdentNode start="(479, 59)" end="(479, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(479, 61)" end="(479, 63)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(479, 64)" end="(479, 69)" kind="«term_+_»">
                        <IdentNode start="(479, 64)" end="(479, 65)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(479, 66)" end="(479, 67)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(479, 68)" end="(479, 69)" kind="num">
                          <AtomNode start="(479, 68)" end="(479, 69)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(479, 70)" end="(481, 37)">
          <AtomNode start="(479, 70)" end="(479, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(479, 73)" end="(481, 37)">
            <AtomNode start="(479, 73)" end="(479, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(480, 3)" end="(481, 37)">
              <TacticTacticseq1IndentedNode start="(480, 3)" end="(481, 37)">
                <NullNode start="(480, 3)" end="(481, 37)">
                  <OtherNode start="(480, 3)" end="(481, 37)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;⊢ findIdx?.go p xs (i + 1) = Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p xs i)" state_after="no goals" tactic="induction xs generalizing i with simp&#10;| cons _ _ _ =&amp;gt; split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(480, 3)" end="(480, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(480, 13)" end="(480, 15)">
                      <OtherNode start="(480, 13)" end="(480, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(480, 13)" end="(480, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(480, 16)" end="(480, 30)">
                      <AtomNode start="(480, 16)" end="(480, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(480, 29)" end="(480, 30)">
                        <IdentNode start="(480, 29)" end="(480, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(480, 31)" end="(481, 37)">
                      <OtherNode start="(480, 31)" end="(481, 37)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(480, 31)" end="(480, 35)" leading="" trailing=" " val="with"/>
                        <NullNode start="(480, 36)" end="(480, 40)">
                          <OtherNode start="(480, 36)" end="(480, 40)" kind="Lean.Parser.Tactic.simp">
                            <AtomNode start="(480, 36)" end="(480, 40)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(481, 3)" end="(481, 37)">
                          <OtherNode start="(481, 3)" end="(481, 37)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(481, 3)" end="(481, 15)">
                              <OtherNode start="(481, 3)" end="(481, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(481, 3)" end="(481, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(481, 5)" end="(481, 9)">
                                  <NullNode/>
                                  <IdentNode start="(481, 5)" end="(481, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(481, 10)" end="(481, 15)">
                                  <TermHoleNode start="(481, 10)" end="(481, 11)">
                                    <AtomNode start="(481, 10)" end="(481, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(481, 12)" end="(481, 13)">
                                    <AtomNode start="(481, 12)" end="(481, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(481, 14)" end="(481, 15)">
                                    <AtomNode start="(481, 14)" end="(481, 15)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(481, 16)" end="(481, 37)">
                              <AtomNode start="(481, 16)" end="(481, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(481, 19)" end="(481, 37)">
                                <TacticTacticseq1IndentedNode start="(481, 19)" end="(481, 37)">
                                  <NullNode start="(481, 19)" end="(481, 37)">
                                    <OtherNode start="(481, 19)" end="(481, 37)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)&#10;i : Nat&#10;⊢ (if p head✝ = true then some (i + 1) else findIdx?.go p tail✝ (i + 1 + 1)) =&#10;    Option.map (fun i =&amp;gt; i + 1) (if p head✝ = true then some i else findIdx?.go p tail✝ (i + 1))" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(481, 19)" end="(481, 24)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(481, 19)" end="(481, 24)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(481, 25)" end="(481, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(481, 29)" end="(481, 37)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(481, 29)" end="(481, 37)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(483, 1)" end="(494, 69)" name="findIdx?_go_eq" full_name="List.findIdx?_go_eq">
      <CommandDeclmodifiersNode start="(483, 1)" end="(483, 8)">
        <NullNode/>
        <NullNode/>
        <NullNode start="(483, 1)" end="(483, 8)">
          <CommandPrivateNode start="(483, 1)" end="(483, 8)">
            <AtomNode start="(483, 1)" end="(483, 8)" leading="" trailing=" " val="private"/>
          </CommandPrivateNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(483, 9)" end="(494, 69)" name="findIdx?_go_eq" full_name="List.findIdx?_go_eq" _is_private_decl="True">
        <AtomNode start="(483, 9)" end="(483, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(483, 17)" end="(483, 31)">
          <IdentNode start="(483, 17)" end="(483, 31)" leading="" trailing=" " raw_val="findIdx?_go_eq" val="findIdx?_go_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(483, 32)" end="(484, 75)">
          <NullNode start="(483, 32)" end="(483, 70)">
            <OtherNode start="(483, 32)" end="(483, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 32)" end="(483, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 33)" end="(483, 34)">
                <IdentNode start="(483, 33)" end="(483, 34)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(483, 35)" end="(483, 45)">
                <AtomNode start="(483, 35)" end="(483, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(483, 37)" end="(483, 45)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(483, 37)" end="(483, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(483, 39)" end="(483, 40)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(483, 41)" end="(483, 45)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(483, 45)" end="(483, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(483, 47)" end="(483, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 47)" end="(483, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 48)" end="(483, 50)">
                <IdentNode start="(483, 48)" end="(483, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(483, 51)" end="(483, 59)">
                <AtomNode start="(483, 51)" end="(483, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(483, 53)" end="(483, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(483, 53)" end="(483, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(483, 58)" end="(483, 59)">
                    <IdentNode start="(483, 58)" end="(483, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(483, 59)" end="(483, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(483, 61)" end="(483, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 61)" end="(483, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 62)" end="(483, 63)">
                <IdentNode start="(483, 62)" end="(483, 63)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(483, 64)" end="(483, 69)">
                <AtomNode start="(483, 64)" end="(483, 65)" leading="" trailing=" " val=":"/>
                <IdentNode start="(483, 66)" end="(483, 69)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(483, 69)" end="(483, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(483, 71)" end="(484, 75)">
            <AtomNode start="(483, 71)" end="(483, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(484, 5)" end="(484, 75)" kind="«term_=_»">
              <OtherNode start="(484, 5)" end="(484, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(484, 5)" end="(484, 16)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(484, 17)" end="(484, 27)">
                  <IdentNode start="(484, 17)" end="(484, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(484, 19)" end="(484, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <OtherNode start="(484, 22)" end="(484, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(484, 22)" end="(484, 23)" leading="" trailing="" val="("/>
                    <OtherNode start="(484, 23)" end="(484, 26)" kind="«term_+_»">
                      <IdentNode start="(484, 23)" end="(484, 24)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(484, 24)" end="(484, 25)" leading="" trailing="" val="+"/>
                      <OtherNode start="(484, 25)" end="(484, 26)" kind="num">
                        <AtomNode start="(484, 25)" end="(484, 26)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(484, 26)" end="(484, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(484, 28)" end="(484, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(484, 30)" end="(484, 75)" kind="Lean.Parser.Term.app">
                <OtherNode start="(484, 30)" end="(484, 54)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(484, 30)" end="(484, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(484, 30)" end="(484, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(484, 31)" end="(484, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(484, 31)" end="(484, 42)" leading="" trailing=" " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(484, 43)" end="(484, 49)">
                        <IdentNode start="(484, 43)" end="(484, 44)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(484, 45)" end="(484, 47)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <OtherNode start="(484, 48)" end="(484, 49)" kind="num">
                          <AtomNode start="(484, 48)" end="(484, 49)" leading="" trailing="" val="0"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(484, 49)" end="(484, 50)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(484, 50)" end="(484, 51)" leading="" trailing="" val="."/>
                  <IdentNode start="(484, 51)" end="(484, 54)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(484, 55)" end="(484, 75)">
                  <OtherNode start="(484, 55)" end="(484, 75)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(484, 55)" end="(484, 58)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(484, 59)" end="(484, 75)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(484, 59)" end="(484, 60)">
                        <IdentNode start="(484, 59)" end="(484, 60)" leading="" trailing=" " raw_val="k" val="k"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(484, 61)" end="(484, 63)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(484, 64)" end="(484, 75)" kind="«term_+_»">
                        <IdentNode start="(484, 64)" end="(484, 65)" leading="" trailing=" " raw_val="k" val="k"/>
                        <AtomNode start="(484, 66)" end="(484, 67)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(484, 68)" end="(484, 75)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(484, 68)" end="(484, 69)" leading="" trailing="" val="("/>
                          <OtherNode start="(484, 69)" end="(484, 74)" kind="«term_+_»">
                            <IdentNode start="(484, 69)" end="(484, 70)" leading="" trailing=" " raw_val="i" val="i"/>
                            <AtomNode start="(484, 71)" end="(484, 72)" leading="" trailing=" " val="+"/>
                            <OtherNode start="(484, 73)" end="(484, 74)" kind="num">
                              <AtomNode start="(484, 73)" end="(484, 74)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(484, 74)" end="(484, 75)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(484, 76)" end="(494, 69)">
          <AtomNode start="(484, 76)" end="(484, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(484, 79)" end="(494, 69)">
            <AtomNode start="(484, 79)" end="(484, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(485, 3)" end="(494, 69)">
              <TacticTacticseq1IndentedNode start="(485, 3)" end="(494, 69)">
                <NullNode start="(485, 3)" end="(494, 69)">
                  <OtherNode start="(485, 3)" end="(494, 69)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;⊢ findIdx?.go p xs (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p xs 0)" state_after="no goals" tactic="induction xs generalizing i with&#10;| nil =&amp;gt; simp&#10;| cons _ _ _ =&amp;gt;&#10;  simp only [findIdx?_go_succ, findIdx?_go_cons, Nat.zero_add]&#10;  split&#10;  · simp_all&#10;  · simp_all only [findIdx?_go_succ, Bool.not_eq_true, Option.map_map, Nat.zero_add]&#10;    congr&#10;    ext&#10;    simp only [Nat.add_comm i, Function.comp_apply, Nat.add_assoc]">
                    <AtomNode start="(485, 3)" end="(485, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(485, 13)" end="(485, 15)">
                      <OtherNode start="(485, 13)" end="(485, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(485, 13)" end="(485, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(485, 16)" end="(485, 30)">
                      <AtomNode start="(485, 16)" end="(485, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(485, 29)" end="(485, 30)">
                        <IdentNode start="(485, 29)" end="(485, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(485, 31)" end="(494, 69)">
                      <OtherNode start="(485, 31)" end="(494, 69)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(485, 31)" end="(485, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(486, 3)" end="(494, 69)">
                          <OtherNode start="(486, 3)" end="(486, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(486, 3)" end="(486, 8)">
                              <OtherNode start="(486, 3)" end="(486, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(486, 3)" end="(486, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(486, 5)" end="(486, 8)">
                                  <NullNode/>
                                  <IdentNode start="(486, 5)" end="(486, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(486, 9)" end="(486, 16)">
                              <AtomNode start="(486, 9)" end="(486, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(486, 12)" end="(486, 16)">
                                <TacticTacticseq1IndentedNode start="(486, 12)" end="(486, 16)">
                                  <NullNode start="(486, 12)" end="(486, 16)">
                                    <OtherNode start="(486, 12)" end="(486, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx?.go p [] (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p [] 0)" state_after="no goals" tactic="simp">
                                      <AtomNode start="(486, 12)" end="(486, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(487, 3)" end="(494, 69)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(487, 3)" end="(487, 15)">
                              <OtherNode start="(487, 3)" end="(487, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(487, 3)" end="(487, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(487, 5)" end="(487, 9)">
                                  <NullNode/>
                                  <IdentNode start="(487, 5)" end="(487, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(487, 10)" end="(487, 15)">
                                  <TermHoleNode start="(487, 10)" end="(487, 11)">
                                    <AtomNode start="(487, 10)" end="(487, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(487, 12)" end="(487, 13)">
                                    <AtomNode start="(487, 12)" end="(487, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(487, 14)" end="(487, 15)">
                                    <AtomNode start="(487, 14)" end="(487, 15)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(487, 16)" end="(494, 69)">
                              <AtomNode start="(487, 16)" end="(487, 18)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(488, 5)" end="(494, 69)">
                                <TacticTacticseq1IndentedNode start="(488, 5)" end="(494, 69)">
                                  <NullNode start="(488, 5)" end="(494, 69)">
                                    <OtherNode start="(488, 5)" end="(488, 65)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;⊢ findIdx?.go p (head✝ :: tail✝) (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p (head✝ :: tail✝) 0)" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (if p head✝ = true then some i else Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1))&#10;      (if p head✝ = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" tactic="simp only [findIdx?_go_succ, findIdx?_go_cons, Nat.zero_add]">
                                      <AtomNode start="(488, 5)" end="(488, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(488, 10)" end="(488, 14)">
                                        <AtomNode start="(488, 10)" end="(488, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(488, 15)" end="(488, 65)">
                                        <AtomNode start="(488, 15)" end="(488, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(488, 16)" end="(488, 64)">
                                          <OtherNode start="(488, 16)" end="(488, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(488, 16)" end="(488, 32)" leading="" trailing="" raw_val="findIdx?_go_succ" val="findIdx?_go_succ" full_name="_private.Init.Data.List.Find.0.List.findIdx?_go_succ" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(478, 17)" def_end="(478, 33)"/>
                                          </OtherNode>
                                          <AtomNode start="(488, 32)" end="(488, 33)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(488, 34)" end="(488, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(488, 34)" end="(488, 50)" leading="" trailing="" raw_val="findIdx?_go_cons" val="findIdx?_go_cons" full_name="_private.Init.Data.List.Find.0.List.findIdx?_go_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(475, 31)" def_end="(475, 47)"/>
                                          </OtherNode>
                                          <AtomNode start="(488, 50)" end="(488, 51)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(488, 52)" end="(488, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(488, 52)" end="(488, 64)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(488, 64)" end="(488, 65)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(489, 5)" end="(489, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (if p head✝ = true then some i else Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1))&#10;      (if p head✝ = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (some i) = Option.map (fun k =&amp;gt; k + (i + 1)) (some 0)&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : ¬p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1)) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" tactic="split">
                                      <AtomNode start="(489, 5)" end="(489, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(490, 5)" end="(490, 15)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (some i) = Option.map (fun k =&amp;gt; k + (i + 1)) (some 0)&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : ¬p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1)) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : ¬p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1)) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" tactic="· simp_all">
                                      <OtherNode start="(490, 5)" end="(490, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(490, 5)" end="(490, 6)" kind="patternIgnore">
                                          <OtherNode start="(490, 5)" end="(490, 6)" kind="token.«· »">
                                            <AtomNode start="(490, 5)" end="(490, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(490, 7)" end="(490, 15)">
                                        <TacticTacticseq1IndentedNode start="(490, 7)" end="(490, 15)">
                                          <NullNode start="(490, 7)" end="(490, 15)">
                                            <OtherNode start="(490, 7)" end="(490, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (some i) = Option.map (fun k =&amp;gt; k + (i + 1)) (some 0)" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(490, 7)" end="(490, 15)" leading="" trailing="&#10;    " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(491, 5)" end="(494, 69)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : ¬p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1)) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" state_after="no goals" tactic="· simp_all only [findIdx?_go_succ, Bool.not_eq_true, Option.map_map, Nat.zero_add]&#10;  congr&#10;  ext&#10;  simp only [Nat.add_comm i, Function.comp_apply, Nat.add_assoc]">
                                      <OtherNode start="(491, 5)" end="(491, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(491, 5)" end="(491, 6)" kind="patternIgnore">
                                          <OtherNode start="(491, 5)" end="(491, 6)" kind="token.«· »">
                                            <AtomNode start="(491, 5)" end="(491, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(491, 7)" end="(494, 69)">
                                        <TacticTacticseq1IndentedNode start="(491, 7)" end="(494, 69)">
                                          <NullNode start="(491, 7)" end="(494, 69)">
                                            <OtherNode start="(491, 7)" end="(491, 87)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : ∀ {i : Nat}, findIdx?.go p tail✝ (i + 1) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;i : Nat&#10;h✝ : ¬p head✝ = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i)) =&#10;    Option.map (fun k =&amp;gt; k + (i + 1)) (Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ 0))" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;i : Nat&#10;tail_ih✝ :&#10;  ∀ {i : Nat},&#10;    Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;h✝ : p head✝ = false&#10;⊢ Option.map ((fun i =&amp;gt; i + 1) ∘ fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0) =&#10;    Option.map ((fun k =&amp;gt; k + (i + 1)) ∘ fun k =&amp;gt; k + 1) (findIdx?.go p tail✝ 0)" tactic="simp_all only [findIdx?_go_succ, Bool.not_eq_true, Option.map_map, Nat.zero_add]">
                                              <AtomNode start="(491, 7)" end="(491, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(491, 16)" end="(491, 20)">
                                                <AtomNode start="(491, 16)" end="(491, 20)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(491, 21)" end="(491, 87)">
                                                <AtomNode start="(491, 21)" end="(491, 22)" leading="" trailing="" val="["/>
                                                <NullNode start="(491, 22)" end="(491, 86)">
                                                  <OtherNode start="(491, 22)" end="(491, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(491, 22)" end="(491, 38)" leading="" trailing="" raw_val="findIdx?_go_succ" val="findIdx?_go_succ" full_name="_private.Init.Data.List.Find.0.List.findIdx?_go_succ" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(478, 17)" def_end="(478, 33)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(491, 38)" end="(491, 39)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(491, 40)" end="(491, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(491, 40)" end="(491, 56)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(491, 56)" end="(491, 57)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(491, 58)" end="(491, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(491, 58)" end="(491, 72)" leading="" trailing="" raw_val="Option.map_map" val="Option.map_map" full_name="Option.map_map" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(491, 72)" end="(491, 73)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(491, 74)" end="(491, 86)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(491, 74)" end="(491, 86)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(491, 86)" end="(491, 87)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(492, 7)" end="(492, 12)" kind="Lean.Parser.Tactic.congr" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;i : Nat&#10;tail_ih✝ :&#10;  ∀ {i : Nat},&#10;    Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;h✝ : p head✝ = false&#10;⊢ Option.map ((fun i =&amp;gt; i + 1) ∘ fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0) =&#10;    Option.map ((fun k =&amp;gt; k + (i + 1)) ∘ fun k =&amp;gt; k + 1) (findIdx?.go p tail✝ 0)" state_after="case cons.isFalse.e_f&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;i : Nat&#10;tail_ih✝ :&#10;  ∀ {i : Nat},&#10;    Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;h✝ : p head✝ = false&#10;⊢ ((fun i =&amp;gt; i + 1) ∘ fun k =&amp;gt; k + (i + 1)) = (fun k =&amp;gt; k + (i + 1)) ∘ fun k =&amp;gt; k + 1" tactic="congr">
                                              <AtomNode start="(492, 7)" end="(492, 12)" leading="" trailing="&#10;      " val="congr"/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(493, 7)" end="(493, 10)" kind="Lean.Elab.Tactic.Ext.ext" state_before="case cons.isFalse.e_f&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;i : Nat&#10;tail_ih✝ :&#10;  ∀ {i : Nat},&#10;    Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;h✝ : p head✝ = false&#10;⊢ ((fun i =&amp;gt; i + 1) ∘ fun k =&amp;gt; k + (i + 1)) = (fun k =&amp;gt; k + (i + 1)) ∘ fun k =&amp;gt; k + 1" state_after="case cons.isFalse.e_f.h&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;i : Nat&#10;tail_ih✝ :&#10;  ∀ {i : Nat},&#10;    Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;h✝ : p head✝ = false&#10;x✝ : Nat&#10;⊢ ((fun i =&amp;gt; i + 1) ∘ fun k =&amp;gt; k + (i + 1)) x✝ = ((fun k =&amp;gt; k + (i + 1)) ∘ fun k =&amp;gt; k + 1) x✝" tactic="ext">
                                              <AtomNode start="(493, 7)" end="(493, 10)" leading="" trailing="&#10;      " val="ext"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(494, 7)" end="(494, 69)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse.e_f.h&#10;α : Type u_1&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;i : Nat&#10;tail_ih✝ :&#10;  ∀ {i : Nat},&#10;    Option.map (fun i =&amp;gt; i + 1) (findIdx?.go p tail✝ i) = Option.map (fun k =&amp;gt; k + (i + 1)) (findIdx?.go p tail✝ 0)&#10;h✝ : p head✝ = false&#10;x✝ : Nat&#10;⊢ ((fun i =&amp;gt; i + 1) ∘ fun k =&amp;gt; k + (i + 1)) x✝ = ((fun k =&amp;gt; k + (i + 1)) ∘ fun k =&amp;gt; k + 1) x✝" state_after="no goals" tactic="simp only [Nat.add_comm i, Function.comp_apply, Nat.add_assoc]">
                                              <AtomNode start="(494, 7)" end="(494, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(494, 12)" end="(494, 16)">
                                                <AtomNode start="(494, 12)" end="(494, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(494, 17)" end="(494, 69)">
                                                <AtomNode start="(494, 17)" end="(494, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(494, 18)" end="(494, 68)">
                                                  <OtherNode start="(494, 18)" end="(494, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <OtherNode start="(494, 18)" end="(494, 32)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(494, 18)" end="(494, 30)" leading="" trailing=" " raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                      <NullNode start="(494, 31)" end="(494, 32)">
                                                        <IdentNode start="(494, 31)" end="(494, 32)" leading="" trailing="" raw_val="i" val="i"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(494, 32)" end="(494, 33)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(494, 34)" end="(494, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(494, 34)" end="(494, 53)" leading="" trailing="" raw_val="Function.comp_apply" val="Function.comp_apply" full_name="Function.comp_apply" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(494, 53)" end="(494, 54)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(494, 55)" end="(494, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(494, 55)" end="(494, 68)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(494, 68)" end="(494, 69)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(496, 1)" end="(496, 70)" name="findIdx?_nil" full_name="List.findIdx?_nil">
      <CommandDeclmodifiersNode start="(496, 1)" end="(496, 8)">
        <NullNode/>
        <NullNode start="(496, 1)" end="(496, 8)">
          <OtherNode start="(496, 1)" end="(496, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(496, 1)" end="(496, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(496, 3)" end="(496, 7)">
              <OtherNode start="(496, 3)" end="(496, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(496, 3)" end="(496, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(496, 3)" end="(496, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(496, 7)" end="(496, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(496, 9)" end="(496, 70)" name="findIdx?_nil" full_name="List.findIdx?_nil" _is_private_decl="False">
        <AtomNode start="(496, 9)" end="(496, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(496, 17)" end="(496, 29)">
          <IdentNode start="(496, 17)" end="(496, 29)" leading="" trailing=" " raw_val="findIdx?_nil" val="findIdx?_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(496, 30)" end="(496, 63)">
          <NullNode/>
          <TermTypespecNode start="(496, 30)" end="(496, 63)">
            <AtomNode start="(496, 30)" end="(496, 31)" leading="" trailing=" " val=":"/>
            <OtherNode start="(496, 32)" end="(496, 63)" kind="«term_=_»">
              <OtherNode start="(496, 32)" end="(496, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(496, 32)" end="(496, 54)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(496, 32)" end="(496, 45)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(496, 32)" end="(496, 33)" leading="" trailing="" val="("/>
                    <OtherNode start="(496, 33)" end="(496, 35)" kind="«term[_]»">
                      <AtomNode start="(496, 33)" end="(496, 34)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(496, 34)" end="(496, 35)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(496, 36)" end="(496, 37)" leading="" trailing=" " val=":"/>
                    <NullNode start="(496, 38)" end="(496, 44)">
                      <OtherNode start="(496, 38)" end="(496, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(496, 38)" end="(496, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(496, 43)" end="(496, 44)">
                          <IdentNode start="(496, 43)" end="(496, 44)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(496, 44)" end="(496, 45)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(496, 45)" end="(496, 46)" leading="" trailing="" val="."/>
                  <IdentNode start="(496, 46)" end="(496, 54)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(496, 55)" end="(496, 56)">
                  <IdentNode start="(496, 55)" end="(496, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(496, 57)" end="(496, 58)" leading="" trailing=" " val="="/>
              <IdentNode start="(496, 59)" end="(496, 63)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(496, 64)" end="(496, 70)">
          <AtomNode start="(496, 64)" end="(496, 66)" leading="" trailing=" " val=":="/>
          <IdentNode start="(496, 67)" end="(496, 70)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(498, 1)" end="(500, 34)" name="findIdx?_cons" full_name="List.findIdx?_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(498, 1)" end="(500, 34)" name="findIdx?_cons" full_name="List.findIdx?_cons" _is_private_decl="False">
        <AtomNode start="(498, 1)" end="(498, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(498, 9)" end="(498, 22)">
          <IdentNode start="(498, 9)" end="(498, 22)" leading="" trailing=" " raw_val="findIdx?_cons" val="findIdx?_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(498, 23)" end="(499, 86)">
          <NullNode/>
          <TermTypespecNode start="(498, 23)" end="(499, 86)">
            <AtomNode start="(498, 23)" end="(498, 24)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(499, 5)" end="(499, 86)" kind="«term_=_»">
              <OtherNode start="(499, 5)" end="(499, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(499, 5)" end="(499, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(499, 5)" end="(499, 14)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(499, 5)" end="(499, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(499, 6)" end="(499, 13)" kind="«term_::_»">
                      <IdentNode start="(499, 6)" end="(499, 7)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(499, 8)" end="(499, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(499, 11)" end="(499, 13)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(499, 13)" end="(499, 14)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(499, 14)" end="(499, 15)" leading="" trailing="" val="."/>
                  <IdentNode start="(499, 15)" end="(499, 23)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(499, 24)" end="(499, 25)">
                  <IdentNode start="(499, 24)" end="(499, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(499, 26)" end="(499, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(499, 28)" end="(499, 86)" kind="termIfThenElse">
                <AtomNode start="(499, 28)" end="(499, 30)" leading="" trailing=" " val="if"/>
                <OtherNode start="(499, 31)" end="(499, 34)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(499, 31)" end="(499, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(499, 33)" end="(499, 34)">
                    <IdentNode start="(499, 33)" end="(499, 34)" leading="" trailing=" " raw_val="x" val="x"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(499, 35)" end="(499, 39)" leading="" trailing=" " val="then"/>
                <OtherNode start="(499, 40)" end="(499, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(499, 40)" end="(499, 44)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(499, 45)" end="(499, 46)">
                    <OtherNode start="(499, 45)" end="(499, 46)" kind="num">
                      <AtomNode start="(499, 45)" end="(499, 46)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(499, 47)" end="(499, 51)" leading="" trailing=" " val="else"/>
                <OtherNode start="(499, 52)" end="(499, 86)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(499, 52)" end="(499, 71)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(499, 52)" end="(499, 67)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(499, 52)" end="(499, 53)" leading="" trailing="" val="("/>
                      <OtherNode start="(499, 53)" end="(499, 66)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(499, 53)" end="(499, 64)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                        <NullNode start="(499, 65)" end="(499, 66)">
                          <IdentNode start="(499, 65)" end="(499, 66)" leading="" trailing="" raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(499, 66)" end="(499, 67)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(499, 67)" end="(499, 68)" leading="" trailing="" val="."/>
                    <IdentNode start="(499, 68)" end="(499, 71)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <NullNode start="(499, 72)" end="(499, 86)">
                    <OtherNode start="(499, 72)" end="(499, 86)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(499, 72)" end="(499, 75)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(499, 76)" end="(499, 86)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(499, 76)" end="(499, 77)">
                          <IdentNode start="(499, 76)" end="(499, 77)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(499, 78)" end="(499, 80)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(499, 81)" end="(499, 86)" kind="«term_+_»">
                          <IdentNode start="(499, 81)" end="(499, 82)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(499, 83)" end="(499, 84)" leading="" trailing=" " val="+"/>
                          <OtherNode start="(499, 85)" end="(499, 86)" kind="num">
                            <AtomNode start="(499, 85)" end="(499, 86)" leading="" trailing=" " val="1"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(499, 87)" end="(500, 34)">
          <AtomNode start="(499, 87)" end="(499, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(499, 90)" end="(500, 34)">
            <AtomNode start="(499, 90)" end="(499, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(500, 3)" end="(500, 34)">
              <TacticTacticseq1IndentedNode start="(500, 3)" end="(500, 34)">
                <NullNode start="(500, 3)" end="(500, 34)">
                  <OtherNode start="(500, 3)" end="(500, 34)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;x : α✝&#10;xs : List α✝&#10;p : α✝ → Bool&#10;⊢ findIdx? p (x :: xs) = if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)" state_after="no goals" tactic="simp [findIdx?, findIdx?_go_eq]">
                    <AtomNode start="(500, 3)" end="(500, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(500, 8)" end="(500, 34)">
                      <AtomNode start="(500, 8)" end="(500, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(500, 9)" end="(500, 33)">
                        <OtherNode start="(500, 9)" end="(500, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(500, 9)" end="(500, 17)" leading="" trailing="" raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(500, 17)" end="(500, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(500, 19)" end="(500, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(500, 19)" end="(500, 33)" leading="" trailing="" raw_val="findIdx?_go_eq" val="findIdx?_go_eq" full_name="_private.Init.Data.List.Find.0.List.findIdx?_go_eq" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(483, 17)" def_end="(483, 31)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(500, 33)" end="(500, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(502, 1)" end="(503, 37)" name="findIdx?_singleton" full_name="List.findIdx?_singleton">
      <CommandDeclmodifiersNode start="(502, 1)" end="(502, 8)">
        <NullNode/>
        <NullNode start="(502, 1)" end="(502, 8)">
          <OtherNode start="(502, 1)" end="(502, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(502, 1)" end="(502, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(502, 3)" end="(502, 7)">
              <OtherNode start="(502, 3)" end="(502, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(502, 3)" end="(502, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(502, 3)" end="(502, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(502, 7)" end="(502, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(502, 9)" end="(503, 37)" name="findIdx?_singleton" full_name="List.findIdx?_singleton" _is_private_decl="False">
        <AtomNode start="(502, 9)" end="(502, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(502, 17)" end="(502, 35)">
          <IdentNode start="(502, 17)" end="(502, 35)" leading="" trailing=" " raw_val="findIdx?_singleton" val="findIdx?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(502, 36)" end="(502, 106)">
          <NullNode start="(502, 36)" end="(502, 58)">
            <OtherNode start="(502, 36)" end="(502, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(502, 36)" end="(502, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(502, 37)" end="(502, 38)">
                <IdentNode start="(502, 37)" end="(502, 38)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(502, 39)" end="(502, 42)">
                <AtomNode start="(502, 39)" end="(502, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(502, 41)" end="(502, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(502, 42)" end="(502, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(502, 44)" end="(502, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(502, 44)" end="(502, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(502, 45)" end="(502, 46)">
                <IdentNode start="(502, 45)" end="(502, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(502, 47)" end="(502, 57)">
                <AtomNode start="(502, 47)" end="(502, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(502, 49)" end="(502, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(502, 49)" end="(502, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(502, 51)" end="(502, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(502, 53)" end="(502, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(502, 57)" end="(502, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(502, 59)" end="(502, 106)">
            <AtomNode start="(502, 59)" end="(502, 60)" leading="" trailing=" " val=":"/>
            <OtherNode start="(502, 61)" end="(502, 106)" kind="«term_=_»">
              <OtherNode start="(502, 61)" end="(502, 75)" kind="Lean.Parser.Term.app">
                <OtherNode start="(502, 61)" end="(502, 73)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(502, 61)" end="(502, 64)" kind="«term[_]»">
                    <AtomNode start="(502, 61)" end="(502, 62)" leading="" trailing="" val="["/>
                    <NullNode start="(502, 62)" end="(502, 63)">
                      <IdentNode start="(502, 62)" end="(502, 63)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(502, 63)" end="(502, 64)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(502, 64)" end="(502, 65)" leading="" trailing="" val="."/>
                  <IdentNode start="(502, 65)" end="(502, 73)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(502, 74)" end="(502, 75)">
                  <IdentNode start="(502, 74)" end="(502, 75)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(502, 76)" end="(502, 77)" leading="" trailing=" " val="="/>
              <OtherNode start="(502, 78)" end="(502, 106)" kind="termIfThenElse">
                <AtomNode start="(502, 78)" end="(502, 80)" leading="" trailing=" " val="if"/>
                <OtherNode start="(502, 81)" end="(502, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(502, 81)" end="(502, 82)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(502, 83)" end="(502, 84)">
                    <IdentNode start="(502, 83)" end="(502, 84)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(502, 85)" end="(502, 89)" leading="" trailing=" " val="then"/>
                <OtherNode start="(502, 90)" end="(502, 96)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(502, 90)" end="(502, 94)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(502, 95)" end="(502, 96)">
                    <OtherNode start="(502, 95)" end="(502, 96)" kind="num">
                      <AtomNode start="(502, 95)" end="(502, 96)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(502, 97)" end="(502, 101)" leading="" trailing=" " val="else"/>
                <IdentNode start="(502, 102)" end="(502, 106)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(502, 107)" end="(503, 37)">
          <AtomNode start="(502, 107)" end="(502, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(502, 110)" end="(503, 37)">
            <AtomNode start="(502, 110)" end="(502, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(503, 3)" end="(503, 37)">
              <TacticTacticseq1IndentedNode start="(503, 3)" end="(503, 37)">
                <NullNode start="(503, 3)" end="(503, 37)">
                  <OtherNode start="(503, 3)" end="(503, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ findIdx? p [a] = if p a = true then some 0 else none" state_after="no goals" tactic="simp [findIdx?_cons, findIdx?_nil]">
                    <AtomNode start="(503, 3)" end="(503, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(503, 8)" end="(503, 37)">
                      <AtomNode start="(503, 8)" end="(503, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(503, 9)" end="(503, 36)">
                        <OtherNode start="(503, 9)" end="(503, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(503, 9)" end="(503, 22)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                        </OtherNode>
                        <AtomNode start="(503, 22)" end="(503, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(503, 24)" end="(503, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(503, 24)" end="(503, 36)" leading="" trailing="" raw_val="findIdx?_nil" val="findIdx?_nil" full_name="List.findIdx?_nil" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(496, 17)" def_end="(496, 29)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(503, 36)" end="(503, 37)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(505, 1)" end="(505, 19)" comment="### findIdx -/">
      <AtomNode start="(505, 1)" end="(505, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(505, 5)" end="(505, 19)" leading="" trailing="&#10;&#10;" val="### findIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(507, 1)" end="(520, 41)" name="findIdx_cons" full_name="List.findIdx_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(507, 1)" end="(520, 41)" name="findIdx_cons" full_name="List.findIdx_cons" _is_private_decl="False">
        <AtomNode start="(507, 1)" end="(507, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(507, 9)" end="(507, 21)">
          <IdentNode start="(507, 9)" end="(507, 21)" leading="" trailing=" " raw_val="findIdx_cons" val="findIdx_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(507, 22)" end="(508, 63)">
          <NullNode start="(507, 22)" end="(507, 57)">
            <OtherNode start="(507, 22)" end="(507, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(507, 22)" end="(507, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(507, 23)" end="(507, 24)">
                <IdentNode start="(507, 23)" end="(507, 24)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(507, 25)" end="(507, 35)">
                <AtomNode start="(507, 25)" end="(507, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(507, 27)" end="(507, 35)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(507, 27)" end="(507, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(507, 29)" end="(507, 30)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(507, 31)" end="(507, 35)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(507, 35)" end="(507, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(507, 37)" end="(507, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(507, 37)" end="(507, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(507, 38)" end="(507, 39)">
                <IdentNode start="(507, 38)" end="(507, 39)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(507, 40)" end="(507, 43)">
                <AtomNode start="(507, 40)" end="(507, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(507, 42)" end="(507, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(507, 43)" end="(507, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(507, 45)" end="(507, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(507, 45)" end="(507, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(507, 46)" end="(507, 47)">
                <IdentNode start="(507, 46)" end="(507, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(507, 48)" end="(507, 56)">
                <AtomNode start="(507, 48)" end="(507, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(507, 50)" end="(507, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(507, 50)" end="(507, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(507, 55)" end="(507, 56)">
                    <IdentNode start="(507, 55)" end="(507, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(507, 56)" end="(507, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(507, 58)" end="(508, 63)">
            <AtomNode start="(507, 58)" end="(507, 59)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(508, 5)" end="(508, 63)" kind="«term_=_»">
              <OtherNode start="(508, 5)" end="(508, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(508, 5)" end="(508, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(508, 5)" end="(508, 13)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(508, 5)" end="(508, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(508, 6)" end="(508, 12)" kind="«term_::_»">
                      <IdentNode start="(508, 6)" end="(508, 7)" leading="" trailing=" " raw_val="b" val="b"/>
                      <AtomNode start="(508, 8)" end="(508, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(508, 11)" end="(508, 12)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(508, 12)" end="(508, 13)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(508, 13)" end="(508, 14)" leading="" trailing="" val="."/>
                  <IdentNode start="(508, 14)" end="(508, 21)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="List.findIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(508, 22)" end="(508, 23)">
                  <IdentNode start="(508, 22)" end="(508, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(508, 24)" end="(508, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(508, 26)" end="(508, 63)" kind="boolIfThenElse">
                <AtomNode start="(508, 26)" end="(508, 29)" leading="" trailing=" " val="bif"/>
                <OtherNode start="(508, 30)" end="(508, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(508, 30)" end="(508, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(508, 32)" end="(508, 33)">
                    <IdentNode start="(508, 32)" end="(508, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(508, 34)" end="(508, 38)" leading="" trailing=" " val="then"/>
                <OtherNode start="(508, 39)" end="(508, 40)" kind="num">
                  <AtomNode start="(508, 39)" end="(508, 40)" leading="" trailing=" " val="0"/>
                </OtherNode>
                <AtomNode start="(508, 41)" end="(508, 45)" leading="" trailing=" " val="else"/>
                <OtherNode start="(508, 46)" end="(508, 63)" kind="«term_+_»">
                  <OtherNode start="(508, 46)" end="(508, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(508, 46)" end="(508, 47)" leading="" trailing="" val="("/>
                    <OtherNode start="(508, 47)" end="(508, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(508, 47)" end="(508, 56)" leading="" trailing=" " raw_val="l.findIdx" val="l.findIdx"/>
                      <NullNode start="(508, 57)" end="(508, 58)">
                        <IdentNode start="(508, 57)" end="(508, 58)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(508, 58)" end="(508, 59)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(508, 60)" end="(508, 61)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(508, 62)" end="(508, 63)" kind="num">
                    <AtomNode start="(508, 62)" end="(508, 63)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(508, 64)" end="(520, 41)">
          <AtomNode start="(508, 64)" end="(508, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(508, 67)" end="(511, 60)">
            <AtomNode start="(508, 67)" end="(508, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(509, 3)" end="(511, 60)">
              <TacticTacticseq1IndentedNode start="(509, 3)" end="(511, 60)">
                <NullNode start="(509, 3)" end="(511, 60)">
                  <OtherNode start="(509, 3)" end="(511, 60)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p : α → Bool&#10;b : α&#10;l : List α&#10;⊢ findIdx p (b :: l) = bif p b then 0 else findIdx p l + 1" state_after="no goals" tactic="cases H : p b with&#10;| true =&amp;gt; simp [H, findIdx, findIdx.go]&#10;| false =&amp;gt; simp [H, findIdx, findIdx.go, findIdx_go_succ]">
                    <AtomNode start="(509, 3)" end="(509, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(509, 9)" end="(509, 16)">
                      <OtherNode start="(509, 9)" end="(509, 16)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode start="(509, 9)" end="(509, 12)">
                          <LeanBinderidentNode start="(509, 9)" end="(509, 10)">
                            <IdentNode start="(509, 9)" end="(509, 10)" leading="" trailing=" " raw_val="H" val="H"/>
                          </LeanBinderidentNode>
                          <AtomNode start="(509, 11)" end="(509, 12)" leading="" trailing=" " val=":"/>
                        </NullNode>
                        <OtherNode start="(509, 13)" end="(509, 16)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(509, 13)" end="(509, 14)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(509, 15)" end="(509, 16)">
                            <IdentNode start="(509, 15)" end="(509, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(509, 17)" end="(511, 60)">
                      <OtherNode start="(509, 17)" end="(511, 60)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(509, 17)" end="(509, 21)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(510, 3)" end="(511, 60)">
                          <OtherNode start="(510, 3)" end="(510, 42)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(510, 3)" end="(510, 9)">
                              <OtherNode start="(510, 3)" end="(510, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(510, 3)" end="(510, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(510, 5)" end="(510, 9)">
                                  <NullNode/>
                                  <IdentNode start="(510, 5)" end="(510, 9)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(510, 10)" end="(510, 42)">
                              <AtomNode start="(510, 10)" end="(510, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(510, 13)" end="(510, 42)">
                                <TacticTacticseq1IndentedNode start="(510, 13)" end="(510, 42)">
                                  <NullNode start="(510, 13)" end="(510, 42)">
                                    <OtherNode start="(510, 13)" end="(510, 42)" kind="Lean.Parser.Tactic.simp" state_before="case true&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;l : List α&#10;H : p b = true&#10;⊢ findIdx p (b :: l) = bif true then 0 else findIdx p l + 1" state_after="no goals" tactic="simp [H, findIdx, findIdx.go]">
                                      <AtomNode start="(510, 13)" end="(510, 17)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(510, 18)" end="(510, 42)">
                                        <AtomNode start="(510, 18)" end="(510, 19)" leading="" trailing="" val="["/>
                                        <NullNode start="(510, 19)" end="(510, 41)">
                                          <OtherNode start="(510, 19)" end="(510, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(510, 19)" end="(510, 20)" leading="" trailing="" raw_val="H" val="H"/>
                                          </OtherNode>
                                          <AtomNode start="(510, 20)" end="(510, 21)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(510, 22)" end="(510, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(510, 22)" end="(510, 29)" leading="" trailing="" raw_val="findIdx" val="findIdx" full_name="List.findIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(510, 29)" end="(510, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(510, 31)" end="(510, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(510, 31)" end="(510, 41)" leading="" trailing="" raw_val="findIdx.go" val="findIdx.go" full_name="List.findIdx.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(510, 41)" end="(510, 42)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(511, 3)" end="(511, 60)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(511, 3)" end="(511, 10)">
                              <OtherNode start="(511, 3)" end="(511, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(511, 3)" end="(511, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(511, 5)" end="(511, 10)">
                                  <NullNode/>
                                  <IdentNode start="(511, 5)" end="(511, 10)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(511, 11)" end="(511, 60)">
                              <AtomNode start="(511, 11)" end="(511, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(511, 14)" end="(511, 60)">
                                <TacticTacticseq1IndentedNode start="(511, 14)" end="(511, 60)">
                                  <NullNode start="(511, 14)" end="(511, 60)">
                                    <OtherNode start="(511, 14)" end="(511, 60)" kind="Lean.Parser.Tactic.simp" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;b : α&#10;l : List α&#10;H : p b = false&#10;⊢ findIdx p (b :: l) = bif false then 0 else findIdx p l + 1" state_after="no goals" tactic="simp [H, findIdx, findIdx.go, findIdx_go_succ]">
                                      <AtomNode start="(511, 14)" end="(511, 18)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(511, 19)" end="(511, 60)">
                                        <AtomNode start="(511, 19)" end="(511, 20)" leading="" trailing="" val="["/>
                                        <NullNode start="(511, 20)" end="(511, 59)">
                                          <OtherNode start="(511, 20)" end="(511, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(511, 20)" end="(511, 21)" leading="" trailing="" raw_val="H" val="H"/>
                                          </OtherNode>
                                          <AtomNode start="(511, 21)" end="(511, 22)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(511, 23)" end="(511, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(511, 23)" end="(511, 30)" leading="" trailing="" raw_val="findIdx" val="findIdx" full_name="List.findIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(511, 30)" end="(511, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(511, 32)" end="(511, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(511, 32)" end="(511, 42)" leading="" trailing="" raw_val="findIdx.go" val="findIdx.go" full_name="List.findIdx.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(511, 42)" end="(511, 43)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(511, 44)" end="(511, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(511, 44)" end="(511, 59)" leading="" trailing="" raw_val="findIdx_go_succ" val="findIdx_go_succ"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(511, 59)" end="(511, 60)" leading="" trailing="&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(512, 1)" end="(520, 41)">
            <OtherNode start="(512, 1)" end="(520, 41)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(512, 1)" end="(512, 6)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(513, 3)" end="(520, 41)">
                <OtherNode start="(513, 3)" end="(520, 41)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(513, 3)" end="(520, 41)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(513, 3)" end="(520, 41)" kind="Lean.Parser.Term.letIdDecl">
                      <IdentNode start="(513, 3)" end="(513, 18)" leading="" trailing=" " raw_val="findIdx_go_succ" val="findIdx_go_succ"/>
                      <NullNode start="(513, 19)" end="(513, 56)">
                        <TermExplicitbinderNode start="(513, 19)" end="(513, 33)">
                          <AtomNode start="(513, 19)" end="(513, 20)" leading="" trailing="" val="("/>
                          <NullNode start="(513, 20)" end="(513, 21)">
                            <IdentNode start="(513, 20)" end="(513, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                          <NullNode start="(513, 22)" end="(513, 32)">
                            <AtomNode start="(513, 22)" end="(513, 23)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(513, 24)" end="(513, 32)" kind="Lean.Parser.Term.arrow">
                              <IdentNode start="(513, 24)" end="(513, 25)" leading="" trailing=" " raw_val="α" val="α"/>
                              <AtomNode start="(513, 26)" end="(513, 27)" leading="" trailing=" " val="→"/>
                              <IdentNode start="(513, 28)" end="(513, 32)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(513, 32)" end="(513, 33)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <TermExplicitbinderNode start="(513, 34)" end="(513, 46)">
                          <AtomNode start="(513, 34)" end="(513, 35)" leading="" trailing="" val="("/>
                          <NullNode start="(513, 35)" end="(513, 36)">
                            <IdentNode start="(513, 35)" end="(513, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                          </NullNode>
                          <NullNode start="(513, 37)" end="(513, 45)">
                            <AtomNode start="(513, 37)" end="(513, 38)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(513, 39)" end="(513, 45)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(513, 39)" end="(513, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(513, 44)" end="(513, 45)">
                                <IdentNode start="(513, 44)" end="(513, 45)" leading="" trailing="" raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(513, 45)" end="(513, 46)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <TermExplicitbinderNode start="(513, 47)" end="(513, 56)">
                          <AtomNode start="(513, 47)" end="(513, 48)" leading="" trailing="" val="("/>
                          <NullNode start="(513, 48)" end="(513, 49)">
                            <IdentNode start="(513, 48)" end="(513, 49)" leading="" trailing=" " raw_val="n" val="n"/>
                          </NullNode>
                          <NullNode start="(513, 50)" end="(513, 55)">
                            <AtomNode start="(513, 50)" end="(513, 51)" leading="" trailing=" " val=":"/>
                            <IdentNode start="(513, 52)" end="(513, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(513, 55)" end="(513, 56)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                      </NullNode>
                      <NullNode start="(513, 57)" end="(514, 59)">
                        <TermTypespecNode start="(513, 57)" end="(514, 59)">
                          <AtomNode start="(513, 57)" end="(513, 58)" leading="" trailing="&#10;      " val=":"/>
                          <OtherNode start="(514, 7)" end="(514, 59)" kind="«term_=_»">
                            <OtherNode start="(514, 7)" end="(514, 34)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(514, 7)" end="(514, 22)" leading="" trailing=" " raw_val="List.findIdx.go" val="List.findIdx.go" full_name="List.findIdx.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              <NullNode start="(514, 23)" end="(514, 34)">
                                <IdentNode start="(514, 23)" end="(514, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                                <IdentNode start="(514, 25)" end="(514, 26)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(514, 27)" end="(514, 34)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(514, 27)" end="(514, 28)" leading="" trailing="" val="("/>
                                  <OtherNode start="(514, 28)" end="(514, 33)" kind="«term_+_»">
                                    <IdentNode start="(514, 28)" end="(514, 29)" leading="" trailing=" " raw_val="n" val="n"/>
                                    <AtomNode start="(514, 30)" end="(514, 31)" leading="" trailing=" " val="+"/>
                                    <OtherNode start="(514, 32)" end="(514, 33)" kind="num">
                                      <AtomNode start="(514, 32)" end="(514, 33)" leading="" trailing="" val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(514, 33)" end="(514, 34)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(514, 35)" end="(514, 36)" leading="" trailing=" " val="="/>
                            <OtherNode start="(514, 37)" end="(514, 59)" kind="«term_+_»">
                              <OtherNode start="(514, 37)" end="(514, 55)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(514, 37)" end="(514, 38)" leading="" trailing="" val="("/>
                                <OtherNode start="(514, 38)" end="(514, 54)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(514, 38)" end="(514, 48)" leading="" trailing=" " raw_val="findIdx.go" val="findIdx.go" full_name="List.findIdx.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  <NullNode start="(514, 49)" end="(514, 54)">
                                    <IdentNode start="(514, 49)" end="(514, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                                    <IdentNode start="(514, 51)" end="(514, 52)" leading="" trailing=" " raw_val="l" val="l"/>
                                    <IdentNode start="(514, 53)" end="(514, 54)" leading="" trailing="" raw_val="n" val="n"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(514, 54)" end="(514, 55)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <AtomNode start="(514, 56)" end="(514, 57)" leading="" trailing=" " val="+"/>
                              <OtherNode start="(514, 58)" end="(514, 59)" kind="num">
                                <AtomNode start="(514, 58)" end="(514, 59)" leading="" trailing=" " val="1"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <AtomNode start="(514, 60)" end="(514, 62)" leading="" trailing=" " val=":="/>
                      <TermBytacticNode start="(514, 63)" end="(520, 41)">
                        <AtomNode start="(514, 63)" end="(514, 65)" leading="" trailing="&#10;    " val="by"/>
                        <TacticTacticseqNode start="(515, 5)" end="(520, 41)">
                          <TacticTacticseq1IndentedNode start="(515, 5)" end="(520, 41)">
                            <NullNode start="(515, 5)" end="(520, 41)">
                              <OtherNode start="(515, 5)" end="(520, 41)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l✝ : List α&#10;p : α → Bool&#10;l : List α&#10;n : Nat&#10;⊢ findIdx.go p l (n + 1) = findIdx.go p l n + 1" state_after="no goals" tactic="cases l with&#10;| nil =&amp;gt; unfold findIdx.go; exact Nat.succ_eq_add_one n&#10;| cons hd tl =&amp;gt;&#10;  unfold findIdx.go&#10;  cases p hd &amp;lt;;&amp;gt; simp only [cond_false, cond_true]&#10;  exact findIdx_go_succ p tl (n + 1)">
                                <AtomNode start="(515, 5)" end="(515, 10)" leading="" trailing=" " val="cases"/>
                                <NullNode start="(515, 11)" end="(515, 12)">
                                  <OtherNode start="(515, 11)" end="(515, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                    <NullNode/>
                                    <IdentNode start="(515, 11)" end="(515, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <NullNode start="(515, 13)" end="(520, 41)">
                                  <OtherNode start="(515, 13)" end="(520, 41)" kind="Lean.Parser.Tactic.inductionAlts">
                                    <AtomNode start="(515, 13)" end="(515, 17)" leading="" trailing="&#10;    " val="with"/>
                                    <NullNode/>
                                    <NullNode start="(516, 5)" end="(520, 41)">
                                      <OtherNode start="(516, 5)" end="(516, 60)" kind="Lean.Parser.Tactic.inductionAlt">
                                        <NullNode start="(516, 5)" end="(516, 10)">
                                          <OtherNode start="(516, 5)" end="(516, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                            <AtomNode start="(516, 5)" end="(516, 6)" leading="" trailing=" " val="|"/>
                                            <GroupNode start="(516, 7)" end="(516, 10)">
                                              <NullNode/>
                                              <IdentNode start="(516, 7)" end="(516, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            </GroupNode>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode start="(516, 11)" end="(516, 60)">
                                          <AtomNode start="(516, 11)" end="(516, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                          <TacticTacticseqNode start="(516, 14)" end="(516, 60)">
                                            <TacticTacticseq1IndentedNode start="(516, 14)" end="(516, 60)">
                                              <NullNode start="(516, 14)" end="(516, 60)">
                                                <OtherNode start="(516, 14)" end="(516, 31)" kind="Lean.Parser.Tactic.unfold" state_before="case nil&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;⊢ findIdx.go p [] (n + 1) = findIdx.go p [] n + 1" state_after="case nil&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;⊢ n + 1 = n + 1" tactic="unfold findIdx.go">
                                                  <AtomNode start="(516, 14)" end="(516, 20)" leading="" trailing=" " val="unfold"/>
                                                  <NullNode start="(516, 21)" end="(516, 31)">
                                                    <IdentNode start="(516, 21)" end="(516, 31)" leading="" trailing="" raw_val="findIdx.go" val="findIdx.go" full_name="List.findIdx.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(516, 31)" end="(516, 32)" leading="" trailing=" " val=";"/>
                                                <OtherNode start="(516, 33)" end="(516, 60)" kind="Lean.Parser.Tactic.exact" state_before="case nil&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;⊢ n + 1 = n + 1" state_after="no goals" tactic="exact Nat.succ_eq_add_one n">
                                                  <AtomNode start="(516, 33)" end="(516, 38)" leading="" trailing=" " val="exact"/>
                                                  <OtherNode start="(516, 39)" end="(516, 60)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(516, 39)" end="(516, 58)" leading="" trailing=" " raw_val="Nat.succ_eq_add_one" val="Nat.succ_eq_add_one" full_name="Nat.succ_eq_add_one" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                    <NullNode start="(516, 59)" end="(516, 60)">
                                                      <IdentNode start="(516, 59)" end="(516, 60)" leading="" trailing="&#10;    " raw_val="n" val="n"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </NullNode>
                                      </OtherNode>
                                      <OtherNode start="(517, 5)" end="(520, 41)" kind="Lean.Parser.Tactic.inductionAlt">
                                        <NullNode start="(517, 5)" end="(517, 17)">
                                          <OtherNode start="(517, 5)" end="(517, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                            <AtomNode start="(517, 5)" end="(517, 6)" leading="" trailing=" " val="|"/>
                                            <GroupNode start="(517, 7)" end="(517, 11)">
                                              <NullNode/>
                                              <IdentNode start="(517, 7)" end="(517, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            </GroupNode>
                                            <NullNode start="(517, 12)" end="(517, 17)">
                                              <IdentNode start="(517, 12)" end="(517, 14)" leading="" trailing=" " raw_val="hd" val="hd"/>
                                              <IdentNode start="(517, 15)" end="(517, 17)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                            </NullNode>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode start="(517, 18)" end="(520, 41)">
                                          <AtomNode start="(517, 18)" end="(517, 20)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                          <TacticTacticseqNode start="(518, 7)" end="(520, 41)">
                                            <TacticTacticseq1IndentedNode start="(518, 7)" end="(520, 41)">
                                              <NullNode start="(518, 7)" end="(520, 41)">
                                                <OtherNode start="(518, 7)" end="(518, 24)" kind="Lean.Parser.Tactic.unfold" state_before="case cons&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;hd : α&#10;tl : List α&#10;⊢ findIdx.go p (hd :: tl) (n + 1) = findIdx.go p (hd :: tl) n + 1" state_after="case cons&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;hd : α&#10;tl : List α&#10;⊢ (bif p hd then n + 1 else findIdx.go p tl (n + 1 + 1)) = (bif p hd then n else findIdx.go p tl (n + 1)) + 1" tactic="unfold findIdx.go">
                                                  <AtomNode start="(518, 7)" end="(518, 13)" leading="" trailing=" " val="unfold"/>
                                                  <NullNode start="(518, 14)" end="(518, 24)">
                                                    <IdentNode start="(518, 14)" end="(518, 24)" leading="" trailing="&#10;      " raw_val="findIdx.go" val="findIdx.go" full_name="List.findIdx.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <OtherNode start="(519, 7)" end="(519, 55)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;hd : α&#10;tl : List α&#10;⊢ (bif p hd then n + 1 else findIdx.go p tl (n + 1 + 1)) = (bif p hd then n else findIdx.go p tl (n + 1)) + 1" state_after="case cons.false&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;hd : α&#10;tl : List α&#10;⊢ findIdx.go p tl (n + 1 + 1) = findIdx.go p tl (n + 1) + 1" tactic="cases p hd &amp;lt;;&amp;gt; simp only [cond_false, cond_true]">
                                                  <OtherNode start="(519, 7)" end="(519, 17)" kind="Lean.Parser.Tactic.cases">
                                                    <AtomNode start="(519, 7)" end="(519, 12)" leading="" trailing=" " val="cases"/>
                                                    <NullNode start="(519, 13)" end="(519, 17)">
                                                      <OtherNode start="(519, 13)" end="(519, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                                        <NullNode/>
                                                        <OtherNode start="(519, 13)" end="(519, 17)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(519, 13)" end="(519, 14)" leading="" trailing=" " raw_val="p" val="p"/>
                                                          <NullNode start="(519, 15)" end="(519, 17)">
                                                            <IdentNode start="(519, 15)" end="(519, 17)" leading="" trailing=" " raw_val="hd" val="hd"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(519, 18)" end="(519, 21)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                  <OtherNode start="(519, 22)" end="(519, 55)" kind="Lean.Parser.Tactic.simp">
                                                    <AtomNode start="(519, 22)" end="(519, 26)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode start="(519, 27)" end="(519, 31)">
                                                      <AtomNode start="(519, 27)" end="(519, 31)" leading="" trailing=" " val="only"/>
                                                    </NullNode>
                                                    <NullNode start="(519, 32)" end="(519, 55)">
                                                      <AtomNode start="(519, 32)" end="(519, 33)" leading="" trailing="" val="["/>
                                                      <NullNode start="(519, 33)" end="(519, 54)">
                                                        <OtherNode start="(519, 33)" end="(519, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(519, 33)" end="(519, 43)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                        </OtherNode>
                                                        <AtomNode start="(519, 43)" end="(519, 44)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(519, 45)" end="(519, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(519, 45)" end="(519, 54)" leading="" trailing="" raw_val="cond_true" val="cond_true" full_name="cond_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(519, 54)" end="(519, 55)" leading="" trailing="&#10;      " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode/>
                                                <OtherNode start="(520, 7)" end="(520, 41)" kind="Lean.Parser.Tactic.exact" state_before="case cons.false&#10;α : Type u_1&#10;p✝ : α → Bool&#10;b : α&#10;l : List α&#10;p : α → Bool&#10;n : Nat&#10;hd : α&#10;tl : List α&#10;⊢ findIdx.go p tl (n + 1 + 1) = findIdx.go p tl (n + 1) + 1" state_after="no goals" tactic="exact findIdx_go_succ p tl (n + 1)">
                                                  <AtomNode start="(520, 7)" end="(520, 12)" leading="" trailing=" " val="exact"/>
                                                  <OtherNode start="(520, 13)" end="(520, 41)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(520, 13)" end="(520, 28)" leading="" trailing=" " raw_val="findIdx_go_succ" val="findIdx_go_succ"/>
                                                    <NullNode start="(520, 29)" end="(520, 41)">
                                                      <IdentNode start="(520, 29)" end="(520, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                                                      <IdentNode start="(520, 31)" end="(520, 33)" leading="" trailing=" " raw_val="tl" val="tl"/>
                                                      <OtherNode start="(520, 34)" end="(520, 41)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(520, 34)" end="(520, 35)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(520, 35)" end="(520, 40)" kind="«term_+_»">
                                                          <IdentNode start="(520, 35)" end="(520, 36)" leading="" trailing=" " raw_val="n" val="n"/>
                                                          <AtomNode start="(520, 37)" end="(520, 38)" leading="" trailing=" " val="+"/>
                                                          <OtherNode start="(520, 39)" end="(520, 40)" kind="num">
                                                            <AtomNode start="(520, 39)" end="(520, 40)" leading="" trailing="" val="1"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <AtomNode start="(520, 40)" end="(520, 41)" leading="" trailing="&#10;&#10;" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </NullNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </TermBytacticNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(522, 1)" end="(523, 35)" name="findIdx_singleton" full_name="List.findIdx_singleton">
      <CommandDeclmodifiersNode start="(522, 1)" end="(522, 8)">
        <NullNode/>
        <NullNode start="(522, 1)" end="(522, 8)">
          <OtherNode start="(522, 1)" end="(522, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(522, 1)" end="(522, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(522, 3)" end="(522, 7)">
              <OtherNode start="(522, 3)" end="(522, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(522, 3)" end="(522, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(522, 3)" end="(522, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(522, 7)" end="(522, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(522, 9)" end="(523, 35)" name="findIdx_singleton" full_name="List.findIdx_singleton" _is_private_decl="False">
        <AtomNode start="(522, 9)" end="(522, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(522, 17)" end="(522, 34)">
          <IdentNode start="(522, 17)" end="(522, 34)" leading="" trailing=" " raw_val="findIdx_singleton" val="findIdx_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(522, 35)" end="(522, 96)">
          <NullNode start="(522, 35)" end="(522, 57)">
            <OtherNode start="(522, 35)" end="(522, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(522, 35)" end="(522, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(522, 36)" end="(522, 37)">
                <IdentNode start="(522, 36)" end="(522, 37)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(522, 38)" end="(522, 41)">
                <AtomNode start="(522, 38)" end="(522, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(522, 40)" end="(522, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(522, 41)" end="(522, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(522, 43)" end="(522, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(522, 43)" end="(522, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(522, 44)" end="(522, 45)">
                <IdentNode start="(522, 44)" end="(522, 45)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(522, 46)" end="(522, 56)">
                <AtomNode start="(522, 46)" end="(522, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(522, 48)" end="(522, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(522, 48)" end="(522, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(522, 50)" end="(522, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(522, 52)" end="(522, 56)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(522, 56)" end="(522, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(522, 58)" end="(522, 96)">
            <AtomNode start="(522, 58)" end="(522, 59)" leading="" trailing=" " val=":"/>
            <OtherNode start="(522, 60)" end="(522, 96)" kind="«term_=_»">
              <OtherNode start="(522, 60)" end="(522, 73)" kind="Lean.Parser.Term.app">
                <OtherNode start="(522, 60)" end="(522, 71)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(522, 60)" end="(522, 63)" kind="«term[_]»">
                    <AtomNode start="(522, 60)" end="(522, 61)" leading="" trailing="" val="["/>
                    <NullNode start="(522, 61)" end="(522, 62)">
                      <IdentNode start="(522, 61)" end="(522, 62)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(522, 62)" end="(522, 63)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(522, 63)" end="(522, 64)" leading="" trailing="" val="."/>
                  <IdentNode start="(522, 64)" end="(522, 71)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="List.findIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(522, 72)" end="(522, 73)">
                  <IdentNode start="(522, 72)" end="(522, 73)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(522, 74)" end="(522, 75)" leading="" trailing=" " val="="/>
              <OtherNode start="(522, 76)" end="(522, 96)" kind="termIfThenElse">
                <AtomNode start="(522, 76)" end="(522, 78)" leading="" trailing=" " val="if"/>
                <OtherNode start="(522, 79)" end="(522, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(522, 79)" end="(522, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(522, 81)" end="(522, 82)">
                    <IdentNode start="(522, 81)" end="(522, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(522, 83)" end="(522, 87)" leading="" trailing=" " val="then"/>
                <OtherNode start="(522, 88)" end="(522, 89)" kind="num">
                  <AtomNode start="(522, 88)" end="(522, 89)" leading="" trailing=" " val="0"/>
                </OtherNode>
                <AtomNode start="(522, 90)" end="(522, 94)" leading="" trailing=" " val="else"/>
                <OtherNode start="(522, 95)" end="(522, 96)" kind="num">
                  <AtomNode start="(522, 95)" end="(522, 96)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(522, 97)" end="(523, 35)">
          <AtomNode start="(522, 97)" end="(522, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(522, 100)" end="(523, 35)">
            <AtomNode start="(522, 100)" end="(522, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(523, 3)" end="(523, 35)">
              <TacticTacticseq1IndentedNode start="(523, 3)" end="(523, 35)">
                <NullNode start="(523, 3)" end="(523, 35)">
                  <OtherNode start="(523, 3)" end="(523, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ findIdx p [a] = if p a = true then 0 else 1" state_after="no goals" tactic="simp [findIdx_cons, findIdx_nil]">
                    <AtomNode start="(523, 3)" end="(523, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(523, 8)" end="(523, 35)">
                      <AtomNode start="(523, 8)" end="(523, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(523, 9)" end="(523, 34)">
                        <OtherNode start="(523, 9)" end="(523, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(523, 9)" end="(523, 21)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                        </OtherNode>
                        <AtomNode start="(523, 21)" end="(523, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(523, 23)" end="(523, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(523, 23)" end="(523, 34)" leading="" trailing="" raw_val="findIdx_nil" val="findIdx_nil" full_name="List.findIdx_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(523, 34)" end="(523, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(525, 1)" end="(528, 65)" name="findIdx_of_getElem?_eq_some" full_name="List.findIdx_of_getElem?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(525, 1)" end="(528, 65)" name="findIdx_of_getElem?_eq_some" full_name="List.findIdx_of_getElem?_eq_some" _is_private_decl="False">
        <AtomNode start="(525, 1)" end="(525, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(525, 9)" end="(525, 36)">
          <IdentNode start="(525, 9)" end="(525, 36)" leading="" trailing=" " raw_val="findIdx_of_getElem?_eq_some" val="findIdx_of_getElem?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(525, 37)" end="(525, 89)">
          <NullNode start="(525, 37)" end="(525, 83)">
            <OtherNode start="(525, 37)" end="(525, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(525, 37)" end="(525, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(525, 38)" end="(525, 40)">
                <IdentNode start="(525, 38)" end="(525, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(525, 41)" end="(525, 49)">
                <AtomNode start="(525, 41)" end="(525, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(525, 43)" end="(525, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(525, 43)" end="(525, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(525, 48)" end="(525, 49)">
                    <IdentNode start="(525, 48)" end="(525, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(525, 49)" end="(525, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(525, 51)" end="(525, 83)">
              <AtomNode start="(525, 51)" end="(525, 52)" leading="" trailing="" val="("/>
              <NullNode start="(525, 52)" end="(525, 53)">
                <IdentNode start="(525, 52)" end="(525, 53)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(525, 54)" end="(525, 82)">
                <AtomNode start="(525, 54)" end="(525, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(525, 56)" end="(525, 82)" kind="«term_=_»">
                  <OtherNode start="(525, 56)" end="(525, 73)" kind="«term__[_]_?»">
                    <IdentNode start="(525, 56)" end="(525, 58)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <GroupNode/>
                    <AtomNode start="(525, 58)" end="(525, 59)" leading="" trailing="" val="["/>
                    <OtherNode start="(525, 59)" end="(525, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(525, 59)" end="(525, 69)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(525, 70)" end="(525, 71)">
                        <IdentNode start="(525, 70)" end="(525, 71)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(525, 71)" end="(525, 72)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(525, 72)" end="(525, 73)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(525, 74)" end="(525, 75)" leading="" trailing=" " val="="/>
                  <OtherNode start="(525, 76)" end="(525, 82)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(525, 76)" end="(525, 80)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(525, 81)" end="(525, 82)">
                      <IdentNode start="(525, 81)" end="(525, 82)" leading="" trailing="" raw_val="y" val="y"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(525, 82)" end="(525, 83)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(525, 84)" end="(525, 89)">
            <AtomNode start="(525, 84)" end="(525, 85)" leading="" trailing=" " val=":"/>
            <OtherNode start="(525, 86)" end="(525, 89)" kind="Lean.Parser.Term.app">
              <IdentNode start="(525, 86)" end="(525, 87)" leading="" trailing=" " raw_val="p" val="p"/>
              <NullNode start="(525, 88)" end="(525, 89)">
                <IdentNode start="(525, 88)" end="(525, 89)" leading="" trailing=" " raw_val="y" val="y"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(525, 90)" end="(528, 65)">
          <AtomNode start="(525, 90)" end="(525, 92)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(525, 93)" end="(528, 65)">
            <AtomNode start="(525, 93)" end="(525, 95)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(526, 3)" end="(528, 65)">
              <TacticTacticseq1IndentedNode start="(526, 3)" end="(528, 65)">
                <NullNode start="(526, 3)" end="(528, 65)">
                  <OtherNode start="(526, 3)" end="(528, 65)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;y : α&#10;xs : List α&#10;w : xs[findIdx p xs]? = some y&#10;⊢ p y = true" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt; by_cases h : p x &amp;lt;;&amp;gt; simp_all [findIdx_cons]">
                    <AtomNode start="(526, 3)" end="(526, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(526, 13)" end="(526, 15)">
                      <OtherNode start="(526, 13)" end="(526, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(526, 13)" end="(526, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(526, 16)" end="(528, 65)">
                      <OtherNode start="(526, 16)" end="(528, 65)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(526, 16)" end="(526, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(527, 3)" end="(528, 65)">
                          <OtherNode start="(527, 3)" end="(527, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(527, 3)" end="(527, 8)">
                              <OtherNode start="(527, 3)" end="(527, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(527, 3)" end="(527, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(527, 5)" end="(527, 8)">
                                  <NullNode/>
                                  <IdentNode start="(527, 5)" end="(527, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(527, 9)" end="(527, 20)">
                              <AtomNode start="(527, 9)" end="(527, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(527, 12)" end="(527, 20)">
                                <TacticTacticseq1IndentedNode start="(527, 12)" end="(527, 20)">
                                  <NullNode start="(527, 12)" end="(527, 20)">
                                    <OtherNode start="(527, 12)" end="(527, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;y : α&#10;w : [][findIdx p []]? = some y&#10;⊢ p y = true" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(527, 12)" end="(527, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(528, 3)" end="(528, 65)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(528, 3)" end="(528, 17)">
                              <OtherNode start="(528, 3)" end="(528, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(528, 3)" end="(528, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(528, 5)" end="(528, 9)">
                                  <NullNode/>
                                  <IdentNode start="(528, 5)" end="(528, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(528, 10)" end="(528, 17)">
                                  <IdentNode start="(528, 10)" end="(528, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(528, 12)" end="(528, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(528, 15)" end="(528, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(528, 18)" end="(528, 65)">
                              <AtomNode start="(528, 18)" end="(528, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(528, 21)" end="(528, 65)">
                                <TacticTacticseq1IndentedNode start="(528, 21)" end="(528, 65)">
                                  <NullNode start="(528, 21)" end="(528, 65)">
                                    <OtherNode start="(528, 21)" end="(528, 65)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;y x : α&#10;xs : List α&#10;ih : xs[findIdx p xs]? = some y → p y = true&#10;w : (x :: xs)[findIdx p (x :: xs)]? = some y&#10;⊢ p y = true" state_after="no goals" tactic="by_cases h : p x &amp;lt;;&amp;gt; simp_all [findIdx_cons]">
                                      <OtherNode start="(528, 21)" end="(528, 37)" kind="«tacticBy_cases_:_»">
                                        <AtomNode start="(528, 21)" end="(528, 29)" leading="" trailing=" " val="by_cases"/>
                                        <NullNode start="(528, 30)" end="(528, 33)">
                                          <IdentNode start="(528, 30)" end="(528, 31)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <AtomNode start="(528, 32)" end="(528, 33)" leading="" trailing=" " val=":"/>
                                        </NullNode>
                                        <OtherNode start="(528, 34)" end="(528, 37)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(528, 34)" end="(528, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                                          <NullNode start="(528, 36)" end="(528, 37)">
                                            <IdentNode start="(528, 36)" end="(528, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(528, 38)" end="(528, 41)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(528, 42)" end="(528, 65)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(528, 42)" end="(528, 50)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(528, 51)" end="(528, 65)">
                                          <AtomNode start="(528, 51)" end="(528, 52)" leading="" trailing="" val="["/>
                                          <NullNode start="(528, 52)" end="(528, 64)">
                                            <OtherNode start="(528, 52)" end="(528, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(528, 52)" end="(528, 64)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(528, 64)" end="(528, 65)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(530, 1)" end="(532, 57)" name="findIdx_getElem" full_name="List.findIdx_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(530, 1)" end="(532, 57)" name="findIdx_getElem" full_name="List.findIdx_getElem" _is_private_decl="False">
        <AtomNode start="(530, 1)" end="(530, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(530, 9)" end="(530, 24)">
          <IdentNode start="(530, 9)" end="(530, 24)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(530, 25)" end="(531, 23)">
          <NullNode start="(530, 25)" end="(530, 69)">
            <OtherNode start="(530, 25)" end="(530, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(530, 25)" end="(530, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(530, 26)" end="(530, 28)">
                <IdentNode start="(530, 26)" end="(530, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(530, 29)" end="(530, 37)">
                <AtomNode start="(530, 29)" end="(530, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(530, 31)" end="(530, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(530, 31)" end="(530, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(530, 36)" end="(530, 37)">
                    <IdentNode start="(530, 36)" end="(530, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(530, 37)" end="(530, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(530, 39)" end="(530, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(530, 39)" end="(530, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(530, 40)" end="(530, 41)">
                <IdentNode start="(530, 40)" end="(530, 41)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(530, 42)" end="(530, 68)">
                <AtomNode start="(530, 42)" end="(530, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(530, 44)" end="(530, 68)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(530, 44)" end="(530, 56)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(530, 44)" end="(530, 54)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(530, 55)" end="(530, 56)">
                      <IdentNode start="(530, 55)" end="(530, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(530, 57)" end="(530, 58)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(530, 59)" end="(530, 68)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(530, 68)" end="(530, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(530, 70)" end="(531, 23)">
            <AtomNode start="(530, 70)" end="(530, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(531, 5)" end="(531, 23)" kind="Lean.Parser.Term.app">
              <IdentNode start="(531, 5)" end="(531, 6)" leading="" trailing=" " raw_val="p" val="p"/>
              <NullNode start="(531, 7)" end="(531, 23)">
                <OtherNode start="(531, 7)" end="(531, 23)" kind="«term__[_]»">
                  <IdentNode start="(531, 7)" end="(531, 9)" leading="" trailing="" raw_val="xs" val="xs"/>
                  <AtomNode start="(531, 9)" end="(531, 10)" leading="" trailing="" val="["/>
                  <OtherNode start="(531, 10)" end="(531, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(531, 10)" end="(531, 20)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(531, 21)" end="(531, 22)">
                      <IdentNode start="(531, 21)" end="(531, 22)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(531, 22)" end="(531, 23)" leading="" trailing=" " val="]"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(531, 24)" end="(532, 57)">
          <AtomNode start="(531, 24)" end="(531, 26)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(532, 3)" end="(532, 57)" kind="Lean.Parser.Term.app">
            <IdentNode start="(532, 3)" end="(532, 33)" leading="" trailing=" " raw_val="xs.findIdx_of_getElem?_eq_some" val="xs.findIdx_of_getElem?_eq_some"/>
            <NullNode start="(532, 34)" end="(532, 57)">
              <OtherNode start="(532, 34)" end="(532, 57)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(532, 34)" end="(532, 35)" leading="" trailing="" val="("/>
                <OtherNode start="(532, 35)" end="(532, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(532, 35)" end="(532, 54)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                  <NullNode start="(532, 55)" end="(532, 56)">
                    <IdentNode start="(532, 55)" end="(532, 56)" leading="" trailing="" raw_val="w" val="w"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(532, 56)" end="(532, 57)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(534, 1)" end="(545, 24)" name="findIdx_lt_length_of_exists" full_name="List.findIdx_lt_length_of_exists">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(534, 1)" end="(545, 24)" name="findIdx_lt_length_of_exists" full_name="List.findIdx_lt_length_of_exists" _is_private_decl="False">
        <AtomNode start="(534, 1)" end="(534, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(534, 9)" end="(534, 36)">
          <IdentNode start="(534, 9)" end="(534, 36)" leading="" trailing=" " raw_val="findIdx_lt_length_of_exists" val="findIdx_lt_length_of_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(534, 37)" end="(535, 29)">
          <NullNode start="(534, 37)" end="(534, 70)">
            <OtherNode start="(534, 37)" end="(534, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(534, 37)" end="(534, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(534, 38)" end="(534, 40)">
                <IdentNode start="(534, 38)" end="(534, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(534, 41)" end="(534, 49)">
                <AtomNode start="(534, 41)" end="(534, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(534, 43)" end="(534, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(534, 43)" end="(534, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(534, 48)" end="(534, 49)">
                    <IdentNode start="(534, 48)" end="(534, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(534, 49)" end="(534, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(534, 51)" end="(534, 70)">
              <AtomNode start="(534, 51)" end="(534, 52)" leading="" trailing="" val="("/>
              <NullNode start="(534, 52)" end="(534, 53)">
                <IdentNode start="(534, 52)" end="(534, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(534, 54)" end="(534, 69)">
                <AtomNode start="(534, 54)" end="(534, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(534, 56)" end="(534, 69)" kind="Lean.«term∃__,_»">
                  <AtomNode start="(534, 56)" end="(534, 57)" leading="" trailing=" " val="∃"/>
                  <LeanBinderidentNode start="(534, 58)" end="(534, 59)">
                    <IdentNode start="(534, 58)" end="(534, 59)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(534, 60)" end="(534, 64)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(534, 60)" end="(534, 61)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(534, 62)" end="(534, 64)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(534, 64)" end="(534, 65)" leading="" trailing=" " val=","/>
                  <OtherNode start="(534, 66)" end="(534, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(534, 66)" end="(534, 67)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(534, 68)" end="(534, 69)">
                      <IdentNode start="(534, 68)" end="(534, 69)" leading="" trailing="" raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(534, 69)" end="(534, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(534, 71)" end="(535, 29)">
            <AtomNode start="(534, 71)" end="(534, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(535, 5)" end="(535, 29)" kind="«term_&amp;lt;_»">
              <OtherNode start="(535, 5)" end="(535, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(535, 5)" end="(535, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(535, 16)" end="(535, 17)">
                  <IdentNode start="(535, 16)" end="(535, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(535, 18)" end="(535, 19)" leading="" trailing=" " val="&amp;lt;"/>
              <IdentNode start="(535, 20)" end="(535, 29)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(535, 30)" end="(545, 24)">
          <AtomNode start="(535, 30)" end="(535, 32)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(535, 33)" end="(545, 24)">
            <AtomNode start="(535, 33)" end="(535, 35)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(536, 3)" end="(545, 24)">
              <TacticTacticseq1IndentedNode start="(536, 3)" end="(545, 24)">
                <NullNode start="(536, 3)" end="(545, 24)">
                  <OtherNode start="(536, 3)" end="(545, 24)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs &amp;lt; xs.length" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt;&#10;  by_cases p x&#10;  · simp_all only [forall_exists_index, and_imp, mem_cons, exists_eq_or_imp, true_or,&#10;      findIdx_cons, cond_true, length_cons]&#10;    apply Nat.succ_pos&#10;  · simp_all [findIdx_cons, Nat.succ_lt_succ_iff]&#10;    obtain ⟨x', m', h'⟩ := h&#10;    exact ih x' m' h'">
                    <AtomNode start="(536, 3)" end="(536, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(536, 13)" end="(536, 15)">
                      <OtherNode start="(536, 13)" end="(536, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(536, 13)" end="(536, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(536, 16)" end="(545, 24)">
                      <OtherNode start="(536, 16)" end="(545, 24)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(536, 16)" end="(536, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(537, 3)" end="(545, 24)">
                          <OtherNode start="(537, 3)" end="(537, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(537, 3)" end="(537, 8)">
                              <OtherNode start="(537, 3)" end="(537, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(537, 3)" end="(537, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(537, 5)" end="(537, 8)">
                                  <NullNode/>
                                  <IdentNode start="(537, 5)" end="(537, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(537, 9)" end="(537, 20)">
                              <AtomNode start="(537, 9)" end="(537, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(537, 12)" end="(537, 20)">
                                <TacticTacticseq1IndentedNode start="(537, 12)" end="(537, 20)">
                                  <NullNode start="(537, 12)" end="(537, 20)">
                                    <OtherNode start="(537, 12)" end="(537, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;h : ∃ x, x ∈ [] ∧ p x = true&#10;⊢ findIdx p [] &amp;lt; [].length" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(537, 12)" end="(537, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(538, 3)" end="(545, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(538, 3)" end="(538, 17)">
                              <OtherNode start="(538, 3)" end="(538, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(538, 3)" end="(538, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(538, 5)" end="(538, 9)">
                                  <NullNode/>
                                  <IdentNode start="(538, 5)" end="(538, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(538, 10)" end="(538, 17)">
                                  <IdentNode start="(538, 10)" end="(538, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(538, 12)" end="(538, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(538, 15)" end="(538, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(538, 18)" end="(545, 24)">
                              <AtomNode start="(538, 18)" end="(538, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(539, 5)" end="(545, 24)">
                                <TacticTacticseq1IndentedNode start="(539, 5)" end="(545, 24)">
                                  <NullNode start="(539, 5)" end="(545, 24)">
                                    <OtherNode start="(539, 5)" end="(539, 17)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" tactic="by_cases p x">
                                      <AtomNode start="(539, 5)" end="(539, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode/>
                                      <OtherNode start="(539, 14)" end="(539, 17)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(539, 14)" end="(539, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                                        <NullNode start="(539, 16)" end="(539, 17)">
                                          <IdentNode start="(539, 16)" end="(539, 17)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(540, 5)" end="(542, 25)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" tactic="· simp_all only [forall_exists_index, and_imp, mem_cons, exists_eq_or_imp, true_or,&#10;    findIdx_cons, cond_true, length_cons]&#10;  apply Nat.succ_pos">
                                      <OtherNode start="(540, 5)" end="(540, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(540, 5)" end="(540, 6)" kind="patternIgnore">
                                          <OtherNode start="(540, 5)" end="(540, 6)" kind="token.«· »">
                                            <AtomNode start="(540, 5)" end="(540, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(540, 7)" end="(542, 25)">
                                        <TacticTacticseq1IndentedNode start="(540, 7)" end="(542, 25)">
                                          <NullNode start="(540, 7)" end="(542, 25)">
                                            <OtherNode start="(540, 7)" end="(541, 46)" kind="Lean.Parser.Tactic.simpAll" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (x : α), x ∈ xs → p x = true → findIdx p xs &amp;lt; xs.length&#10;h✝ : p x = true&#10;⊢ 0 &amp;lt; xs.length + 1" tactic="simp_all only [forall_exists_index, and_imp, mem_cons, exists_eq_or_imp, true_or,&#10;  findIdx_cons, cond_true, length_cons]">
                                              <AtomNode start="(540, 7)" end="(540, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(540, 16)" end="(540, 20)">
                                                <AtomNode start="(540, 16)" end="(540, 20)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(540, 21)" end="(541, 46)">
                                                <AtomNode start="(540, 21)" end="(540, 22)" leading="" trailing="" val="["/>
                                                <NullNode start="(540, 22)" end="(541, 45)">
                                                  <OtherNode start="(540, 22)" end="(540, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(540, 22)" end="(540, 41)" leading="" trailing="" raw_val="forall_exists_index" val="forall_exists_index" full_name="forall_exists_index" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(540, 41)" end="(540, 42)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(540, 43)" end="(540, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(540, 43)" end="(540, 50)" leading="" trailing="" raw_val="and_imp" val="and_imp" full_name="and_imp" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(540, 50)" end="(540, 51)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(540, 52)" end="(540, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(540, 52)" end="(540, 60)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(540, 60)" end="(540, 61)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(540, 62)" end="(540, 78)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(540, 62)" end="(540, 78)" leading="" trailing="" raw_val="exists_eq_or_imp" val="exists_eq_or_imp" full_name="exists_eq_or_imp" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(540, 78)" end="(540, 79)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(540, 80)" end="(540, 87)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(540, 80)" end="(540, 87)" leading="" trailing="" raw_val="true_or" val="true_or" full_name="true_or" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(540, 87)" end="(540, 88)" leading="" trailing="&#10;        " val=","/>
                                                  <OtherNode start="(541, 9)" end="(541, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(541, 9)" end="(541, 21)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(541, 21)" end="(541, 22)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(541, 23)" end="(541, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(541, 23)" end="(541, 32)" leading="" trailing="" raw_val="cond_true" val="cond_true" full_name="cond_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(541, 32)" end="(541, 33)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(541, 34)" end="(541, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(541, 34)" end="(541, 45)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(541, 45)" end="(541, 46)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(542, 7)" end="(542, 25)" kind="Lean.Parser.Tactic.apply" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (x : α), x ∈ xs → p x = true → findIdx p xs &amp;lt; xs.length&#10;h✝ : p x = true&#10;⊢ 0 &amp;lt; xs.length + 1" state_after="no goals" tactic="apply Nat.succ_pos">
                                              <AtomNode start="(542, 7)" end="(542, 12)" leading="" trailing=" " val="apply"/>
                                              <IdentNode start="(542, 13)" end="(542, 25)" leading="" trailing="&#10;    " raw_val="Nat.succ_pos" val="Nat.succ_pos" full_name="Nat.succ_pos" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(543, 5)" end="(545, 24)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" state_after="no goals" tactic="· simp_all [findIdx_cons, Nat.succ_lt_succ_iff]&#10;  obtain ⟨x', m', h'⟩ := h&#10;  exact ih x' m' h'">
                                      <OtherNode start="(543, 5)" end="(543, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(543, 5)" end="(543, 6)" kind="patternIgnore">
                                          <OtherNode start="(543, 5)" end="(543, 6)" kind="token.«· »">
                                            <AtomNode start="(543, 5)" end="(543, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(543, 7)" end="(545, 24)">
                                        <TacticTacticseq1IndentedNode start="(543, 7)" end="(545, 24)">
                                          <NullNode start="(543, 7)" end="(545, 24)">
                                            <OtherNode start="(543, 7)" end="(543, 52)" kind="Lean.Parser.Tactic.simpAll" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∃ x, x ∈ xs ∧ p x = true) → findIdx p xs &amp;lt; xs.length&#10;h : ∃ x_1, x_1 ∈ x :: xs ∧ p x_1 = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx p (x :: xs) &amp;lt; (x :: xs).length" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (x : α), x ∈ xs → p x = true → findIdx p xs &amp;lt; xs.length&#10;h : ∃ a, a ∈ xs ∧ p a = true&#10;h✝ : p x = false&#10;⊢ findIdx p xs &amp;lt; xs.length" tactic="simp_all [findIdx_cons, Nat.succ_lt_succ_iff]">
                                              <AtomNode start="(543, 7)" end="(543, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(543, 16)" end="(543, 52)">
                                                <AtomNode start="(543, 16)" end="(543, 17)" leading="" trailing="" val="["/>
                                                <NullNode start="(543, 17)" end="(543, 51)">
                                                  <OtherNode start="(543, 17)" end="(543, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(543, 17)" end="(543, 29)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(543, 29)" end="(543, 30)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(543, 31)" end="(543, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(543, 31)" end="(543, 51)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(543, 51)" end="(543, 52)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(544, 7)" end="(544, 31)" kind="Lean.Parser.Tactic.obtain" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (x : α), x ∈ xs → p x = true → findIdx p xs &amp;lt; xs.length&#10;h : ∃ a, a ∈ xs ∧ p a = true&#10;h✝ : p x = false&#10;⊢ findIdx p xs &amp;lt; xs.length" state_after="case neg.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (x : α), x ∈ xs → p x = true → findIdx p xs &amp;lt; xs.length&#10;h✝ : p x = false&#10;x' : α&#10;m' : x' ∈ xs&#10;h' : p x' = true&#10;⊢ findIdx p xs &amp;lt; xs.length" tactic="obtain ⟨x', m', h'⟩ := h">
                                              <AtomNode start="(544, 7)" end="(544, 13)" leading="" trailing=" " val="obtain"/>
                                              <NullNode start="(544, 14)" end="(544, 26)">
                                                <OtherNode start="(544, 14)" end="(544, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(544, 14)" end="(544, 26)">
                                                    <OtherNode start="(544, 14)" end="(544, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                      <AtomNode start="(544, 14)" end="(544, 15)" leading="" trailing="" val="⟨"/>
                                                      <NullNode start="(544, 15)" end="(544, 25)">
                                                        <OtherNode start="(544, 15)" end="(544, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(544, 15)" end="(544, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(544, 15)" end="(544, 17)">
                                                            <OtherNode start="(544, 15)" end="(544, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(544, 15)" end="(544, 17)" leading="" trailing="" raw_val="x'" val="x'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(544, 17)" end="(544, 18)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(544, 19)" end="(544, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(544, 19)" end="(544, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(544, 19)" end="(544, 21)">
                                                            <OtherNode start="(544, 19)" end="(544, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(544, 19)" end="(544, 21)" leading="" trailing="" raw_val="m'" val="m'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(544, 21)" end="(544, 22)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(544, 23)" end="(544, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                          <OtherNode start="(544, 23)" end="(544, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(544, 23)" end="(544, 25)">
                                                            <OtherNode start="(544, 23)" end="(544, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(544, 23)" end="(544, 25)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(544, 25)" end="(544, 26)" leading="" trailing=" " val="⟩"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(544, 27)" end="(544, 31)">
                                                <AtomNode start="(544, 27)" end="(544, 29)" leading="" trailing=" " val=":="/>
                                                <NullNode start="(544, 30)" end="(544, 31)">
                                                  <IdentNode start="(544, 30)" end="(544, 31)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                </NullNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(545, 7)" end="(545, 24)" kind="Lean.Parser.Tactic.exact" state_before="case neg.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ (x : α), x ∈ xs → p x = true → findIdx p xs &amp;lt; xs.length&#10;h✝ : p x = false&#10;x' : α&#10;m' : x' ∈ xs&#10;h' : p x' = true&#10;⊢ findIdx p xs &amp;lt; xs.length" state_after="no goals" tactic="exact ih x' m' h'">
                                              <AtomNode start="(545, 7)" end="(545, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(545, 13)" end="(545, 24)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(545, 13)" end="(545, 15)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(545, 16)" end="(545, 24)">
                                                  <IdentNode start="(545, 16)" end="(545, 18)" leading="" trailing=" " raw_val="x'" val="x'"/>
                                                  <IdentNode start="(545, 19)" end="(545, 21)" leading="" trailing=" " raw_val="m'" val="m'"/>
                                                  <IdentNode start="(545, 22)" end="(545, 24)" leading="" trailing="&#10;&#10;" raw_val="h'" val="h'"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(547, 1)" end="(549, 54)" name="findIdx_getElem?_eq_getElem_of_exists" full_name="List.findIdx_getElem?_eq_getElem_of_exists">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(547, 1)" end="(549, 54)" name="findIdx_getElem?_eq_getElem_of_exists" full_name="List.findIdx_getElem?_eq_getElem_of_exists" _is_private_decl="False">
        <AtomNode start="(547, 1)" end="(547, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(547, 9)" end="(547, 46)">
          <IdentNode start="(547, 9)" end="(547, 46)" leading="" trailing=" " raw_val="findIdx_getElem?_eq_getElem_of_exists" val="findIdx_getElem?_eq_getElem_of_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(547, 47)" end="(548, 83)">
          <NullNode start="(547, 47)" end="(547, 80)">
            <OtherNode start="(547, 47)" end="(547, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(547, 47)" end="(547, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(547, 48)" end="(547, 50)">
                <IdentNode start="(547, 48)" end="(547, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(547, 51)" end="(547, 59)">
                <AtomNode start="(547, 51)" end="(547, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(547, 53)" end="(547, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(547, 53)" end="(547, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(547, 58)" end="(547, 59)">
                    <IdentNode start="(547, 58)" end="(547, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(547, 59)" end="(547, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(547, 61)" end="(547, 80)">
              <AtomNode start="(547, 61)" end="(547, 62)" leading="" trailing="" val="("/>
              <NullNode start="(547, 62)" end="(547, 63)">
                <IdentNode start="(547, 62)" end="(547, 63)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(547, 64)" end="(547, 79)">
                <AtomNode start="(547, 64)" end="(547, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(547, 66)" end="(547, 79)" kind="Lean.«term∃__,_»">
                  <AtomNode start="(547, 66)" end="(547, 67)" leading="" trailing=" " val="∃"/>
                  <LeanBinderidentNode start="(547, 68)" end="(547, 69)">
                    <IdentNode start="(547, 68)" end="(547, 69)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(547, 70)" end="(547, 74)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(547, 70)" end="(547, 71)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(547, 72)" end="(547, 74)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(547, 74)" end="(547, 75)" leading="" trailing=" " val=","/>
                  <OtherNode start="(547, 76)" end="(547, 79)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(547, 76)" end="(547, 77)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(547, 78)" end="(547, 79)">
                      <IdentNode start="(547, 78)" end="(547, 79)" leading="" trailing="" raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(547, 79)" end="(547, 80)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(547, 81)" end="(548, 83)">
            <AtomNode start="(547, 81)" end="(547, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(548, 5)" end="(548, 83)" kind="«term_=_»">
              <OtherNode start="(548, 5)" end="(548, 22)" kind="«term__[_]_?»">
                <IdentNode start="(548, 5)" end="(548, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                <GroupNode/>
                <AtomNode start="(548, 7)" end="(548, 8)" leading="" trailing="" val="["/>
                <OtherNode start="(548, 8)" end="(548, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(548, 8)" end="(548, 18)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(548, 19)" end="(548, 20)">
                    <IdentNode start="(548, 19)" end="(548, 20)" leading="" trailing="" raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(548, 20)" end="(548, 21)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(548, 21)" end="(548, 22)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(548, 23)" end="(548, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(548, 25)" end="(548, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(548, 25)" end="(548, 29)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(548, 30)" end="(548, 83)">
                  <OtherNode start="(548, 30)" end="(548, 83)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(548, 30)" end="(548, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(548, 31)" end="(548, 82)" kind="«term__[_]'_»">
                      <IdentNode start="(548, 31)" end="(548, 33)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(548, 33)" end="(548, 34)" leading="" trailing="" val="["/>
                      <OtherNode start="(548, 34)" end="(548, 46)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(548, 34)" end="(548, 44)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                        <NullNode start="(548, 45)" end="(548, 46)">
                          <IdentNode start="(548, 45)" end="(548, 46)" leading="" trailing="" raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(548, 46)" end="(548, 48)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(548, 48)" end="(548, 82)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(548, 48)" end="(548, 49)" leading="" trailing="" val="("/>
                        <OtherNode start="(548, 49)" end="(548, 81)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(548, 49)" end="(548, 79)" leading="" trailing=" " raw_val="xs.findIdx_lt_length_of_exists" val="xs.findIdx_lt_length_of_exists"/>
                          <NullNode start="(548, 80)" end="(548, 81)">
                            <IdentNode start="(548, 80)" end="(548, 81)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(548, 81)" end="(548, 82)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(548, 82)" end="(548, 83)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(548, 84)" end="(549, 54)">
          <AtomNode start="(548, 84)" end="(548, 86)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(549, 3)" end="(549, 54)" kind="Lean.Parser.Term.app">
            <IdentNode start="(549, 3)" end="(549, 22)" leading="" trailing=" " raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="List.getElem?_eq_getElem" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
            <NullNode start="(549, 23)" end="(549, 54)">
              <OtherNode start="(549, 23)" end="(549, 54)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(549, 23)" end="(549, 24)" leading="" trailing="" val="("/>
                <OtherNode start="(549, 24)" end="(549, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(549, 24)" end="(549, 51)" leading="" trailing=" " raw_val="findIdx_lt_length_of_exists" val="findIdx_lt_length_of_exists" full_name="List.findIdx_lt_length_of_exists" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(534, 9)" def_end="(534, 36)"/>
                  <NullNode start="(549, 52)" end="(549, 53)">
                    <IdentNode start="(549, 52)" end="(549, 53)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(549, 53)" end="(549, 54)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(551, 1)" end="(559, 40)" name="findIdx_eq_length" full_name="List.findIdx_eq_length">
      <CommandDeclmodifiersNode start="(551, 1)" end="(551, 8)">
        <NullNode/>
        <NullNode start="(551, 1)" end="(551, 8)">
          <OtherNode start="(551, 1)" end="(551, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(551, 1)" end="(551, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(551, 3)" end="(551, 7)">
              <OtherNode start="(551, 3)" end="(551, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(551, 3)" end="(551, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(551, 3)" end="(551, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(551, 7)" end="(551, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(552, 1)" end="(559, 40)" name="findIdx_eq_length" full_name="List.findIdx_eq_length" _is_private_decl="False">
        <AtomNode start="(552, 1)" end="(552, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(552, 9)" end="(552, 26)">
          <IdentNode start="(552, 9)" end="(552, 26)" leading="" trailing=" " raw_val="findIdx_eq_length" val="findIdx_eq_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(552, 27)" end="(553, 53)">
          <NullNode start="(552, 27)" end="(552, 55)">
            <OtherNode start="(552, 27)" end="(552, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(552, 27)" end="(552, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(552, 28)" end="(552, 29)">
                <IdentNode start="(552, 28)" end="(552, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(552, 30)" end="(552, 40)">
                <AtomNode start="(552, 30)" end="(552, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(552, 32)" end="(552, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(552, 32)" end="(552, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(552, 34)" end="(552, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(552, 36)" end="(552, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(552, 40)" end="(552, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(552, 42)" end="(552, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(552, 42)" end="(552, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(552, 43)" end="(552, 45)">
                <IdentNode start="(552, 43)" end="(552, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(552, 46)" end="(552, 54)">
                <AtomNode start="(552, 46)" end="(552, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(552, 48)" end="(552, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(552, 48)" end="(552, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(552, 53)" end="(552, 54)">
                    <IdentNode start="(552, 53)" end="(552, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(552, 54)" end="(552, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(552, 56)" end="(553, 53)">
            <AtomNode start="(552, 56)" end="(552, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(553, 5)" end="(553, 53)" kind="«term_↔_»">
              <OtherNode start="(553, 5)" end="(553, 29)" kind="«term_=_»">
                <OtherNode start="(553, 5)" end="(553, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(553, 5)" end="(553, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(553, 16)" end="(553, 17)">
                    <IdentNode start="(553, 16)" end="(553, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(553, 18)" end="(553, 19)" leading="" trailing=" " val="="/>
                <IdentNode start="(553, 20)" end="(553, 29)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
              </OtherNode>
              <AtomNode start="(553, 30)" end="(553, 31)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(553, 32)" end="(553, 53)" kind="Lean.«term∀__,_»">
                <AtomNode start="(553, 32)" end="(553, 33)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(553, 34)" end="(553, 35)">
                  <IdentNode start="(553, 34)" end="(553, 35)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(553, 36)" end="(553, 40)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(553, 36)" end="(553, 37)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(553, 38)" end="(553, 40)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(553, 40)" end="(553, 41)" leading="" trailing=" " val=","/>
                <OtherNode start="(553, 42)" end="(553, 53)" kind="«term_=_»">
                  <OtherNode start="(553, 42)" end="(553, 45)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(553, 42)" end="(553, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(553, 44)" end="(553, 45)">
                      <IdentNode start="(553, 44)" end="(553, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(553, 46)" end="(553, 47)" leading="" trailing=" " val="="/>
                  <IdentNode start="(553, 48)" end="(553, 53)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(553, 54)" end="(559, 40)">
          <AtomNode start="(553, 54)" end="(553, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(553, 57)" end="(559, 40)">
            <AtomNode start="(553, 57)" end="(553, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(554, 3)" end="(559, 40)">
              <TacticTacticseq1IndentedNode start="(554, 3)" end="(559, 40)">
                <NullNode start="(554, 3)" end="(559, 40)">
                  <OtherNode start="(554, 3)" end="(559, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p xs = xs.length ↔ ∀ (x : α), x ∈ xs → p x = false" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt;&#10;  rw [findIdx_cons, length_cons]&#10;  simp only [cond_eq_if]&#10;  split &amp;lt;;&amp;gt; simp_all [Nat.succ.injEq]">
                    <AtomNode start="(554, 3)" end="(554, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(554, 13)" end="(554, 15)">
                      <OtherNode start="(554, 13)" end="(554, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(554, 13)" end="(554, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(554, 16)" end="(559, 40)">
                      <OtherNode start="(554, 16)" end="(559, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(554, 16)" end="(554, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(555, 3)" end="(559, 40)">
                          <OtherNode start="(555, 3)" end="(555, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(555, 3)" end="(555, 8)">
                              <OtherNode start="(555, 3)" end="(555, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(555, 3)" end="(555, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(555, 5)" end="(555, 8)">
                                  <NullNode/>
                                  <IdentNode start="(555, 5)" end="(555, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(555, 9)" end="(555, 20)">
                              <AtomNode start="(555, 9)" end="(555, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(555, 12)" end="(555, 20)">
                                <TacticTacticseq1IndentedNode start="(555, 12)" end="(555, 20)">
                                  <NullNode start="(555, 12)" end="(555, 20)">
                                    <OtherNode start="(555, 12)" end="(555, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx p [] = [].length ↔ ∀ (x : α), x ∈ [] → p x = false" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(555, 12)" end="(555, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(556, 3)" end="(559, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(556, 3)" end="(556, 17)">
                              <OtherNode start="(556, 3)" end="(556, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(556, 3)" end="(556, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(556, 5)" end="(556, 9)">
                                  <NullNode/>
                                  <IdentNode start="(556, 5)" end="(556, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(556, 10)" end="(556, 17)">
                                  <IdentNode start="(556, 10)" end="(556, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(556, 12)" end="(556, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(556, 15)" end="(556, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(556, 18)" end="(559, 40)">
                              <AtomNode start="(556, 18)" end="(556, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(557, 5)" end="(559, 40)">
                                <TacticTacticseq1IndentedNode start="(557, 5)" end="(559, 40)">
                                  <NullNode start="(557, 5)" end="(559, 40)">
                                    <OtherNode start="(557, 5)" end="(557, 35)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = xs.length ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p (x :: xs) = (x :: xs).length ↔ ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = xs.length ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ (bif p x then 0 else findIdx p xs + 1) = xs.length + 1 ↔ ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" tactic="rw [findIdx_cons, length_cons]">
                                      <AtomNode start="(557, 5)" end="(557, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(557, 8)" end="(557, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(557, 8)" end="(557, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(557, 9)" end="(557, 34)">
                                          <OtherNode start="(557, 9)" end="(557, 21)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(557, 9)" end="(557, 21)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                          <AtomNode start="(557, 21)" end="(557, 22)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(557, 23)" end="(557, 34)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(557, 23)" end="(557, 34)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(557, 34)" end="(557, 35)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(558, 5)" end="(558, 27)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = xs.length ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ (bif p x then 0 else findIdx p xs + 1) = xs.length + 1 ↔ ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = xs.length ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ (if p x = true then 0 else findIdx p xs + 1) = xs.length + 1 ↔ ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" tactic="simp only [cond_eq_if]">
                                      <AtomNode start="(558, 5)" end="(558, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(558, 10)" end="(558, 14)">
                                        <AtomNode start="(558, 10)" end="(558, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(558, 15)" end="(558, 27)">
                                        <AtomNode start="(558, 15)" end="(558, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(558, 16)" end="(558, 26)">
                                          <OtherNode start="(558, 16)" end="(558, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(558, 16)" end="(558, 26)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(558, 26)" end="(558, 27)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(559, 5)" end="(559, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = xs.length ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ (if p x = true then 0 else findIdx p xs + 1) = xs.length + 1 ↔ ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [Nat.succ.injEq]">
                                      <OtherNode start="(559, 5)" end="(559, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(559, 5)" end="(559, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(559, 11)" end="(559, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(559, 15)" end="(559, 40)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(559, 15)" end="(559, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(559, 24)" end="(559, 40)">
                                          <AtomNode start="(559, 24)" end="(559, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(559, 25)" end="(559, 39)">
                                            <OtherNode start="(559, 25)" end="(559, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(559, 25)" end="(559, 39)" leading="" trailing="" raw_val="Nat.succ.injEq" val="Nat.succ.injEq" full_name="Nat.succ.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(559, 39)" end="(559, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(561, 1)" end="(564, 10)" name="findIdx_eq_length_of_false" full_name="List.findIdx_eq_length_of_false">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(561, 1)" end="(564, 10)" name="findIdx_eq_length_of_false" full_name="List.findIdx_eq_length_of_false" _is_private_decl="False">
        <AtomNode start="(561, 1)" end="(561, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(561, 9)" end="(561, 35)">
          <IdentNode start="(561, 9)" end="(561, 35)" leading="" trailing=" " raw_val="findIdx_eq_length_of_false" val="findIdx_eq_length_of_false"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(561, 36)" end="(562, 29)">
          <NullNode start="(561, 36)" end="(561, 92)">
            <OtherNode start="(561, 36)" end="(561, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(561, 36)" end="(561, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(561, 37)" end="(561, 38)">
                <IdentNode start="(561, 37)" end="(561, 38)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(561, 39)" end="(561, 49)">
                <AtomNode start="(561, 39)" end="(561, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(561, 41)" end="(561, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(561, 41)" end="(561, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(561, 43)" end="(561, 44)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(561, 45)" end="(561, 49)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(561, 49)" end="(561, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(561, 51)" end="(561, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(561, 51)" end="(561, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(561, 52)" end="(561, 54)">
                <IdentNode start="(561, 52)" end="(561, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(561, 55)" end="(561, 63)">
                <AtomNode start="(561, 55)" end="(561, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(561, 57)" end="(561, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(561, 57)" end="(561, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(561, 62)" end="(561, 63)">
                    <IdentNode start="(561, 62)" end="(561, 63)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(561, 63)" end="(561, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(561, 65)" end="(561, 92)">
              <AtomNode start="(561, 65)" end="(561, 66)" leading="" trailing="" val="("/>
              <NullNode start="(561, 66)" end="(561, 67)">
                <IdentNode start="(561, 66)" end="(561, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(561, 68)" end="(561, 91)">
                <AtomNode start="(561, 68)" end="(561, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(561, 70)" end="(561, 91)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(561, 70)" end="(561, 71)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(561, 72)" end="(561, 73)">
                    <IdentNode start="(561, 72)" end="(561, 73)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(561, 74)" end="(561, 78)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(561, 74)" end="(561, 75)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(561, 76)" end="(561, 78)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(561, 78)" end="(561, 79)" leading="" trailing=" " val=","/>
                  <OtherNode start="(561, 80)" end="(561, 91)" kind="«term_=_»">
                    <OtherNode start="(561, 80)" end="(561, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(561, 80)" end="(561, 81)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(561, 82)" end="(561, 83)">
                        <IdentNode start="(561, 82)" end="(561, 83)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(561, 84)" end="(561, 85)" leading="" trailing=" " val="="/>
                    <IdentNode start="(561, 86)" end="(561, 91)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(561, 91)" end="(561, 92)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(561, 93)" end="(562, 29)">
            <AtomNode start="(561, 93)" end="(561, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(562, 5)" end="(562, 29)" kind="«term_=_»">
              <OtherNode start="(562, 5)" end="(562, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(562, 5)" end="(562, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(562, 16)" end="(562, 17)">
                  <IdentNode start="(562, 16)" end="(562, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(562, 18)" end="(562, 19)" leading="" trailing=" " val="="/>
              <IdentNode start="(562, 20)" end="(562, 29)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(562, 30)" end="(564, 10)">
          <AtomNode start="(562, 30)" end="(562, 32)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(562, 33)" end="(564, 10)">
            <AtomNode start="(562, 33)" end="(562, 35)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(563, 3)" end="(564, 10)">
              <TacticTacticseq1IndentedNode start="(563, 3)" end="(564, 10)">
                <NullNode start="(563, 3)" end="(564, 10)">
                  <OtherNode start="(563, 3)" end="(563, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p xs = xs.length" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ ∀ (x : α), x ∈ xs → p x = false" tactic="rw [findIdx_eq_length]">
                    <AtomNode start="(563, 3)" end="(563, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(563, 6)" end="(563, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(563, 6)" end="(563, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(563, 7)" end="(563, 24)">
                        <OtherNode start="(563, 7)" end="(563, 24)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(563, 7)" end="(563, 24)" leading="" trailing="" raw_val="findIdx_eq_length" val="findIdx_eq_length" full_name="List.findIdx_eq_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(552, 9)" def_end="(552, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(563, 24)" end="(563, 25)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(564, 3)" end="(564, 10)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;h : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ ∀ (x : α), x ∈ xs → p x = false" state_after="no goals" tactic="exact h">
                    <AtomNode start="(564, 3)" end="(564, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(564, 9)" end="(564, 10)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(566, 1)" end="(570, 49)" name="findIdx_le_length" full_name="List.findIdx_le_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(566, 1)" end="(570, 49)" name="findIdx_le_length" full_name="List.findIdx_le_length" _is_private_decl="False">
        <AtomNode start="(566, 1)" end="(566, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(566, 9)" end="(566, 26)">
          <IdentNode start="(566, 9)" end="(566, 26)" leading="" trailing=" " raw_val="findIdx_le_length" val="findIdx_le_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(566, 27)" end="(566, 82)">
          <NullNode start="(566, 27)" end="(566, 55)">
            <OtherNode start="(566, 27)" end="(566, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(566, 27)" end="(566, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(566, 28)" end="(566, 29)">
                <IdentNode start="(566, 28)" end="(566, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(566, 30)" end="(566, 40)">
                <AtomNode start="(566, 30)" end="(566, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(566, 32)" end="(566, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(566, 32)" end="(566, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(566, 34)" end="(566, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(566, 36)" end="(566, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(566, 40)" end="(566, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(566, 42)" end="(566, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(566, 42)" end="(566, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(566, 43)" end="(566, 45)">
                <IdentNode start="(566, 43)" end="(566, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(566, 46)" end="(566, 54)">
                <AtomNode start="(566, 46)" end="(566, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(566, 48)" end="(566, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(566, 48)" end="(566, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(566, 53)" end="(566, 54)">
                    <IdentNode start="(566, 53)" end="(566, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(566, 54)" end="(566, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(566, 56)" end="(566, 82)">
            <AtomNode start="(566, 56)" end="(566, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(566, 58)" end="(566, 82)" kind="«term_≤_»">
              <OtherNode start="(566, 58)" end="(566, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(566, 58)" end="(566, 68)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(566, 69)" end="(566, 70)">
                  <IdentNode start="(566, 69)" end="(566, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(566, 71)" end="(566, 72)" leading="" trailing=" " val="≤"/>
              <IdentNode start="(566, 73)" end="(566, 82)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(566, 83)" end="(570, 49)">
          <AtomNode start="(566, 83)" end="(566, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(566, 86)" end="(570, 49)">
            <AtomNode start="(566, 86)" end="(566, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(567, 3)" end="(570, 49)">
              <TacticTacticseq1IndentedNode start="(567, 3)" end="(570, 49)">
                <NullNode start="(567, 3)" end="(570, 49)">
                  <OtherNode start="(567, 3)" end="(567, 29)" kind="«tacticBy_cases_:_»" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p xs ≤ xs.length" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length" tactic="by_cases e : ∃ x ∈ xs, p x">
                    <AtomNode start="(567, 3)" end="(567, 11)" leading="" trailing=" " val="by_cases"/>
                    <NullNode start="(567, 12)" end="(567, 15)">
                      <IdentNode start="(567, 12)" end="(567, 13)" leading="" trailing=" " raw_val="e" val="e"/>
                      <AtomNode start="(567, 14)" end="(567, 15)" leading="" trailing=" " val=":"/>
                    </NullNode>
                    <OtherNode start="(567, 16)" end="(567, 29)" kind="Lean.«term∃__,_»">
                      <AtomNode start="(567, 16)" end="(567, 17)" leading="" trailing=" " val="∃"/>
                      <LeanBinderidentNode start="(567, 18)" end="(567, 19)">
                        <IdentNode start="(567, 18)" end="(567, 19)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(567, 20)" end="(567, 24)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(567, 20)" end="(567, 21)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(567, 22)" end="(567, 24)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(567, 24)" end="(567, 25)" leading="" trailing=" " val=","/>
                      <OtherNode start="(567, 26)" end="(567, 29)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(567, 26)" end="(567, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(567, 28)" end="(567, 29)">
                          <IdentNode start="(567, 28)" end="(567, 29)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(568, 3)" end="(568, 55)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length" tactic="· exact Nat.le_of_lt (findIdx_lt_length_of_exists e)">
                    <OtherNode start="(568, 3)" end="(568, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(568, 3)" end="(568, 4)" kind="patternIgnore">
                        <OtherNode start="(568, 3)" end="(568, 4)" kind="token.«· »">
                          <AtomNode start="(568, 3)" end="(568, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(568, 5)" end="(568, 55)">
                      <TacticTacticseq1IndentedNode start="(568, 5)" end="(568, 55)">
                        <NullNode start="(568, 5)" end="(568, 55)">
                          <OtherNode start="(568, 5)" end="(568, 55)" kind="Lean.Parser.Tactic.exact" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length" state_after="no goals" tactic="exact Nat.le_of_lt (findIdx_lt_length_of_exists e)">
                            <AtomNode start="(568, 5)" end="(568, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(568, 11)" end="(568, 55)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(568, 11)" end="(568, 23)" leading="" trailing=" " raw_val="Nat.le_of_lt" val="Nat.le_of_lt" full_name="Nat.le_of_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(568, 24)" end="(568, 55)">
                                <OtherNode start="(568, 24)" end="(568, 55)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(568, 24)" end="(568, 25)" leading="" trailing="" val="("/>
                                  <OtherNode start="(568, 25)" end="(568, 54)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(568, 25)" end="(568, 52)" leading="" trailing=" " raw_val="findIdx_lt_length_of_exists" val="findIdx_lt_length_of_exists" full_name="List.findIdx_lt_length_of_exists" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(534, 9)" def_end="(534, 36)"/>
                                    <NullNode start="(568, 53)" end="(568, 54)">
                                      <IdentNode start="(568, 53)" end="(568, 54)" leading="" trailing="" raw_val="e" val="e"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(568, 54)" end="(568, 55)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(569, 3)" end="(570, 49)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length" state_after="no goals" tactic="· simp at e&#10;  exact Nat.le_of_eq (findIdx_eq_length.mpr e)">
                    <OtherNode start="(569, 3)" end="(569, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(569, 3)" end="(569, 4)" kind="patternIgnore">
                        <OtherNode start="(569, 3)" end="(569, 4)" kind="token.«· »">
                          <AtomNode start="(569, 3)" end="(569, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(569, 5)" end="(570, 49)">
                      <TacticTacticseq1IndentedNode start="(569, 5)" end="(570, 49)">
                        <NullNode start="(569, 5)" end="(570, 49)">
                          <OtherNode start="(569, 5)" end="(569, 14)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ¬∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs ≤ xs.length" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p xs ≤ xs.length" tactic="simp at e">
                            <AtomNode start="(569, 5)" end="(569, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(569, 10)" end="(569, 14)">
                              <OtherNode start="(569, 10)" end="(569, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(569, 10)" end="(569, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(569, 13)" end="(569, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(569, 13)" end="(569, 14)">
                                    <IdentNode start="(569, 13)" end="(569, 14)" leading="" trailing="&#10;    " raw_val="e" val="e"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(570, 5)" end="(570, 49)" kind="Lean.Parser.Tactic.exact" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;e : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx p xs ≤ xs.length" state_after="no goals" tactic="exact Nat.le_of_eq (findIdx_eq_length.mpr e)">
                            <AtomNode start="(570, 5)" end="(570, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(570, 11)" end="(570, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(570, 11)" end="(570, 23)" leading="" trailing=" " raw_val="Nat.le_of_eq" val="Nat.le_of_eq" full_name="Nat.le_of_eq" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                              <NullNode start="(570, 24)" end="(570, 49)">
                                <OtherNode start="(570, 24)" end="(570, 49)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(570, 24)" end="(570, 25)" leading="" trailing="" val="("/>
                                  <OtherNode start="(570, 25)" end="(570, 48)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(570, 25)" end="(570, 46)" leading="" trailing=" " raw_val="findIdx_eq_length.mpr" val="findIdx_eq_length.mpr"/>
                                    <NullNode start="(570, 47)" end="(570, 48)">
                                      <IdentNode start="(570, 47)" end="(570, 48)" leading="" trailing="" raw_val="e" val="e"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(570, 48)" end="(570, 49)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(572, 1)" end="(579, 40)" name="findIdx_lt_length" full_name="List.findIdx_lt_length">
      <CommandDeclmodifiersNode start="(572, 1)" end="(572, 8)">
        <NullNode/>
        <NullNode start="(572, 1)" end="(572, 8)">
          <OtherNode start="(572, 1)" end="(572, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(572, 1)" end="(572, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(572, 3)" end="(572, 7)">
              <OtherNode start="(572, 3)" end="(572, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(572, 3)" end="(572, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(572, 3)" end="(572, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(572, 7)" end="(572, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(573, 1)" end="(579, 40)" name="findIdx_lt_length" full_name="List.findIdx_lt_length" _is_private_decl="False">
        <AtomNode start="(573, 1)" end="(573, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(573, 9)" end="(573, 26)">
          <IdentNode start="(573, 9)" end="(573, 26)" leading="" trailing=" " raw_val="findIdx_lt_length" val="findIdx_lt_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(573, 27)" end="(574, 45)">
          <NullNode start="(573, 27)" end="(573, 55)">
            <OtherNode start="(573, 27)" end="(573, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(573, 27)" end="(573, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(573, 28)" end="(573, 29)">
                <IdentNode start="(573, 28)" end="(573, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(573, 30)" end="(573, 40)">
                <AtomNode start="(573, 30)" end="(573, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(573, 32)" end="(573, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(573, 32)" end="(573, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(573, 34)" end="(573, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(573, 36)" end="(573, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(573, 40)" end="(573, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(573, 42)" end="(573, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(573, 42)" end="(573, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(573, 43)" end="(573, 45)">
                <IdentNode start="(573, 43)" end="(573, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(573, 46)" end="(573, 54)">
                <AtomNode start="(573, 46)" end="(573, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(573, 48)" end="(573, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(573, 48)" end="(573, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(573, 53)" end="(573, 54)">
                    <IdentNode start="(573, 53)" end="(573, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(573, 54)" end="(573, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(573, 56)" end="(574, 45)">
            <AtomNode start="(573, 56)" end="(573, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(574, 5)" end="(574, 45)" kind="«term_↔_»">
              <OtherNode start="(574, 5)" end="(574, 29)" kind="«term_&amp;lt;_»">
                <OtherNode start="(574, 5)" end="(574, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(574, 5)" end="(574, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(574, 16)" end="(574, 17)">
                    <IdentNode start="(574, 16)" end="(574, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(574, 18)" end="(574, 19)" leading="" trailing=" " val="&amp;lt;"/>
                <IdentNode start="(574, 20)" end="(574, 29)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
              </OtherNode>
              <AtomNode start="(574, 30)" end="(574, 31)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(574, 32)" end="(574, 45)" kind="Lean.«term∃__,_»">
                <AtomNode start="(574, 32)" end="(574, 33)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(574, 34)" end="(574, 35)">
                  <IdentNode start="(574, 34)" end="(574, 35)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(574, 36)" end="(574, 40)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(574, 36)" end="(574, 37)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(574, 38)" end="(574, 40)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(574, 40)" end="(574, 41)" leading="" trailing=" " val=","/>
                <OtherNode start="(574, 42)" end="(574, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(574, 42)" end="(574, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(574, 44)" end="(574, 45)">
                    <IdentNode start="(574, 44)" end="(574, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(574, 46)" end="(579, 40)">
          <AtomNode start="(574, 46)" end="(574, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(574, 49)" end="(579, 40)">
            <AtomNode start="(574, 49)" end="(574, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(575, 3)" end="(579, 40)">
              <TacticTacticseq1IndentedNode start="(575, 3)" end="(579, 40)">
                <NullNode start="(575, 3)" end="(579, 40)">
                  <OtherNode start="(575, 3)" end="(575, 43)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ findIdx p xs &amp;lt; xs.length ↔ ∃ x, x ∈ xs ∧ p x = true" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ xs.length ≤ findIdx p xs ↔ ¬∃ x, x ∈ xs ∧ p x = true" tactic="rw [← Decidable.not_iff_not, Nat.not_lt]">
                    <AtomNode start="(575, 3)" end="(575, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(575, 6)" end="(575, 43)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(575, 6)" end="(575, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(575, 7)" end="(575, 42)">
                        <OtherNode start="(575, 7)" end="(575, 30)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(575, 7)" end="(575, 8)">
                            <OtherNode start="(575, 7)" end="(575, 8)" kind="patternIgnore">
                              <OtherNode start="(575, 7)" end="(575, 8)" kind="token.«← »">
                                <AtomNode start="(575, 7)" end="(575, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(575, 9)" end="(575, 30)" leading="" trailing="" raw_val="Decidable.not_iff_not" val="Decidable.not_iff_not" full_name="Decidable.not_iff_not" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(575, 30)" end="(575, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(575, 32)" end="(575, 42)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(575, 32)" end="(575, 42)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(575, 42)" end="(575, 43)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(576, 3)" end="(576, 56)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ xs.length ≤ findIdx p xs ↔ ¬∃ x, x ∈ xs ∧ p x = true" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;this : findIdx p xs = xs.length ↔ findIdx p xs ≤ xs.length ∧ xs.length ≤ findIdx p xs&#10;⊢ xs.length ≤ findIdx p xs ↔ ¬∃ x, x ∈ xs ∧ p x = true" tactic="have := @Nat.le_antisymm_iff (xs.findIdx p) xs.length">
                    <AtomNode start="(576, 3)" end="(576, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(576, 8)" end="(576, 56)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(576, 8)" end="(576, 56)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(576, 8)" end="(576, 8)" kind="Lean.Parser.Term.haveId">
                          <OtherNode start="(576, 8)" end="(576, 8)" kind="hygieneInfo">
                            <IdentNode start="(576, 8)" end="(576, 8)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(576, 8)" end="(576, 10)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(576, 11)" end="(576, 56)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(576, 11)" end="(576, 31)" kind="Lean.Parser.Term.explicit">
                            <AtomNode start="(576, 11)" end="(576, 12)" leading="" trailing="" val="@"/>
                            <IdentNode start="(576, 12)" end="(576, 31)" leading="" trailing=" " raw_val="Nat.le_antisymm_iff" val="Nat.le_antisymm_iff" full_name="Nat.le_antisymm_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                          </OtherNode>
                          <NullNode start="(576, 32)" end="(576, 56)">
                            <OtherNode start="(576, 32)" end="(576, 46)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(576, 32)" end="(576, 33)" leading="" trailing="" val="("/>
                              <OtherNode start="(576, 33)" end="(576, 45)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(576, 33)" end="(576, 43)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                <NullNode start="(576, 44)" end="(576, 45)">
                                  <IdentNode start="(576, 44)" end="(576, 45)" leading="" trailing="" raw_val="p" val="p"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(576, 45)" end="(576, 46)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(576, 47)" end="(576, 56)" leading="" trailing="&#10;  " raw_val="xs.length" val="xs.length"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(577, 3)" end="(577, 50)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;this : findIdx p xs = xs.length ↔ findIdx p xs ≤ xs.length ∧ xs.length ≤ findIdx p xs&#10;⊢ xs.length ≤ findIdx p xs ↔ ¬∃ x, x ∈ xs ∧ p x = true" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;this : findIdx p xs = xs.length ↔ xs.length ≤ findIdx p xs&#10;⊢ xs.length ≤ findIdx p xs ↔ ¬∃ x, x ∈ xs ∧ p x = true" tactic="simp only [findIdx_le_length, true_and] at this">
                    <AtomNode start="(577, 3)" end="(577, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(577, 8)" end="(577, 12)">
                      <AtomNode start="(577, 8)" end="(577, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(577, 13)" end="(577, 42)">
                      <AtomNode start="(577, 13)" end="(577, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(577, 14)" end="(577, 41)">
                        <OtherNode start="(577, 14)" end="(577, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(577, 14)" end="(577, 31)" leading="" trailing="" raw_val="findIdx_le_length" val="findIdx_le_length" full_name="List.findIdx_le_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(566, 9)" def_end="(566, 26)"/>
                        </OtherNode>
                        <AtomNode start="(577, 31)" end="(577, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(577, 33)" end="(577, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(577, 33)" end="(577, 41)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(577, 41)" end="(577, 42)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(577, 43)" end="(577, 50)">
                      <OtherNode start="(577, 43)" end="(577, 50)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(577, 43)" end="(577, 45)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(577, 46)" end="(577, 50)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(577, 46)" end="(577, 50)">
                            <IdentNode start="(577, 46)" end="(577, 50)" leading="" trailing="&#10;  " raw_val="this" val="this"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(578, 3)" end="(578, 45)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;this : findIdx p xs = xs.length ↔ xs.length ≤ findIdx p xs&#10;⊢ xs.length ≤ findIdx p xs ↔ ¬∃ x, x ∈ xs ∧ p x = true" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;this : findIdx p xs = xs.length ↔ xs.length ≤ findIdx p xs&#10;⊢ (∀ (x : α), x ∈ xs → p x = false) ↔ ∀ (x : α), ¬(x ∈ xs ∧ p x = true)" tactic="rw [← this, findIdx_eq_length, not_exists]">
                    <AtomNode start="(578, 3)" end="(578, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(578, 6)" end="(578, 45)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(578, 6)" end="(578, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(578, 7)" end="(578, 44)">
                        <OtherNode start="(578, 7)" end="(578, 13)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(578, 7)" end="(578, 8)">
                            <OtherNode start="(578, 7)" end="(578, 8)" kind="patternIgnore">
                              <OtherNode start="(578, 7)" end="(578, 8)" kind="token.«← »">
                                <AtomNode start="(578, 7)" end="(578, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(578, 9)" end="(578, 13)" leading="" trailing="" raw_val="this" val="this"/>
                        </OtherNode>
                        <AtomNode start="(578, 13)" end="(578, 14)" leading="" trailing=" " val=","/>
                        <OtherNode start="(578, 15)" end="(578, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(578, 15)" end="(578, 32)" leading="" trailing="" raw_val="findIdx_eq_length" val="findIdx_eq_length" full_name="List.findIdx_eq_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(552, 9)" def_end="(552, 26)"/>
                        </OtherNode>
                        <AtomNode start="(578, 32)" end="(578, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(578, 34)" end="(578, 44)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(578, 34)" end="(578, 44)" leading="" trailing="" raw_val="not_exists" val="not_exists" full_name="not_exists" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(578, 44)" end="(578, 45)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(579, 3)" end="(579, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;this : findIdx p xs = xs.length ↔ xs.length ≤ findIdx p xs&#10;⊢ (∀ (x : α), x ∈ xs → p x = false) ↔ ∀ (x : α), ¬(x ∈ xs ∧ p x = true)" state_after="no goals" tactic="simp only [Bool.not_eq_true, not_and]">
                    <AtomNode start="(579, 3)" end="(579, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(579, 8)" end="(579, 12)">
                      <AtomNode start="(579, 8)" end="(579, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(579, 13)" end="(579, 40)">
                      <AtomNode start="(579, 13)" end="(579, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(579, 14)" end="(579, 39)">
                        <OtherNode start="(579, 14)" end="(579, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(579, 14)" end="(579, 30)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(579, 30)" end="(579, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(579, 32)" end="(579, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(579, 32)" end="(579, 39)" leading="" trailing="" raw_val="not_and" val="not_and" full_name="not_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(579, 39)" end="(579, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(581, 1)" end="(603, 23)" name="not_of_lt_findIdx" full_name="List.not_of_lt_findIdx">
      <CommandDeclmodifiersNode start="(581, 1)" end="(581, 77)">
        <NullNode start="(581, 1)" end="(581, 77)">
          <CommandDoccommentNode start="(581, 1)" end="(581, 77)" comment="`p` does not hold for elements with indices less than `xs.findIdx p`. -/">
            <AtomNode start="(581, 1)" end="(581, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(581, 5)" end="(581, 77)" leading="" trailing="&#10;" val="`p` does not hold for elements with indices less than `xs.findIdx p`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(582, 1)" end="(603, 23)" name="not_of_lt_findIdx" full_name="List.not_of_lt_findIdx" _is_private_decl="False">
        <AtomNode start="(582, 1)" end="(582, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(582, 9)" end="(582, 26)">
          <IdentNode start="(582, 9)" end="(582, 26)" leading="" trailing=" " raw_val="not_of_lt_findIdx" val="not_of_lt_findIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(582, 27)" end="(583, 57)">
          <NullNode start="(582, 27)" end="(582, 88)">
            <OtherNode start="(582, 27)" end="(582, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(582, 27)" end="(582, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(582, 28)" end="(582, 29)">
                <IdentNode start="(582, 28)" end="(582, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(582, 30)" end="(582, 40)">
                <AtomNode start="(582, 30)" end="(582, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(582, 32)" end="(582, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(582, 32)" end="(582, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(582, 34)" end="(582, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(582, 36)" end="(582, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(582, 40)" end="(582, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(582, 42)" end="(582, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(582, 42)" end="(582, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(582, 43)" end="(582, 45)">
                <IdentNode start="(582, 43)" end="(582, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(582, 46)" end="(582, 54)">
                <AtomNode start="(582, 46)" end="(582, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(582, 48)" end="(582, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(582, 48)" end="(582, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(582, 53)" end="(582, 54)">
                    <IdentNode start="(582, 53)" end="(582, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(582, 54)" end="(582, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(582, 56)" end="(582, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(582, 56)" end="(582, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(582, 57)" end="(582, 58)">
                <IdentNode start="(582, 57)" end="(582, 58)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(582, 59)" end="(582, 64)">
                <AtomNode start="(582, 59)" end="(582, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(582, 61)" end="(582, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(582, 64)" end="(582, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(582, 66)" end="(582, 88)">
              <AtomNode start="(582, 66)" end="(582, 67)" leading="" trailing="" val="("/>
              <NullNode start="(582, 67)" end="(582, 68)">
                <IdentNode start="(582, 67)" end="(582, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(582, 69)" end="(582, 87)">
                <AtomNode start="(582, 69)" end="(582, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(582, 71)" end="(582, 87)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(582, 71)" end="(582, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(582, 73)" end="(582, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(582, 75)" end="(582, 87)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(582, 75)" end="(582, 85)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(582, 86)" end="(582, 87)">
                      <IdentNode start="(582, 86)" end="(582, 87)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(582, 87)" end="(582, 88)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(582, 89)" end="(583, 57)">
            <AtomNode start="(582, 89)" end="(582, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(583, 5)" end="(583, 57)" kind="«term_=_»">
              <OtherNode start="(583, 5)" end="(583, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(583, 5)" end="(583, 6)" leading="" trailing=" " raw_val="p" val="p"/>
                <NullNode start="(583, 7)" end="(583, 49)">
                  <OtherNode start="(583, 7)" end="(583, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(583, 7)" end="(583, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(583, 8)" end="(583, 48)" kind="«term__[_]'_»">
                      <IdentNode start="(583, 8)" end="(583, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(583, 10)" end="(583, 11)" leading="" trailing="" val="["/>
                      <IdentNode start="(583, 11)" end="(583, 12)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(583, 12)" end="(583, 14)" leading="" trailing="" val="]'"/>
                      <OtherNode start="(583, 14)" end="(583, 48)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(583, 14)" end="(583, 15)" leading="" trailing="" val="("/>
                        <OtherNode start="(583, 15)" end="(583, 47)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(583, 15)" end="(583, 27)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(583, 28)" end="(583, 47)">
                            <IdentNode start="(583, 28)" end="(583, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                            <IdentNode start="(583, 30)" end="(583, 47)" leading="" trailing="" raw_val="findIdx_le_length" val="findIdx_le_length" full_name="List.findIdx_le_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(566, 9)" def_end="(566, 26)"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(583, 47)" end="(583, 48)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(583, 48)" end="(583, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(583, 50)" end="(583, 51)" leading="" trailing=" " val="="/>
              <IdentNode start="(583, 52)" end="(583, 57)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(583, 58)" end="(603, 23)">
          <AtomNode start="(583, 58)" end="(583, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(583, 61)" end="(603, 23)">
            <AtomNode start="(583, 61)" end="(583, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(584, 3)" end="(603, 23)">
              <TacticTacticseq1IndentedNode start="(584, 3)" end="(603, 23)">
                <NullNode start="(584, 3)" end="(603, 23)">
                  <OtherNode start="(584, 3)" end="(584, 11)" kind="Lean.Parser.Tactic.revert" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; findIdx p xs&#10;⊢ p xs[i] = false" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false" tactic="revert i">
                    <AtomNode start="(584, 3)" end="(584, 9)" leading="" trailing=" " val="revert"/>
                    <NullNode start="(584, 10)" end="(584, 11)">
                      <IdentNode start="(584, 10)" end="(584, 11)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(585, 3)" end="(603, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;⊢ ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; intro i h; rw [findIdx_nil] at h; simp at h&#10;| cons x xs ih =&amp;gt;&#10;  intro i h&#10;  have ho := h&#10;  rw [findIdx_cons] at h&#10;  have npx : p x = false := by&#10;    apply eq_false_of_ne_true&#10;    intro y&#10;    rw [y, cond_true] at h&#10;    simp at h&#10;  simp [npx, cond_false] at h&#10;  cases i.eq_zero_or_pos with&#10;  | inl e =&amp;gt; simpa [e, Fin.zero_eta, get_cons_zero]&#10;  | inr e =&amp;gt;&#10;    have ipm := Nat.succ_pred_eq_of_pos e&#10;    simp +singlePass only [← ipm, getElem_cons_succ]&#10;    rw [← ipm, Nat.succ_lt_succ_iff] at h&#10;    simpa using ih h">
                    <AtomNode start="(585, 3)" end="(585, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(585, 13)" end="(585, 15)">
                      <OtherNode start="(585, 13)" end="(585, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(585, 13)" end="(585, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(585, 16)" end="(603, 23)">
                      <OtherNode start="(585, 16)" end="(603, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(585, 16)" end="(585, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(586, 3)" end="(603, 23)">
                          <OtherNode start="(586, 3)" end="(586, 55)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(586, 3)" end="(586, 8)">
                              <OtherNode start="(586, 3)" end="(586, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(586, 3)" end="(586, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(586, 5)" end="(586, 8)">
                                  <NullNode/>
                                  <IdentNode start="(586, 5)" end="(586, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(586, 9)" end="(586, 55)">
                              <AtomNode start="(586, 9)" end="(586, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(586, 12)" end="(586, 55)">
                                <TacticTacticseq1IndentedNode start="(586, 12)" end="(586, 55)">
                                  <NullNode start="(586, 12)" end="(586, 55)">
                                    <OtherNode start="(586, 12)" end="(586, 21)" kind="Lean.Parser.Tactic.intro" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ ∀ {i : Nat} (h : i &amp;lt; findIdx p []), p [][i] = false" state_after="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;h : i &amp;lt; findIdx p []&#10;⊢ p [][i] = false" tactic="intro i h">
                                      <AtomNode start="(586, 12)" end="(586, 17)" leading="" trailing=" " val="intro"/>
                                      <NullNode start="(586, 18)" end="(586, 21)">
                                        <IdentNode start="(586, 18)" end="(586, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                        <IdentNode start="(586, 20)" end="(586, 21)" leading="" trailing="" raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(586, 21)" end="(586, 22)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(586, 23)" end="(586, 44)" kind="Lean.Parser.Tactic.rwSeq" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;h : i &amp;lt; findIdx p []&#10;⊢ p [][i] = false" state_after="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p []&#10;h : i &amp;lt; 0&#10;⊢ p [][i] = false" tactic="rw [findIdx_nil] at h">
                                      <AtomNode start="(586, 23)" end="(586, 25)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(586, 26)" end="(586, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(586, 26)" end="(586, 27)" leading="" trailing="" val="["/>
                                        <NullNode start="(586, 27)" end="(586, 38)">
                                          <OtherNode start="(586, 27)" end="(586, 38)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(586, 27)" end="(586, 38)" leading="" trailing="" raw_val="findIdx_nil" val="findIdx_nil" full_name="List.findIdx_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(586, 38)" end="(586, 39)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                      <NullNode start="(586, 40)" end="(586, 44)">
                                        <OtherNode start="(586, 40)" end="(586, 44)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(586, 40)" end="(586, 42)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(586, 43)" end="(586, 44)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(586, 43)" end="(586, 44)">
                                              <IdentNode start="(586, 43)" end="(586, 44)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(586, 44)" end="(586, 45)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(586, 46)" end="(586, 55)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p []&#10;h : i &amp;lt; 0&#10;⊢ p [][i] = false" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(586, 46)" end="(586, 50)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(586, 51)" end="(586, 55)">
                                        <OtherNode start="(586, 51)" end="(586, 55)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(586, 51)" end="(586, 53)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(586, 54)" end="(586, 55)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(586, 54)" end="(586, 55)">
                                              <IdentNode start="(586, 54)" end="(586, 55)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(587, 3)" end="(603, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(587, 3)" end="(587, 17)">
                              <OtherNode start="(587, 3)" end="(587, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(587, 3)" end="(587, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(587, 5)" end="(587, 9)">
                                  <NullNode/>
                                  <IdentNode start="(587, 5)" end="(587, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(587, 10)" end="(587, 17)">
                                  <IdentNode start="(587, 10)" end="(587, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(587, 12)" end="(587, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(587, 15)" end="(587, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(587, 18)" end="(603, 23)">
                              <AtomNode start="(587, 18)" end="(587, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(588, 5)" end="(603, 23)">
                                <TacticTacticseq1IndentedNode start="(588, 5)" end="(603, 23)">
                                  <NullNode start="(588, 5)" end="(603, 23)">
                                    <OtherNode start="(588, 5)" end="(588, 14)" kind="Lean.Parser.Tactic.intro" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;⊢ ∀ {i : Nat} (h : i &amp;lt; findIdx p (x :: xs)), p (x :: xs)[i] = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p (x :: xs)[i] = false" tactic="intro i h">
                                      <AtomNode start="(588, 5)" end="(588, 10)" leading="" trailing=" " val="intro"/>
                                      <NullNode start="(588, 11)" end="(588, 14)">
                                        <IdentNode start="(588, 11)" end="(588, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        <IdentNode start="(588, 13)" end="(588, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(589, 5)" end="(589, 17)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p (x :: xs)[i] = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p (x :: xs)[i] = false" tactic="have ho := h">
                                      <AtomNode start="(589, 5)" end="(589, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(589, 10)" end="(589, 17)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(589, 10)" end="(589, 17)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(589, 10)" end="(589, 12)" kind="Lean.Parser.Term.haveId">
                                            <IdentNode start="(589, 10)" end="(589, 12)" leading="" trailing=" " raw_val="ho" val="ho"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <AtomNode start="(589, 13)" end="(589, 15)" leading="" trailing=" " val=":="/>
                                          <IdentNode start="(589, 16)" end="(589, 17)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(590, 5)" end="(590, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p (x :: xs)[i] = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p (x :: xs)[i] = false" tactic="rw [findIdx_cons] at h">
                                      <AtomNode start="(590, 5)" end="(590, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(590, 8)" end="(590, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(590, 8)" end="(590, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(590, 9)" end="(590, 21)">
                                          <OtherNode start="(590, 9)" end="(590, 21)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(590, 9)" end="(590, 21)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(590, 21)" end="(590, 22)" leading="" trailing=" " val="]"/>
                                      </OtherNode>
                                      <NullNode start="(590, 23)" end="(590, 27)">
                                        <OtherNode start="(590, 23)" end="(590, 27)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(590, 23)" end="(590, 25)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(590, 26)" end="(590, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(590, 26)" end="(590, 27)">
                                              <IdentNode start="(590, 26)" end="(590, 27)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(591, 5)" end="(595, 16)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p (x :: xs)[i] = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;⊢ p (x :: xs)[i] = false" tactic="have npx : p x = false := by&#10;  apply eq_false_of_ne_true&#10;  intro y&#10;  rw [y, cond_true] at h&#10;  simp at h">
                                      <AtomNode start="(591, 5)" end="(591, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(591, 10)" end="(595, 16)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(591, 10)" end="(595, 16)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(591, 10)" end="(591, 13)" kind="Lean.Parser.Term.haveId">
                                            <IdentNode start="(591, 10)" end="(591, 13)" leading="" trailing=" " raw_val="npx" val="npx"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(591, 14)" end="(591, 27)">
                                            <TermTypespecNode start="(591, 14)" end="(591, 27)">
                                              <AtomNode start="(591, 14)" end="(591, 15)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(591, 16)" end="(591, 27)" kind="«term_=_»">
                                                <OtherNode start="(591, 16)" end="(591, 19)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(591, 16)" end="(591, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                                                  <NullNode start="(591, 18)" end="(591, 19)">
                                                    <IdentNode start="(591, 18)" end="(591, 19)" leading="" trailing=" " raw_val="x" val="x"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(591, 20)" end="(591, 21)" leading="" trailing=" " val="="/>
                                                <IdentNode start="(591, 22)" end="(591, 27)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(591, 28)" end="(591, 30)" leading="" trailing=" " val=":="/>
                                          <TermBytacticNode start="(591, 31)" end="(595, 16)">
                                            <AtomNode start="(591, 31)" end="(591, 33)" leading="" trailing="&#10;      " val="by"/>
                                            <TacticTacticseqNode start="(592, 7)" end="(595, 16)">
                                              <TacticTacticseq1IndentedNode start="(592, 7)" end="(595, 16)">
                                                <NullNode start="(592, 7)" end="(595, 16)">
                                                  <OtherNode start="(592, 7)" end="(592, 32)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ p x = false" state_after="case a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ ¬p x = true" tactic="apply eq_false_of_ne_true">
                                                    <AtomNode start="(592, 7)" end="(592, 12)" leading="" trailing=" " val="apply"/>
                                                    <IdentNode start="(592, 13)" end="(592, 32)" leading="" trailing="&#10;      " raw_val="eq_false_of_ne_true" val="eq_false_of_ne_true" full_name="eq_false_of_ne_true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(593, 7)" end="(593, 14)" kind="Lean.Parser.Tactic.intro" state_before="case a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;⊢ ¬p x = true" state_after="case a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;y : p x = true&#10;⊢ False" tactic="intro y">
                                                    <AtomNode start="(593, 7)" end="(593, 12)" leading="" trailing=" " val="intro"/>
                                                    <NullNode start="(593, 13)" end="(593, 14)">
                                                      <IdentNode start="(593, 13)" end="(593, 14)" leading="" trailing="&#10;      " raw_val="y" val="y"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(594, 7)" end="(594, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="case a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;y : p x = true&#10;⊢ False" state_after="case a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; 0&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;y : p x = true&#10;⊢ False" tactic="rw [y, cond_true] at h">
                                                    <AtomNode start="(594, 7)" end="(594, 9)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(594, 10)" end="(594, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(594, 10)" end="(594, 11)" leading="" trailing="" val="["/>
                                                      <NullNode start="(594, 11)" end="(594, 23)">
                                                        <OtherNode start="(594, 11)" end="(594, 12)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(594, 11)" end="(594, 12)" leading="" trailing="" raw_val="y" val="y"/>
                                                        </OtherNode>
                                                        <AtomNode start="(594, 12)" end="(594, 13)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(594, 14)" end="(594, 23)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(594, 14)" end="(594, 23)" leading="" trailing="" raw_val="cond_true" val="cond_true" full_name="cond_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(594, 23)" end="(594, 24)" leading="" trailing=" " val="]"/>
                                                    </OtherNode>
                                                    <NullNode start="(594, 25)" end="(594, 29)">
                                                      <OtherNode start="(594, 25)" end="(594, 29)" kind="Lean.Parser.Tactic.location">
                                                        <AtomNode start="(594, 25)" end="(594, 27)" leading="" trailing=" " val="at"/>
                                                        <OtherNode start="(594, 28)" end="(594, 29)" kind="Lean.Parser.Tactic.locationHyp">
                                                          <NullNode start="(594, 28)" end="(594, 29)">
                                                            <IdentNode start="(594, 28)" end="(594, 29)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(595, 7)" end="(595, 16)" kind="Lean.Parser.Tactic.simp" state_before="case a&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; 0&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;y : p x = true&#10;⊢ False" state_after="no goals" tactic="simp at h">
                                                    <AtomNode start="(595, 7)" end="(595, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(595, 12)" end="(595, 16)">
                                                      <OtherNode start="(595, 12)" end="(595, 16)" kind="Lean.Parser.Tactic.location">
                                                        <AtomNode start="(595, 12)" end="(595, 14)" leading="" trailing=" " val="at"/>
                                                        <OtherNode start="(595, 15)" end="(595, 16)" kind="Lean.Parser.Tactic.locationHyp">
                                                          <NullNode start="(595, 15)" end="(595, 16)">
                                                            <IdentNode start="(595, 15)" end="(595, 16)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(596, 5)" end="(596, 32)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ : i &amp;lt; findIdx p (x :: xs)&#10;h : i &amp;lt; bif p x then 0 else findIdx p xs + 1&#10;ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;⊢ p (x :: xs)[i] = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;⊢ p (x :: xs)[i] = false" tactic="simp [npx, cond_false] at h">
                                      <AtomNode start="(596, 5)" end="(596, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(596, 10)" end="(596, 27)">
                                        <AtomNode start="(596, 10)" end="(596, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(596, 11)" end="(596, 26)">
                                          <OtherNode start="(596, 11)" end="(596, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(596, 11)" end="(596, 14)" leading="" trailing="" raw_val="npx" val="npx"/>
                                          </OtherNode>
                                          <AtomNode start="(596, 14)" end="(596, 15)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(596, 16)" end="(596, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(596, 16)" end="(596, 26)" leading="" trailing="" raw_val="cond_false" val="cond_false" full_name="cond_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(596, 26)" end="(596, 27)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(596, 28)" end="(596, 32)">
                                        <OtherNode start="(596, 28)" end="(596, 32)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(596, 28)" end="(596, 30)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(596, 31)" end="(596, 32)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(596, 31)" end="(596, 32)">
                                              <IdentNode start="(596, 31)" end="(596, 32)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(597, 5)" end="(603, 23)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;⊢ p (x :: xs)[i] = false" state_after="no goals" tactic="cases i.eq_zero_or_pos with&#10;| inl e =&amp;gt; simpa [e, Fin.zero_eta, get_cons_zero]&#10;| inr e =&amp;gt;&#10;  have ipm := Nat.succ_pred_eq_of_pos e&#10;  simp +singlePass only [← ipm, getElem_cons_succ]&#10;  rw [← ipm, Nat.succ_lt_succ_iff] at h&#10;  simpa using ih h">
                                      <AtomNode start="(597, 5)" end="(597, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(597, 11)" end="(597, 27)">
                                        <OtherNode start="(597, 11)" end="(597, 27)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(597, 11)" end="(597, 27)" leading="" trailing=" " raw_val="i.eq_zero_or_pos" val="i.eq_zero_or_pos"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(597, 28)" end="(603, 23)">
                                        <OtherNode start="(597, 28)" end="(603, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(597, 28)" end="(597, 32)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(598, 5)" end="(603, 23)">
                                            <OtherNode start="(598, 5)" end="(598, 54)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(598, 5)" end="(598, 12)">
                                                <OtherNode start="(598, 5)" end="(598, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(598, 5)" end="(598, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(598, 7)" end="(598, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(598, 7)" end="(598, 10)" leading="" trailing=" " raw_val="inl" val="inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(598, 11)" end="(598, 12)">
                                                    <IdentNode start="(598, 11)" end="(598, 12)" leading="" trailing=" " raw_val="e" val="e"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(598, 13)" end="(598, 54)">
                                                <AtomNode start="(598, 13)" end="(598, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(598, 16)" end="(598, 54)">
                                                  <TacticTacticseq1IndentedNode start="(598, 16)" end="(598, 54)">
                                                    <NullNode start="(598, 16)" end="(598, 54)">
                                                      <OtherNode start="(598, 16)" end="(598, 54)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.inl&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;e : i = 0&#10;⊢ p (x :: xs)[i] = false" state_after="no goals" tactic="simpa [e, Fin.zero_eta, get_cons_zero]">
                                                        <AtomNode start="(598, 16)" end="(598, 21)" leading="" trailing=" " val="simpa"/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(598, 22)" end="(598, 54)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(598, 22)" end="(598, 54)">
                                                            <OtherNode start="(598, 22)" end="(598, 54)" kind="Lean.Parser.Tactic.simpArgs">
                                                            <AtomNode start="(598, 22)" end="(598, 23)" leading="" trailing="" val="["/>
                                                            <NullNode start="(598, 23)" end="(598, 53)">
                                                            <OtherNode start="(598, 23)" end="(598, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(598, 23)" end="(598, 24)" leading="" trailing="" raw_val="e" val="e"/>
                                                            </OtherNode>
                                                            <AtomNode start="(598, 24)" end="(598, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(598, 26)" end="(598, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(598, 26)" end="(598, 38)" leading="" trailing="" raw_val="Fin.zero_eta" val="Fin.zero_eta" full_name="Fin.zero_eta" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(598, 38)" end="(598, 39)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(598, 40)" end="(598, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(598, 40)" end="(598, 53)" leading="" trailing="" raw_val="get_cons_zero" val="get_cons_zero" full_name="List.get_cons_zero" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(598, 53)" end="(598, 54)" leading="" trailing="&#10;    " val="]"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(599, 5)" end="(603, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(599, 5)" end="(599, 12)">
                                                <OtherNode start="(599, 5)" end="(599, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(599, 5)" end="(599, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(599, 7)" end="(599, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(599, 7)" end="(599, 10)" leading="" trailing=" " raw_val="inr" val="inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(599, 11)" end="(599, 12)">
                                                    <IdentNode start="(599, 11)" end="(599, 12)" leading="" trailing=" " raw_val="e" val="e"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(599, 13)" end="(603, 23)">
                                                <AtomNode start="(599, 13)" end="(599, 15)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(600, 7)" end="(603, 23)">
                                                  <TacticTacticseq1IndentedNode start="(600, 7)" end="(603, 23)">
                                                    <NullNode start="(600, 7)" end="(603, 23)">
                                                      <OtherNode start="(600, 7)" end="(600, 44)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;e : i &amp;gt; 0&#10;⊢ p (x :: xs)[i] = false" state_after="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;e : i &amp;gt; 0&#10;ipm : i.pred.succ = i&#10;⊢ p (x :: xs)[i] = false" tactic="have ipm := Nat.succ_pred_eq_of_pos e">
                                                        <AtomNode start="(600, 7)" end="(600, 11)" leading="" trailing=" " val="have"/>
                                                        <OtherNode start="(600, 12)" end="(600, 44)" kind="Lean.Parser.Term.haveDecl">
                                                          <OtherNode start="(600, 12)" end="(600, 44)" kind="Lean.Parser.Term.haveIdDecl">
                                                            <OtherNode start="(600, 12)" end="(600, 15)" kind="Lean.Parser.Term.haveId">
                                                            <IdentNode start="(600, 12)" end="(600, 15)" leading="" trailing=" " raw_val="ipm" val="ipm"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <AtomNode start="(600, 16)" end="(600, 18)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(600, 19)" end="(600, 44)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(600, 19)" end="(600, 42)" leading="" trailing=" " raw_val="Nat.succ_pred_eq_of_pos" val="Nat.succ_pred_eq_of_pos" full_name="Nat.succ_pred_eq_of_pos" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(600, 43)" end="(600, 44)">
                                                            <IdentNode start="(600, 43)" end="(600, 44)" leading="" trailing="&#10;      " raw_val="e" val="e"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(601, 7)" end="(601, 55)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;e : i &amp;gt; 0&#10;ipm : i.pred.succ = i&#10;⊢ p (x :: xs)[i] = false" state_after="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;e : i &amp;gt; 0&#10;ipm : i.pred.succ = i&#10;⊢ p xs[i.pred] = false" tactic="simp +singlePass only [← ipm, getElem_cons_succ]">
                                                        <AtomNode start="(601, 7)" end="(601, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode start="(601, 12)" end="(601, 23)" kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode start="(601, 12)" end="(601, 23)">
                                                            <OtherNode start="(601, 12)" end="(601, 23)" kind="Lean.Parser.Tactic.configItem">
                                                            <OtherNode start="(601, 12)" end="(601, 23)" kind="Lean.Parser.Tactic.posConfigItem">
                                                            <AtomNode start="(601, 12)" end="(601, 13)" leading="" trailing="" val="+"/>
                                                            <IdentNode start="(601, 13)" end="(601, 23)" leading="" trailing=" " raw_val="singlePass" val="singlePass"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(601, 24)" end="(601, 28)">
                                                          <AtomNode start="(601, 24)" end="(601, 28)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(601, 29)" end="(601, 55)">
                                                          <AtomNode start="(601, 29)" end="(601, 30)" leading="" trailing="" val="["/>
                                                          <NullNode start="(601, 30)" end="(601, 54)">
                                                            <OtherNode start="(601, 30)" end="(601, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode start="(601, 30)" end="(601, 31)">
                                                            <OtherNode start="(601, 30)" end="(601, 31)" kind="patternIgnore">
                                                            <OtherNode start="(601, 30)" end="(601, 31)" kind="token.«← »">
                                                            <AtomNode start="(601, 30)" end="(601, 31)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(601, 32)" end="(601, 35)" leading="" trailing="" raw_val="ipm" val="ipm"/>
                                                            </OtherNode>
                                                            <AtomNode start="(601, 35)" end="(601, 36)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(601, 37)" end="(601, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(601, 37)" end="(601, 54)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(601, 54)" end="(601, 55)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(602, 7)" end="(602, 44)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i &amp;lt; findIdx p xs + 1&#10;e : i &amp;gt; 0&#10;ipm : i.pred.succ = i&#10;⊢ p xs[i.pred] = false" state_after="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i.pred &amp;lt; findIdx p xs&#10;e : i &amp;gt; 0&#10;ipm : i.pred.succ = i&#10;⊢ p xs[i.pred] = false" tactic="rw [← ipm, Nat.succ_lt_succ_iff] at h">
                                                        <AtomNode start="(602, 7)" end="(602, 9)" leading="" trailing=" " val="rw"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <OtherNode start="(602, 10)" end="(602, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                          <AtomNode start="(602, 10)" end="(602, 11)" leading="" trailing="" val="["/>
                                                          <NullNode start="(602, 11)" end="(602, 38)">
                                                            <OtherNode start="(602, 11)" end="(602, 16)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode start="(602, 11)" end="(602, 12)">
                                                            <OtherNode start="(602, 11)" end="(602, 12)" kind="patternIgnore">
                                                            <OtherNode start="(602, 11)" end="(602, 12)" kind="token.«← »">
                                                            <AtomNode start="(602, 11)" end="(602, 12)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(602, 13)" end="(602, 16)" leading="" trailing="" raw_val="ipm" val="ipm"/>
                                                            </OtherNode>
                                                            <AtomNode start="(602, 16)" end="(602, 17)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(602, 18)" end="(602, 38)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(602, 18)" end="(602, 38)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(602, 38)" end="(602, 39)" leading="" trailing=" " val="]"/>
                                                        </OtherNode>
                                                        <NullNode start="(602, 40)" end="(602, 44)">
                                                          <OtherNode start="(602, 40)" end="(602, 44)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(602, 40)" end="(602, 42)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(602, 43)" end="(602, 44)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(602, 43)" end="(602, 44)">
                                                            <IdentNode start="(602, 43)" end="(602, 44)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(603, 7)" end="(603, 23)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.inr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat} (h : i &amp;lt; findIdx p xs), p xs[i] = false&#10;i : Nat&#10;h✝ ho : i &amp;lt; findIdx p (x :: xs)&#10;npx : p x = false&#10;h : i.pred &amp;lt; findIdx p xs&#10;e : i &amp;gt; 0&#10;ipm : i.pred.succ = i&#10;⊢ p xs[i.pred] = false" state_after="no goals" tactic="simpa using ih h">
                                                        <AtomNode start="(603, 7)" end="(603, 12)" leading="" trailing=" " val="simpa"/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(603, 13)" end="(603, 23)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(603, 13)" end="(603, 23)">
                                                            <AtomNode start="(603, 13)" end="(603, 18)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(603, 19)" end="(603, 23)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(603, 19)" end="(603, 21)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(603, 22)" end="(603, 23)">
                                                            <IdentNode start="(603, 22)" end="(603, 23)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(605, 1)" end="(611, 97)" name="le_findIdx_of_not" full_name="List.le_findIdx_of_not">
      <CommandDeclmodifiersNode start="(605, 1)" end="(605, 64)">
        <NullNode start="(605, 1)" end="(605, 64)">
          <CommandDoccommentNode start="(605, 1)" end="(605, 64)" comment="If `¬ p xs[j]` for all `j &amp;lt; i`, then `i ≤ xs.findIdx p`. -/">
            <AtomNode start="(605, 1)" end="(605, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(605, 5)" end="(605, 64)" leading="" trailing="&#10;" val="If `¬ p xs[j]` for all `j &amp;lt; i`, then `i ≤ xs.findIdx p`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(606, 1)" end="(611, 97)" name="le_findIdx_of_not" full_name="List.le_findIdx_of_not" _is_private_decl="False">
        <AtomNode start="(606, 1)" end="(606, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(606, 9)" end="(606, 26)">
          <IdentNode start="(606, 9)" end="(606, 26)" leading="" trailing=" " raw_val="le_findIdx_of_not" val="le_findIdx_of_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(606, 27)" end="(607, 88)">
          <NullNode start="(606, 27)" end="(607, 69)">
            <OtherNode start="(606, 27)" end="(606, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(606, 27)" end="(606, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(606, 28)" end="(606, 29)">
                <IdentNode start="(606, 28)" end="(606, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(606, 30)" end="(606, 40)">
                <AtomNode start="(606, 30)" end="(606, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(606, 32)" end="(606, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(606, 32)" end="(606, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(606, 34)" end="(606, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(606, 36)" end="(606, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(606, 40)" end="(606, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(606, 42)" end="(606, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(606, 42)" end="(606, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(606, 43)" end="(606, 45)">
                <IdentNode start="(606, 43)" end="(606, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(606, 46)" end="(606, 54)">
                <AtomNode start="(606, 46)" end="(606, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(606, 48)" end="(606, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(606, 48)" end="(606, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(606, 53)" end="(606, 54)">
                    <IdentNode start="(606, 53)" end="(606, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(606, 54)" end="(606, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(606, 56)" end="(606, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(606, 56)" end="(606, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(606, 57)" end="(606, 58)">
                <IdentNode start="(606, 57)" end="(606, 58)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(606, 59)" end="(606, 64)">
                <AtomNode start="(606, 59)" end="(606, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(606, 61)" end="(606, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(606, 64)" end="(606, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(606, 66)" end="(606, 85)">
              <AtomNode start="(606, 66)" end="(606, 67)" leading="" trailing="" val="("/>
              <NullNode start="(606, 67)" end="(606, 68)">
                <IdentNode start="(606, 67)" end="(606, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(606, 69)" end="(606, 84)">
                <AtomNode start="(606, 69)" end="(606, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(606, 71)" end="(606, 84)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(606, 71)" end="(606, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(606, 73)" end="(606, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(606, 75)" end="(606, 84)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(606, 84)" end="(606, 85)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(607, 5)" end="(607, 69)">
              <AtomNode start="(607, 5)" end="(607, 6)" leading="" trailing="" val="("/>
              <NullNode start="(607, 6)" end="(607, 8)">
                <IdentNode start="(607, 6)" end="(607, 8)" leading="" trailing=" " raw_val="h2" val="h2"/>
              </NullNode>
              <NullNode start="(607, 9)" end="(607, 68)">
                <AtomNode start="(607, 9)" end="(607, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(607, 11)" end="(607, 68)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(607, 11)" end="(607, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(607, 13)" end="(607, 28)">
                    <IdentNode start="(607, 13)" end="(607, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(607, 15)" end="(607, 28)">
                      <AtomNode start="(607, 15)" end="(607, 16)" leading="" trailing="" val="("/>
                      <NullNode start="(607, 16)" end="(607, 19)">
                        <IdentNode start="(607, 16)" end="(607, 19)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(607, 20)" end="(607, 27)">
                        <AtomNode start="(607, 20)" end="(607, 21)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(607, 22)" end="(607, 27)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(607, 22)" end="(607, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(607, 24)" end="(607, 25)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(607, 26)" end="(607, 27)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(607, 27)" end="(607, 28)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(607, 28)" end="(607, 29)" leading="" trailing=" " val=","/>
                  <OtherNode start="(607, 30)" end="(607, 68)" kind="«term_=_»">
                    <OtherNode start="(607, 30)" end="(607, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(607, 30)" end="(607, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(607, 32)" end="(607, 60)">
                        <OtherNode start="(607, 32)" end="(607, 60)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(607, 32)" end="(607, 33)" leading="" trailing="" val="("/>
                          <OtherNode start="(607, 33)" end="(607, 59)" kind="«term__[_]'_»">
                            <IdentNode start="(607, 33)" end="(607, 35)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(607, 35)" end="(607, 36)" leading="" trailing="" val="["/>
                            <IdentNode start="(607, 36)" end="(607, 37)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(607, 37)" end="(607, 39)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(607, 39)" end="(607, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(607, 39)" end="(607, 40)" leading="" trailing="" val="("/>
                              <OtherNode start="(607, 40)" end="(607, 58)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(607, 40)" end="(607, 52)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(607, 53)" end="(607, 58)">
                                  <IdentNode start="(607, 53)" end="(607, 56)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <IdentNode start="(607, 57)" end="(607, 58)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(607, 58)" end="(607, 59)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(607, 59)" end="(607, 60)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(607, 61)" end="(607, 62)" leading="" trailing=" " val="="/>
                    <IdentNode start="(607, 63)" end="(607, 68)" leading="" trailing="" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(607, 68)" end="(607, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(607, 70)" end="(607, 88)">
            <AtomNode start="(607, 70)" end="(607, 71)" leading="" trailing=" " val=":"/>
            <OtherNode start="(607, 72)" end="(607, 88)" kind="«term_≤_»">
              <IdentNode start="(607, 72)" end="(607, 73)" leading="" trailing=" " raw_val="i" val="i"/>
              <AtomNode start="(607, 74)" end="(607, 75)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(607, 76)" end="(607, 88)" kind="Lean.Parser.Term.app">
                <IdentNode start="(607, 76)" end="(607, 86)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(607, 87)" end="(607, 88)">
                  <IdentNode start="(607, 87)" end="(607, 88)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(607, 89)" end="(611, 97)">
          <AtomNode start="(607, 89)" end="(607, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(607, 92)" end="(611, 97)">
            <AtomNode start="(607, 92)" end="(607, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(608, 3)" end="(611, 97)">
              <TacticTacticseq1IndentedNode start="(608, 3)" end="(611, 97)">
                <NullNode start="(608, 3)" end="(611, 97)">
                  <OtherNode start="(608, 3)" end="(608, 34)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ i ≤ findIdx p xs" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬i ≤ findIdx p xs → False" tactic="apply Decidable.byContradiction">
                    <AtomNode start="(608, 3)" end="(608, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(608, 9)" end="(608, 34)" leading="" trailing="&#10;  " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(609, 3)" end="(609, 10)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬i ≤ findIdx p xs → False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : ¬i ≤ findIdx p xs&#10;⊢ False" tactic="intro f">
                    <AtomNode start="(609, 3)" end="(609, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(609, 9)" end="(609, 10)">
                      <IdentNode start="(609, 9)" end="(609, 10)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(610, 3)" end="(610, 30)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : ¬i ≤ findIdx p xs&#10;⊢ False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : findIdx p xs &amp;lt; i&#10;⊢ False" tactic="simp only [Nat.not_le] at f">
                    <AtomNode start="(610, 3)" end="(610, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(610, 8)" end="(610, 12)">
                      <AtomNode start="(610, 8)" end="(610, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(610, 13)" end="(610, 25)">
                      <AtomNode start="(610, 13)" end="(610, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(610, 14)" end="(610, 24)">
                        <OtherNode start="(610, 14)" end="(610, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(610, 14)" end="(610, 24)" leading="" trailing="" raw_val="Nat.not_le" val="Nat.not_le" full_name="Nat.not_le" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(610, 24)" end="(610, 25)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(610, 26)" end="(610, 30)">
                      <OtherNode start="(610, 26)" end="(610, 30)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(610, 26)" end="(610, 28)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(610, 29)" end="(610, 30)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(610, 29)" end="(610, 30)">
                            <IdentNode start="(610, 29)" end="(610, 30)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(611, 3)" end="(611, 97)" kind="Lean.Parser.Tactic.exact" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : findIdx p xs &amp;lt; i&#10;⊢ False" state_after="no goals" tactic="exact absurd (@findIdx_getElem _ p xs (Nat.lt_trans f h)) (by simpa using h2 (xs.findIdx p) f)">
                    <AtomNode start="(611, 3)" end="(611, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(611, 9)" end="(611, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(611, 9)" end="(611, 15)" leading="" trailing=" " raw_val="absurd" val="absurd" full_name="absurd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(611, 16)" end="(611, 97)">
                        <OtherNode start="(611, 16)" end="(611, 60)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(611, 16)" end="(611, 17)" leading="" trailing="" val="("/>
                          <OtherNode start="(611, 17)" end="(611, 59)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(611, 17)" end="(611, 33)" kind="Lean.Parser.Term.explicit">
                              <AtomNode start="(611, 17)" end="(611, 18)" leading="" trailing="" val="@"/>
                              <IdentNode start="(611, 18)" end="(611, 33)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem" full_name="List.findIdx_getElem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(530, 9)" def_end="(530, 24)"/>
                            </OtherNode>
                            <NullNode start="(611, 34)" end="(611, 59)">
                              <TermHoleNode start="(611, 34)" end="(611, 35)">
                                <AtomNode start="(611, 34)" end="(611, 35)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                              <IdentNode start="(611, 36)" end="(611, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                              <IdentNode start="(611, 38)" end="(611, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <OtherNode start="(611, 41)" end="(611, 59)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(611, 41)" end="(611, 42)" leading="" trailing="" val="("/>
                                <OtherNode start="(611, 42)" end="(611, 58)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(611, 42)" end="(611, 54)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(611, 55)" end="(611, 58)">
                                    <IdentNode start="(611, 55)" end="(611, 56)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <IdentNode start="(611, 57)" end="(611, 58)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(611, 58)" end="(611, 59)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(611, 59)" end="(611, 60)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(611, 61)" end="(611, 97)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(611, 61)" end="(611, 62)" leading="" trailing="" val="("/>
                          <TermBytacticNode start="(611, 62)" end="(611, 96)">
                            <AtomNode start="(611, 62)" end="(611, 64)" leading="" trailing=" " val="by"/>
                            <TacticTacticseqNode start="(611, 65)" end="(611, 96)">
                              <TacticTacticseq1IndentedNode start="(611, 65)" end="(611, 96)">
                                <NullNode start="(611, 65)" end="(611, 96)">
                                  <OtherNode start="(611, 65)" end="(611, 96)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;f : findIdx p xs &amp;lt; i&#10;⊢ ¬p xs[findIdx p xs] = true" state_after="no goals" tactic="simpa using h2 (xs.findIdx p) f">
                                    <AtomNode start="(611, 65)" end="(611, 70)" leading="" trailing=" " val="simpa"/>
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(611, 71)" end="(611, 96)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(611, 71)" end="(611, 96)">
                                        <AtomNode start="(611, 71)" end="(611, 76)" leading="" trailing=" " val="using"/>
                                        <OtherNode start="(611, 77)" end="(611, 96)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(611, 77)" end="(611, 79)" leading="" trailing=" " raw_val="h2" val="h2"/>
                                          <NullNode start="(611, 80)" end="(611, 96)">
                                            <OtherNode start="(611, 80)" end="(611, 94)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(611, 80)" end="(611, 81)" leading="" trailing="" val="("/>
                                              <OtherNode start="(611, 81)" end="(611, 93)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(611, 81)" end="(611, 91)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                                <NullNode start="(611, 92)" end="(611, 93)">
                                                  <IdentNode start="(611, 92)" end="(611, 93)" leading="" trailing="" raw_val="p" val="p"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(611, 93)" end="(611, 94)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                            <IdentNode start="(611, 95)" end="(611, 96)" leading="" trailing="" raw_val="f" val="f"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </TermBytacticNode>
                          <AtomNode start="(611, 96)" end="(611, 97)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(613, 1)" end="(619, 88)" name="lt_findIdx_of_not" full_name="List.lt_findIdx_of_not">
      <CommandDeclmodifiersNode start="(613, 1)" end="(613, 64)">
        <NullNode start="(613, 1)" end="(613, 64)">
          <CommandDoccommentNode start="(613, 1)" end="(613, 64)" comment="If `¬ p xs[j]` for all `j ≤ i`, then `i &amp;lt; xs.findIdx p`. -/">
            <AtomNode start="(613, 1)" end="(613, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(613, 5)" end="(613, 64)" leading="" trailing="&#10;" val="If `¬ p xs[j]` for all `j ≤ i`, then `i &amp;lt; xs.findIdx p`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(614, 1)" end="(619, 88)" name="lt_findIdx_of_not" full_name="List.lt_findIdx_of_not" _is_private_decl="False">
        <AtomNode start="(614, 1)" end="(614, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(614, 9)" end="(614, 26)">
          <IdentNode start="(614, 9)" end="(614, 26)" leading="" trailing=" " raw_val="lt_findIdx_of_not" val="lt_findIdx_of_not"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(614, 27)" end="(615, 87)">
          <NullNode start="(614, 27)" end="(615, 68)">
            <OtherNode start="(614, 27)" end="(614, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(614, 27)" end="(614, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(614, 28)" end="(614, 29)">
                <IdentNode start="(614, 28)" end="(614, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(614, 30)" end="(614, 40)">
                <AtomNode start="(614, 30)" end="(614, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(614, 32)" end="(614, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(614, 32)" end="(614, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(614, 34)" end="(614, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(614, 36)" end="(614, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(614, 40)" end="(614, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(614, 42)" end="(614, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(614, 42)" end="(614, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(614, 43)" end="(614, 45)">
                <IdentNode start="(614, 43)" end="(614, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(614, 46)" end="(614, 54)">
                <AtomNode start="(614, 46)" end="(614, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(614, 48)" end="(614, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(614, 48)" end="(614, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(614, 53)" end="(614, 54)">
                    <IdentNode start="(614, 53)" end="(614, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(614, 54)" end="(614, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(614, 56)" end="(614, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(614, 56)" end="(614, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(614, 57)" end="(614, 58)">
                <IdentNode start="(614, 57)" end="(614, 58)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(614, 59)" end="(614, 64)">
                <AtomNode start="(614, 59)" end="(614, 60)" leading="" trailing=" " val=":"/>
                <IdentNode start="(614, 61)" end="(614, 64)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(614, 64)" end="(614, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(614, 66)" end="(614, 85)">
              <AtomNode start="(614, 66)" end="(614, 67)" leading="" trailing="" val="("/>
              <NullNode start="(614, 67)" end="(614, 68)">
                <IdentNode start="(614, 67)" end="(614, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(614, 69)" end="(614, 84)">
                <AtomNode start="(614, 69)" end="(614, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(614, 71)" end="(614, 84)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(614, 71)" end="(614, 72)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(614, 73)" end="(614, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(614, 75)" end="(614, 84)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(614, 84)" end="(614, 85)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(615, 5)" end="(615, 68)">
              <AtomNode start="(615, 5)" end="(615, 6)" leading="" trailing="" val="("/>
              <NullNode start="(615, 6)" end="(615, 8)">
                <IdentNode start="(615, 6)" end="(615, 8)" leading="" trailing=" " raw_val="h2" val="h2"/>
              </NullNode>
              <NullNode start="(615, 9)" end="(615, 67)">
                <AtomNode start="(615, 9)" end="(615, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(615, 11)" end="(615, 67)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(615, 11)" end="(615, 12)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(615, 13)" end="(615, 28)">
                    <IdentNode start="(615, 13)" end="(615, 14)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(615, 15)" end="(615, 28)">
                      <AtomNode start="(615, 15)" end="(615, 16)" leading="" trailing="" val="("/>
                      <NullNode start="(615, 16)" end="(615, 19)">
                        <IdentNode start="(615, 16)" end="(615, 19)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(615, 20)" end="(615, 27)">
                        <AtomNode start="(615, 20)" end="(615, 21)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(615, 22)" end="(615, 27)" kind="«term_≤_»">
                          <IdentNode start="(615, 22)" end="(615, 23)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(615, 24)" end="(615, 25)" leading="" trailing=" " val="≤"/>
                          <IdentNode start="(615, 26)" end="(615, 27)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(615, 27)" end="(615, 28)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(615, 28)" end="(615, 29)" leading="" trailing=" " val=","/>
                  <OtherNode start="(615, 30)" end="(615, 67)" kind="«term¬_»">
                    <AtomNode start="(615, 30)" end="(615, 31)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(615, 31)" end="(615, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(615, 31)" end="(615, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(615, 33)" end="(615, 67)">
                        <OtherNode start="(615, 33)" end="(615, 67)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(615, 33)" end="(615, 34)" leading="" trailing="" val="("/>
                          <OtherNode start="(615, 34)" end="(615, 66)" kind="«term__[_]'_»">
                            <IdentNode start="(615, 34)" end="(615, 36)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(615, 36)" end="(615, 37)" leading="" trailing="" val="["/>
                            <IdentNode start="(615, 37)" end="(615, 38)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(615, 38)" end="(615, 40)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(615, 40)" end="(615, 66)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(615, 40)" end="(615, 41)" leading="" trailing="" val="("/>
                              <OtherNode start="(615, 41)" end="(615, 65)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(615, 41)" end="(615, 59)" leading="" trailing=" " raw_val="Nat.lt_of_le_of_lt" val="Nat.lt_of_le_of_lt" full_name="Nat.lt_of_le_of_lt" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(615, 60)" end="(615, 65)">
                                  <IdentNode start="(615, 60)" end="(615, 63)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <IdentNode start="(615, 64)" end="(615, 65)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(615, 65)" end="(615, 66)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(615, 66)" end="(615, 67)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(615, 67)" end="(615, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(615, 69)" end="(615, 87)">
            <AtomNode start="(615, 69)" end="(615, 70)" leading="" trailing=" " val=":"/>
            <OtherNode start="(615, 71)" end="(615, 87)" kind="«term_&amp;lt;_»">
              <IdentNode start="(615, 71)" end="(615, 72)" leading="" trailing=" " raw_val="i" val="i"/>
              <AtomNode start="(615, 73)" end="(615, 74)" leading="" trailing=" " val="&amp;lt;"/>
              <OtherNode start="(615, 75)" end="(615, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(615, 75)" end="(615, 85)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(615, 86)" end="(615, 87)">
                  <IdentNode start="(615, 86)" end="(615, 87)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(615, 88)" end="(619, 88)">
          <AtomNode start="(615, 88)" end="(615, 90)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(615, 91)" end="(619, 88)">
            <AtomNode start="(615, 91)" end="(615, 93)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(616, 3)" end="(619, 88)">
              <TacticTacticseq1IndentedNode start="(616, 3)" end="(619, 88)">
                <NullNode start="(616, 3)" end="(619, 88)">
                  <OtherNode start="(616, 3)" end="(616, 34)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;⊢ i &amp;lt; findIdx p xs" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;⊢ ¬i &amp;lt; findIdx p xs → False" tactic="apply Decidable.byContradiction">
                    <AtomNode start="(616, 3)" end="(616, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(616, 9)" end="(616, 34)" leading="" trailing="&#10;  " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(617, 3)" end="(617, 10)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;⊢ ¬i &amp;lt; findIdx p xs → False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : ¬i &amp;lt; findIdx p xs&#10;⊢ False" tactic="intro f">
                    <AtomNode start="(617, 3)" end="(617, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(617, 9)" end="(617, 10)">
                      <IdentNode start="(617, 9)" end="(617, 10)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(618, 3)" end="(618, 30)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : ¬i &amp;lt; findIdx p xs&#10;⊢ False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : findIdx p xs ≤ i&#10;⊢ False" tactic="simp only [Nat.not_lt] at f">
                    <AtomNode start="(618, 3)" end="(618, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(618, 8)" end="(618, 12)">
                      <AtomNode start="(618, 8)" end="(618, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(618, 13)" end="(618, 25)">
                      <AtomNode start="(618, 13)" end="(618, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(618, 14)" end="(618, 24)">
                        <OtherNode start="(618, 14)" end="(618, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(618, 14)" end="(618, 24)" leading="" trailing="" raw_val="Nat.not_lt" val="Nat.not_lt" full_name="Nat.not_lt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(618, 24)" end="(618, 25)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(618, 26)" end="(618, 30)">
                      <OtherNode start="(618, 26)" end="(618, 30)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(618, 26)" end="(618, 28)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(618, 29)" end="(618, 30)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(618, 29)" end="(618, 30)">
                            <IdentNode start="(618, 29)" end="(618, 30)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(619, 3)" end="(619, 88)" kind="Lean.Parser.Tactic.exact" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;h2 : ∀ (j : Nat) (hji : j ≤ i), ¬p xs[j] = true&#10;f : findIdx p xs ≤ i&#10;⊢ False" state_after="no goals" tactic="exact absurd (@findIdx_getElem _ p xs (Nat.lt_of_le_of_lt f h)) (h2 (xs.findIdx p) f)">
                    <AtomNode start="(619, 3)" end="(619, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(619, 9)" end="(619, 88)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(619, 9)" end="(619, 15)" leading="" trailing=" " raw_val="absurd" val="absurd" full_name="absurd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(619, 16)" end="(619, 88)">
                        <OtherNode start="(619, 16)" end="(619, 66)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(619, 16)" end="(619, 17)" leading="" trailing="" val="("/>
                          <OtherNode start="(619, 17)" end="(619, 65)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(619, 17)" end="(619, 33)" kind="Lean.Parser.Term.explicit">
                              <AtomNode start="(619, 17)" end="(619, 18)" leading="" trailing="" val="@"/>
                              <IdentNode start="(619, 18)" end="(619, 33)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem" full_name="List.findIdx_getElem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(530, 9)" def_end="(530, 24)"/>
                            </OtherNode>
                            <NullNode start="(619, 34)" end="(619, 65)">
                              <TermHoleNode start="(619, 34)" end="(619, 35)">
                                <AtomNode start="(619, 34)" end="(619, 35)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                              <IdentNode start="(619, 36)" end="(619, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                              <IdentNode start="(619, 38)" end="(619, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              <OtherNode start="(619, 41)" end="(619, 65)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(619, 41)" end="(619, 42)" leading="" trailing="" val="("/>
                                <OtherNode start="(619, 42)" end="(619, 64)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(619, 42)" end="(619, 60)" leading="" trailing=" " raw_val="Nat.lt_of_le_of_lt" val="Nat.lt_of_le_of_lt" full_name="Nat.lt_of_le_of_lt" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(619, 61)" end="(619, 64)">
                                    <IdentNode start="(619, 61)" end="(619, 62)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <IdentNode start="(619, 63)" end="(619, 64)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(619, 64)" end="(619, 65)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(619, 65)" end="(619, 66)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(619, 67)" end="(619, 88)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(619, 67)" end="(619, 68)" leading="" trailing="" val="("/>
                          <OtherNode start="(619, 68)" end="(619, 87)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(619, 68)" end="(619, 70)" leading="" trailing=" " raw_val="h2" val="h2"/>
                            <NullNode start="(619, 71)" end="(619, 87)">
                              <OtherNode start="(619, 71)" end="(619, 85)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(619, 71)" end="(619, 72)" leading="" trailing="" val="("/>
                                <OtherNode start="(619, 72)" end="(619, 84)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(619, 72)" end="(619, 82)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                  <NullNode start="(619, 83)" end="(619, 84)">
                                    <IdentNode start="(619, 83)" end="(619, 84)" leading="" trailing="" raw_val="p" val="p"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(619, 84)" end="(619, 85)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <IdentNode start="(619, 86)" end="(619, 87)" leading="" trailing="" raw_val="f" val="f"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(619, 87)" end="(619, 88)" leading="" trailing="&#10;&#10;" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(621, 1)" end="(630, 34)" name="findIdx_eq" full_name="List.findIdx_eq">
      <CommandDeclmodifiersNode start="(621, 1)" end="(621, 74)">
        <NullNode start="(621, 1)" end="(621, 74)">
          <CommandDoccommentNode start="(621, 1)" end="(621, 74)" comment="`xs.findIdx p = i` iff `p xs[i]` and `¬ p xs [j]` for all `j &amp;lt; i`. -/">
            <AtomNode start="(621, 1)" end="(621, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(621, 5)" end="(621, 74)" leading="" trailing="&#10;" val="`xs.findIdx p = i` iff `p xs[i]` and `¬ p xs [j]` for all `j &amp;lt; i`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(622, 1)" end="(630, 34)" name="findIdx_eq" full_name="List.findIdx_eq" _is_private_decl="False">
        <AtomNode start="(622, 1)" end="(622, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(622, 9)" end="(622, 19)">
          <IdentNode start="(622, 9)" end="(622, 19)" leading="" trailing=" " raw_val="findIdx_eq" val="findIdx_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(622, 20)" end="(623, 91)">
          <NullNode start="(622, 20)" end="(622, 78)">
            <OtherNode start="(622, 20)" end="(622, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(622, 20)" end="(622, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(622, 21)" end="(622, 22)">
                <IdentNode start="(622, 21)" end="(622, 22)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(622, 23)" end="(622, 33)">
                <AtomNode start="(622, 23)" end="(622, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(622, 25)" end="(622, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(622, 25)" end="(622, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(622, 27)" end="(622, 28)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(622, 29)" end="(622, 33)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(622, 33)" end="(622, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(622, 35)" end="(622, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(622, 35)" end="(622, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(622, 36)" end="(622, 38)">
                <IdentNode start="(622, 36)" end="(622, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(622, 39)" end="(622, 47)">
                <AtomNode start="(622, 39)" end="(622, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(622, 41)" end="(622, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(622, 41)" end="(622, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(622, 46)" end="(622, 47)">
                    <IdentNode start="(622, 46)" end="(622, 47)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(622, 47)" end="(622, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(622, 49)" end="(622, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(622, 49)" end="(622, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(622, 50)" end="(622, 51)">
                <IdentNode start="(622, 50)" end="(622, 51)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(622, 52)" end="(622, 57)">
                <AtomNode start="(622, 52)" end="(622, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(622, 54)" end="(622, 57)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(622, 57)" end="(622, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(622, 59)" end="(622, 78)">
              <AtomNode start="(622, 59)" end="(622, 60)" leading="" trailing="" val="("/>
              <NullNode start="(622, 60)" end="(622, 61)">
                <IdentNode start="(622, 60)" end="(622, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(622, 62)" end="(622, 77)">
                <AtomNode start="(622, 62)" end="(622, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(622, 64)" end="(622, 77)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(622, 64)" end="(622, 65)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(622, 66)" end="(622, 67)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(622, 68)" end="(622, 77)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(622, 77)" end="(622, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(622, 79)" end="(623, 91)">
            <AtomNode start="(622, 79)" end="(622, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(623, 5)" end="(623, 91)" kind="«term_↔_»">
              <OtherNode start="(623, 5)" end="(623, 21)" kind="«term_=_»">
                <OtherNode start="(623, 5)" end="(623, 17)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(623, 5)" end="(623, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(623, 16)" end="(623, 17)">
                    <IdentNode start="(623, 16)" end="(623, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(623, 18)" end="(623, 19)" leading="" trailing=" " val="="/>
                <IdentNode start="(623, 20)" end="(623, 21)" leading="" trailing=" " raw_val="i" val="i"/>
              </OtherNode>
              <AtomNode start="(623, 22)" end="(623, 23)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(623, 24)" end="(623, 91)" kind="«term_∧_»">
                <OtherNode start="(623, 24)" end="(623, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(623, 24)" end="(623, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(623, 26)" end="(623, 31)">
                    <OtherNode start="(623, 26)" end="(623, 31)" kind="«term__[_]»">
                      <IdentNode start="(623, 26)" end="(623, 28)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(623, 28)" end="(623, 29)" leading="" trailing="" val="["/>
                      <IdentNode start="(623, 29)" end="(623, 30)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(623, 30)" end="(623, 31)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(623, 32)" end="(623, 33)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(623, 34)" end="(623, 91)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(623, 34)" end="(623, 35)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(623, 36)" end="(623, 51)">
                    <IdentNode start="(623, 36)" end="(623, 37)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(623, 38)" end="(623, 51)">
                      <AtomNode start="(623, 38)" end="(623, 39)" leading="" trailing="" val="("/>
                      <NullNode start="(623, 39)" end="(623, 42)">
                        <IdentNode start="(623, 39)" end="(623, 42)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(623, 43)" end="(623, 50)">
                        <AtomNode start="(623, 43)" end="(623, 44)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(623, 45)" end="(623, 50)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(623, 45)" end="(623, 46)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(623, 47)" end="(623, 48)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(623, 49)" end="(623, 50)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(623, 50)" end="(623, 51)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(623, 51)" end="(623, 52)" leading="" trailing=" " val=","/>
                  <OtherNode start="(623, 53)" end="(623, 91)" kind="«term_=_»">
                    <OtherNode start="(623, 53)" end="(623, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(623, 53)" end="(623, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(623, 55)" end="(623, 83)">
                        <OtherNode start="(623, 55)" end="(623, 83)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(623, 55)" end="(623, 56)" leading="" trailing="" val="("/>
                          <OtherNode start="(623, 56)" end="(623, 82)" kind="«term__[_]'_»">
                            <IdentNode start="(623, 56)" end="(623, 58)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(623, 58)" end="(623, 59)" leading="" trailing="" val="["/>
                            <IdentNode start="(623, 59)" end="(623, 60)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(623, 60)" end="(623, 62)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(623, 62)" end="(623, 82)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(623, 62)" end="(623, 63)" leading="" trailing="" val="("/>
                              <OtherNode start="(623, 63)" end="(623, 81)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(623, 63)" end="(623, 75)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(623, 76)" end="(623, 81)">
                                  <IdentNode start="(623, 76)" end="(623, 79)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <IdentNode start="(623, 80)" end="(623, 81)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(623, 81)" end="(623, 82)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(623, 82)" end="(623, 83)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(623, 84)" end="(623, 85)" leading="" trailing=" " val="="/>
                    <IdentNode start="(623, 86)" end="(623, 91)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(623, 92)" end="(630, 34)">
          <AtomNode start="(623, 92)" end="(623, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(623, 95)" end="(630, 34)">
            <AtomNode start="(623, 95)" end="(623, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(624, 3)" end="(630, 34)">
              <TacticTacticseq1IndentedNode start="(624, 3)" end="(630, 34)">
                <NullNode start="(624, 3)" end="(630, 34)">
                  <OtherNode start="(624, 3)" end="(625, 22)" kind="Lean.Parser.Tactic.refine" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;⊢ findIdx p xs = i ↔ p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs = i" tactic="refine ⟨fun f ↦ ⟨f ▸ (@findIdx_getElem _ p xs (f ▸ h)), fun _ hji ↦ not_of_lt_findIdx (f ▸ hji)⟩,&#10;  fun ⟨_, h2⟩ ↦ ?_⟩">
                    <AtomNode start="(624, 3)" end="(624, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(624, 10)" end="(625, 22)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(624, 10)" end="(624, 11)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(624, 11)" end="(625, 21)">
                        <OtherNode start="(624, 11)" end="(624, 99)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(624, 11)" end="(624, 14)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(624, 15)" end="(624, 99)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(624, 15)" end="(624, 16)">
                              <IdentNode start="(624, 15)" end="(624, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(624, 17)" end="(624, 18)" leading="" trailing=" " val="↦"/>
                            <OtherNode start="(624, 19)" end="(624, 99)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(624, 19)" end="(624, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(624, 20)" end="(624, 98)">
                                <OtherNode start="(624, 20)" end="(624, 57)" kind="Lean.Parser.Term.subst">
                                  <IdentNode start="(624, 20)" end="(624, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                                  <AtomNode start="(624, 22)" end="(624, 23)" leading="" trailing=" " val="▸"/>
                                  <NullNode start="(624, 24)" end="(624, 57)">
                                    <OtherNode start="(624, 24)" end="(624, 57)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(624, 24)" end="(624, 25)" leading="" trailing="" val="("/>
                                      <OtherNode start="(624, 25)" end="(624, 56)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(624, 25)" end="(624, 41)" kind="Lean.Parser.Term.explicit">
                                          <AtomNode start="(624, 25)" end="(624, 26)" leading="" trailing="" val="@"/>
                                          <IdentNode start="(624, 26)" end="(624, 41)" leading="" trailing=" " raw_val="findIdx_getElem" val="findIdx_getElem" full_name="List.findIdx_getElem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(530, 9)" def_end="(530, 24)"/>
                                        </OtherNode>
                                        <NullNode start="(624, 42)" end="(624, 56)">
                                          <TermHoleNode start="(624, 42)" end="(624, 43)">
                                            <AtomNode start="(624, 42)" end="(624, 43)" leading="" trailing=" " val="_"/>
                                          </TermHoleNode>
                                          <IdentNode start="(624, 44)" end="(624, 45)" leading="" trailing=" " raw_val="p" val="p"/>
                                          <IdentNode start="(624, 46)" end="(624, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                          <OtherNode start="(624, 49)" end="(624, 56)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(624, 49)" end="(624, 50)" leading="" trailing="" val="("/>
                                            <OtherNode start="(624, 50)" end="(624, 55)" kind="Lean.Parser.Term.subst">
                                              <IdentNode start="(624, 50)" end="(624, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                                              <AtomNode start="(624, 52)" end="(624, 53)" leading="" trailing=" " val="▸"/>
                                              <NullNode start="(624, 54)" end="(624, 55)">
                                                <IdentNode start="(624, 54)" end="(624, 55)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(624, 55)" end="(624, 56)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(624, 56)" end="(624, 57)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(624, 57)" end="(624, 58)" leading="" trailing=" " val=","/>
                                <OtherNode start="(624, 59)" end="(624, 98)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(624, 59)" end="(624, 62)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(624, 63)" end="(624, 98)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(624, 63)" end="(624, 68)">
                                      <TermHoleNode start="(624, 63)" end="(624, 64)">
                                        <AtomNode start="(624, 63)" end="(624, 64)" leading="" trailing=" " val="_"/>
                                      </TermHoleNode>
                                      <IdentNode start="(624, 65)" end="(624, 68)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(624, 69)" end="(624, 70)" leading="" trailing=" " val="↦"/>
                                    <OtherNode start="(624, 71)" end="(624, 98)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(624, 71)" end="(624, 88)" leading="" trailing=" " raw_val="not_of_lt_findIdx" val="not_of_lt_findIdx" full_name="List.not_of_lt_findIdx" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(582, 9)" def_end="(582, 26)"/>
                                      <NullNode start="(624, 89)" end="(624, 98)">
                                        <OtherNode start="(624, 89)" end="(624, 98)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(624, 89)" end="(624, 90)" leading="" trailing="" val="("/>
                                          <OtherNode start="(624, 90)" end="(624, 97)" kind="Lean.Parser.Term.subst">
                                            <IdentNode start="(624, 90)" end="(624, 91)" leading="" trailing=" " raw_val="f" val="f"/>
                                            <AtomNode start="(624, 92)" end="(624, 93)" leading="" trailing=" " val="▸"/>
                                            <NullNode start="(624, 94)" end="(624, 97)">
                                              <IdentNode start="(624, 94)" end="(624, 97)" leading="" trailing="" raw_val="hji" val="hji"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(624, 97)" end="(624, 98)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(624, 98)" end="(624, 99)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(624, 99)" end="(624, 100)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(625, 5)" end="(625, 21)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(625, 5)" end="(625, 8)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(625, 9)" end="(625, 21)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(625, 9)" end="(625, 16)">
                              <OtherNode start="(625, 9)" end="(625, 16)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(625, 9)" end="(625, 10)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(625, 10)" end="(625, 15)">
                                  <TermHoleNode start="(625, 10)" end="(625, 11)">
                                    <AtomNode start="(625, 10)" end="(625, 11)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(625, 11)" end="(625, 12)" leading="" trailing=" " val=","/>
                                  <IdentNode start="(625, 13)" end="(625, 15)" leading="" trailing="" raw_val="h2" val="h2"/>
                                </NullNode>
                                <AtomNode start="(625, 15)" end="(625, 16)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(625, 17)" end="(625, 18)" leading="" trailing=" " val="↦"/>
                            <OtherNode start="(625, 19)" end="(625, 21)" kind="Lean.Parser.Term.syntheticHole">
                              <AtomNode start="(625, 19)" end="(625, 20)" leading="" trailing="" val="?"/>
                              <AtomNode start="(625, 20)" end="(625, 21)" leading="" trailing="" val="_"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(625, 21)" end="(625, 22)" leading="" trailing="&#10;  " val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(626, 3)" end="(626, 51)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs = i" state_after="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs ≤ i" tactic="apply Nat.le_antisymm _ (le_findIdx_of_not h h2)">
                    <AtomNode start="(626, 3)" end="(626, 8)" leading="" trailing=" " val="apply"/>
                    <OtherNode start="(626, 9)" end="(626, 51)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(626, 9)" end="(626, 24)" leading="" trailing=" " raw_val="Nat.le_antisymm" val="Nat.le_antisymm" full_name="Nat.le_antisymm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(626, 25)" end="(626, 51)">
                        <TermHoleNode start="(626, 25)" end="(626, 26)">
                          <AtomNode start="(626, 25)" end="(626, 26)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                        <OtherNode start="(626, 27)" end="(626, 51)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(626, 27)" end="(626, 28)" leading="" trailing="" val="("/>
                          <OtherNode start="(626, 28)" end="(626, 50)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(626, 28)" end="(626, 45)" leading="" trailing=" " raw_val="le_findIdx_of_not" val="le_findIdx_of_not" full_name="List.le_findIdx_of_not" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(606, 9)" def_end="(606, 26)"/>
                            <NullNode start="(626, 46)" end="(626, 50)">
                              <IdentNode start="(626, 46)" end="(626, 47)" leading="" trailing=" " raw_val="h" val="h"/>
                              <IdentNode start="(626, 48)" end="(626, 50)" leading="" trailing="" raw_val="h2" val="h2"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(626, 50)" end="(626, 51)" leading="" trailing="&#10;  " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(627, 3)" end="(627, 34)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ findIdx p xs ≤ i" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬findIdx p xs ≤ i → False" tactic="apply Decidable.byContradiction">
                    <AtomNode start="(627, 3)" end="(627, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(627, 9)" end="(627, 34)" leading="" trailing="&#10;  " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(628, 3)" end="(628, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ ¬findIdx p xs ≤ i → False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : ¬findIdx p xs ≤ i&#10;⊢ False" tactic="intro h3">
                    <AtomNode start="(628, 3)" end="(628, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(628, 9)" end="(628, 11)">
                      <IdentNode start="(628, 9)" end="(628, 11)" leading="" trailing="&#10;  " raw_val="h3" val="h3"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(629, 3)" end="(629, 13)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : ¬findIdx p xs ≤ i&#10;⊢ False" state_after="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : i &amp;lt; findIdx p xs&#10;⊢ False" tactic="simp at h3">
                    <AtomNode start="(629, 3)" end="(629, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(629, 8)" end="(629, 13)">
                      <OtherNode start="(629, 8)" end="(629, 13)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(629, 8)" end="(629, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(629, 11)" end="(629, 13)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(629, 11)" end="(629, 13)">
                            <IdentNode start="(629, 11)" end="(629, 13)" leading="" trailing="&#10;  " raw_val="h3" val="h3"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(630, 3)" end="(630, 34)" kind="Lean.Parser.Tactic.simpAll" state_before="case h&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;i : Nat&#10;h : i &amp;lt; xs.length&#10;x✝ : p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;left✝ : p xs[i] = true&#10;h2 : ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;h3 : i &amp;lt; findIdx p xs&#10;⊢ False" state_after="no goals" tactic="simp_all [not_of_lt_findIdx h3]">
                    <AtomNode start="(630, 3)" end="(630, 11)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(630, 12)" end="(630, 34)">
                      <AtomNode start="(630, 12)" end="(630, 13)" leading="" trailing="" val="["/>
                      <NullNode start="(630, 13)" end="(630, 33)">
                        <OtherNode start="(630, 13)" end="(630, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(630, 13)" end="(630, 33)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(630, 13)" end="(630, 30)" leading="" trailing=" " raw_val="not_of_lt_findIdx" val="not_of_lt_findIdx" full_name="List.not_of_lt_findIdx" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(582, 9)" def_end="(582, 26)"/>
                            <NullNode start="(630, 31)" end="(630, 33)">
                              <IdentNode start="(630, 31)" end="(630, 33)" leading="" trailing="" raw_val="h3" val="h3"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(630, 33)" end="(630, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(632, 1)" end="(642, 37)" name="findIdx_append" full_name="List.findIdx_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(632, 1)" end="(642, 37)" name="findIdx_append" full_name="List.findIdx_append" _is_private_decl="False">
        <AtomNode start="(632, 1)" end="(632, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(632, 9)" end="(632, 23)">
          <IdentNode start="(632, 9)" end="(632, 23)" leading="" trailing=" " raw_val="findIdx_append" val="findIdx_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(632, 24)" end="(634, 82)">
          <NullNode start="(632, 24)" end="(632, 55)">
            <OtherNode start="(632, 24)" end="(632, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(632, 24)" end="(632, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(632, 25)" end="(632, 26)">
                <IdentNode start="(632, 25)" end="(632, 26)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(632, 27)" end="(632, 37)">
                <AtomNode start="(632, 27)" end="(632, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(632, 29)" end="(632, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(632, 29)" end="(632, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(632, 31)" end="(632, 32)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(632, 33)" end="(632, 37)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(632, 37)" end="(632, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(632, 39)" end="(632, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(632, 39)" end="(632, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(632, 40)" end="(632, 45)">
                <IdentNode start="(632, 40)" end="(632, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(632, 43)" end="(632, 45)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(632, 46)" end="(632, 54)">
                <AtomNode start="(632, 46)" end="(632, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(632, 48)" end="(632, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(632, 48)" end="(632, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(632, 53)" end="(632, 54)">
                    <IdentNode start="(632, 53)" end="(632, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(632, 54)" end="(632, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(632, 56)" end="(634, 82)">
            <AtomNode start="(632, 56)" end="(632, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(633, 5)" end="(634, 82)" kind="«term_=_»">
              <OtherNode start="(633, 5)" end="(633, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(633, 5)" end="(633, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(633, 5)" end="(633, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(633, 5)" end="(633, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(633, 6)" end="(633, 14)" kind="«term_++_»">
                      <IdentNode start="(633, 6)" end="(633, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(633, 9)" end="(633, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(633, 12)" end="(633, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(633, 14)" end="(633, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(633, 15)" end="(633, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(633, 16)" end="(633, 23)" leading="" trailing=" " raw_val="findIdx" val="findIdx" full_name="List.findIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(633, 24)" end="(633, 25)">
                  <IdentNode start="(633, 24)" end="(633, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(633, 26)" end="(633, 27)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(634, 7)" end="(634, 82)" kind="termIfThenElse">
                <AtomNode start="(634, 7)" end="(634, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(634, 10)" end="(634, 34)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(634, 10)" end="(634, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(634, 10)" end="(634, 20)" leading="" trailing=" " raw_val="l₁.findIdx" val="l₁.findIdx"/>
                    <NullNode start="(634, 21)" end="(634, 22)">
                      <IdentNode start="(634, 21)" end="(634, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(634, 23)" end="(634, 24)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(634, 25)" end="(634, 34)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                </OtherNode>
                <AtomNode start="(634, 35)" end="(634, 39)" leading="" trailing=" " val="then"/>
                <OtherNode start="(634, 40)" end="(634, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(634, 40)" end="(634, 50)" leading="" trailing=" " raw_val="l₁.findIdx" val="l₁.findIdx"/>
                  <NullNode start="(634, 51)" end="(634, 52)">
                    <IdentNode start="(634, 51)" end="(634, 52)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(634, 53)" end="(634, 57)" leading="" trailing=" " val="else"/>
                <OtherNode start="(634, 58)" end="(634, 82)" kind="«term_+_»">
                  <OtherNode start="(634, 58)" end="(634, 70)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(634, 58)" end="(634, 68)" leading="" trailing=" " raw_val="l₂.findIdx" val="l₂.findIdx"/>
                    <NullNode start="(634, 69)" end="(634, 70)">
                      <IdentNode start="(634, 69)" end="(634, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(634, 71)" end="(634, 72)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(634, 73)" end="(634, 82)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(634, 83)" end="(642, 37)">
          <AtomNode start="(634, 83)" end="(634, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(634, 86)" end="(642, 37)">
            <AtomNode start="(634, 86)" end="(634, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(635, 3)" end="(642, 37)">
              <TacticTacticseq1IndentedNode start="(635, 3)" end="(642, 37)">
                <NullNode start="(635, 3)" end="(642, 37)">
                  <OtherNode start="(635, 3)" end="(642, 37)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;⊢ findIdx p (l₁ ++ l₂) = if findIdx p l₁ &amp;lt; l₁.length then findIdx p l₁ else findIdx p l₂ + l₁.length" state_after="no goals" tactic="induction l₁ with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx_cons, length_cons, cons_append]&#10;  by_cases h : p x&#10;  · simp [h]&#10;  · simp only [h, ih, cond_eq_if, Bool.false_eq_true, ↓reduceIte, add_one_lt_add_one_iff]&#10;    split &amp;lt;;&amp;gt; simp [Nat.add_assoc]">
                    <AtomNode start="(635, 3)" end="(635, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(635, 13)" end="(635, 15)">
                      <OtherNode start="(635, 13)" end="(635, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(635, 13)" end="(635, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(635, 16)" end="(642, 37)">
                      <OtherNode start="(635, 16)" end="(642, 37)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(635, 16)" end="(635, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(636, 3)" end="(642, 37)">
                          <OtherNode start="(636, 3)" end="(636, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(636, 3)" end="(636, 8)">
                              <OtherNode start="(636, 3)" end="(636, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(636, 3)" end="(636, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(636, 5)" end="(636, 8)">
                                  <NullNode/>
                                  <IdentNode start="(636, 5)" end="(636, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(636, 9)" end="(636, 16)">
                              <AtomNode start="(636, 9)" end="(636, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(636, 12)" end="(636, 16)">
                                <TacticTacticseq1IndentedNode start="(636, 12)" end="(636, 16)">
                                  <NullNode start="(636, 12)" end="(636, 16)">
                                    <OtherNode start="(636, 12)" end="(636, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;⊢ findIdx p ([] ++ l₂) = if findIdx p [] &amp;lt; [].length then findIdx p [] else findIdx p l₂ + [].length" state_after="no goals" tactic="simp">
                                      <AtomNode start="(636, 12)" end="(636, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(637, 3)" end="(642, 37)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(637, 3)" end="(637, 17)">
                              <OtherNode start="(637, 3)" end="(637, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(637, 3)" end="(637, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(637, 5)" end="(637, 9)">
                                  <NullNode/>
                                  <IdentNode start="(637, 5)" end="(637, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(637, 10)" end="(637, 17)">
                                  <IdentNode start="(637, 10)" end="(637, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(637, 12)" end="(637, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(637, 15)" end="(637, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(637, 18)" end="(642, 37)">
                              <AtomNode start="(637, 18)" end="(637, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(638, 5)" end="(642, 37)">
                                <TacticTacticseq1IndentedNode start="(638, 5)" end="(642, 37)">
                                  <NullNode start="(638, 5)" end="(642, 37)">
                                    <OtherNode start="(638, 5)" end="(638, 55)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;⊢ findIdx p (x :: xs ++ l₂) =&#10;    if findIdx p (x :: xs) &amp;lt; (x :: xs).length then findIdx p (x :: xs) else findIdx p l₂ + (x :: xs).length" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" tactic="simp only [findIdx_cons, length_cons, cons_append]">
                                      <AtomNode start="(638, 5)" end="(638, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(638, 10)" end="(638, 14)">
                                        <AtomNode start="(638, 10)" end="(638, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(638, 15)" end="(638, 55)">
                                        <AtomNode start="(638, 15)" end="(638, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(638, 16)" end="(638, 54)">
                                          <OtherNode start="(638, 16)" end="(638, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(638, 16)" end="(638, 28)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                          <AtomNode start="(638, 28)" end="(638, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(638, 30)" end="(638, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(638, 30)" end="(638, 41)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(638, 41)" end="(638, 42)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(638, 43)" end="(638, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(638, 43)" end="(638, 54)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(638, 54)" end="(638, 55)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(639, 5)" end="(639, 21)" kind="«tacticBy_cases_:_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" state_after="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" tactic="by_cases h : p x">
                                      <AtomNode start="(639, 5)" end="(639, 13)" leading="" trailing=" " val="by_cases"/>
                                      <NullNode start="(639, 14)" end="(639, 17)">
                                        <IdentNode start="(639, 14)" end="(639, 15)" leading="" trailing=" " raw_val="h" val="h"/>
                                        <AtomNode start="(639, 16)" end="(639, 17)" leading="" trailing=" " val=":"/>
                                      </NullNode>
                                      <OtherNode start="(639, 18)" end="(639, 21)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(639, 18)" end="(639, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                                        <NullNode start="(639, 20)" end="(639, 21)">
                                          <IdentNode start="(639, 20)" end="(639, 21)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(640, 5)" end="(640, 15)" kind="Lean.cdot" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)&#10;&#10;case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" tactic="· simp [h]">
                                      <OtherNode start="(640, 5)" end="(640, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(640, 5)" end="(640, 6)" kind="patternIgnore">
                                          <OtherNode start="(640, 5)" end="(640, 6)" kind="token.«· »">
                                            <AtomNode start="(640, 5)" end="(640, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(640, 7)" end="(640, 15)">
                                        <TacticTacticseq1IndentedNode start="(640, 7)" end="(640, 15)">
                                          <NullNode start="(640, 7)" end="(640, 15)">
                                            <OtherNode start="(640, 7)" end="(640, 15)" kind="Lean.Parser.Tactic.simp" state_before="case pos&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" state_after="no goals" tactic="simp [h]">
                                              <AtomNode start="(640, 7)" end="(640, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(640, 12)" end="(640, 15)">
                                                <AtomNode start="(640, 12)" end="(640, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(640, 13)" end="(640, 14)">
                                                  <OtherNode start="(640, 13)" end="(640, 14)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(640, 13)" end="(640, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(640, 14)" end="(640, 15)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(641, 5)" end="(642, 37)" kind="Lean.cdot" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" state_after="no goals" tactic="· simp only [h, ih, cond_eq_if, Bool.false_eq_true, ↓reduceIte, add_one_lt_add_one_iff]&#10;  split &amp;lt;;&amp;gt; simp [Nat.add_assoc]">
                                      <OtherNode start="(641, 5)" end="(641, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(641, 5)" end="(641, 6)" kind="patternIgnore">
                                          <OtherNode start="(641, 5)" end="(641, 6)" kind="token.«· »">
                                            <AtomNode start="(641, 5)" end="(641, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(641, 7)" end="(642, 37)">
                                        <TacticTacticseq1IndentedNode start="(641, 7)" end="(642, 37)">
                                          <NullNode start="(641, 7)" end="(642, 37)">
                                            <OtherNode start="(641, 7)" end="(641, 92)" kind="Lean.Parser.Tactic.simp" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (bif p x then 0 else findIdx p (xs ++ l₂) + 1) =&#10;    if (bif p x then 0 else findIdx p xs + 1) &amp;lt; xs.length + 1 then bif p x then 0 else findIdx p xs + 1&#10;    else findIdx p l₂ + (xs.length + 1)" state_after="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length) + 1 =&#10;    if findIdx p xs &amp;lt; xs.length then findIdx p xs + 1 else findIdx p l₂ + (xs.length + 1)" tactic="simp only [h, ih, cond_eq_if, Bool.false_eq_true, ↓reduceIte, add_one_lt_add_one_iff]">
                                              <AtomNode start="(641, 7)" end="(641, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(641, 12)" end="(641, 16)">
                                                <AtomNode start="(641, 12)" end="(641, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(641, 17)" end="(641, 92)">
                                                <AtomNode start="(641, 17)" end="(641, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(641, 18)" end="(641, 91)">
                                                  <OtherNode start="(641, 18)" end="(641, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(641, 18)" end="(641, 19)" leading="" trailing="" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                  <AtomNode start="(641, 19)" end="(641, 20)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(641, 21)" end="(641, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(641, 21)" end="(641, 23)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(641, 23)" end="(641, 24)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(641, 25)" end="(641, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(641, 25)" end="(641, 35)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(641, 35)" end="(641, 36)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(641, 37)" end="(641, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(641, 37)" end="(641, 55)" leading="" trailing="" raw_val="Bool.false_eq_true" val="Bool.false_eq_true" full_name="Bool.false_eq_true" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(641, 55)" end="(641, 56)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(641, 57)" end="(641, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode start="(641, 57)" end="(641, 58)">
                                                      <OtherNode start="(641, 57)" end="(641, 58)" kind="Lean.Parser.Tactic.simpPre">
                                                        <AtomNode start="(641, 57)" end="(641, 58)" leading="" trailing="" val="↓"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <IdentNode start="(641, 58)" end="(641, 67)" leading="" trailing="" raw_val="reduceIte" val="reduceIte"/>
                                                  </OtherNode>
                                                  <AtomNode start="(641, 67)" end="(641, 68)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(641, 69)" end="(641, 91)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(641, 69)" end="(641, 91)" leading="" trailing="" raw_val="add_one_lt_add_one_iff" val="add_one_lt_add_one_iff" full_name="Nat.add_one_lt_add_one_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(641, 91)" end="(641, 92)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(642, 7)" end="(642, 37)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case neg&#10;α : Type u_1&#10;p : α → Bool&#10;l₂ : List α&#10;x : α&#10;xs : List α&#10;ih : findIdx p (xs ++ l₂) = if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length&#10;h : ¬p x = true&#10;⊢ (if findIdx p xs &amp;lt; xs.length then findIdx p xs else findIdx p l₂ + xs.length) + 1 =&#10;    if findIdx p xs &amp;lt; xs.length then findIdx p xs + 1 else findIdx p l₂ + (xs.length + 1)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [Nat.add_assoc]">
                                              <OtherNode start="(642, 7)" end="(642, 12)" kind="Lean.Parser.Tactic.split">
                                                <AtomNode start="(642, 7)" end="(642, 12)" leading="" trailing=" " val="split"/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(642, 13)" end="(642, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(642, 17)" end="(642, 37)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(642, 17)" end="(642, 21)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(642, 22)" end="(642, 37)">
                                                  <AtomNode start="(642, 22)" end="(642, 23)" leading="" trailing="" val="["/>
                                                  <NullNode start="(642, 23)" end="(642, 36)">
                                                    <OtherNode start="(642, 23)" end="(642, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(642, 23)" end="(642, 36)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(642, 36)" end="(642, 37)" leading="" trailing="&#10;&#10;" val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(644, 1)" end="(651, 42)" name="IsPrefix.findIdx_le" full_name="List.IsPrefix.findIdx_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(644, 1)" end="(651, 42)" name="IsPrefix.findIdx_le" full_name="List.IsPrefix.findIdx_le" _is_private_decl="False">
        <AtomNode start="(644, 1)" end="(644, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(644, 9)" end="(644, 28)">
          <IdentNode start="(644, 9)" end="(644, 28)" leading="" trailing=" " raw_val="IsPrefix.findIdx_le" val="IsPrefix.findIdx_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(644, 29)" end="(645, 32)">
          <NullNode start="(644, 29)" end="(644, 76)">
            <OtherNode start="(644, 29)" end="(644, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(644, 29)" end="(644, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(644, 30)" end="(644, 35)">
                <IdentNode start="(644, 30)" end="(644, 32)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(644, 33)" end="(644, 35)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(644, 36)" end="(644, 44)">
                <AtomNode start="(644, 36)" end="(644, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(644, 38)" end="(644, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(644, 38)" end="(644, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(644, 43)" end="(644, 44)">
                    <IdentNode start="(644, 43)" end="(644, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(644, 44)" end="(644, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(644, 46)" end="(644, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(644, 46)" end="(644, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(644, 47)" end="(644, 48)">
                <IdentNode start="(644, 47)" end="(644, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(644, 49)" end="(644, 59)">
                <AtomNode start="(644, 49)" end="(644, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(644, 51)" end="(644, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(644, 51)" end="(644, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(644, 53)" end="(644, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(644, 55)" end="(644, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(644, 59)" end="(644, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(644, 61)" end="(644, 76)">
              <AtomNode start="(644, 61)" end="(644, 62)" leading="" trailing="" val="("/>
              <NullNode start="(644, 62)" end="(644, 63)">
                <IdentNode start="(644, 62)" end="(644, 63)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(644, 64)" end="(644, 75)">
                <AtomNode start="(644, 64)" end="(644, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(644, 66)" end="(644, 75)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(644, 66)" end="(644, 68)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(644, 69)" end="(644, 72)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(644, 73)" end="(644, 75)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(644, 75)" end="(644, 76)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(644, 77)" end="(645, 32)">
            <AtomNode start="(644, 77)" end="(644, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(645, 5)" end="(645, 32)" kind="«term_≤_»">
              <OtherNode start="(645, 5)" end="(645, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(645, 5)" end="(645, 15)" leading="" trailing=" " raw_val="l₁.findIdx" val="l₁.findIdx"/>
                <NullNode start="(645, 16)" end="(645, 17)">
                  <IdentNode start="(645, 16)" end="(645, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(645, 18)" end="(645, 19)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(645, 20)" end="(645, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(645, 20)" end="(645, 30)" leading="" trailing=" " raw_val="l₂.findIdx" val="l₂.findIdx"/>
                <NullNode start="(645, 31)" end="(645, 32)">
                  <IdentNode start="(645, 31)" end="(645, 32)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(645, 33)" end="(651, 42)">
          <AtomNode start="(645, 33)" end="(645, 35)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(645, 36)" end="(651, 42)">
            <AtomNode start="(645, 36)" end="(645, 38)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(646, 3)" end="(651, 42)">
              <TacticTacticseq1IndentedNode start="(646, 3)" end="(651, 42)">
                <NullNode start="(646, 3)" end="(651, 42)">
                  <OtherNode start="(646, 3)" end="(646, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ findIdx p l₁ ≤ findIdx p l₂" state_after="α : Type u_1&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ findIdx p l₁ ≤ findIdx p l₂" tactic="rw [IsPrefix] at h">
                    <AtomNode start="(646, 3)" end="(646, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(646, 6)" end="(646, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(646, 6)" end="(646, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(646, 7)" end="(646, 15)">
                        <OtherNode start="(646, 7)" end="(646, 15)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(646, 7)" end="(646, 15)" leading="" trailing="" raw_val="IsPrefix" val="IsPrefix" full_name="List.IsPrefix" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(646, 15)" end="(646, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(646, 17)" end="(646, 21)">
                      <OtherNode start="(646, 17)" end="(646, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(646, 17)" end="(646, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(646, 20)" end="(646, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(646, 20)" end="(646, 21)">
                            <IdentNode start="(646, 20)" end="(646, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(647, 3)" end="(647, 23)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ findIdx p l₁ ≤ findIdx p l₂" state_after="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ findIdx p l₁ ≤ findIdx p (l₁ ++ t)" tactic="obtain ⟨t, rfl⟩ := h">
                    <AtomNode start="(647, 3)" end="(647, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(647, 10)" end="(647, 18)">
                      <OtherNode start="(647, 10)" end="(647, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(647, 10)" end="(647, 18)">
                          <OtherNode start="(647, 10)" end="(647, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(647, 10)" end="(647, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(647, 11)" end="(647, 17)">
                              <OtherNode start="(647, 11)" end="(647, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(647, 11)" end="(647, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(647, 11)" end="(647, 12)">
                                    <OtherNode start="(647, 11)" end="(647, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(647, 11)" end="(647, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(647, 12)" end="(647, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(647, 14)" end="(647, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(647, 14)" end="(647, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(647, 14)" end="(647, 17)">
                                    <OtherNode start="(647, 14)" end="(647, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(647, 14)" end="(647, 17)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(647, 17)" end="(647, 18)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(647, 19)" end="(647, 23)">
                      <AtomNode start="(647, 19)" end="(647, 21)" leading="" trailing=" " val=":="/>
                      <NullNode start="(647, 22)" end="(647, 23)">
                        <IdentNode start="(647, 22)" end="(647, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(648, 3)" end="(648, 48)" kind="Lean.Parser.Tactic.simp" state_before="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ findIdx p l₁ ≤ findIdx p (l₁ ++ t)" state_after="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ findIdx p l₁ ≤ if ∃ x, x ∈ l₁ ∧ p x = true then findIdx p l₁ else findIdx p t + l₁.length" tactic="simp only [findIdx_append, findIdx_lt_length]">
                    <AtomNode start="(648, 3)" end="(648, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(648, 8)" end="(648, 12)">
                      <AtomNode start="(648, 8)" end="(648, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(648, 13)" end="(648, 48)">
                      <AtomNode start="(648, 13)" end="(648, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(648, 14)" end="(648, 47)">
                        <OtherNode start="(648, 14)" end="(648, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(648, 14)" end="(648, 28)" leading="" trailing="" raw_val="findIdx_append" val="findIdx_append" full_name="List.findIdx_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(632, 9)" def_end="(632, 23)"/>
                        </OtherNode>
                        <AtomNode start="(648, 28)" end="(648, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(648, 30)" end="(648, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(648, 30)" end="(648, 47)" leading="" trailing="" raw_val="findIdx_lt_length" val="findIdx_lt_length" full_name="List.findIdx_lt_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(573, 9)" def_end="(573, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(648, 47)" end="(648, 48)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(649, 3)" end="(649, 8)" kind="Lean.Parser.Tactic.split" state_before="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ findIdx p l₁ ≤ if ∃ x, x ∈ l₁ ∧ p x = true then findIdx p l₁ else findIdx p t + l₁.length" state_after="case intro.isTrue&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p l₁&#10;&#10;case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p t + l₁.length" tactic="split">
                    <AtomNode start="(649, 3)" end="(649, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(650, 3)" end="(650, 25)" kind="Lean.cdot" state_before="case intro.isTrue&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p l₁&#10;&#10;case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p t + l₁.length" state_after="case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p t + l₁.length" tactic="· exact Nat.le_refl ..">
                    <OtherNode start="(650, 3)" end="(650, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(650, 3)" end="(650, 4)" kind="patternIgnore">
                        <OtherNode start="(650, 3)" end="(650, 4)" kind="token.«· »">
                          <AtomNode start="(650, 3)" end="(650, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(650, 5)" end="(650, 25)">
                      <TacticTacticseq1IndentedNode start="(650, 5)" end="(650, 25)">
                        <NullNode start="(650, 5)" end="(650, 25)">
                          <OtherNode start="(650, 5)" end="(650, 25)" kind="Lean.Parser.Tactic.exact" state_before="case intro.isTrue&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p l₁" state_after="no goals" tactic="exact Nat.le_refl ..">
                            <AtomNode start="(650, 5)" end="(650, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(650, 11)" end="(650, 25)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(650, 11)" end="(650, 22)" leading="" trailing=" " raw_val="Nat.le_refl" val="Nat.le_refl" full_name="Nat.le_refl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(650, 23)" end="(650, 25)">
                                <OtherNode start="(650, 23)" end="(650, 25)" kind="Lean.Parser.Term.ellipsis">
                                  <AtomNode start="(650, 23)" end="(650, 25)" leading="" trailing="&#10;  " val=".."/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(651, 3)" end="(651, 42)" kind="Lean.cdot" state_before="case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p t + l₁.length" state_after="no goals" tactic="· simp_all [findIdx_eq_length_of_false]">
                    <OtherNode start="(651, 3)" end="(651, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(651, 3)" end="(651, 4)" kind="patternIgnore">
                        <OtherNode start="(651, 3)" end="(651, 4)" kind="token.«· »">
                          <AtomNode start="(651, 3)" end="(651, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(651, 5)" end="(651, 42)">
                      <TacticTacticseq1IndentedNode start="(651, 5)" end="(651, 42)">
                        <NullNode start="(651, 5)" end="(651, 42)">
                          <OtherNode start="(651, 5)" end="(651, 42)" kind="Lean.Parser.Tactic.simpAll" state_before="case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ ≤ findIdx p t + l₁.length" state_after="no goals" tactic="simp_all [findIdx_eq_length_of_false]">
                            <AtomNode start="(651, 5)" end="(651, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(651, 14)" end="(651, 42)">
                              <AtomNode start="(651, 14)" end="(651, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(651, 15)" end="(651, 41)">
                                <OtherNode start="(651, 15)" end="(651, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(651, 15)" end="(651, 41)" leading="" trailing="" raw_val="findIdx_eq_length_of_false" val="findIdx_eq_length_of_false" full_name="List.findIdx_eq_length_of_false" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(561, 9)" def_end="(561, 35)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(651, 41)" end="(651, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(653, 1)" end="(660, 13)" name="IsPrefix.findIdx_eq_of_findIdx_lt_length" full_name="List.IsPrefix.findIdx_eq_of_findIdx_lt_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(653, 1)" end="(660, 13)" name="IsPrefix.findIdx_eq_of_findIdx_lt_length" full_name="List.IsPrefix.findIdx_eq_of_findIdx_lt_length" _is_private_decl="False">
        <AtomNode start="(653, 1)" end="(653, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(653, 9)" end="(653, 49)">
          <IdentNode start="(653, 9)" end="(653, 49)" leading="" trailing=" " raw_val="IsPrefix.findIdx_eq_of_findIdx_lt_length" val="IsPrefix.findIdx_eq_of_findIdx_lt_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(653, 50)" end="(654, 66)">
          <NullNode start="(653, 50)" end="(654, 36)">
            <OtherNode start="(653, 50)" end="(653, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(653, 50)" end="(653, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(653, 51)" end="(653, 56)">
                <IdentNode start="(653, 51)" end="(653, 53)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(653, 54)" end="(653, 56)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(653, 57)" end="(653, 65)">
                <AtomNode start="(653, 57)" end="(653, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(653, 59)" end="(653, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(653, 59)" end="(653, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(653, 64)" end="(653, 65)">
                    <IdentNode start="(653, 64)" end="(653, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(653, 65)" end="(653, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(653, 67)" end="(653, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(653, 67)" end="(653, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(653, 68)" end="(653, 69)">
                <IdentNode start="(653, 68)" end="(653, 69)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(653, 70)" end="(653, 80)">
                <AtomNode start="(653, 70)" end="(653, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(653, 72)" end="(653, 80)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(653, 72)" end="(653, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(653, 74)" end="(653, 75)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(653, 76)" end="(653, 80)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(653, 80)" end="(653, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(653, 82)" end="(653, 97)">
              <AtomNode start="(653, 82)" end="(653, 83)" leading="" trailing="" val="("/>
              <NullNode start="(653, 83)" end="(653, 84)">
                <IdentNode start="(653, 83)" end="(653, 84)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(653, 85)" end="(653, 96)">
                <AtomNode start="(653, 85)" end="(653, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(653, 87)" end="(653, 96)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(653, 87)" end="(653, 89)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(653, 90)" end="(653, 93)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(653, 94)" end="(653, 96)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(653, 96)" end="(653, 97)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(654, 5)" end="(654, 36)">
              <AtomNode start="(654, 5)" end="(654, 6)" leading="" trailing="" val="("/>
              <NullNode start="(654, 6)" end="(654, 8)">
                <IdentNode start="(654, 6)" end="(654, 8)" leading="" trailing=" " raw_val="lt" val="lt"/>
              </NullNode>
              <NullNode start="(654, 9)" end="(654, 35)">
                <AtomNode start="(654, 9)" end="(654, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(654, 11)" end="(654, 35)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(654, 11)" end="(654, 23)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(654, 11)" end="(654, 21)" leading="" trailing=" " raw_val="l₁.findIdx" val="l₁.findIdx"/>
                    <NullNode start="(654, 22)" end="(654, 23)">
                      <IdentNode start="(654, 22)" end="(654, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(654, 24)" end="(654, 25)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(654, 26)" end="(654, 35)" leading="" trailing="" raw_val="l₁.length" val="l₁.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(654, 35)" end="(654, 36)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(654, 37)" end="(654, 66)">
            <AtomNode start="(654, 37)" end="(654, 38)" leading="" trailing=" " val=":"/>
            <OtherNode start="(654, 39)" end="(654, 66)" kind="«term_=_»">
              <OtherNode start="(654, 39)" end="(654, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(654, 39)" end="(654, 49)" leading="" trailing=" " raw_val="l₂.findIdx" val="l₂.findIdx"/>
                <NullNode start="(654, 50)" end="(654, 51)">
                  <IdentNode start="(654, 50)" end="(654, 51)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(654, 52)" end="(654, 53)" leading="" trailing=" " val="="/>
              <OtherNode start="(654, 54)" end="(654, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(654, 54)" end="(654, 64)" leading="" trailing=" " raw_val="l₁.findIdx" val="l₁.findIdx"/>
                <NullNode start="(654, 65)" end="(654, 66)">
                  <IdentNode start="(654, 65)" end="(654, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(654, 67)" end="(660, 13)">
          <AtomNode start="(654, 67)" end="(654, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(654, 70)" end="(660, 13)">
            <AtomNode start="(654, 70)" end="(654, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(655, 3)" end="(660, 13)">
              <TacticTacticseq1IndentedNode start="(655, 3)" end="(660, 13)">
                <NullNode start="(655, 3)" end="(660, 13)">
                  <OtherNode start="(655, 3)" end="(655, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : l₁ &amp;lt;+: l₂&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;⊢ findIdx p l₂ = findIdx p l₁" state_after="α : Type u_1&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;⊢ findIdx p l₂ = findIdx p l₁" tactic="rw [IsPrefix] at h">
                    <AtomNode start="(655, 3)" end="(655, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(655, 6)" end="(655, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(655, 6)" end="(655, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(655, 7)" end="(655, 15)">
                        <OtherNode start="(655, 7)" end="(655, 15)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(655, 7)" end="(655, 15)" leading="" trailing="" raw_val="IsPrefix" val="IsPrefix" full_name="List.IsPrefix" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(655, 15)" end="(655, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(655, 17)" end="(655, 21)">
                      <OtherNode start="(655, 17)" end="(655, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(655, 17)" end="(655, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(655, 20)" end="(655, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(655, 20)" end="(655, 21)">
                            <IdentNode start="(655, 20)" end="(655, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(656, 3)" end="(656, 23)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;⊢ findIdx p l₂ = findIdx p l₁" state_after="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;⊢ findIdx p (l₁ ++ t) = findIdx p l₁" tactic="obtain ⟨t, rfl⟩ := h">
                    <AtomNode start="(656, 3)" end="(656, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(656, 10)" end="(656, 18)">
                      <OtherNode start="(656, 10)" end="(656, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(656, 10)" end="(656, 18)">
                          <OtherNode start="(656, 10)" end="(656, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(656, 10)" end="(656, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(656, 11)" end="(656, 17)">
                              <OtherNode start="(656, 11)" end="(656, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(656, 11)" end="(656, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(656, 11)" end="(656, 12)">
                                    <OtherNode start="(656, 11)" end="(656, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(656, 11)" end="(656, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(656, 12)" end="(656, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(656, 14)" end="(656, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(656, 14)" end="(656, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(656, 14)" end="(656, 17)">
                                    <OtherNode start="(656, 14)" end="(656, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(656, 14)" end="(656, 17)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(656, 17)" end="(656, 18)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(656, 19)" end="(656, 23)">
                      <AtomNode start="(656, 19)" end="(656, 21)" leading="" trailing=" " val=":="/>
                      <NullNode start="(656, 22)" end="(656, 23)">
                        <IdentNode start="(656, 22)" end="(656, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(657, 3)" end="(657, 48)" kind="Lean.Parser.Tactic.simp" state_before="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;⊢ findIdx p (l₁ ++ t) = findIdx p l₁" state_after="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;⊢ (if ∃ x, x ∈ l₁ ∧ p x = true then findIdx p l₁ else findIdx p t + l₁.length) = findIdx p l₁" tactic="simp only [findIdx_append, findIdx_lt_length]">
                    <AtomNode start="(657, 3)" end="(657, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(657, 8)" end="(657, 12)">
                      <AtomNode start="(657, 8)" end="(657, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(657, 13)" end="(657, 48)">
                      <AtomNode start="(657, 13)" end="(657, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(657, 14)" end="(657, 47)">
                        <OtherNode start="(657, 14)" end="(657, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(657, 14)" end="(657, 28)" leading="" trailing="" raw_val="findIdx_append" val="findIdx_append" full_name="List.findIdx_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(632, 9)" def_end="(632, 23)"/>
                        </OtherNode>
                        <AtomNode start="(657, 28)" end="(657, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(657, 30)" end="(657, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(657, 30)" end="(657, 47)" leading="" trailing="" raw_val="findIdx_lt_length" val="findIdx_lt_length" full_name="List.findIdx_lt_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(573, 9)" def_end="(573, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(657, 47)" end="(657, 48)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(658, 3)" end="(658, 8)" kind="Lean.Parser.Tactic.split" state_before="case intro&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;⊢ (if ∃ x, x ∈ l₁ ∧ p x = true then findIdx p l₁ else findIdx p t + l₁.length) = findIdx p l₁" state_after="case intro.isTrue&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ = findIdx p l₁&#10;&#10;case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p t + l₁.length = findIdx p l₁" tactic="split">
                    <AtomNode start="(658, 3)" end="(658, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(659, 3)" end="(659, 8)" kind="Lean.cdot" state_before="case intro.isTrue&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ = findIdx p l₁&#10;&#10;case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p t + l₁.length = findIdx p l₁" state_after="case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p t + l₁.length = findIdx p l₁" tactic="· rfl">
                    <OtherNode start="(659, 3)" end="(659, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(659, 3)" end="(659, 4)" kind="patternIgnore">
                        <OtherNode start="(659, 3)" end="(659, 4)" kind="token.«· »">
                          <AtomNode start="(659, 3)" end="(659, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(659, 5)" end="(659, 8)">
                      <TacticTacticseq1IndentedNode start="(659, 5)" end="(659, 8)">
                        <NullNode start="(659, 5)" end="(659, 8)">
                          <OtherNode start="(659, 5)" end="(659, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case intro.isTrue&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p l₁ = findIdx p l₁" state_after="no goals" tactic="rfl">
                            <AtomNode start="(659, 5)" end="(659, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(660, 3)" end="(660, 13)" kind="Lean.cdot" state_before="case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p t + l₁.length = findIdx p l₁" state_after="no goals" tactic="· simp_all">
                    <OtherNode start="(660, 3)" end="(660, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(660, 3)" end="(660, 4)" kind="patternIgnore">
                        <OtherNode start="(660, 3)" end="(660, 4)" kind="token.«· »">
                          <AtomNode start="(660, 3)" end="(660, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(660, 5)" end="(660, 13)">
                      <TacticTacticseq1IndentedNode start="(660, 5)" end="(660, 13)">
                        <NullNode start="(660, 5)" end="(660, 13)">
                          <OtherNode start="(660, 5)" end="(660, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case intro.isFalse&#10;α : Type u_1&#10;l₁ : List α&#10;p : α → Bool&#10;lt : findIdx p l₁ &amp;lt; l₁.length&#10;t : List α&#10;h✝ : ¬∃ x, x ∈ l₁ ∧ p x = true&#10;⊢ findIdx p t + l₁.length = findIdx p l₁" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(660, 5)" end="(660, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(662, 1)" end="(672, 58)" name="findIdx_le_findIdx" full_name="List.findIdx_le_findIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(662, 1)" end="(672, 58)" name="findIdx_le_findIdx" full_name="List.findIdx_le_findIdx" _is_private_decl="False">
        <AtomNode start="(662, 1)" end="(662, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(662, 9)" end="(662, 27)">
          <IdentNode start="(662, 9)" end="(662, 27)" leading="" trailing=" " raw_val="findIdx_le_findIdx" val="findIdx_le_findIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(662, 28)" end="(662, 110)">
          <NullNode start="(662, 28)" end="(662, 82)">
            <OtherNode start="(662, 28)" end="(662, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(662, 28)" end="(662, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(662, 29)" end="(662, 30)">
                <IdentNode start="(662, 29)" end="(662, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(662, 31)" end="(662, 39)">
                <AtomNode start="(662, 31)" end="(662, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(662, 33)" end="(662, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(662, 33)" end="(662, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(662, 38)" end="(662, 39)">
                    <IdentNode start="(662, 38)" end="(662, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(662, 39)" end="(662, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(662, 41)" end="(662, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(662, 41)" end="(662, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(662, 42)" end="(662, 45)">
                <IdentNode start="(662, 42)" end="(662, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(662, 44)" end="(662, 45)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(662, 46)" end="(662, 56)">
                <AtomNode start="(662, 46)" end="(662, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(662, 48)" end="(662, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(662, 48)" end="(662, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(662, 50)" end="(662, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(662, 52)" end="(662, 56)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(662, 56)" end="(662, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(662, 58)" end="(662, 82)">
              <AtomNode start="(662, 58)" end="(662, 59)" leading="" trailing="" val="("/>
              <NullNode start="(662, 59)" end="(662, 60)">
                <IdentNode start="(662, 59)" end="(662, 60)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(662, 61)" end="(662, 81)">
                <AtomNode start="(662, 61)" end="(662, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(662, 63)" end="(662, 81)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(662, 63)" end="(662, 64)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(662, 65)" end="(662, 66)">
                    <IdentNode start="(662, 65)" end="(662, 66)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(662, 67)" end="(662, 70)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(662, 67)" end="(662, 68)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(662, 69)" end="(662, 70)" leading="" trailing="" raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(662, 70)" end="(662, 71)" leading="" trailing=" " val=","/>
                  <OtherNode start="(662, 72)" end="(662, 81)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(662, 72)" end="(662, 75)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(662, 72)" end="(662, 73)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(662, 74)" end="(662, 75)">
                        <IdentNode start="(662, 74)" end="(662, 75)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(662, 76)" end="(662, 77)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(662, 78)" end="(662, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(662, 78)" end="(662, 79)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(662, 80)" end="(662, 81)">
                        <IdentNode start="(662, 80)" end="(662, 81)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(662, 81)" end="(662, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(662, 83)" end="(662, 110)">
            <AtomNode start="(662, 83)" end="(662, 84)" leading="" trailing=" " val=":"/>
            <OtherNode start="(662, 85)" end="(662, 110)" kind="«term_≤_»">
              <OtherNode start="(662, 85)" end="(662, 96)" kind="Lean.Parser.Term.app">
                <IdentNode start="(662, 85)" end="(662, 94)" leading="" trailing=" " raw_val="l.findIdx" val="l.findIdx"/>
                <NullNode start="(662, 95)" end="(662, 96)">
                  <IdentNode start="(662, 95)" end="(662, 96)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(662, 97)" end="(662, 98)" leading="" trailing=" " val="≤"/>
              <OtherNode start="(662, 99)" end="(662, 110)" kind="Lean.Parser.Term.app">
                <IdentNode start="(662, 99)" end="(662, 108)" leading="" trailing=" " raw_val="l.findIdx" val="l.findIdx"/>
                <NullNode start="(662, 109)" end="(662, 110)">
                  <IdentNode start="(662, 109)" end="(662, 110)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(662, 111)" end="(672, 58)">
          <AtomNode start="(662, 111)" end="(662, 113)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(662, 114)" end="(672, 58)">
            <AtomNode start="(662, 114)" end="(662, 116)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(663, 3)" end="(672, 58)">
              <TacticTacticseq1IndentedNode start="(663, 3)" end="(672, 58)">
                <NullNode start="(663, 3)" end="(672, 58)">
                  <OtherNode start="(663, 3)" end="(672, 58)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List α&#10;p q : α → Bool&#10;h : ∀ (x : α), x ∈ l → p x = true → q x = true&#10;⊢ findIdx q l ≤ findIdx p l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx_cons, cond_eq_if]&#10;  split&#10;  · simp&#10;  · split&#10;    · simp_all&#10;    · simp only [Nat.add_le_add_iff_right]&#10;      exact ih fun _ m w =&amp;gt; h _ (mem_cons_of_mem x m) w">
                    <AtomNode start="(663, 3)" end="(663, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(663, 13)" end="(663, 14)">
                      <OtherNode start="(663, 13)" end="(663, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(663, 13)" end="(663, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(663, 15)" end="(672, 58)">
                      <OtherNode start="(663, 15)" end="(672, 58)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(663, 15)" end="(663, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(664, 3)" end="(672, 58)">
                          <OtherNode start="(664, 3)" end="(664, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(664, 3)" end="(664, 8)">
                              <OtherNode start="(664, 3)" end="(664, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(664, 3)" end="(664, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(664, 5)" end="(664, 8)">
                                  <NullNode/>
                                  <IdentNode start="(664, 5)" end="(664, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(664, 9)" end="(664, 16)">
                              <AtomNode start="(664, 9)" end="(664, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(664, 12)" end="(664, 16)">
                                <TacticTacticseq1IndentedNode start="(664, 12)" end="(664, 16)">
                                  <NullNode start="(664, 12)" end="(664, 16)">
                                    <OtherNode start="(664, 12)" end="(664, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p q : α → Bool&#10;h : ∀ (x : α), x ∈ [] → p x = true → q x = true&#10;⊢ findIdx q [] ≤ findIdx p []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(664, 12)" end="(664, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(665, 3)" end="(672, 58)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(665, 3)" end="(665, 17)">
                              <OtherNode start="(665, 3)" end="(665, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(665, 3)" end="(665, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(665, 5)" end="(665, 9)">
                                  <NullNode/>
                                  <IdentNode start="(665, 5)" end="(665, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(665, 10)" end="(665, 17)">
                                  <IdentNode start="(665, 10)" end="(665, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(665, 12)" end="(665, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(665, 15)" end="(665, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(665, 18)" end="(672, 58)">
                              <AtomNode start="(665, 18)" end="(665, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(666, 5)" end="(672, 58)">
                                <TacticTacticseq1IndentedNode start="(666, 5)" end="(672, 58)">
                                  <NullNode start="(666, 5)" end="(672, 58)">
                                    <OtherNode start="(666, 5)" end="(666, 41)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;⊢ findIdx q (x :: xs) ≤ findIdx p (x :: xs)" state_after="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;⊢ (if q x = true then 0 else findIdx q xs + 1) ≤ if p x = true then 0 else findIdx p xs + 1" tactic="simp only [findIdx_cons, cond_eq_if]">
                                      <AtomNode start="(666, 5)" end="(666, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(666, 10)" end="(666, 14)">
                                        <AtomNode start="(666, 10)" end="(666, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(666, 15)" end="(666, 41)">
                                        <AtomNode start="(666, 15)" end="(666, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(666, 16)" end="(666, 40)">
                                          <OtherNode start="(666, 16)" end="(666, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(666, 16)" end="(666, 28)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                          <AtomNode start="(666, 28)" end="(666, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(666, 30)" end="(666, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(666, 30)" end="(666, 40)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(666, 40)" end="(666, 41)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(667, 5)" end="(667, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;⊢ (if q x = true then 0 else findIdx q xs + 1) ≤ if p x = true then 0 else findIdx p xs + 1" state_after="case cons.isTrue&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : q x = true&#10;⊢ 0 ≤ if p x = true then 0 else findIdx p xs + 1&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : ¬q x = true&#10;⊢ findIdx q xs + 1 ≤ if p x = true then 0 else findIdx p xs + 1" tactic="split">
                                      <AtomNode start="(667, 5)" end="(667, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(668, 5)" end="(668, 11)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : q x = true&#10;⊢ 0 ≤ if p x = true then 0 else findIdx p xs + 1&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : ¬q x = true&#10;⊢ findIdx q xs + 1 ≤ if p x = true then 0 else findIdx p xs + 1" state_after="case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : ¬q x = true&#10;⊢ findIdx q xs + 1 ≤ if p x = true then 0 else findIdx p xs + 1" tactic="· simp">
                                      <OtherNode start="(668, 5)" end="(668, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(668, 5)" end="(668, 6)" kind="patternIgnore">
                                          <OtherNode start="(668, 5)" end="(668, 6)" kind="token.«· »">
                                            <AtomNode start="(668, 5)" end="(668, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(668, 7)" end="(668, 11)">
                                        <TacticTacticseq1IndentedNode start="(668, 7)" end="(668, 11)">
                                          <NullNode start="(668, 7)" end="(668, 11)">
                                            <OtherNode start="(668, 7)" end="(668, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : q x = true&#10;⊢ 0 ≤ if p x = true then 0 else findIdx p xs + 1" state_after="no goals" tactic="simp">
                                              <AtomNode start="(668, 7)" end="(668, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(669, 5)" end="(672, 58)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : ¬q x = true&#10;⊢ findIdx q xs + 1 ≤ if p x = true then 0 else findIdx p xs + 1" state_after="no goals" tactic="· split&#10;  · simp_all&#10;  · simp only [Nat.add_le_add_iff_right]&#10;    exact ih fun _ m w =&amp;gt; h _ (mem_cons_of_mem x m) w">
                                      <OtherNode start="(669, 5)" end="(669, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(669, 5)" end="(669, 6)" kind="patternIgnore">
                                          <OtherNode start="(669, 5)" end="(669, 6)" kind="token.«· »">
                                            <AtomNode start="(669, 5)" end="(669, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(669, 7)" end="(672, 58)">
                                        <TacticTacticseq1IndentedNode start="(669, 7)" end="(672, 58)">
                                          <NullNode start="(669, 7)" end="(672, 58)">
                                            <OtherNode start="(669, 7)" end="(669, 12)" kind="Lean.Parser.Tactic.split" state_before="case cons.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝ : ¬q x = true&#10;⊢ findIdx q xs + 1 ≤ if p x = true then 0 else findIdx p xs + 1" state_after="case cons.isFalse.isTrue&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : p x = true&#10;⊢ findIdx q xs + 1 ≤ 0&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs + 1 ≤ findIdx p xs + 1" tactic="split">
                                              <AtomNode start="(669, 7)" end="(669, 12)" leading="" trailing="&#10;      " val="split"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(670, 7)" end="(670, 17)" kind="Lean.cdot" state_before="case cons.isFalse.isTrue&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : p x = true&#10;⊢ findIdx q xs + 1 ≤ 0&#10;&#10;case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs + 1 ≤ findIdx p xs + 1" state_after="case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs + 1 ≤ findIdx p xs + 1" tactic="· simp_all">
                                              <OtherNode start="(670, 7)" end="(670, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(670, 7)" end="(670, 8)" kind="patternIgnore">
                                                  <OtherNode start="(670, 7)" end="(670, 8)" kind="token.«· »">
                                                    <AtomNode start="(670, 7)" end="(670, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(670, 9)" end="(670, 17)">
                                                <TacticTacticseq1IndentedNode start="(670, 9)" end="(670, 17)">
                                                  <NullNode start="(670, 9)" end="(670, 17)">
                                                    <OtherNode start="(670, 9)" end="(670, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse.isTrue&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : p x = true&#10;⊢ findIdx q xs + 1 ≤ 0" state_after="no goals" tactic="simp_all">
                                                      <AtomNode start="(670, 9)" end="(670, 17)" leading="" trailing="&#10;      " val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(671, 7)" end="(672, 58)" kind="Lean.cdot" state_before="case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs + 1 ≤ findIdx p xs + 1" state_after="no goals" tactic="· simp only [Nat.add_le_add_iff_right]&#10;  exact ih fun _ m w =&amp;gt; h _ (mem_cons_of_mem x m) w">
                                              <OtherNode start="(671, 7)" end="(671, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(671, 7)" end="(671, 8)" kind="patternIgnore">
                                                  <OtherNode start="(671, 7)" end="(671, 8)" kind="token.«· »">
                                                    <AtomNode start="(671, 7)" end="(671, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(671, 9)" end="(672, 58)">
                                                <TacticTacticseq1IndentedNode start="(671, 9)" end="(672, 58)">
                                                  <NullNode start="(671, 9)" end="(672, 58)">
                                                    <OtherNode start="(671, 9)" end="(671, 45)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs + 1 ≤ findIdx p xs + 1" state_after="case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs ≤ findIdx p xs" tactic="simp only [Nat.add_le_add_iff_right]">
                                                      <AtomNode start="(671, 9)" end="(671, 13)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode start="(671, 14)" end="(671, 18)">
                                                        <AtomNode start="(671, 14)" end="(671, 18)" leading="" trailing=" " val="only"/>
                                                      </NullNode>
                                                      <NullNode start="(671, 19)" end="(671, 45)">
                                                        <AtomNode start="(671, 19)" end="(671, 20)" leading="" trailing="" val="["/>
                                                        <NullNode start="(671, 20)" end="(671, 44)">
                                                          <OtherNode start="(671, 20)" end="(671, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(671, 20)" end="(671, 44)" leading="" trailing="" raw_val="Nat.add_le_add_iff_right" val="Nat.add_le_add_iff_right" full_name="Nat.add_le_add_iff_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(671, 44)" end="(671, 45)" leading="" trailing="&#10;        " val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(672, 9)" end="(672, 58)" kind="Lean.Parser.Tactic.exact" state_before="case cons.isFalse.isFalse&#10;α : Type u_1&#10;p q : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (∀ (x : α), x ∈ xs → p x = true → q x = true) → findIdx q xs ≤ findIdx p xs&#10;h : ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = true → q x_1 = true&#10;h✝¹ : ¬q x = true&#10;h✝ : ¬p x = true&#10;⊢ findIdx q xs ≤ findIdx p xs" state_after="no goals" tactic="exact ih fun _ m w =&amp;gt; h _ (mem_cons_of_mem x m) w">
                                                      <AtomNode start="(672, 9)" end="(672, 14)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(672, 15)" end="(672, 58)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(672, 15)" end="(672, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                        <NullNode start="(672, 18)" end="(672, 58)">
                                                          <OtherNode start="(672, 18)" end="(672, 58)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(672, 18)" end="(672, 21)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(672, 22)" end="(672, 58)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(672, 22)" end="(672, 27)">
                                                            <TermHoleNode start="(672, 22)" end="(672, 23)">
                                                            <AtomNode start="(672, 22)" end="(672, 23)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(672, 24)" end="(672, 25)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            <IdentNode start="(672, 26)" end="(672, 27)" leading="" trailing=" " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(672, 28)" end="(672, 30)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(672, 31)" end="(672, 58)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(672, 31)" end="(672, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(672, 33)" end="(672, 58)">
                                                            <TermHoleNode start="(672, 33)" end="(672, 34)">
                                                            <AtomNode start="(672, 33)" end="(672, 34)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(672, 35)" end="(672, 56)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(672, 35)" end="(672, 36)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(672, 36)" end="(672, 55)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(672, 36)" end="(672, 51)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(672, 52)" end="(672, 55)">
                                                            <IdentNode start="(672, 52)" end="(672, 53)" leading="" trailing=" " raw_val="x" val="x"/>
                                                            <IdentNode start="(672, 54)" end="(672, 55)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(672, 55)" end="(672, 56)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(672, 57)" end="(672, 58)" leading="" trailing="&#10;&#10;" raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(674, 1)" end="(681, 32)" name="findIdx_subtype" full_name="List.findIdx_subtype">
      <CommandDeclmodifiersNode start="(674, 1)" end="(674, 8)">
        <NullNode/>
        <NullNode start="(674, 1)" end="(674, 8)">
          <OtherNode start="(674, 1)" end="(674, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(674, 1)" end="(674, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(674, 3)" end="(674, 7)">
              <OtherNode start="(674, 3)" end="(674, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(674, 3)" end="(674, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(674, 3)" end="(674, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(674, 7)" end="(674, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(674, 9)" end="(681, 32)" name="findIdx_subtype" full_name="List.findIdx_subtype" _is_private_decl="False">
        <AtomNode start="(674, 9)" end="(674, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(674, 17)" end="(674, 32)">
          <IdentNode start="(674, 17)" end="(674, 32)" leading="" trailing=" " raw_val="findIdx_subtype" val="findIdx_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(674, 33)" end="(676, 39)">
          <NullNode start="(674, 33)" end="(675, 74)">
            <OtherNode start="(674, 33)" end="(674, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(674, 33)" end="(674, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(674, 34)" end="(674, 35)">
                <IdentNode start="(674, 34)" end="(674, 35)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(674, 36)" end="(674, 46)">
                <AtomNode start="(674, 36)" end="(674, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(674, 38)" end="(674, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(674, 38)" end="(674, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(674, 40)" end="(674, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(674, 42)" end="(674, 46)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(674, 42)" end="(674, 46)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(674, 46)" end="(674, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(674, 48)" end="(674, 71)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(674, 48)" end="(674, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(674, 49)" end="(674, 50)">
                <IdentNode start="(674, 49)" end="(674, 50)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(674, 51)" end="(674, 70)">
                <AtomNode start="(674, 51)" end="(674, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(674, 53)" end="(674, 70)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(674, 53)" end="(674, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(674, 58)" end="(674, 70)">
                    <OtherNode start="(674, 58)" end="(674, 70)" kind="«term{_:_//_}»">
                      <AtomNode start="(674, 58)" end="(674, 59)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(674, 60)" end="(674, 61)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(674, 62)" end="(674, 64)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(674, 65)" end="(674, 68)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(674, 65)" end="(674, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(674, 67)" end="(674, 68)">
                          <IdentNode start="(674, 67)" end="(674, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(674, 69)" end="(674, 70)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(674, 70)" end="(674, 71)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(675, 5)" end="(675, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(675, 5)" end="(675, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(675, 6)" end="(675, 7)">
                <IdentNode start="(675, 6)" end="(675, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(675, 8)" end="(675, 29)">
                <AtomNode start="(675, 8)" end="(675, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(675, 10)" end="(675, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(675, 10)" end="(675, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(675, 10)" end="(675, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(675, 12)" end="(675, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(675, 14)" end="(675, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(675, 17)" end="(675, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(675, 17)" end="(675, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(675, 19)" end="(675, 20)">
                        <IdentNode start="(675, 19)" end="(675, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(675, 21)" end="(675, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(675, 23)" end="(675, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(675, 25)" end="(675, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(675, 29)" end="(675, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(675, 31)" end="(675, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(675, 31)" end="(675, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(675, 32)" end="(675, 33)">
                <IdentNode start="(675, 32)" end="(675, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(675, 34)" end="(675, 44)">
                <AtomNode start="(675, 34)" end="(675, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(675, 36)" end="(675, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(675, 36)" end="(675, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(675, 38)" end="(675, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(675, 40)" end="(675, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(675, 44)" end="(675, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(675, 46)" end="(675, 74)">
              <AtomNode start="(675, 46)" end="(675, 47)" leading="" trailing="" val="("/>
              <NullNode start="(675, 47)" end="(675, 49)">
                <IdentNode start="(675, 47)" end="(675, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(675, 50)" end="(675, 73)">
                <AtomNode start="(675, 50)" end="(675, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(675, 52)" end="(675, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(675, 52)" end="(675, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(675, 54)" end="(675, 57)">
                    <IdentNode start="(675, 54)" end="(675, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(675, 56)" end="(675, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(675, 57)" end="(675, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(675, 59)" end="(675, 73)" kind="«term_=_»">
                    <OtherNode start="(675, 59)" end="(675, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(675, 59)" end="(675, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(675, 61)" end="(675, 67)">
                        <OtherNode start="(675, 61)" end="(675, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(675, 61)" end="(675, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(675, 62)" end="(675, 66)">
                            <IdentNode start="(675, 62)" end="(675, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(675, 63)" end="(675, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(675, 65)" end="(675, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(675, 66)" end="(675, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(675, 68)" end="(675, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(675, 70)" end="(675, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(675, 70)" end="(675, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(675, 72)" end="(675, 73)">
                        <IdentNode start="(675, 72)" end="(675, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(675, 73)" end="(675, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(675, 75)" end="(676, 39)">
            <AtomNode start="(675, 75)" end="(675, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(676, 5)" end="(676, 39)" kind="«term_=_»">
              <OtherNode start="(676, 5)" end="(676, 16)" kind="Lean.Parser.Term.app">
                <IdentNode start="(676, 5)" end="(676, 14)" leading="" trailing=" " raw_val="l.findIdx" val="l.findIdx"/>
                <NullNode start="(676, 15)" end="(676, 16)">
                  <IdentNode start="(676, 15)" end="(676, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(676, 17)" end="(676, 18)" leading="" trailing=" " val="="/>
              <OtherNode start="(676, 19)" end="(676, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(676, 19)" end="(676, 37)" leading="" trailing=" " raw_val="l.unattach.findIdx" val="l.unattach.findIdx"/>
                <NullNode start="(676, 38)" end="(676, 39)">
                  <IdentNode start="(676, 38)" end="(676, 39)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(676, 40)" end="(681, 32)">
          <AtomNode start="(676, 40)" end="(676, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(676, 43)" end="(681, 32)">
            <AtomNode start="(676, 43)" end="(676, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(677, 3)" end="(681, 32)">
              <TacticTacticseq1IndentedNode start="(677, 3)" end="(681, 32)">
                <NullNode start="(677, 3)" end="(681, 32)">
                  <OtherNode start="(677, 3)" end="(677, 18)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx f l = findIdx g l.unattach" state_after="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx f l = findIdx g (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(677, 3)" end="(677, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(677, 10)" end="(677, 18)">
                      <IdentNode start="(677, 10)" end="(677, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(678, 3)" end="(681, 32)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx f l = findIdx g (map (fun x =&amp;gt; x.val) l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp [ih, hf, findIdx_cons]">
                    <AtomNode start="(678, 3)" end="(678, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(678, 13)" end="(678, 14)">
                      <OtherNode start="(678, 13)" end="(678, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(678, 13)" end="(678, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(678, 15)" end="(681, 32)">
                      <OtherNode start="(678, 15)" end="(681, 32)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(678, 15)" end="(678, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(679, 3)" end="(681, 32)">
                          <OtherNode start="(679, 3)" end="(679, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(679, 3)" end="(679, 8)">
                              <OtherNode start="(679, 3)" end="(679, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(679, 3)" end="(679, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(679, 5)" end="(679, 8)">
                                  <NullNode/>
                                  <IdentNode start="(679, 5)" end="(679, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(679, 9)" end="(679, 16)">
                              <AtomNode start="(679, 9)" end="(679, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(679, 12)" end="(679, 16)">
                                <TacticTacticseq1IndentedNode start="(679, 12)" end="(679, 16)">
                                  <NullNode start="(679, 12)" end="(679, 16)">
                                    <OtherNode start="(679, 12)" end="(679, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx f [] = findIdx g (map (fun x =&amp;gt; x.val) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(679, 12)" end="(679, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(680, 3)" end="(681, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(680, 3)" end="(680, 16)">
                              <OtherNode start="(680, 3)" end="(680, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(680, 3)" end="(680, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(680, 5)" end="(680, 9)">
                                  <NullNode/>
                                  <IdentNode start="(680, 5)" end="(680, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(680, 10)" end="(680, 16)">
                                  <IdentNode start="(680, 10)" end="(680, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(680, 12)" end="(680, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(680, 14)" end="(680, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(680, 17)" end="(681, 32)">
                              <AtomNode start="(680, 17)" end="(680, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(681, 5)" end="(681, 32)">
                                <TacticTacticseq1IndentedNode start="(681, 5)" end="(681, 32)">
                                  <NullNode start="(681, 5)" end="(681, 32)">
                                    <OtherNode start="(681, 5)" end="(681, 32)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findIdx f l = findIdx g (map (fun x =&amp;gt; x.val) l)&#10;⊢ findIdx f (a :: l) = findIdx g (map (fun x =&amp;gt; x.val) (a :: l))" state_after="no goals" tactic="simp [ih, hf, findIdx_cons]">
                                      <AtomNode start="(681, 5)" end="(681, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(681, 10)" end="(681, 32)">
                                        <AtomNode start="(681, 10)" end="(681, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(681, 11)" end="(681, 31)">
                                          <OtherNode start="(681, 11)" end="(681, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(681, 11)" end="(681, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(681, 13)" end="(681, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(681, 15)" end="(681, 17)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(681, 15)" end="(681, 17)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                          <AtomNode start="(681, 17)" end="(681, 18)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(681, 19)" end="(681, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(681, 19)" end="(681, 31)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(681, 31)" end="(681, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(683, 1)" end="(683, 20)" comment="### findIdx? -/">
      <AtomNode start="(683, 1)" end="(683, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(683, 5)" end="(683, 20)" leading="" trailing="&#10;&#10;" val="### findIdx? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(685, 1)" end="(692, 36)" name="findIdx?_eq_none_iff" full_name="List.findIdx?_eq_none_iff">
      <CommandDeclmodifiersNode start="(685, 1)" end="(685, 8)">
        <NullNode/>
        <NullNode start="(685, 1)" end="(685, 8)">
          <OtherNode start="(685, 1)" end="(685, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(685, 1)" end="(685, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(685, 3)" end="(685, 7)">
              <OtherNode start="(685, 3)" end="(685, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(685, 3)" end="(685, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(685, 3)" end="(685, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(685, 7)" end="(685, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(686, 1)" end="(692, 36)" name="findIdx?_eq_none_iff" full_name="List.findIdx?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(686, 1)" end="(686, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(686, 9)" end="(686, 29)">
          <IdentNode start="(686, 9)" end="(686, 29)" leading="" trailing=" " raw_val="findIdx?_eq_none_iff" val="findIdx?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(686, 30)" end="(687, 53)">
          <NullNode start="(686, 30)" end="(686, 58)">
            <OtherNode start="(686, 30)" end="(686, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(686, 30)" end="(686, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(686, 31)" end="(686, 33)">
                <IdentNode start="(686, 31)" end="(686, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(686, 34)" end="(686, 42)">
                <AtomNode start="(686, 34)" end="(686, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(686, 36)" end="(686, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(686, 36)" end="(686, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(686, 41)" end="(686, 42)">
                    <IdentNode start="(686, 41)" end="(686, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(686, 42)" end="(686, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(686, 44)" end="(686, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(686, 44)" end="(686, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(686, 45)" end="(686, 46)">
                <IdentNode start="(686, 45)" end="(686, 46)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(686, 47)" end="(686, 57)">
                <AtomNode start="(686, 47)" end="(686, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(686, 49)" end="(686, 57)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(686, 49)" end="(686, 50)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(686, 51)" end="(686, 52)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(686, 53)" end="(686, 57)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(686, 57)" end="(686, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(686, 59)" end="(687, 53)">
            <AtomNode start="(686, 59)" end="(686, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(687, 5)" end="(687, 53)" kind="«term_↔_»">
              <OtherNode start="(687, 5)" end="(687, 25)" kind="«term_=_»">
                <OtherNode start="(687, 5)" end="(687, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(687, 5)" end="(687, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(687, 17)" end="(687, 18)">
                    <IdentNode start="(687, 17)" end="(687, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(687, 19)" end="(687, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(687, 21)" end="(687, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(687, 26)" end="(687, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(687, 28)" end="(687, 53)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(687, 28)" end="(687, 29)" leading="" trailing=" " val="∀"/>
                <NullNode start="(687, 30)" end="(687, 31)">
                  <IdentNode start="(687, 30)" end="(687, 31)" leading="" trailing="" raw_val="x" val="x"/>
                </NullNode>
                <NullNode/>
                <AtomNode start="(687, 31)" end="(687, 32)" leading="" trailing=" " val=","/>
                <OtherNode start="(687, 33)" end="(687, 53)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(687, 33)" end="(687, 39)" kind="«term_∈_»">
                    <IdentNode start="(687, 33)" end="(687, 34)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(687, 35)" end="(687, 36)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(687, 37)" end="(687, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(687, 40)" end="(687, 41)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(687, 42)" end="(687, 53)" kind="«term_=_»">
                    <OtherNode start="(687, 42)" end="(687, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(687, 42)" end="(687, 43)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(687, 44)" end="(687, 45)">
                        <IdentNode start="(687, 44)" end="(687, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(687, 46)" end="(687, 47)" leading="" trailing=" " val="="/>
                    <IdentNode start="(687, 48)" end="(687, 53)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(687, 54)" end="(692, 36)">
          <AtomNode start="(687, 54)" end="(687, 56)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(687, 57)" end="(692, 36)">
            <AtomNode start="(687, 57)" end="(687, 59)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(688, 3)" end="(692, 36)">
              <TacticTacticseq1IndentedNode start="(688, 3)" end="(692, 36)">
                <NullNode start="(688, 3)" end="(692, 36)">
                  <OtherNode start="(688, 3)" end="(692, 36)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx? p xs = none ↔ ∀ (x : α), x ∈ xs → p x = false" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all [cond_eq_if]">
                    <AtomNode start="(688, 3)" end="(688, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(688, 13)" end="(688, 15)">
                      <OtherNode start="(688, 13)" end="(688, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(688, 13)" end="(688, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(688, 16)" end="(692, 36)">
                      <OtherNode start="(688, 16)" end="(692, 36)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(688, 16)" end="(688, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(689, 3)" end="(692, 36)">
                          <OtherNode start="(689, 3)" end="(689, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(689, 3)" end="(689, 8)">
                              <OtherNode start="(689, 3)" end="(689, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(689, 3)" end="(689, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(689, 5)" end="(689, 8)">
                                  <NullNode/>
                                  <IdentNode start="(689, 5)" end="(689, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(689, 9)" end="(689, 20)">
                              <AtomNode start="(689, 9)" end="(689, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(689, 12)" end="(689, 20)">
                                <TacticTacticseq1IndentedNode start="(689, 12)" end="(689, 20)">
                                  <NullNode start="(689, 12)" end="(689, 20)">
                                    <OtherNode start="(689, 12)" end="(689, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx? p [] = none ↔ ∀ (x : α), x ∈ [] → p x = false" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(689, 12)" end="(689, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(690, 3)" end="(692, 36)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(690, 3)" end="(690, 17)">
                              <OtherNode start="(690, 3)" end="(690, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(690, 3)" end="(690, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(690, 5)" end="(690, 9)">
                                  <NullNode/>
                                  <IdentNode start="(690, 5)" end="(690, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(690, 10)" end="(690, 17)">
                                  <IdentNode start="(690, 10)" end="(690, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(690, 12)" end="(690, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(690, 15)" end="(690, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(690, 18)" end="(692, 36)">
                              <AtomNode start="(690, 18)" end="(690, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(691, 5)" end="(692, 36)">
                                <TacticTacticseq1IndentedNode start="(691, 5)" end="(692, 36)">
                                  <NullNode start="(691, 5)" end="(692, 36)">
                                    <OtherNode start="(691, 5)" end="(691, 30)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = none ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ findIdx? p (x :: xs) = none ↔ ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = none ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none ↔&#10;    ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" tactic="simp only [findIdx?_cons]">
                                      <AtomNode start="(691, 5)" end="(691, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(691, 10)" end="(691, 14)">
                                        <AtomNode start="(691, 10)" end="(691, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(691, 15)" end="(691, 30)">
                                        <AtomNode start="(691, 15)" end="(691, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(691, 16)" end="(691, 29)">
                                          <OtherNode start="(691, 16)" end="(691, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(691, 16)" end="(691, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(691, 29)" end="(691, 30)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(692, 5)" end="(692, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = none ↔ ∀ (x : α), x ∈ xs → p x = false&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none ↔&#10;    ∀ (x_1 : α), x_1 ∈ x :: xs → p x_1 = false" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [cond_eq_if]">
                                      <OtherNode start="(692, 5)" end="(692, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(692, 5)" end="(692, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(692, 11)" end="(692, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(692, 15)" end="(692, 36)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(692, 15)" end="(692, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(692, 24)" end="(692, 36)">
                                          <AtomNode start="(692, 24)" end="(692, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(692, 25)" end="(692, 35)">
                                            <OtherNode start="(692, 25)" end="(692, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(692, 25)" end="(692, 35)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(692, 35)" end="(692, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(694, 1)" end="(701, 23)" name="findIdx?_isSome" full_name="List.findIdx?_isSome">
      <CommandDeclmodifiersNode start="(694, 1)" end="(694, 8)">
        <NullNode/>
        <NullNode start="(694, 1)" end="(694, 8)">
          <OtherNode start="(694, 1)" end="(694, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(694, 1)" end="(694, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(694, 3)" end="(694, 7)">
              <OtherNode start="(694, 3)" end="(694, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(694, 3)" end="(694, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(694, 3)" end="(694, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(694, 7)" end="(694, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(695, 1)" end="(701, 23)" name="findIdx?_isSome" full_name="List.findIdx?_isSome" _is_private_decl="False">
        <AtomNode start="(695, 1)" end="(695, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(695, 9)" end="(695, 24)">
          <IdentNode start="(695, 9)" end="(695, 24)" leading="" trailing=" " raw_val="findIdx?_isSome" val="findIdx?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(695, 25)" end="(696, 38)">
          <NullNode start="(695, 25)" end="(695, 53)">
            <OtherNode start="(695, 25)" end="(695, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(695, 25)" end="(695, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(695, 26)" end="(695, 28)">
                <IdentNode start="(695, 26)" end="(695, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(695, 29)" end="(695, 37)">
                <AtomNode start="(695, 29)" end="(695, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(695, 31)" end="(695, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(695, 31)" end="(695, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(695, 36)" end="(695, 37)">
                    <IdentNode start="(695, 36)" end="(695, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(695, 37)" end="(695, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(695, 39)" end="(695, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(695, 39)" end="(695, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(695, 40)" end="(695, 41)">
                <IdentNode start="(695, 40)" end="(695, 41)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(695, 42)" end="(695, 52)">
                <AtomNode start="(695, 42)" end="(695, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(695, 44)" end="(695, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(695, 44)" end="(695, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(695, 46)" end="(695, 47)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(695, 48)" end="(695, 52)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(695, 52)" end="(695, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(695, 54)" end="(696, 38)">
            <AtomNode start="(695, 54)" end="(695, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(696, 5)" end="(696, 38)" kind="«term_=_»">
              <OtherNode start="(696, 5)" end="(696, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(696, 5)" end="(696, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(696, 5)" end="(696, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(696, 6)" end="(696, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(696, 6)" end="(696, 17)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(696, 18)" end="(696, 19)">
                      <IdentNode start="(696, 18)" end="(696, 19)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(696, 19)" end="(696, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(696, 20)" end="(696, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(696, 21)" end="(696, 27)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(696, 28)" end="(696, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(696, 30)" end="(696, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(696, 30)" end="(696, 36)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                <NullNode start="(696, 37)" end="(696, 38)">
                  <IdentNode start="(696, 37)" end="(696, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(696, 39)" end="(701, 23)">
          <AtomNode start="(696, 39)" end="(696, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(696, 42)" end="(701, 23)">
            <AtomNode start="(696, 42)" end="(696, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(697, 3)" end="(701, 23)">
              <TacticTacticseq1IndentedNode start="(697, 3)" end="(701, 23)">
                <NullNode start="(697, 3)" end="(701, 23)">
                  <OtherNode start="(697, 3)" end="(701, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ (findIdx? p xs).isSome = xs.any p" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(697, 3)" end="(697, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(697, 13)" end="(697, 15)">
                      <OtherNode start="(697, 13)" end="(697, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(697, 13)" end="(697, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(697, 16)" end="(701, 23)">
                      <OtherNode start="(697, 16)" end="(701, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(697, 16)" end="(697, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(698, 3)" end="(701, 23)">
                          <OtherNode start="(698, 3)" end="(698, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(698, 3)" end="(698, 8)">
                              <OtherNode start="(698, 3)" end="(698, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(698, 3)" end="(698, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(698, 5)" end="(698, 8)">
                                  <NullNode/>
                                  <IdentNode start="(698, 5)" end="(698, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(698, 9)" end="(698, 16)">
                              <AtomNode start="(698, 9)" end="(698, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(698, 12)" end="(698, 16)">
                                <TacticTacticseq1IndentedNode start="(698, 12)" end="(698, 16)">
                                  <NullNode start="(698, 12)" end="(698, 16)">
                                    <OtherNode start="(698, 12)" end="(698, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ (findIdx? p []).isSome = [].any p" state_after="no goals" tactic="simp">
                                      <AtomNode start="(698, 12)" end="(698, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(699, 3)" end="(701, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(699, 3)" end="(699, 17)">
                              <OtherNode start="(699, 3)" end="(699, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(699, 3)" end="(699, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(699, 5)" end="(699, 9)">
                                  <NullNode/>
                                  <IdentNode start="(699, 5)" end="(699, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(699, 10)" end="(699, 17)">
                                  <IdentNode start="(699, 10)" end="(699, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(699, 12)" end="(699, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(699, 15)" end="(699, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(699, 18)" end="(701, 23)">
                              <AtomNode start="(699, 18)" end="(699, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(700, 5)" end="(701, 23)">
                                <TacticTacticseq1IndentedNode start="(700, 5)" end="(701, 23)">
                                  <NullNode start="(700, 5)" end="(701, 23)">
                                    <OtherNode start="(700, 5)" end="(700, 30)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findIdx? p xs).isSome = xs.any p&#10;⊢ (findIdx? p (x :: xs)).isSome = (x :: xs).any p" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findIdx? p xs).isSome = xs.any p&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)).isSome = (x :: xs).any p" tactic="simp only [findIdx?_cons]">
                                      <AtomNode start="(700, 5)" end="(700, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(700, 10)" end="(700, 14)">
                                        <AtomNode start="(700, 10)" end="(700, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(700, 15)" end="(700, 30)">
                                        <AtomNode start="(700, 15)" end="(700, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(700, 16)" end="(700, 29)">
                                          <OtherNode start="(700, 16)" end="(700, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(700, 16)" end="(700, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(700, 29)" end="(700, 30)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(701, 5)" end="(701, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findIdx? p xs).isSome = xs.any p&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)).isSome = (x :: xs).any p" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(701, 5)" end="(701, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(701, 5)" end="(701, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(701, 11)" end="(701, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(701, 15)" end="(701, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(701, 15)" end="(701, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(703, 1)" end="(710, 23)" name="findIdx?_isNone" full_name="List.findIdx?_isNone">
      <CommandDeclmodifiersNode start="(703, 1)" end="(703, 8)">
        <NullNode/>
        <NullNode start="(703, 1)" end="(703, 8)">
          <OtherNode start="(703, 1)" end="(703, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(703, 1)" end="(703, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(703, 3)" end="(703, 7)">
              <OtherNode start="(703, 3)" end="(703, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(703, 3)" end="(703, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(703, 3)" end="(703, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(703, 7)" end="(703, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(704, 1)" end="(710, 23)" name="findIdx?_isNone" full_name="List.findIdx?_isNone" _is_private_decl="False">
        <AtomNode start="(704, 1)" end="(704, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(704, 9)" end="(704, 24)">
          <IdentNode start="(704, 9)" end="(704, 24)" leading="" trailing=" " raw_val="findIdx?_isNone" val="findIdx?_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(704, 25)" end="(705, 43)">
          <NullNode start="(704, 25)" end="(704, 53)">
            <OtherNode start="(704, 25)" end="(704, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(704, 25)" end="(704, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(704, 26)" end="(704, 28)">
                <IdentNode start="(704, 26)" end="(704, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(704, 29)" end="(704, 37)">
                <AtomNode start="(704, 29)" end="(704, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(704, 31)" end="(704, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(704, 31)" end="(704, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(704, 36)" end="(704, 37)">
                    <IdentNode start="(704, 36)" end="(704, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(704, 37)" end="(704, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(704, 39)" end="(704, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(704, 39)" end="(704, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(704, 40)" end="(704, 41)">
                <IdentNode start="(704, 40)" end="(704, 41)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(704, 42)" end="(704, 52)">
                <AtomNode start="(704, 42)" end="(704, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(704, 44)" end="(704, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(704, 44)" end="(704, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(704, 46)" end="(704, 47)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(704, 48)" end="(704, 52)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(704, 52)" end="(704, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(704, 54)" end="(705, 43)">
            <AtomNode start="(704, 54)" end="(704, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(705, 5)" end="(705, 43)" kind="«term_=_»">
              <OtherNode start="(705, 5)" end="(705, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(705, 5)" end="(705, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(705, 5)" end="(705, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(705, 6)" end="(705, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(705, 6)" end="(705, 17)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(705, 18)" end="(705, 19)">
                      <IdentNode start="(705, 18)" end="(705, 19)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(705, 19)" end="(705, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(705, 20)" end="(705, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(705, 21)" end="(705, 27)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(705, 28)" end="(705, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(705, 30)" end="(705, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(705, 30)" end="(705, 36)" leading="" trailing=" " raw_val="xs.all" val="xs.all"/>
                <NullNode start="(705, 37)" end="(705, 43)">
                  <OtherNode start="(705, 37)" end="(705, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(705, 37)" end="(705, 38)" leading="" trailing="" val="("/>
                    <OtherNode start="(705, 38)" end="(705, 42)" kind="«term¬_»">
                      <AtomNode start="(705, 38)" end="(705, 39)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(705, 39)" end="(705, 42)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(705, 39)" end="(705, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(705, 41)" end="(705, 42)">
                          <OtherNode start="(705, 41)" end="(705, 42)" kind="Lean.Parser.Term.cdot">
                            <AtomNode start="(705, 41)" end="(705, 42)" leading="" trailing="" val="·"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(705, 42)" end="(705, 43)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(705, 44)" end="(710, 23)">
          <AtomNode start="(705, 44)" end="(705, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(705, 47)" end="(710, 23)">
            <AtomNode start="(705, 47)" end="(705, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(706, 3)" end="(710, 23)">
              <TacticTacticseq1IndentedNode start="(706, 3)" end="(710, 23)">
                <NullNode start="(706, 3)" end="(710, 23)">
                  <OtherNode start="(706, 3)" end="(710, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ (findIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(706, 3)" end="(706, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(706, 13)" end="(706, 15)">
                      <OtherNode start="(706, 13)" end="(706, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(706, 13)" end="(706, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(706, 16)" end="(710, 23)">
                      <OtherNode start="(706, 16)" end="(710, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(706, 16)" end="(706, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(707, 3)" end="(710, 23)">
                          <OtherNode start="(707, 3)" end="(707, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(707, 3)" end="(707, 8)">
                              <OtherNode start="(707, 3)" end="(707, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(707, 3)" end="(707, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(707, 5)" end="(707, 8)">
                                  <NullNode/>
                                  <IdentNode start="(707, 5)" end="(707, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(707, 9)" end="(707, 16)">
                              <AtomNode start="(707, 9)" end="(707, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(707, 12)" end="(707, 16)">
                                <TacticTacticseq1IndentedNode start="(707, 12)" end="(707, 16)">
                                  <NullNode start="(707, 12)" end="(707, 16)">
                                    <OtherNode start="(707, 12)" end="(707, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ (findIdx? p []).isNone = [].all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(707, 12)" end="(707, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(708, 3)" end="(710, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(708, 3)" end="(708, 17)">
                              <OtherNode start="(708, 3)" end="(708, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(708, 3)" end="(708, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(708, 5)" end="(708, 9)">
                                  <NullNode/>
                                  <IdentNode start="(708, 5)" end="(708, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(708, 10)" end="(708, 17)">
                                  <IdentNode start="(708, 10)" end="(708, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(708, 12)" end="(708, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(708, 15)" end="(708, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(708, 18)" end="(710, 23)">
                              <AtomNode start="(708, 18)" end="(708, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(709, 5)" end="(710, 23)">
                                <TacticTacticseq1IndentedNode start="(709, 5)" end="(710, 23)">
                                  <NullNode start="(709, 5)" end="(710, 23)">
                                    <OtherNode start="(709, 5)" end="(709, 30)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true&#10;⊢ (findIdx? p (x :: xs)).isNone = (x :: xs).all fun x =&amp;gt; decide ¬p x = true" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)).isNone =&#10;    (x :: xs).all fun x =&amp;gt; decide ¬p x = true" tactic="simp only [findIdx?_cons]">
                                      <AtomNode start="(709, 5)" end="(709, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(709, 10)" end="(709, 14)">
                                        <AtomNode start="(709, 10)" end="(709, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(709, 15)" end="(709, 30)">
                                        <AtomNode start="(709, 15)" end="(709, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(709, 16)" end="(709, 29)">
                                          <OtherNode start="(709, 16)" end="(709, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(709, 16)" end="(709, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(709, 29)" end="(709, 30)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(710, 5)" end="(710, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)).isNone =&#10;    (x :: xs).all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(710, 5)" end="(710, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(710, 5)" end="(710, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(710, 11)" end="(710, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(710, 15)" end="(710, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(710, 15)" end="(710, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(712, 1)" end="(727, 64)" name="findIdx?_eq_some_iff_findIdx_eq" full_name="List.findIdx?_eq_some_iff_findIdx_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(712, 1)" end="(727, 64)" name="findIdx?_eq_some_iff_findIdx_eq" full_name="List.findIdx?_eq_some_iff_findIdx_eq" _is_private_decl="False">
        <AtomNode start="(712, 1)" end="(712, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(712, 9)" end="(712, 40)">
          <IdentNode start="(712, 9)" end="(712, 40)" leading="" trailing=" " raw_val="findIdx?_eq_some_iff_findIdx_eq" val="findIdx?_eq_some_iff_findIdx_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(712, 41)" end="(713, 62)">
          <NullNode start="(712, 41)" end="(712, 79)">
            <OtherNode start="(712, 41)" end="(712, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(712, 41)" end="(712, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(712, 42)" end="(712, 44)">
                <IdentNode start="(712, 42)" end="(712, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(712, 45)" end="(712, 53)">
                <AtomNode start="(712, 45)" end="(712, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(712, 47)" end="(712, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(712, 47)" end="(712, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(712, 52)" end="(712, 53)">
                    <IdentNode start="(712, 52)" end="(712, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(712, 53)" end="(712, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(712, 55)" end="(712, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(712, 55)" end="(712, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(712, 56)" end="(712, 57)">
                <IdentNode start="(712, 56)" end="(712, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(712, 58)" end="(712, 68)">
                <AtomNode start="(712, 58)" end="(712, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(712, 60)" end="(712, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(712, 60)" end="(712, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(712, 62)" end="(712, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(712, 64)" end="(712, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(712, 68)" end="(712, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(712, 70)" end="(712, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(712, 70)" end="(712, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(712, 71)" end="(712, 72)">
                <IdentNode start="(712, 71)" end="(712, 72)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(712, 73)" end="(712, 78)">
                <AtomNode start="(712, 73)" end="(712, 74)" leading="" trailing=" " val=":"/>
                <IdentNode start="(712, 75)" end="(712, 78)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(712, 78)" end="(712, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(712, 80)" end="(713, 62)">
            <AtomNode start="(712, 80)" end="(712, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(713, 5)" end="(713, 62)" kind="«term_↔_»">
              <OtherNode start="(713, 5)" end="(713, 27)" kind="«term_=_»">
                <OtherNode start="(713, 5)" end="(713, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(713, 5)" end="(713, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(713, 17)" end="(713, 18)">
                    <IdentNode start="(713, 17)" end="(713, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(713, 19)" end="(713, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(713, 21)" end="(713, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(713, 21)" end="(713, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(713, 26)" end="(713, 27)">
                    <IdentNode start="(713, 26)" end="(713, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(713, 28)" end="(713, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(713, 30)" end="(713, 62)" kind="«term_∧_»">
                <OtherNode start="(713, 30)" end="(713, 43)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(713, 30)" end="(713, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(713, 32)" end="(713, 33)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(713, 34)" end="(713, 43)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                </OtherNode>
                <AtomNode start="(713, 44)" end="(713, 45)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(713, 46)" end="(713, 62)" kind="«term_=_»">
                  <OtherNode start="(713, 46)" end="(713, 58)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(713, 46)" end="(713, 56)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                    <NullNode start="(713, 57)" end="(713, 58)">
                      <IdentNode start="(713, 57)" end="(713, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(713, 59)" end="(713, 60)" leading="" trailing=" " val="="/>
                  <IdentNode start="(713, 61)" end="(713, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(713, 63)" end="(727, 64)">
          <AtomNode start="(713, 63)" end="(713, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(713, 66)" end="(727, 64)">
            <AtomNode start="(713, 66)" end="(713, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(714, 3)" end="(727, 64)">
              <TacticTacticseq1IndentedNode start="(714, 3)" end="(727, 64)">
                <NullNode start="(714, 3)" end="(727, 64)">
                  <OtherNode start="(714, 3)" end="(727, 64)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i" state_after="no goals" tactic="induction xs generalizing i with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons, findIdx_cons]&#10;  split&#10;  · simp_all [cond_eq_if]&#10;    rintro rfl&#10;    exact zero_lt_succ xs.length&#10;  · simp_all [cond_eq_if, and_assoc]&#10;    constructor&#10;    · rintro ⟨a, lt, rfl, rfl⟩&#10;      simp_all [Nat.succ_lt_succ_iff]&#10;    · rintro ⟨h, rfl⟩&#10;      exact ⟨_, by simp_all [Nat.succ_lt_succ_iff], rfl, rfl⟩">
                    <AtomNode start="(714, 3)" end="(714, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(714, 13)" end="(714, 15)">
                      <OtherNode start="(714, 13)" end="(714, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(714, 13)" end="(714, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(714, 16)" end="(714, 30)">
                      <AtomNode start="(714, 16)" end="(714, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(714, 29)" end="(714, 30)">
                        <IdentNode start="(714, 29)" end="(714, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(714, 31)" end="(727, 64)">
                      <OtherNode start="(714, 31)" end="(727, 64)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(714, 31)" end="(714, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(715, 3)" end="(727, 64)">
                          <OtherNode start="(715, 3)" end="(715, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(715, 3)" end="(715, 8)">
                              <OtherNode start="(715, 3)" end="(715, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(715, 3)" end="(715, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(715, 5)" end="(715, 8)">
                                  <NullNode/>
                                  <IdentNode start="(715, 5)" end="(715, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(715, 9)" end="(715, 20)">
                              <AtomNode start="(715, 9)" end="(715, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(715, 12)" end="(715, 20)">
                                <TacticTacticseq1IndentedNode start="(715, 12)" end="(715, 20)">
                                  <NullNode start="(715, 12)" end="(715, 20)">
                                    <OtherNode start="(715, 12)" end="(715, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx? p [] = some i ↔ i &amp;lt; [].length ∧ findIdx p [] = i" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(715, 12)" end="(715, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(716, 3)" end="(727, 64)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(716, 3)" end="(716, 17)">
                              <OtherNode start="(716, 3)" end="(716, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(716, 3)" end="(716, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(716, 5)" end="(716, 9)">
                                  <NullNode/>
                                  <IdentNode start="(716, 5)" end="(716, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(716, 10)" end="(716, 17)">
                                  <IdentNode start="(716, 10)" end="(716, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(716, 12)" end="(716, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(716, 15)" end="(716, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(716, 18)" end="(727, 64)">
                              <AtomNode start="(716, 18)" end="(716, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(717, 5)" end="(727, 64)">
                                <TacticTacticseq1IndentedNode start="(717, 5)" end="(727, 64)">
                                  <NullNode start="(717, 5)" end="(727, 64)">
                                    <OtherNode start="(717, 5)" end="(717, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;⊢ findIdx? p (x :: xs) = some i ↔ i &amp;lt; (x :: xs).length ∧ findIdx p (x :: xs) = i" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" tactic="simp only [findIdx?_cons, findIdx_cons]">
                                      <AtomNode start="(717, 5)" end="(717, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(717, 10)" end="(717, 14)">
                                        <AtomNode start="(717, 10)" end="(717, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(717, 15)" end="(717, 44)">
                                        <AtomNode start="(717, 15)" end="(717, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(717, 16)" end="(717, 43)">
                                          <OtherNode start="(717, 16)" end="(717, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(717, 16)" end="(717, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(717, 29)" end="(717, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(717, 31)" end="(717, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(717, 31)" end="(717, 43)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(717, 43)" end="(717, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(718, 5)" end="(718, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ some 0 = some i ↔ i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" tactic="split">
                                      <AtomNode start="(718, 5)" end="(718, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(719, 5)" end="(721, 35)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ some 0 = some i ↔ i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" tactic="· simp_all [cond_eq_if]&#10;  rintro rfl&#10;  exact zero_lt_succ xs.length">
                                      <OtherNode start="(719, 5)" end="(719, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(719, 5)" end="(719, 6)" kind="patternIgnore">
                                          <OtherNode start="(719, 5)" end="(719, 6)" kind="token.«· »">
                                            <AtomNode start="(719, 5)" end="(719, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(719, 7)" end="(721, 35)">
                                        <TacticTacticseq1IndentedNode start="(719, 7)" end="(721, 35)">
                                          <NullNode start="(719, 7)" end="(721, 35)">
                                            <OtherNode start="(719, 7)" end="(719, 28)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ some 0 = some i ↔ i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ 0 = i → i &amp;lt; xs.length + 1" tactic="simp_all [cond_eq_if]">
                                              <AtomNode start="(719, 7)" end="(719, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(719, 16)" end="(719, 28)">
                                                <AtomNode start="(719, 16)" end="(719, 17)" leading="" trailing="" val="["/>
                                                <NullNode start="(719, 17)" end="(719, 27)">
                                                  <OtherNode start="(719, 17)" end="(719, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(719, 17)" end="(719, 27)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(719, 27)" end="(719, 28)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(720, 7)" end="(720, 17)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ 0 = i → i &amp;lt; xs.length + 1" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = true&#10;⊢ 0 &amp;lt; xs.length + 1" tactic="rintro rfl">
                                              <AtomNode start="(720, 7)" end="(720, 13)" leading="" trailing=" " val="rintro"/>
                                              <NullNode start="(720, 14)" end="(720, 17)">
                                                <OtherNode start="(720, 14)" end="(720, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                  <OtherNode start="(720, 14)" end="(720, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(720, 14)" end="(720, 17)" leading="" trailing="&#10;      " raw_val="rfl" val="rfl"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(721, 7)" end="(721, 35)" kind="Lean.Parser.Tactic.exact" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = true&#10;⊢ 0 &amp;lt; xs.length + 1" state_after="no goals" tactic="exact zero_lt_succ xs.length">
                                              <AtomNode start="(721, 7)" end="(721, 12)" leading="" trailing=" " val="exact"/>
                                              <OtherNode start="(721, 13)" end="(721, 35)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(721, 13)" end="(721, 25)" leading="" trailing=" " raw_val="zero_lt_succ" val="zero_lt_succ" full_name="Nat.zero_lt_succ" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                <NullNode start="(721, 26)" end="(721, 35)">
                                                  <IdentNode start="(721, 26)" end="(721, 35)" leading="" trailing="&#10;    " raw_val="xs.length" val="xs.length"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(722, 5)" end="(727, 64)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" state_after="no goals" tactic="· simp_all [cond_eq_if, and_assoc]&#10;  constructor&#10;  · rintro ⟨a, lt, rfl, rfl⟩&#10;    simp_all [Nat.succ_lt_succ_iff]&#10;  · rintro ⟨h, rfl⟩&#10;    exact ⟨_, by simp_all [Nat.succ_lt_succ_iff], rfl, rfl⟩">
                                      <OtherNode start="(722, 5)" end="(722, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(722, 5)" end="(722, 6)" kind="patternIgnore">
                                          <OtherNode start="(722, 5)" end="(722, 6)" kind="token.«· »">
                                            <AtomNode start="(722, 5)" end="(722, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(722, 7)" end="(727, 64)">
                                        <TacticTacticseq1IndentedNode start="(722, 7)" end="(727, 64)">
                                          <NullNode start="(722, 7)" end="(727, 64)">
                                            <OtherNode start="(722, 7)" end="(722, 39)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    i &amp;lt; (x :: xs).length ∧ (bif p x then 0 else findIdx p xs + 1) = i" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ (∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i) ↔ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i" tactic="simp_all [cond_eq_if, and_assoc]">
                                              <AtomNode start="(722, 7)" end="(722, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(722, 16)" end="(722, 39)">
                                                <AtomNode start="(722, 16)" end="(722, 17)" leading="" trailing="" val="["/>
                                                <NullNode start="(722, 17)" end="(722, 38)">
                                                  <OtherNode start="(722, 17)" end="(722, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(722, 17)" end="(722, 27)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(722, 27)" end="(722, 28)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(722, 29)" end="(722, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(722, 29)" end="(722, 38)" leading="" trailing="" raw_val="and_assoc" val="and_assoc" full_name="and_assoc" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(722, 38)" end="(722, 39)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(723, 7)" end="(723, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ (∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i) ↔ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i" state_after="case cons.isFalse.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ (∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i) → i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i&#10;&#10;case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i → ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i" tactic="constructor">
                                              <AtomNode start="(723, 7)" end="(723, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(724, 7)" end="(725, 40)" kind="Lean.cdot" state_before="case cons.isFalse.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ (∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i) → i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i&#10;&#10;case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i → ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i" state_after="case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i → ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i" tactic="· rintro ⟨a, lt, rfl, rfl⟩&#10;  simp_all [Nat.succ_lt_succ_iff]">
                                              <OtherNode start="(724, 7)" end="(724, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(724, 7)" end="(724, 8)" kind="patternIgnore">
                                                  <OtherNode start="(724, 7)" end="(724, 8)" kind="token.«· »">
                                                    <AtomNode start="(724, 7)" end="(724, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(724, 9)" end="(725, 40)">
                                                <TacticTacticseq1IndentedNode start="(724, 9)" end="(725, 40)">
                                                  <NullNode start="(724, 9)" end="(725, 40)">
                                                    <OtherNode start="(724, 9)" end="(724, 33)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isFalse.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ (∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i) → i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i" state_after="case cons.isFalse.mp.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = false&#10;lt : findIdx p xs &amp;lt; xs.length&#10;⊢ findIdx p xs + 1 &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = findIdx p xs + 1" tactic="rintro ⟨a, lt, rfl, rfl⟩">
                                                      <AtomNode start="(724, 9)" end="(724, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(724, 16)" end="(724, 33)">
                                                        <OtherNode start="(724, 16)" end="(724, 33)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(724, 16)" end="(724, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(724, 16)" end="(724, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(724, 17)" end="(724, 32)">
                                                            <OtherNode start="(724, 17)" end="(724, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(724, 17)" end="(724, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(724, 17)" end="(724, 18)">
                                                            <OtherNode start="(724, 17)" end="(724, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(724, 17)" end="(724, 18)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(724, 18)" end="(724, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(724, 20)" end="(724, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(724, 20)" end="(724, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(724, 20)" end="(724, 22)">
                                                            <OtherNode start="(724, 20)" end="(724, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(724, 20)" end="(724, 22)" leading="" trailing="" raw_val="lt" val="lt"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(724, 22)" end="(724, 23)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(724, 24)" end="(724, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(724, 24)" end="(724, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(724, 24)" end="(724, 27)">
                                                            <OtherNode start="(724, 24)" end="(724, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(724, 24)" end="(724, 27)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(724, 27)" end="(724, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(724, 29)" end="(724, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(724, 29)" end="(724, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(724, 29)" end="(724, 32)">
                                                            <OtherNode start="(724, 29)" end="(724, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(724, 29)" end="(724, 32)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(724, 32)" end="(724, 33)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(725, 9)" end="(725, 40)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse.mp.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = false&#10;lt : findIdx p xs &amp;lt; xs.length&#10;⊢ findIdx p xs + 1 &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = findIdx p xs + 1" state_after="no goals" tactic="simp_all [Nat.succ_lt_succ_iff]">
                                                      <AtomNode start="(725, 9)" end="(725, 17)" leading="" trailing=" " val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(725, 18)" end="(725, 40)">
                                                        <AtomNode start="(725, 18)" end="(725, 19)" leading="" trailing="" val="["/>
                                                        <NullNode start="(725, 19)" end="(725, 39)">
                                                          <OtherNode start="(725, 19)" end="(725, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(725, 19)" end="(725, 39)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(725, 39)" end="(725, 40)" leading="" trailing="&#10;      " val="]"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(726, 7)" end="(727, 64)" kind="Lean.cdot" state_before="case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i → ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i" state_after="no goals" tactic="· rintro ⟨h, rfl⟩&#10;  exact ⟨_, by simp_all [Nat.succ_lt_succ_iff], rfl, rfl⟩">
                                              <OtherNode start="(726, 7)" end="(726, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(726, 7)" end="(726, 8)" kind="patternIgnore">
                                                  <OtherNode start="(726, 7)" end="(726, 8)" kind="token.«· »">
                                                    <AtomNode start="(726, 7)" end="(726, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(726, 9)" end="(727, 64)">
                                                <TacticTacticseq1IndentedNode start="(726, 9)" end="(727, 64)">
                                                  <NullNode start="(726, 9)" end="(727, 64)">
                                                    <OtherNode start="(726, 9)" end="(726, 24)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;i : Nat&#10;h✝ : p x = false&#10;⊢ i &amp;lt; xs.length + 1 ∧ findIdx p xs + 1 = i → ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = i" state_after="case cons.isFalse.mpr.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = false&#10;h : findIdx p xs + 1 &amp;lt; xs.length + 1&#10;⊢ ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = findIdx p xs + 1" tactic="rintro ⟨h, rfl⟩">
                                                      <AtomNode start="(726, 9)" end="(726, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(726, 16)" end="(726, 24)">
                                                        <OtherNode start="(726, 16)" end="(726, 24)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(726, 16)" end="(726, 24)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(726, 16)" end="(726, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(726, 17)" end="(726, 23)">
                                                            <OtherNode start="(726, 17)" end="(726, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(726, 17)" end="(726, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(726, 17)" end="(726, 18)">
                                                            <OtherNode start="(726, 17)" end="(726, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(726, 17)" end="(726, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(726, 18)" end="(726, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(726, 20)" end="(726, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(726, 20)" end="(726, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(726, 20)" end="(726, 23)">
                                                            <OtherNode start="(726, 20)" end="(726, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(726, 20)" end="(726, 23)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(726, 23)" end="(726, 24)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(727, 9)" end="(727, 64)" kind="Lean.Parser.Tactic.exact" state_before="case cons.isFalse.mpr.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = false&#10;h : findIdx p xs + 1 &amp;lt; xs.length + 1&#10;⊢ ∃ a, a &amp;lt; xs.length ∧ findIdx p xs = a ∧ a + 1 = findIdx p xs + 1" state_after="no goals" tactic="exact ⟨_, by simp_all [Nat.succ_lt_succ_iff], rfl, rfl⟩">
                                                      <AtomNode start="(727, 9)" end="(727, 14)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(727, 15)" end="(727, 64)" kind="Lean.Parser.Term.anonymousCtor">
                                                        <AtomNode start="(727, 15)" end="(727, 16)" leading="" trailing="" val="⟨"/>
                                                        <NullNode start="(727, 16)" end="(727, 63)">
                                                          <TermHoleNode start="(727, 16)" end="(727, 17)">
                                                            <AtomNode start="(727, 16)" end="(727, 17)" leading="" trailing="" val="_"/>
                                                          </TermHoleNode>
                                                          <AtomNode start="(727, 17)" end="(727, 18)" leading="" trailing=" " val=","/>
                                                          <TermBytacticNode start="(727, 19)" end="(727, 53)">
                                                            <AtomNode start="(727, 19)" end="(727, 21)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(727, 22)" end="(727, 53)">
                                                            <TacticTacticseq1IndentedNode start="(727, 22)" end="(727, 53)">
                                                            <NullNode start="(727, 22)" end="(727, 53)">
                                                            <OtherNode start="(727, 22)" end="(727, 53)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ i &amp;lt; xs.length ∧ findIdx p xs = i&#10;h✝ : p x = false&#10;h : findIdx p xs + 1 &amp;lt; xs.length + 1&#10;⊢ findIdx p xs &amp;lt; xs.length" state_after="no goals" tactic="simp_all [Nat.succ_lt_succ_iff]">
                                                            <AtomNode start="(727, 22)" end="(727, 30)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(727, 31)" end="(727, 53)">
                                                            <AtomNode start="(727, 31)" end="(727, 32)" leading="" trailing="" val="["/>
                                                            <NullNode start="(727, 32)" end="(727, 52)">
                                                            <OtherNode start="(727, 32)" end="(727, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(727, 32)" end="(727, 52)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(727, 52)" end="(727, 53)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(727, 53)" end="(727, 54)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(727, 55)" end="(727, 58)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          <AtomNode start="(727, 58)" end="(727, 59)" leading="" trailing=" " val=","/>
                                                          <IdentNode start="(727, 60)" end="(727, 63)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                        </NullNode>
                                                        <AtomNode start="(727, 63)" end="(727, 64)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(729, 1)" end="(732, 45)" name="findIdx?_eq_some_of_exists" full_name="List.findIdx?_eq_some_of_exists">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(729, 1)" end="(732, 45)" name="findIdx?_eq_some_of_exists" full_name="List.findIdx?_eq_some_of_exists" _is_private_decl="False">
        <AtomNode start="(729, 1)" end="(729, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(729, 9)" end="(729, 35)">
          <IdentNode start="(729, 9)" end="(729, 35)" leading="" trailing=" " raw_val="findIdx?_eq_some_of_exists" val="findIdx?_eq_some_of_exists"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(729, 36)" end="(730, 40)">
          <NullNode start="(729, 36)" end="(729, 88)">
            <OtherNode start="(729, 36)" end="(729, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(729, 36)" end="(729, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(729, 37)" end="(729, 39)">
                <IdentNode start="(729, 37)" end="(729, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(729, 40)" end="(729, 48)">
                <AtomNode start="(729, 40)" end="(729, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(729, 42)" end="(729, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(729, 42)" end="(729, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(729, 47)" end="(729, 48)">
                    <IdentNode start="(729, 47)" end="(729, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(729, 48)" end="(729, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(729, 50)" end="(729, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(729, 50)" end="(729, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(729, 51)" end="(729, 52)">
                <IdentNode start="(729, 51)" end="(729, 52)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(729, 53)" end="(729, 63)">
                <AtomNode start="(729, 53)" end="(729, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(729, 55)" end="(729, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(729, 55)" end="(729, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(729, 57)" end="(729, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(729, 59)" end="(729, 63)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(729, 63)" end="(729, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(729, 65)" end="(729, 88)">
              <AtomNode start="(729, 65)" end="(729, 66)" leading="" trailing="" val="("/>
              <NullNode start="(729, 66)" end="(729, 67)">
                <IdentNode start="(729, 66)" end="(729, 67)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(729, 68)" end="(729, 87)">
                <AtomNode start="(729, 68)" end="(729, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(729, 70)" end="(729, 87)" kind="«term∃_,_»">
                  <AtomNode start="(729, 70)" end="(729, 71)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(729, 72)" end="(729, 73)" kind="Lean.explicitBinders">
                    <OtherNode start="(729, 72)" end="(729, 73)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(729, 72)" end="(729, 73)">
                        <LeanBinderidentNode start="(729, 72)" end="(729, 73)">
                          <IdentNode start="(729, 72)" end="(729, 73)" leading="" trailing="" raw_val="x" val="x"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(729, 73)" end="(729, 74)" leading="" trailing=" " val=","/>
                  <OtherNode start="(729, 75)" end="(729, 87)" kind="«term_∧_»">
                    <OtherNode start="(729, 75)" end="(729, 81)" kind="«term_∈_»">
                      <IdentNode start="(729, 75)" end="(729, 76)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(729, 77)" end="(729, 78)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(729, 79)" end="(729, 81)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(729, 82)" end="(729, 83)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(729, 84)" end="(729, 87)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(729, 84)" end="(729, 85)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(729, 86)" end="(729, 87)">
                        <IdentNode start="(729, 86)" end="(729, 87)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(729, 87)" end="(729, 88)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(729, 89)" end="(730, 40)">
            <AtomNode start="(729, 89)" end="(729, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(730, 5)" end="(730, 40)" kind="«term_=_»">
              <OtherNode start="(730, 5)" end="(730, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(730, 5)" end="(730, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(730, 17)" end="(730, 18)">
                  <IdentNode start="(730, 17)" end="(730, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(730, 19)" end="(730, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(730, 21)" end="(730, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(730, 21)" end="(730, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(730, 26)" end="(730, 40)">
                  <OtherNode start="(730, 26)" end="(730, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(730, 26)" end="(730, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(730, 27)" end="(730, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(730, 27)" end="(730, 37)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(730, 38)" end="(730, 39)">
                        <IdentNode start="(730, 38)" end="(730, 39)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(730, 39)" end="(730, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(730, 41)" end="(732, 45)">
          <AtomNode start="(730, 41)" end="(730, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(730, 44)" end="(732, 45)">
            <AtomNode start="(730, 44)" end="(730, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(731, 3)" end="(732, 45)">
              <TacticTacticseq1IndentedNode start="(731, 3)" end="(732, 45)">
                <NullNode start="(731, 3)" end="(732, 45)">
                  <OtherNode start="(731, 3)" end="(731, 39)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx? p xs = some (findIdx p xs)" state_after="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs &amp;lt; xs.length ∧ findIdx p xs = findIdx p xs" tactic="rw [findIdx?_eq_some_iff_findIdx_eq]">
                    <AtomNode start="(731, 3)" end="(731, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(731, 6)" end="(731, 39)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(731, 6)" end="(731, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(731, 7)" end="(731, 38)">
                        <OtherNode start="(731, 7)" end="(731, 38)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(731, 7)" end="(731, 38)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_findIdx_eq" val="findIdx?_eq_some_iff_findIdx_eq" full_name="List.findIdx?_eq_some_iff_findIdx_eq" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(712, 9)" def_end="(712, 40)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(731, 38)" end="(731, 39)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(732, 3)" end="(732, 45)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx p xs &amp;lt; xs.length ∧ findIdx p xs = findIdx p xs" state_after="no goals" tactic="exact ⟨findIdx_lt_length_of_exists h, rfl⟩">
                    <AtomNode start="(732, 3)" end="(732, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(732, 9)" end="(732, 45)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(732, 9)" end="(732, 10)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(732, 10)" end="(732, 44)">
                        <OtherNode start="(732, 10)" end="(732, 39)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(732, 10)" end="(732, 37)" leading="" trailing=" " raw_val="findIdx_lt_length_of_exists" val="findIdx_lt_length_of_exists" full_name="List.findIdx_lt_length_of_exists" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(534, 9)" def_end="(534, 36)"/>
                          <NullNode start="(732, 38)" end="(732, 39)">
                            <IdentNode start="(732, 38)" end="(732, 39)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(732, 39)" end="(732, 40)" leading="" trailing=" " val=","/>
                        <IdentNode start="(732, 41)" end="(732, 44)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <AtomNode start="(732, 44)" end="(732, 45)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(734, 1)" end="(736, 7)" name="findIdx?_eq_none_iff_findIdx_eq" full_name="List.findIdx?_eq_none_iff_findIdx_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(734, 1)" end="(736, 7)" name="findIdx?_eq_none_iff_findIdx_eq" full_name="List.findIdx?_eq_none_iff_findIdx_eq" _is_private_decl="False">
        <AtomNode start="(734, 1)" end="(734, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(734, 9)" end="(734, 40)">
          <IdentNode start="(734, 9)" end="(734, 40)" leading="" trailing=" " raw_val="findIdx?_eq_none_iff_findIdx_eq" val="findIdx?_eq_none_iff_findIdx_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(734, 41)" end="(735, 52)">
          <NullNode start="(734, 41)" end="(734, 69)">
            <OtherNode start="(734, 41)" end="(734, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(734, 41)" end="(734, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(734, 42)" end="(734, 44)">
                <IdentNode start="(734, 42)" end="(734, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(734, 45)" end="(734, 53)">
                <AtomNode start="(734, 45)" end="(734, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(734, 47)" end="(734, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(734, 47)" end="(734, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(734, 52)" end="(734, 53)">
                    <IdentNode start="(734, 52)" end="(734, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(734, 53)" end="(734, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(734, 55)" end="(734, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(734, 55)" end="(734, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(734, 56)" end="(734, 57)">
                <IdentNode start="(734, 56)" end="(734, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(734, 58)" end="(734, 68)">
                <AtomNode start="(734, 58)" end="(734, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(734, 60)" end="(734, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(734, 60)" end="(734, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(734, 62)" end="(734, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(734, 64)" end="(734, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(734, 68)" end="(734, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(734, 70)" end="(735, 52)">
            <AtomNode start="(734, 70)" end="(734, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(735, 5)" end="(735, 52)" kind="«term_↔_»">
              <OtherNode start="(735, 5)" end="(735, 25)" kind="«term_=_»">
                <OtherNode start="(735, 5)" end="(735, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(735, 5)" end="(735, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(735, 17)" end="(735, 18)">
                    <IdentNode start="(735, 17)" end="(735, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(735, 19)" end="(735, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(735, 21)" end="(735, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(735, 26)" end="(735, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(735, 28)" end="(735, 52)" kind="«term_=_»">
                <OtherNode start="(735, 28)" end="(735, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(735, 28)" end="(735, 38)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                  <NullNode start="(735, 39)" end="(735, 40)">
                    <IdentNode start="(735, 39)" end="(735, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(735, 41)" end="(735, 42)" leading="" trailing=" " val="="/>
                <IdentNode start="(735, 43)" end="(735, 52)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(735, 53)" end="(736, 7)">
          <AtomNode start="(735, 53)" end="(735, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(735, 56)" end="(736, 7)">
            <AtomNode start="(735, 56)" end="(735, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(736, 3)" end="(736, 7)">
              <TacticTacticseq1IndentedNode start="(736, 3)" end="(736, 7)">
                <NullNode start="(736, 3)" end="(736, 7)">
                  <OtherNode start="(736, 3)" end="(736, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx? p xs = none ↔ findIdx p xs = xs.length" state_after="no goals" tactic="simp">
                    <AtomNode start="(736, 3)" end="(736, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(738, 1)" end="(746, 13)" name="findIdx?_eq_guard_findIdx_lt" full_name="List.findIdx?_eq_guard_findIdx_lt">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(738, 1)" end="(746, 13)" name="findIdx?_eq_guard_findIdx_lt" full_name="List.findIdx?_eq_guard_findIdx_lt" _is_private_decl="False">
        <AtomNode start="(738, 1)" end="(738, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(738, 9)" end="(738, 37)">
          <IdentNode start="(738, 9)" end="(738, 37)" leading="" trailing=" " raw_val="findIdx?_eq_guard_findIdx_lt" val="findIdx?_eq_guard_findIdx_lt"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(738, 38)" end="(739, 73)">
          <NullNode start="(738, 38)" end="(738, 66)">
            <OtherNode start="(738, 38)" end="(738, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(738, 38)" end="(738, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(738, 39)" end="(738, 41)">
                <IdentNode start="(738, 39)" end="(738, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(738, 42)" end="(738, 50)">
                <AtomNode start="(738, 42)" end="(738, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(738, 44)" end="(738, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(738, 44)" end="(738, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(738, 49)" end="(738, 50)">
                    <IdentNode start="(738, 49)" end="(738, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(738, 50)" end="(738, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(738, 52)" end="(738, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(738, 52)" end="(738, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(738, 53)" end="(738, 54)">
                <IdentNode start="(738, 53)" end="(738, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(738, 55)" end="(738, 65)">
                <AtomNode start="(738, 55)" end="(738, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(738, 57)" end="(738, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(738, 57)" end="(738, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(738, 59)" end="(738, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(738, 61)" end="(738, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(738, 65)" end="(738, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(738, 67)" end="(739, 73)">
            <AtomNode start="(738, 67)" end="(738, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(739, 5)" end="(739, 73)" kind="«term_=_»">
              <OtherNode start="(739, 5)" end="(739, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(739, 5)" end="(739, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(739, 17)" end="(739, 18)">
                  <IdentNode start="(739, 17)" end="(739, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(739, 19)" end="(739, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(739, 21)" end="(739, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(739, 21)" end="(739, 33)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                <NullNode start="(739, 34)" end="(739, 73)">
                  <OtherNode start="(739, 34)" end="(739, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(739, 34)" end="(739, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(739, 35)" end="(739, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(739, 35)" end="(739, 38)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(739, 39)" end="(739, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(739, 39)" end="(739, 40)">
                          <IdentNode start="(739, 39)" end="(739, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(739, 41)" end="(739, 43)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(739, 44)" end="(739, 57)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(739, 44)" end="(739, 45)" leading="" trailing=" " raw_val="i" val="i"/>
                          <AtomNode start="(739, 46)" end="(739, 47)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(739, 48)" end="(739, 57)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(739, 57)" end="(739, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(739, 59)" end="(739, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(739, 59)" end="(739, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(739, 60)" end="(739, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(739, 60)" end="(739, 70)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                      <NullNode start="(739, 71)" end="(739, 72)">
                        <IdentNode start="(739, 71)" end="(739, 72)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(739, 72)" end="(739, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(739, 74)" end="(746, 13)">
          <AtomNode start="(739, 74)" end="(739, 76)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(739, 77)" end="(746, 13)">
            <AtomNode start="(739, 77)" end="(739, 79)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(740, 3)" end="(746, 13)">
              <TacticTacticseq1IndentedNode start="(740, 3)" end="(746, 13)">
                <NullNode start="(740, 3)" end="(746, 13)">
                  <OtherNode start="(740, 3)" end="(746, 13)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx? p xs = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" state_after="no goals" tactic="match h : xs.findIdx? p with&#10;| none =&amp;gt;&#10;  simp only [findIdx?_eq_none_iff] at h&#10;  simp [findIdx_eq_length_of_false h, Option.guard]&#10;| some i =&amp;gt;&#10;  simp only [findIdx?_eq_some_iff_findIdx_eq] at h&#10;  simp [h]">
                    <AtomNode start="(740, 3)" end="(740, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(740, 9)" end="(740, 26)">
                      <OtherNode start="(740, 9)" end="(740, 26)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode start="(740, 9)" end="(740, 12)">
                          <IdentNode start="(740, 9)" end="(740, 10)" leading="" trailing=" " raw_val="h" val="h"/>
                          <AtomNode start="(740, 11)" end="(740, 12)" leading="" trailing=" " val=":"/>
                        </NullNode>
                        <OtherNode start="(740, 13)" end="(740, 26)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(740, 13)" end="(740, 24)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                          <NullNode start="(740, 25)" end="(740, 26)">
                            <IdentNode start="(740, 25)" end="(740, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(740, 27)" end="(740, 31)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(741, 3)" end="(746, 13)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(741, 3)" end="(746, 13)">
                        <OtherNode start="(741, 3)" end="(743, 54)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(741, 3)" end="(741, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(741, 5)" end="(741, 9)">
                            <NullNode start="(741, 5)" end="(741, 9)">
                              <IdentNode start="(741, 5)" end="(741, 9)" leading="" trailing=" " raw_val="none" val="none" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(741, 10)" end="(741, 12)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(742, 5)" end="(743, 54)">
                            <TacticTacticseq1IndentedNode start="(742, 5)" end="(743, 54)">
                              <NullNode start="(742, 5)" end="(743, 54)">
                                <OtherNode start="(742, 5)" end="(742, 42)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : findIdx? p xs = none&#10;⊢ none = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" state_after="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ none = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" tactic="simp only [findIdx?_eq_none_iff] at h">
                                  <AtomNode start="(742, 5)" end="(742, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(742, 10)" end="(742, 14)">
                                    <AtomNode start="(742, 10)" end="(742, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(742, 15)" end="(742, 37)">
                                    <AtomNode start="(742, 15)" end="(742, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(742, 16)" end="(742, 36)">
                                      <OtherNode start="(742, 16)" end="(742, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(742, 16)" end="(742, 36)" leading="" trailing="" raw_val="findIdx?_eq_none_iff" val="findIdx?_eq_none_iff" full_name="List.findIdx?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(686, 9)" def_end="(686, 29)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(742, 36)" end="(742, 37)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(742, 38)" end="(742, 42)">
                                    <OtherNode start="(742, 38)" end="(742, 42)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(742, 38)" end="(742, 40)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(742, 41)" end="(742, 42)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(742, 41)" end="(742, 42)">
                                          <IdentNode start="(742, 41)" end="(742, 42)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(743, 5)" end="(743, 54)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;h : ∀ (x : α), x ∈ xs → p x = false&#10;⊢ none = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" state_after="no goals" tactic="simp [findIdx_eq_length_of_false h, Option.guard]">
                                  <AtomNode start="(743, 5)" end="(743, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(743, 10)" end="(743, 54)">
                                    <AtomNode start="(743, 10)" end="(743, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(743, 11)" end="(743, 53)">
                                      <OtherNode start="(743, 11)" end="(743, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(743, 11)" end="(743, 39)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(743, 11)" end="(743, 37)" leading="" trailing=" " raw_val="findIdx_eq_length_of_false" val="findIdx_eq_length_of_false" full_name="List.findIdx_eq_length_of_false" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(561, 9)" def_end="(561, 35)"/>
                                          <NullNode start="(743, 38)" end="(743, 39)">
                                            <IdentNode start="(743, 38)" end="(743, 39)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(743, 39)" end="(743, 40)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(743, 41)" end="(743, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(743, 41)" end="(743, 53)" leading="" trailing="" raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(743, 53)" end="(743, 54)" leading="" trailing="&#10;  " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(744, 3)" end="(746, 13)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(744, 3)" end="(744, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(744, 5)" end="(744, 11)">
                            <NullNode start="(744, 5)" end="(744, 11)">
                              <OtherNode start="(744, 5)" end="(744, 11)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(744, 5)" end="(744, 9)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(744, 10)" end="(744, 11)">
                                  <IdentNode start="(744, 10)" end="(744, 11)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(744, 12)" end="(744, 14)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(745, 5)" end="(746, 13)">
                            <TacticTacticseq1IndentedNode start="(745, 5)" end="(746, 13)">
                              <NullNode start="(745, 5)" end="(746, 13)">
                                <OtherNode start="(745, 5)" end="(745, 53)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : findIdx? p xs = some i&#10;⊢ some i = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" state_after="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : i &amp;lt; xs.length ∧ findIdx p xs = i&#10;⊢ some i = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" tactic="simp only [findIdx?_eq_some_iff_findIdx_eq] at h">
                                  <AtomNode start="(745, 5)" end="(745, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(745, 10)" end="(745, 14)">
                                    <AtomNode start="(745, 10)" end="(745, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(745, 15)" end="(745, 48)">
                                    <AtomNode start="(745, 15)" end="(745, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(745, 16)" end="(745, 47)">
                                      <OtherNode start="(745, 16)" end="(745, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(745, 16)" end="(745, 47)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_findIdx_eq" val="findIdx?_eq_some_iff_findIdx_eq" full_name="List.findIdx?_eq_some_iff_findIdx_eq" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(712, 9)" def_end="(712, 40)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(745, 47)" end="(745, 48)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(745, 49)" end="(745, 53)">
                                    <OtherNode start="(745, 49)" end="(745, 53)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(745, 49)" end="(745, 51)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(745, 52)" end="(745, 53)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(745, 52)" end="(745, 53)">
                                          <IdentNode start="(745, 52)" end="(745, 53)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(746, 5)" end="(746, 13)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : i &amp;lt; xs.length ∧ findIdx p xs = i&#10;⊢ some i = Option.guard (fun i =&amp;gt; decide (i &amp;lt; xs.length)) (findIdx p xs)" state_after="no goals" tactic="simp [h]">
                                  <AtomNode start="(746, 5)" end="(746, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(746, 10)" end="(746, 13)">
                                    <AtomNode start="(746, 10)" end="(746, 11)" leading="" trailing="" val="["/>
                                    <NullNode start="(746, 11)" end="(746, 12)">
                                      <OtherNode start="(746, 11)" end="(746, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(746, 11)" end="(746, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(746, 12)" end="(746, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(748, 1)" end="(778, 63)" name="findIdx?_eq_some_iff_getElem" full_name="List.findIdx?_eq_some_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(748, 1)" end="(778, 63)" name="findIdx?_eq_some_iff_getElem" full_name="List.findIdx?_eq_some_iff_getElem" _is_private_decl="False">
        <AtomNode start="(748, 1)" end="(748, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(748, 9)" end="(748, 37)">
          <IdentNode start="(748, 9)" end="(748, 37)" leading="" trailing=" " raw_val="findIdx?_eq_some_iff_getElem" val="findIdx?_eq_some_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(748, 38)" end="(750, 88)">
          <NullNode start="(748, 38)" end="(748, 76)">
            <OtherNode start="(748, 38)" end="(748, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(748, 38)" end="(748, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(748, 39)" end="(748, 41)">
                <IdentNode start="(748, 39)" end="(748, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(748, 42)" end="(748, 50)">
                <AtomNode start="(748, 42)" end="(748, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(748, 44)" end="(748, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(748, 44)" end="(748, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(748, 49)" end="(748, 50)">
                    <IdentNode start="(748, 49)" end="(748, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(748, 50)" end="(748, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(748, 52)" end="(748, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(748, 52)" end="(748, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(748, 53)" end="(748, 54)">
                <IdentNode start="(748, 53)" end="(748, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(748, 55)" end="(748, 65)">
                <AtomNode start="(748, 55)" end="(748, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(748, 57)" end="(748, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(748, 57)" end="(748, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(748, 59)" end="(748, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(748, 61)" end="(748, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(748, 65)" end="(748, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(748, 67)" end="(748, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(748, 67)" end="(748, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(748, 68)" end="(748, 69)">
                <IdentNode start="(748, 68)" end="(748, 69)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(748, 70)" end="(748, 75)">
                <AtomNode start="(748, 70)" end="(748, 71)" leading="" trailing=" " val=":"/>
                <IdentNode start="(748, 72)" end="(748, 75)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(748, 75)" end="(748, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(748, 77)" end="(750, 88)">
            <AtomNode start="(748, 77)" end="(748, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(749, 5)" end="(750, 88)" kind="«term_↔_»">
              <OtherNode start="(749, 5)" end="(749, 27)" kind="«term_=_»">
                <OtherNode start="(749, 5)" end="(749, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(749, 5)" end="(749, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(749, 17)" end="(749, 18)">
                    <IdentNode start="(749, 17)" end="(749, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(749, 19)" end="(749, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(749, 21)" end="(749, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(749, 21)" end="(749, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(749, 26)" end="(749, 27)">
                    <IdentNode start="(749, 26)" end="(749, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(749, 28)" end="(749, 29)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(750, 7)" end="(750, 88)" kind="«term∃_,_»">
                <AtomNode start="(750, 7)" end="(750, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(750, 9)" end="(750, 26)" kind="Lean.explicitBinders">
                  <OtherNode start="(750, 9)" end="(750, 26)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(750, 9)" end="(750, 10)">
                      <LeanBinderidentNode start="(750, 9)" end="(750, 10)">
                        <IdentNode start="(750, 9)" end="(750, 10)" leading="" trailing=" " raw_val="h" val="h"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode start="(750, 11)" end="(750, 26)">
                      <AtomNode start="(750, 11)" end="(750, 12)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(750, 13)" end="(750, 26)" kind="«term_&amp;lt;_»">
                        <IdentNode start="(750, 13)" end="(750, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                        <AtomNode start="(750, 15)" end="(750, 16)" leading="" trailing=" " val="&amp;lt;"/>
                        <IdentNode start="(750, 17)" end="(750, 26)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(750, 26)" end="(750, 27)" leading="" trailing=" " val=","/>
                <OtherNode start="(750, 28)" end="(750, 88)" kind="«term_∧_»">
                  <OtherNode start="(750, 28)" end="(750, 35)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(750, 28)" end="(750, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(750, 30)" end="(750, 35)">
                      <OtherNode start="(750, 30)" end="(750, 35)" kind="«term__[_]»">
                        <IdentNode start="(750, 30)" end="(750, 32)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(750, 32)" end="(750, 33)" leading="" trailing="" val="["/>
                        <IdentNode start="(750, 33)" end="(750, 34)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(750, 34)" end="(750, 35)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(750, 36)" end="(750, 37)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(750, 38)" end="(750, 88)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(750, 38)" end="(750, 39)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(750, 40)" end="(750, 55)">
                      <IdentNode start="(750, 40)" end="(750, 41)" leading="" trailing=" " raw_val="j" val="j"/>
                      <TermExplicitbinderNode start="(750, 42)" end="(750, 55)">
                        <AtomNode start="(750, 42)" end="(750, 43)" leading="" trailing="" val="("/>
                        <NullNode start="(750, 43)" end="(750, 46)">
                          <IdentNode start="(750, 43)" end="(750, 46)" leading="" trailing=" " raw_val="hji" val="hji"/>
                        </NullNode>
                        <NullNode start="(750, 47)" end="(750, 54)">
                          <AtomNode start="(750, 47)" end="(750, 48)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(750, 49)" end="(750, 54)" kind="«term_&amp;lt;_»">
                            <IdentNode start="(750, 49)" end="(750, 50)" leading="" trailing=" " raw_val="j" val="j"/>
                            <AtomNode start="(750, 51)" end="(750, 52)" leading="" trailing=" " val="&amp;lt;"/>
                            <IdentNode start="(750, 53)" end="(750, 54)" leading="" trailing="" raw_val="i" val="i"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(750, 54)" end="(750, 55)" leading="" trailing="" val=")"/>
                      </TermExplicitbinderNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(750, 55)" end="(750, 56)" leading="" trailing=" " val=","/>
                    <OtherNode start="(750, 57)" end="(750, 88)" kind="«term¬_»">
                      <AtomNode start="(750, 57)" end="(750, 58)" leading="" trailing="" val="¬"/>
                      <OtherNode start="(750, 58)" end="(750, 88)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(750, 58)" end="(750, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(750, 60)" end="(750, 88)">
                          <OtherNode start="(750, 60)" end="(750, 88)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(750, 60)" end="(750, 61)" leading="" trailing="" val="("/>
                            <OtherNode start="(750, 61)" end="(750, 87)" kind="«term__[_]'_»">
                              <IdentNode start="(750, 61)" end="(750, 63)" leading="" trailing="" raw_val="xs" val="xs"/>
                              <AtomNode start="(750, 63)" end="(750, 64)" leading="" trailing="" val="["/>
                              <IdentNode start="(750, 64)" end="(750, 65)" leading="" trailing="" raw_val="j" val="j"/>
                              <AtomNode start="(750, 65)" end="(750, 67)" leading="" trailing="" val="]'"/>
                              <OtherNode start="(750, 67)" end="(750, 87)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(750, 67)" end="(750, 68)" leading="" trailing="" val="("/>
                                <OtherNode start="(750, 68)" end="(750, 86)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(750, 68)" end="(750, 80)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(750, 81)" end="(750, 86)">
                                    <IdentNode start="(750, 81)" end="(750, 84)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                    <IdentNode start="(750, 85)" end="(750, 86)" leading="" trailing="" raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(750, 86)" end="(750, 87)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(750, 87)" end="(750, 88)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(750, 89)" end="(778, 63)">
          <AtomNode start="(750, 89)" end="(750, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(750, 92)" end="(778, 63)">
            <AtomNode start="(750, 92)" end="(750, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(751, 3)" end="(778, 63)">
              <TacticTacticseq1IndentedNode start="(751, 3)" end="(778, 63)">
                <NullNode start="(751, 3)" end="(778, 63)">
                  <OtherNode start="(751, 3)" end="(778, 63)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true" state_after="no goals" tactic="induction xs generalizing i with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons, Nat.zero_add]&#10;  split&#10;  · simp only [Option.some.injEq, Bool.not_eq_true, length_cons]&#10;    cases i with&#10;    | zero =&amp;gt; simp_all&#10;    | succ i =&amp;gt;&#10;      simp only [Bool.not_eq_true, zero_ne_add_one, getElem_cons_succ, false_iff, not_exists,&#10;        not_and, Classical.not_forall, Bool.not_eq_false]&#10;      intros&#10;      refine ⟨0, zero_lt_succ i, ‹_›⟩&#10;  · simp only [Option.map_eq_some_iff, ih, Bool.not_eq_true, length_cons]&#10;    constructor&#10;    · rintro ⟨a, ⟨⟨h, h₁, h₂⟩, rfl⟩⟩&#10;      refine ⟨Nat.succ_lt_succ_iff.mpr h, by simpa, fun j hj =&amp;gt; ?_⟩&#10;      cases j with&#10;      | zero =&amp;gt; simp_all&#10;      | succ j =&amp;gt;&#10;        apply h₂&#10;        simp_all [Nat.succ_lt_succ_iff]&#10;    · rintro ⟨h, h₁, h₂⟩&#10;      cases i with&#10;      | zero =&amp;gt; simp_all&#10;      | succ i =&amp;gt;&#10;        refine ⟨i, ⟨Nat.succ_lt_succ_iff.mp h, by simpa, fun j hj =&amp;gt; ?_⟩, rfl⟩&#10;        simpa using h₂ (j + 1) (Nat.succ_lt_succ_iff.mpr hj)">
                    <AtomNode start="(751, 3)" end="(751, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(751, 13)" end="(751, 15)">
                      <OtherNode start="(751, 13)" end="(751, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(751, 13)" end="(751, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(751, 16)" end="(751, 30)">
                      <AtomNode start="(751, 16)" end="(751, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(751, 29)" end="(751, 30)">
                        <IdentNode start="(751, 29)" end="(751, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(751, 31)" end="(778, 63)">
                      <OtherNode start="(751, 31)" end="(778, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(751, 31)" end="(751, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(752, 3)" end="(778, 63)">
                          <OtherNode start="(752, 3)" end="(752, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(752, 3)" end="(752, 8)">
                              <OtherNode start="(752, 3)" end="(752, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(752, 3)" end="(752, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(752, 5)" end="(752, 8)">
                                  <NullNode/>
                                  <IdentNode start="(752, 5)" end="(752, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(752, 9)" end="(752, 16)">
                              <AtomNode start="(752, 9)" end="(752, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(752, 12)" end="(752, 16)">
                                <TacticTacticseq1IndentedNode start="(752, 12)" end="(752, 16)">
                                  <NullNode start="(752, 12)" end="(752, 16)">
                                    <OtherNode start="(752, 12)" end="(752, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;⊢ findIdx? p [] = some i ↔ ∃ h, p [][i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p [][j] = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(752, 12)" end="(752, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(753, 3)" end="(778, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(753, 3)" end="(753, 17)">
                              <OtherNode start="(753, 3)" end="(753, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(753, 3)" end="(753, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(753, 5)" end="(753, 9)">
                                  <NullNode/>
                                  <IdentNode start="(753, 5)" end="(753, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(753, 10)" end="(753, 17)">
                                  <IdentNode start="(753, 10)" end="(753, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(753, 12)" end="(753, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(753, 15)" end="(753, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(753, 18)" end="(778, 63)">
                              <AtomNode start="(753, 18)" end="(753, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(754, 5)" end="(778, 63)">
                                <TacticTacticseq1IndentedNode start="(754, 5)" end="(778, 63)">
                                  <NullNode start="(754, 5)" end="(778, 63)">
                                    <OtherNode start="(754, 5)" end="(754, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;⊢ findIdx? p (x :: xs) = some i ↔ ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" tactic="simp only [findIdx?_cons, Nat.zero_add]">
                                      <AtomNode start="(754, 5)" end="(754, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(754, 10)" end="(754, 14)">
                                        <AtomNode start="(754, 10)" end="(754, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(754, 15)" end="(754, 44)">
                                        <AtomNode start="(754, 15)" end="(754, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(754, 16)" end="(754, 43)">
                                          <OtherNode start="(754, 16)" end="(754, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(754, 16)" end="(754, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(754, 29)" end="(754, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(754, 31)" end="(754, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(754, 31)" end="(754, 43)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(754, 43)" end="(754, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(755, 5)" end="(755, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ some 0 = some i ↔ ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" tactic="split">
                                      <AtomNode start="(755, 5)" end="(755, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(756, 5)" end="(763, 40)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ some 0 = some i ↔ ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" tactic="· simp only [Option.some.injEq, Bool.not_eq_true, length_cons]&#10;  cases i with&#10;  | zero =&amp;gt; simp_all&#10;  | succ i =&amp;gt;&#10;    simp only [Bool.not_eq_true, zero_ne_add_one, getElem_cons_succ, false_iff, not_exists,&#10;      not_and, Classical.not_forall, Bool.not_eq_false]&#10;    intros&#10;    refine ⟨0, zero_lt_succ i, ‹_›⟩">
                                      <OtherNode start="(756, 5)" end="(756, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(756, 5)" end="(756, 6)" kind="patternIgnore">
                                          <OtherNode start="(756, 5)" end="(756, 6)" kind="token.«· »">
                                            <AtomNode start="(756, 5)" end="(756, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(756, 7)" end="(763, 40)">
                                        <TacticTacticseq1IndentedNode start="(756, 7)" end="(763, 40)">
                                          <NullNode start="(756, 7)" end="(763, 40)">
                                            <OtherNode start="(756, 7)" end="(756, 67)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ some 0 = some i ↔ ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ 0 = i ↔ ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false" tactic="simp only [Option.some.injEq, Bool.not_eq_true, length_cons]">
                                              <AtomNode start="(756, 7)" end="(756, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(756, 12)" end="(756, 16)">
                                                <AtomNode start="(756, 12)" end="(756, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(756, 17)" end="(756, 67)">
                                                <AtomNode start="(756, 17)" end="(756, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(756, 18)" end="(756, 66)">
                                                  <OtherNode start="(756, 18)" end="(756, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(756, 18)" end="(756, 35)" leading="" trailing="" raw_val="Option.some.injEq" val="Option.some.injEq" full_name="Option.some.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(756, 35)" end="(756, 36)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(756, 37)" end="(756, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(756, 37)" end="(756, 53)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(756, 53)" end="(756, 54)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(756, 55)" end="(756, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(756, 55)" end="(756, 66)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(756, 66)" end="(756, 67)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(757, 7)" end="(763, 40)" kind="Lean.Parser.Tactic.cases" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : p x = true&#10;⊢ 0 = i ↔ ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt; simp_all&#10;| succ i =&amp;gt;&#10;  simp only [Bool.not_eq_true, zero_ne_add_one, getElem_cons_succ, false_iff, not_exists,&#10;    not_and, Classical.not_forall, Bool.not_eq_false]&#10;  intros&#10;  refine ⟨0, zero_lt_succ i, ‹_›⟩">
                                              <AtomNode start="(757, 7)" end="(757, 12)" leading="" trailing=" " val="cases"/>
                                              <NullNode start="(757, 13)" end="(757, 14)">
                                                <OtherNode start="(757, 13)" end="(757, 14)" kind="Lean.Parser.Tactic.elimTarget">
                                                  <NullNode/>
                                                  <IdentNode start="(757, 13)" end="(757, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode/>
                                              <NullNode start="(757, 15)" end="(763, 40)">
                                                <OtherNode start="(757, 15)" end="(763, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                                                  <AtomNode start="(757, 15)" end="(757, 19)" leading="" trailing="&#10;      " val="with"/>
                                                  <NullNode/>
                                                  <NullNode start="(758, 7)" end="(763, 40)">
                                                    <OtherNode start="(758, 7)" end="(758, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(758, 7)" end="(758, 13)">
                                                        <OtherNode start="(758, 7)" end="(758, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(758, 7)" end="(758, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(758, 9)" end="(758, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(758, 9)" end="(758, 13)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                          </GroupNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(758, 14)" end="(758, 25)">
                                                        <AtomNode start="(758, 14)" end="(758, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(758, 17)" end="(758, 25)">
                                                          <TacticTacticseq1IndentedNode start="(758, 17)" end="(758, 25)">
                                                            <NullNode start="(758, 17)" end="(758, 25)">
                                                            <OtherNode start="(758, 17)" end="(758, 25)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isTrue.zero&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : p x = true&#10;⊢ 0 = 0 ↔ ∃ h, p (x :: xs)[0] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; 0), p (x :: xs)[j] = false" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(758, 17)" end="(758, 25)" leading="" trailing="&#10;      " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <OtherNode start="(759, 7)" end="(763, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                                                      <NullNode start="(759, 7)" end="(759, 15)">
                                                        <OtherNode start="(759, 7)" end="(759, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                          <AtomNode start="(759, 7)" end="(759, 8)" leading="" trailing=" " val="|"/>
                                                          <GroupNode start="(759, 9)" end="(759, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(759, 9)" end="(759, 13)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                          </GroupNode>
                                                          <NullNode start="(759, 14)" end="(759, 15)">
                                                            <IdentNode start="(759, 14)" end="(759, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode start="(759, 16)" end="(763, 40)">
                                                        <AtomNode start="(759, 16)" end="(759, 18)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                                                        <TacticTacticseqNode start="(760, 9)" end="(763, 40)">
                                                          <TacticTacticseq1IndentedNode start="(760, 9)" end="(763, 40)">
                                                            <NullNode start="(760, 9)" end="(763, 40)">
                                                            <OtherNode start="(760, 9)" end="(761, 60)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : p x = true&#10;i : Nat&#10;⊢ 0 = i + 1 ↔ ∃ h, p (x :: xs)[i + 1] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i + 1), p (x :: xs)[j] = false" state_after="case cons.isTrue.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : p x = true&#10;i : Nat&#10;⊢ ∀ (x_1 : i + 1 &amp;lt; xs.length + 1), p xs[i] = true → ∃ x_2 h, p (x :: xs)[x_2] = true" tactic="simp only [Bool.not_eq_true, zero_ne_add_one, getElem_cons_succ, false_iff, not_exists,&#10;  not_and, Classical.not_forall, Bool.not_eq_false]">
                                                            <AtomNode start="(760, 9)" end="(760, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(760, 14)" end="(760, 18)">
                                                            <AtomNode start="(760, 14)" end="(760, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(760, 19)" end="(761, 60)">
                                                            <AtomNode start="(760, 19)" end="(760, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(760, 20)" end="(761, 59)">
                                                            <OtherNode start="(760, 20)" end="(760, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(760, 20)" end="(760, 36)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(760, 36)" end="(760, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(760, 38)" end="(760, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(760, 38)" end="(760, 53)" leading="" trailing="" raw_val="zero_ne_add_one" val="zero_ne_add_one" full_name="Nat.zero_ne_add_one" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(760, 53)" end="(760, 54)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(760, 55)" end="(760, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(760, 55)" end="(760, 72)" leading="" trailing="" raw_val="getElem_cons_succ" val="getElem_cons_succ" full_name="List.getElem_cons_succ" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(760, 72)" end="(760, 73)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(760, 74)" end="(760, 83)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(760, 74)" end="(760, 83)" leading="" trailing="" raw_val="false_iff" val="false_iff" full_name="false_iff" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(760, 83)" end="(760, 84)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(760, 85)" end="(760, 95)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(760, 85)" end="(760, 95)" leading="" trailing="" raw_val="not_exists" val="not_exists" full_name="not_exists" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(760, 95)" end="(760, 96)" leading="" trailing="&#10;          " val=","/>
                                                            <OtherNode start="(761, 11)" end="(761, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(761, 11)" end="(761, 18)" leading="" trailing="" raw_val="not_and" val="not_and" full_name="not_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(761, 18)" end="(761, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(761, 20)" end="(761, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(761, 20)" end="(761, 40)" leading="" trailing="" raw_val="Classical.not_forall" val="Classical.not_forall" full_name="Classical.not_forall" mod_name="Init.Classical" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Classical.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(761, 40)" end="(761, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(761, 42)" end="(761, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(761, 42)" end="(761, 59)" leading="" trailing="" raw_val="Bool.not_eq_false" val="Bool.not_eq_false" full_name="Bool.not_eq_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(761, 59)" end="(761, 60)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(762, 9)" end="(762, 15)" kind="Lean.Parser.Tactic.intros" state_before="case cons.isTrue.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : p x = true&#10;i : Nat&#10;⊢ ∀ (x_1 : i + 1 &amp;lt; xs.length + 1), p xs[i] = true → ∃ x_2 h, p (x :: xs)[x_2] = true" state_after="case cons.isTrue.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : p x = true&#10;i : Nat&#10;x✝ : i + 1 &amp;lt; xs.length + 1&#10;a✝ : p xs[i] = true&#10;⊢ ∃ x_1 h, p (x :: xs)[x_1] = true" tactic="intros">
                                                            <AtomNode start="(762, 9)" end="(762, 15)" leading="" trailing="&#10;        " val="intros"/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(763, 9)" end="(763, 40)" kind="Lean.Parser.Tactic.refine" state_before="case cons.isTrue.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : p x = true&#10;i : Nat&#10;x✝ : i + 1 &amp;lt; xs.length + 1&#10;a✝ : p xs[i] = true&#10;⊢ ∃ x_1 h, p (x :: xs)[x_1] = true" state_after="no goals" tactic="refine ⟨0, zero_lt_succ i, ‹_›⟩">
                                                            <AtomNode start="(763, 9)" end="(763, 15)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(763, 16)" end="(763, 40)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(763, 16)" end="(763, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(763, 17)" end="(763, 39)">
                                                            <OtherNode start="(763, 17)" end="(763, 18)" kind="num">
                                                            <AtomNode start="(763, 17)" end="(763, 18)" leading="" trailing="" val="0"/>
                                                            </OtherNode>
                                                            <AtomNode start="(763, 18)" end="(763, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(763, 20)" end="(763, 34)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(763, 20)" end="(763, 32)" leading="" trailing=" " raw_val="zero_lt_succ" val="zero_lt_succ" full_name="Nat.zero_lt_succ" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            <NullNode start="(763, 33)" end="(763, 34)">
                                                            <IdentNode start="(763, 33)" end="(763, 34)" leading="" trailing="" raw_val="i" val="i"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(763, 34)" end="(763, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(763, 36)" end="(763, 39)" kind="«term‹_›»">
                                                            <AtomNode start="(763, 36)" end="(763, 37)" leading="" trailing="" val="‹"/>
                                                            <TermHoleNode start="(763, 37)" end="(763, 38)">
                                                            <AtomNode start="(763, 37)" end="(763, 38)" leading="" trailing="" val="_"/>
                                                            </TermHoleNode>
                                                            <AtomNode start="(763, 38)" end="(763, 39)" leading="" trailing="" val="›"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(763, 39)" end="(763, 40)" leading="" trailing="&#10;    " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(764, 5)" end="(778, 63)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" state_after="no goals" tactic="· simp only [Option.map_eq_some_iff, ih, Bool.not_eq_true, length_cons]&#10;  constructor&#10;  · rintro ⟨a, ⟨⟨h, h₁, h₂⟩, rfl⟩⟩&#10;    refine ⟨Nat.succ_lt_succ_iff.mpr h, by simpa, fun j hj =&amp;gt; ?_⟩&#10;    cases j with&#10;    | zero =&amp;gt; simp_all&#10;    | succ j =&amp;gt;&#10;      apply h₂&#10;      simp_all [Nat.succ_lt_succ_iff]&#10;  · rintro ⟨h, h₁, h₂⟩&#10;    cases i with&#10;    | zero =&amp;gt; simp_all&#10;    | succ i =&amp;gt;&#10;      refine ⟨i, ⟨Nat.succ_lt_succ_iff.mp h, by simpa, fun j hj =&amp;gt; ?_⟩, rfl⟩&#10;      simpa using h₂ (j + 1) (Nat.succ_lt_succ_iff.mpr hj)">
                                      <OtherNode start="(764, 5)" end="(764, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(764, 5)" end="(764, 6)" kind="patternIgnore">
                                          <OtherNode start="(764, 5)" end="(764, 6)" kind="token.«· »">
                                            <AtomNode start="(764, 5)" end="(764, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(764, 7)" end="(778, 63)">
                                        <TacticTacticseq1IndentedNode start="(764, 7)" end="(778, 63)">
                                          <NullNode start="(764, 7)" end="(778, 63)">
                                            <OtherNode start="(764, 7)" end="(764, 76)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = some i ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p (x :: xs)[j] = true" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i) ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false" tactic="simp only [Option.map_eq_some_iff, ih, Bool.not_eq_true, length_cons]">
                                              <AtomNode start="(764, 7)" end="(764, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(764, 12)" end="(764, 16)">
                                                <AtomNode start="(764, 12)" end="(764, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(764, 17)" end="(764, 76)">
                                                <AtomNode start="(764, 17)" end="(764, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(764, 18)" end="(764, 75)">
                                                  <OtherNode start="(764, 18)" end="(764, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(764, 18)" end="(764, 40)" leading="" trailing="" raw_val="Option.map_eq_some_iff" val="Option.map_eq_some_iff" full_name="Option.map_eq_some_iff" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(764, 40)" end="(764, 41)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(764, 42)" end="(764, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(764, 42)" end="(764, 44)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(764, 44)" end="(764, 45)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(764, 46)" end="(764, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(764, 46)" end="(764, 62)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(764, 62)" end="(764, 63)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(764, 64)" end="(764, 75)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(764, 64)" end="(764, 75)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(764, 75)" end="(764, 76)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(765, 7)" end="(765, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i) ↔&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false" state_after="case cons.isFalse.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i) →&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false&#10;&#10;case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false) →&#10;    ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" tactic="constructor">
                                              <AtomNode start="(765, 7)" end="(765, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(766, 7)" end="(772, 42)" kind="Lean.cdot" state_before="case cons.isFalse.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i) →&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false&#10;&#10;case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false) →&#10;    ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" state_after="case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false) →&#10;    ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" tactic="· rintro ⟨a, ⟨⟨h, h₁, h₂⟩, rfl⟩⟩&#10;  refine ⟨Nat.succ_lt_succ_iff.mpr h, by simpa, fun j hj =&amp;gt; ?_⟩&#10;  cases j with&#10;  | zero =&amp;gt; simp_all&#10;  | succ j =&amp;gt;&#10;    apply h₂&#10;    simp_all [Nat.succ_lt_succ_iff]">
                                              <OtherNode start="(766, 7)" end="(766, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(766, 7)" end="(766, 8)" kind="patternIgnore">
                                                  <OtherNode start="(766, 7)" end="(766, 8)" kind="token.«· »">
                                                    <AtomNode start="(766, 7)" end="(766, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(766, 9)" end="(772, 42)">
                                                <TacticTacticseq1IndentedNode start="(766, 9)" end="(772, 42)">
                                                  <NullNode start="(766, 9)" end="(772, 42)">
                                                    <OtherNode start="(766, 9)" end="(766, 39)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isFalse.mp&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i) →&#10;    ∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false" state_after="case cons.isFalse.mp.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ ∃ h, p (x :: xs)[a + 1] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a + 1), p (x :: xs)[j] = false" tactic="rintro ⟨a, ⟨⟨h, h₁, h₂⟩, rfl⟩⟩">
                                                      <AtomNode start="(766, 9)" end="(766, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(766, 16)" end="(766, 39)">
                                                        <OtherNode start="(766, 16)" end="(766, 39)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(766, 16)" end="(766, 39)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(766, 16)" end="(766, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(766, 17)" end="(766, 38)">
                                                            <OtherNode start="(766, 17)" end="(766, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 17)" end="(766, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 17)" end="(766, 18)">
                                                            <OtherNode start="(766, 17)" end="(766, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(766, 17)" end="(766, 18)" leading="" trailing="" raw_val="a" val="a"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(766, 18)" end="(766, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(766, 20)" end="(766, 38)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 20)" end="(766, 38)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 20)" end="(766, 38)">
                                                            <OtherNode start="(766, 20)" end="(766, 38)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(766, 20)" end="(766, 21)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(766, 21)" end="(766, 37)">
                                                            <OtherNode start="(766, 21)" end="(766, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 21)" end="(766, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 21)" end="(766, 32)">
                                                            <OtherNode start="(766, 21)" end="(766, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(766, 21)" end="(766, 22)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(766, 22)" end="(766, 31)">
                                                            <OtherNode start="(766, 22)" end="(766, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 22)" end="(766, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 22)" end="(766, 23)">
                                                            <OtherNode start="(766, 22)" end="(766, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(766, 22)" end="(766, 23)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(766, 23)" end="(766, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(766, 25)" end="(766, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 25)" end="(766, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 25)" end="(766, 27)">
                                                            <OtherNode start="(766, 25)" end="(766, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(766, 25)" end="(766, 27)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(766, 27)" end="(766, 28)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(766, 29)" end="(766, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 29)" end="(766, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 29)" end="(766, 31)">
                                                            <OtherNode start="(766, 29)" end="(766, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(766, 29)" end="(766, 31)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(766, 31)" end="(766, 32)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(766, 32)" end="(766, 33)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(766, 34)" end="(766, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(766, 34)" end="(766, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(766, 34)" end="(766, 37)">
                                                            <OtherNode start="(766, 34)" end="(766, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(766, 34)" end="(766, 37)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(766, 37)" end="(766, 38)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(766, 38)" end="(766, 39)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(767, 9)" end="(767, 70)" kind="Lean.Parser.Tactic.refine" state_before="case cons.isFalse.mp.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ ∃ h, p (x :: xs)[a + 1] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a + 1), p (x :: xs)[j] = false" state_after="case cons.isFalse.mp.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Nat&#10;hj : j &amp;lt; a + 1&#10;⊢ p (x :: xs)[j] = false" tactic="refine ⟨Nat.succ_lt_succ_iff.mpr h, by simpa, fun j hj =&amp;gt; ?_⟩">
                                                      <AtomNode start="(767, 9)" end="(767, 15)" leading="" trailing=" " val="refine"/>
                                                      <OtherNode start="(767, 16)" end="(767, 70)" kind="Lean.Parser.Term.anonymousCtor">
                                                        <AtomNode start="(767, 16)" end="(767, 17)" leading="" trailing="" val="⟨"/>
                                                        <NullNode start="(767, 17)" end="(767, 69)">
                                                          <OtherNode start="(767, 17)" end="(767, 43)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(767, 17)" end="(767, 41)" leading="" trailing=" " raw_val="Nat.succ_lt_succ_iff.mpr" val="Nat.succ_lt_succ_iff.mpr"/>
                                                            <NullNode start="(767, 42)" end="(767, 43)">
                                                            <IdentNode start="(767, 42)" end="(767, 43)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <AtomNode start="(767, 43)" end="(767, 44)" leading="" trailing=" " val=","/>
                                                          <TermBytacticNode start="(767, 45)" end="(767, 53)">
                                                            <AtomNode start="(767, 45)" end="(767, 47)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(767, 48)" end="(767, 53)">
                                                            <TacticTacticseq1IndentedNode start="(767, 48)" end="(767, 53)">
                                                            <NullNode start="(767, 48)" end="(767, 53)">
                                                            <OtherNode start="(767, 48)" end="(767, 53)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ p (x :: xs)[a + 1] = true" state_after="no goals" tactic="simpa">
                                                            <AtomNode start="(767, 48)" end="(767, 53)" leading="" trailing="" val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(767, 53)" end="(767, 54)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(767, 55)" end="(767, 69)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(767, 55)" end="(767, 58)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(767, 59)" end="(767, 69)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(767, 59)" end="(767, 63)">
                                                            <IdentNode start="(767, 59)" end="(767, 60)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(767, 61)" end="(767, 63)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(767, 64)" end="(767, 66)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(767, 67)" end="(767, 69)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(767, 67)" end="(767, 68)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(767, 68)" end="(767, 69)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(767, 69)" end="(767, 70)" leading="" trailing="&#10;        " val="⟩"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(768, 9)" end="(772, 42)" kind="Lean.Parser.Tactic.cases" state_before="case cons.isFalse.mp.intro.intro.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Nat&#10;hj : j &amp;lt; a + 1&#10;⊢ p (x :: xs)[j] = false" state_after="no goals" tactic="cases j with&#10;| zero =&amp;gt; simp_all&#10;| succ j =&amp;gt;&#10;  apply h₂&#10;  simp_all [Nat.succ_lt_succ_iff]">
                                                      <AtomNode start="(768, 9)" end="(768, 14)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(768, 15)" end="(768, 16)">
                                                        <OtherNode start="(768, 15)" end="(768, 16)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(768, 15)" end="(768, 16)" leading="" trailing=" " raw_val="j" val="j"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(768, 17)" end="(772, 42)">
                                                        <OtherNode start="(768, 17)" end="(772, 42)" kind="Lean.Parser.Tactic.inductionAlts">
                                                          <AtomNode start="(768, 17)" end="(768, 21)" leading="" trailing="&#10;        " val="with"/>
                                                          <NullNode/>
                                                          <NullNode start="(769, 9)" end="(772, 42)">
                                                            <OtherNode start="(769, 9)" end="(769, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(769, 9)" end="(769, 15)">
                                                            <OtherNode start="(769, 9)" end="(769, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(769, 9)" end="(769, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(769, 11)" end="(769, 15)">
                                                            <NullNode/>
                                                            <IdentNode start="(769, 11)" end="(769, 15)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(769, 16)" end="(769, 27)">
                                                            <AtomNode start="(769, 16)" end="(769, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(769, 19)" end="(769, 27)">
                                                            <TacticTacticseq1IndentedNode start="(769, 19)" end="(769, 27)">
                                                            <NullNode start="(769, 19)" end="(769, 27)">
                                                            <OtherNode start="(769, 19)" end="(769, 27)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse.mp.intro.intro.intro.intro.zero&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;hj : 0 &amp;lt; a + 1&#10;⊢ p (x :: xs)[0] = false" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(769, 19)" end="(769, 27)" leading="" trailing="&#10;        " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(770, 9)" end="(772, 42)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(770, 9)" end="(770, 17)">
                                                            <OtherNode start="(770, 9)" end="(770, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(770, 9)" end="(770, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(770, 11)" end="(770, 15)">
                                                            <NullNode/>
                                                            <IdentNode start="(770, 11)" end="(770, 15)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(770, 16)" end="(770, 17)">
                                                            <IdentNode start="(770, 16)" end="(770, 17)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(770, 18)" end="(772, 42)">
                                                            <AtomNode start="(770, 18)" end="(770, 20)" leading="" trailing="&#10;          " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(771, 11)" end="(772, 42)">
                                                            <TacticTacticseq1IndentedNode start="(771, 11)" end="(772, 42)">
                                                            <NullNode start="(771, 11)" end="(772, 42)">
                                                            <OtherNode start="(771, 11)" end="(771, 19)" kind="Lean.Parser.Tactic.apply" state_before="case cons.isFalse.mp.intro.intro.intro.intro.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Nat&#10;hj : j + 1 &amp;lt; a + 1&#10;⊢ p (x :: xs)[j + 1] = false" state_after="case cons.isFalse.mp.intro.intro.intro.intro.succ.hji&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Nat&#10;hj : j + 1 &amp;lt; a + 1&#10;⊢ j &amp;lt; a" tactic="apply h₂">
                                                            <AtomNode start="(771, 11)" end="(771, 16)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(771, 17)" end="(771, 19)" leading="" trailing="&#10;          " raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(772, 11)" end="(772, 42)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse.mp.intro.intro.intro.intro.succ.hji&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;h₁ : p xs[a] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Nat&#10;hj : j + 1 &amp;lt; a + 1&#10;⊢ j &amp;lt; a" state_after="no goals" tactic="simp_all [Nat.succ_lt_succ_iff]">
                                                            <AtomNode start="(772, 11)" end="(772, 19)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(772, 20)" end="(772, 42)">
                                                            <AtomNode start="(772, 20)" end="(772, 21)" leading="" trailing="" val="["/>
                                                            <NullNode start="(772, 21)" end="(772, 41)">
                                                            <OtherNode start="(772, 21)" end="(772, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(772, 21)" end="(772, 41)" leading="" trailing="" raw_val="Nat.succ_lt_succ_iff" val="Nat.succ_lt_succ_iff" full_name="Nat.succ_lt_succ_iff" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(772, 41)" end="(772, 42)" leading="" trailing="&#10;      " val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(773, 7)" end="(778, 63)" kind="Lean.cdot" state_before="case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false) →&#10;    ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" state_after="no goals" tactic="· rintro ⟨h, h₁, h₂⟩&#10;  cases i with&#10;  | zero =&amp;gt; simp_all&#10;  | succ i =&amp;gt;&#10;    refine ⟨i, ⟨Nat.succ_lt_succ_iff.mp h, by simpa, fun j hj =&amp;gt; ?_⟩, rfl⟩&#10;    simpa using h₂ (j + 1) (Nat.succ_lt_succ_iff.mpr hj)">
                                              <OtherNode start="(773, 7)" end="(773, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(773, 7)" end="(773, 8)" kind="patternIgnore">
                                                  <OtherNode start="(773, 7)" end="(773, 8)" kind="token.«· »">
                                                    <AtomNode start="(773, 7)" end="(773, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(773, 9)" end="(778, 63)">
                                                <TacticTacticseq1IndentedNode start="(773, 9)" end="(778, 63)">
                                                  <NullNode start="(773, 9)" end="(778, 63)">
                                                    <OtherNode start="(773, 9)" end="(773, 27)" kind="Lean.Parser.Tactic.rintro" state_before="case cons.isFalse.mpr&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;⊢ (∃ h, p (x :: xs)[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false) →&#10;    ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" state_after="case cons.isFalse.mpr.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;h : i &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[i] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false&#10;⊢ ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" tactic="rintro ⟨h, h₁, h₂⟩">
                                                      <AtomNode start="(773, 9)" end="(773, 15)" leading="" trailing=" " val="rintro"/>
                                                      <NullNode start="(773, 16)" end="(773, 27)">
                                                        <OtherNode start="(773, 16)" end="(773, 27)" kind="Lean.Parser.Tactic.rintroPat.one">
                                                          <OtherNode start="(773, 16)" end="(773, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(773, 16)" end="(773, 17)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(773, 17)" end="(773, 26)">
                                                            <OtherNode start="(773, 17)" end="(773, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(773, 17)" end="(773, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(773, 17)" end="(773, 18)">
                                                            <OtherNode start="(773, 17)" end="(773, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(773, 17)" end="(773, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(773, 18)" end="(773, 19)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(773, 20)" end="(773, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(773, 20)" end="(773, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(773, 20)" end="(773, 22)">
                                                            <OtherNode start="(773, 20)" end="(773, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(773, 20)" end="(773, 22)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(773, 22)" end="(773, 23)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(773, 24)" end="(773, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(773, 24)" end="(773, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(773, 24)" end="(773, 26)">
                                                            <OtherNode start="(773, 24)" end="(773, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(773, 24)" end="(773, 26)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(773, 26)" end="(773, 27)" leading="" trailing="&#10;        " val="⟩"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <OtherNode start="(774, 9)" end="(778, 63)" kind="Lean.Parser.Tactic.cases" state_before="case cons.isFalse.mpr.intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;i : Nat&#10;h✝ : ¬p x = true&#10;h : i &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[i] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; i), p (x :: xs)[j] = false&#10;⊢ ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt; simp_all&#10;| succ i =&amp;gt;&#10;  refine ⟨i, ⟨Nat.succ_lt_succ_iff.mp h, by simpa, fun j hj =&amp;gt; ?_⟩, rfl⟩&#10;  simpa using h₂ (j + 1) (Nat.succ_lt_succ_iff.mpr hj)">
                                                      <AtomNode start="(774, 9)" end="(774, 14)" leading="" trailing=" " val="cases"/>
                                                      <NullNode start="(774, 15)" end="(774, 16)">
                                                        <OtherNode start="(774, 15)" end="(774, 16)" kind="Lean.Parser.Tactic.elimTarget">
                                                          <NullNode/>
                                                          <IdentNode start="(774, 15)" end="(774, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <NullNode/>
                                                      <NullNode start="(774, 17)" end="(778, 63)">
                                                        <OtherNode start="(774, 17)" end="(778, 63)" kind="Lean.Parser.Tactic.inductionAlts">
                                                          <AtomNode start="(774, 17)" end="(774, 21)" leading="" trailing="&#10;        " val="with"/>
                                                          <NullNode/>
                                                          <NullNode start="(775, 9)" end="(778, 63)">
                                                            <OtherNode start="(775, 9)" end="(775, 27)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(775, 9)" end="(775, 15)">
                                                            <OtherNode start="(775, 9)" end="(775, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(775, 9)" end="(775, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(775, 11)" end="(775, 15)">
                                                            <NullNode/>
                                                            <IdentNode start="(775, 11)" end="(775, 15)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(775, 16)" end="(775, 27)">
                                                            <AtomNode start="(775, 16)" end="(775, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(775, 19)" end="(775, 27)">
                                                            <TacticTacticseq1IndentedNode start="(775, 19)" end="(775, 27)">
                                                            <NullNode start="(775, 19)" end="(775, 27)">
                                                            <OtherNode start="(775, 19)" end="(775, 27)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse.mpr.intro.intro.zero&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;h : 0 &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[0] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; 0), p (x :: xs)[j] = false&#10;⊢ ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = 0" state_after="no goals" tactic="simp_all">
                                                            <AtomNode start="(775, 19)" end="(775, 27)" leading="" trailing="&#10;        " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <OtherNode start="(776, 9)" end="(778, 63)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(776, 9)" end="(776, 17)">
                                                            <OtherNode start="(776, 9)" end="(776, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(776, 9)" end="(776, 10)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(776, 11)" end="(776, 15)">
                                                            <NullNode/>
                                                            <IdentNode start="(776, 11)" end="(776, 15)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                            </GroupNode>
                                                            <NullNode start="(776, 16)" end="(776, 17)">
                                                            <IdentNode start="(776, 16)" end="(776, 17)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(776, 18)" end="(778, 63)">
                                                            <AtomNode start="(776, 18)" end="(776, 20)" leading="" trailing="&#10;          " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(777, 11)" end="(778, 63)">
                                                            <TacticTacticseq1IndentedNode start="(777, 11)" end="(778, 63)">
                                                            <NullNode start="(777, 11)" end="(778, 63)">
                                                            <OtherNode start="(777, 11)" end="(777, 81)" kind="Lean.Parser.Tactic.refine" state_before="case cons.isFalse.mpr.intro.intro.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[i + 1] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; i + 1), p (x :: xs)[j] = false&#10;⊢ ∃ a, (∃ h, p xs[a] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false) ∧ a + 1 = i + 1" state_after="case cons.isFalse.mpr.intro.intro.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[i + 1] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; i + 1), p (x :: xs)[j] = false&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ p xs[j] = false" tactic="refine ⟨i, ⟨Nat.succ_lt_succ_iff.mp h, by simpa, fun j hj =&amp;gt; ?_⟩, rfl⟩">
                                                            <AtomNode start="(777, 11)" end="(777, 17)" leading="" trailing=" " val="refine"/>
                                                            <OtherNode start="(777, 18)" end="(777, 81)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(777, 18)" end="(777, 19)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(777, 19)" end="(777, 80)">
                                                            <IdentNode start="(777, 19)" end="(777, 20)" leading="" trailing="" raw_val="i" val="i"/>
                                                            <AtomNode start="(777, 20)" end="(777, 21)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(777, 22)" end="(777, 75)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(777, 22)" end="(777, 23)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(777, 23)" end="(777, 74)">
                                                            <OtherNode start="(777, 23)" end="(777, 48)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(777, 23)" end="(777, 46)" leading="" trailing=" " raw_val="Nat.succ_lt_succ_iff.mp" val="Nat.succ_lt_succ_iff.mp"/>
                                                            <NullNode start="(777, 47)" end="(777, 48)">
                                                            <IdentNode start="(777, 47)" end="(777, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(777, 48)" end="(777, 49)" leading="" trailing=" " val=","/>
                                                            <TermBytacticNode start="(777, 50)" end="(777, 58)">
                                                            <AtomNode start="(777, 50)" end="(777, 52)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(777, 53)" end="(777, 58)">
                                                            <TacticTacticseq1IndentedNode start="(777, 53)" end="(777, 58)">
                                                            <NullNode start="(777, 53)" end="(777, 58)">
                                                            <OtherNode start="(777, 53)" end="(777, 58)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[i + 1] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; i + 1), p (x :: xs)[j] = false&#10;⊢ p xs[i] = true" state_after="no goals" tactic="simpa">
                                                            <AtomNode start="(777, 53)" end="(777, 58)" leading="" trailing="" val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(777, 58)" end="(777, 59)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(777, 60)" end="(777, 74)" kind="Lean.Parser.Term.fun">
                                                            <AtomNode start="(777, 60)" end="(777, 63)" leading="" trailing=" " val="fun"/>
                                                            <OtherNode start="(777, 64)" end="(777, 74)" kind="Lean.Parser.Term.basicFun">
                                                            <NullNode start="(777, 64)" end="(777, 68)">
                                                            <IdentNode start="(777, 64)" end="(777, 65)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <IdentNode start="(777, 66)" end="(777, 68)" leading="" trailing=" " raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            <AtomNode start="(777, 69)" end="(777, 71)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <OtherNode start="(777, 72)" end="(777, 74)" kind="Lean.Parser.Term.syntheticHole">
                                                            <AtomNode start="(777, 72)" end="(777, 73)" leading="" trailing="" val="?"/>
                                                            <AtomNode start="(777, 73)" end="(777, 74)" leading="" trailing="" val="_"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(777, 74)" end="(777, 75)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(777, 75)" end="(777, 76)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(777, 77)" end="(777, 80)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            <AtomNode start="(777, 80)" end="(777, 81)" leading="" trailing="&#10;          " val="⟩"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(778, 11)" end="(778, 63)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.isFalse.mpr.intro.intro.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : ∀ {i : Nat}, findIdx? p xs = some i ↔ ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), ¬p xs[j] = true&#10;h✝ : ¬p x = true&#10;i : Nat&#10;h : i + 1 &amp;lt; xs.length + 1&#10;h₁ : p (x :: xs)[i + 1] = true&#10;h₂ : ∀ (j : Nat) (hji : j &amp;lt; i + 1), p (x :: xs)[j] = false&#10;j : Nat&#10;hj : j &amp;lt; i&#10;⊢ p xs[j] = false" state_after="no goals" tactic="simpa using h₂ (j + 1) (Nat.succ_lt_succ_iff.mpr hj)">
                                                            <AtomNode start="(778, 11)" end="(778, 16)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(778, 17)" end="(778, 63)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(778, 17)" end="(778, 63)">
                                                            <AtomNode start="(778, 17)" end="(778, 22)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(778, 23)" end="(778, 63)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(778, 23)" end="(778, 25)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            <NullNode start="(778, 26)" end="(778, 63)">
                                                            <OtherNode start="(778, 26)" end="(778, 33)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(778, 26)" end="(778, 27)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(778, 27)" end="(778, 32)" kind="«term_+_»">
                                                            <IdentNode start="(778, 27)" end="(778, 28)" leading="" trailing=" " raw_val="j" val="j"/>
                                                            <AtomNode start="(778, 29)" end="(778, 30)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(778, 31)" end="(778, 32)" kind="num">
                                                            <AtomNode start="(778, 31)" end="(778, 32)" leading="" trailing="" val="1"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(778, 32)" end="(778, 33)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(778, 34)" end="(778, 63)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(778, 34)" end="(778, 35)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(778, 35)" end="(778, 62)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(778, 35)" end="(778, 59)" leading="" trailing=" " raw_val="Nat.succ_lt_succ_iff.mpr" val="Nat.succ_lt_succ_iff.mpr"/>
                                                            <NullNode start="(778, 60)" end="(778, 62)">
                                                            <IdentNode start="(778, 60)" end="(778, 62)" leading="" trailing="" raw_val="hj" val="hj"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(778, 62)" end="(778, 63)" leading="" trailing="&#10;&#10;" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(780, 1)" end="(786, 51)" name="of_findIdx?_eq_some" full_name="List.of_findIdx?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(780, 1)" end="(786, 51)" name="of_findIdx?_eq_some" full_name="List.of_findIdx?_eq_some" _is_private_decl="False">
        <AtomNode start="(780, 1)" end="(780, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(780, 9)" end="(780, 28)">
          <IdentNode start="(780, 9)" end="(780, 28)" leading="" trailing=" " raw_val="of_findIdx?_eq_some" val="of_findIdx?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(780, 29)" end="(781, 54)">
          <NullNode start="(780, 29)" end="(780, 86)">
            <OtherNode start="(780, 29)" end="(780, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(780, 29)" end="(780, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(780, 30)" end="(780, 32)">
                <IdentNode start="(780, 30)" end="(780, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(780, 33)" end="(780, 41)">
                <AtomNode start="(780, 33)" end="(780, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(780, 35)" end="(780, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(780, 35)" end="(780, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(780, 40)" end="(780, 41)">
                    <IdentNode start="(780, 40)" end="(780, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(780, 41)" end="(780, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(780, 43)" end="(780, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(780, 43)" end="(780, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(780, 44)" end="(780, 45)">
                <IdentNode start="(780, 44)" end="(780, 45)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(780, 46)" end="(780, 56)">
                <AtomNode start="(780, 46)" end="(780, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(780, 48)" end="(780, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(780, 48)" end="(780, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(780, 50)" end="(780, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(780, 52)" end="(780, 56)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(780, 56)" end="(780, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(780, 58)" end="(780, 86)">
              <AtomNode start="(780, 58)" end="(780, 59)" leading="" trailing="" val="("/>
              <NullNode start="(780, 59)" end="(780, 60)">
                <IdentNode start="(780, 59)" end="(780, 60)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(780, 61)" end="(780, 85)">
                <AtomNode start="(780, 61)" end="(780, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(780, 63)" end="(780, 85)" kind="«term_=_»">
                  <OtherNode start="(780, 63)" end="(780, 76)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(780, 63)" end="(780, 74)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(780, 75)" end="(780, 76)">
                      <IdentNode start="(780, 75)" end="(780, 76)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(780, 77)" end="(780, 78)" leading="" trailing=" " val="="/>
                  <OtherNode start="(780, 79)" end="(780, 85)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(780, 79)" end="(780, 83)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(780, 84)" end="(780, 85)">
                      <IdentNode start="(780, 84)" end="(780, 85)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(780, 85)" end="(780, 86)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(780, 87)" end="(781, 54)">
            <AtomNode start="(780, 87)" end="(780, 88)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(781, 5)" end="(781, 54)" kind="Lean.Parser.Term.match">
              <AtomNode start="(781, 5)" end="(781, 10)" leading="" trailing=" " val="match"/>
              <NullNode/>
              <NullNode/>
              <NullNode start="(781, 11)" end="(781, 17)">
                <OtherNode start="(781, 11)" end="(781, 17)" kind="Lean.Parser.Term.matchDiscr">
                  <NullNode/>
                  <OtherNode start="(781, 11)" end="(781, 17)" kind="«term__[_]_?»">
                    <IdentNode start="(781, 11)" end="(781, 13)" leading="" trailing="" raw_val="xs" val="xs"/>
                    <GroupNode/>
                    <AtomNode start="(781, 13)" end="(781, 14)" leading="" trailing="" val="["/>
                    <IdentNode start="(781, 14)" end="(781, 15)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(781, 15)" end="(781, 16)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(781, 16)" end="(781, 17)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(781, 18)" end="(781, 22)" leading="" trailing=" " val="with"/>
              <OtherNode start="(781, 23)" end="(781, 54)" kind="Lean.Parser.Term.matchAlts">
                <NullNode start="(781, 23)" end="(781, 54)">
                  <OtherNode start="(781, 23)" end="(781, 38)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(781, 23)" end="(781, 24)" leading="" trailing=" " val="|"/>
                    <NullNode start="(781, 25)" end="(781, 31)">
                      <NullNode start="(781, 25)" end="(781, 31)">
                        <OtherNode start="(781, 25)" end="(781, 31)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(781, 25)" end="(781, 29)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(781, 30)" end="(781, 31)">
                            <IdentNode start="(781, 30)" end="(781, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(781, 32)" end="(781, 34)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(781, 35)" end="(781, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(781, 35)" end="(781, 36)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(781, 37)" end="(781, 38)">
                        <IdentNode start="(781, 37)" end="(781, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(781, 39)" end="(781, 54)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(781, 39)" end="(781, 40)" leading="" trailing=" " val="|"/>
                    <NullNode start="(781, 41)" end="(781, 45)">
                      <NullNode start="(781, 41)" end="(781, 45)">
                        <IdentNode start="(781, 41)" end="(781, 45)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(781, 46)" end="(781, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                    <IdentNode start="(781, 49)" end="(781, 54)" leading="" trailing=" " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(781, 55)" end="(786, 51)">
          <AtomNode start="(781, 55)" end="(781, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(781, 58)" end="(786, 51)">
            <AtomNode start="(781, 58)" end="(781, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(782, 3)" end="(786, 51)">
              <TacticTacticseq1IndentedNode start="(782, 3)" end="(786, 51)">
                <NullNode start="(782, 3)" end="(786, 51)">
                  <OtherNode start="(782, 3)" end="(786, 51)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;i : Nat&#10;xs : List α&#10;p : α → Bool&#10;w : findIdx? p xs = some i&#10;⊢ match xs[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" state_after="no goals" tactic="induction xs generalizing i with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt;&#10;  simp_all only [findIdx?_cons, Nat.zero_add]&#10;  split at w &amp;lt;;&amp;gt; cases i &amp;lt;;&amp;gt; simp_all [succ_inj]">
                    <AtomNode start="(782, 3)" end="(782, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(782, 13)" end="(782, 15)">
                      <OtherNode start="(782, 13)" end="(782, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(782, 13)" end="(782, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(782, 16)" end="(782, 30)">
                      <AtomNode start="(782, 16)" end="(782, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(782, 29)" end="(782, 30)">
                        <IdentNode start="(782, 29)" end="(782, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(782, 31)" end="(786, 51)">
                      <OtherNode start="(782, 31)" end="(786, 51)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(782, 31)" end="(782, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(783, 3)" end="(786, 51)">
                          <OtherNode start="(783, 3)" end="(783, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(783, 3)" end="(783, 8)">
                              <OtherNode start="(783, 3)" end="(783, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(783, 3)" end="(783, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(783, 5)" end="(783, 8)">
                                  <NullNode/>
                                  <IdentNode start="(783, 5)" end="(783, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(783, 9)" end="(783, 20)">
                              <AtomNode start="(783, 9)" end="(783, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(783, 12)" end="(783, 20)">
                                <TacticTacticseq1IndentedNode start="(783, 12)" end="(783, 20)">
                                  <NullNode start="(783, 12)" end="(783, 20)">
                                    <OtherNode start="(783, 12)" end="(783, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;i : Nat&#10;w : findIdx? p [] = some i&#10;⊢ match [][i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(783, 12)" end="(783, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(784, 3)" end="(786, 51)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(784, 3)" end="(784, 17)">
                              <OtherNode start="(784, 3)" end="(784, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(784, 3)" end="(784, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(784, 5)" end="(784, 9)">
                                  <NullNode/>
                                  <IdentNode start="(784, 5)" end="(784, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(784, 10)" end="(784, 17)">
                                  <IdentNode start="(784, 10)" end="(784, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(784, 12)" end="(784, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(784, 15)" end="(784, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(784, 18)" end="(786, 51)">
                              <AtomNode start="(784, 18)" end="(784, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(785, 5)" end="(786, 51)">
                                <TacticTacticseq1IndentedNode start="(785, 5)" end="(786, 51)">
                                  <NullNode start="(785, 5)" end="(786, 51)">
                                    <OtherNode start="(785, 5)" end="(785, 48)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ {i : Nat},&#10;    findIdx? p xs = some i →&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = true&#10;      | none =&amp;gt; false = true&#10;i : Nat&#10;w : findIdx? p (x :: xs) = some i&#10;⊢ match (x :: xs)[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ {i : Nat},&#10;    findIdx? p xs = some i →&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = true&#10;      | none =&amp;gt; false = true&#10;i : Nat&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = some i&#10;⊢ match (x :: xs)[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" tactic="simp_all only [findIdx?_cons, Nat.zero_add]">
                                      <AtomNode start="(785, 5)" end="(785, 13)" leading="" trailing=" " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(785, 14)" end="(785, 18)">
                                        <AtomNode start="(785, 14)" end="(785, 18)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(785, 19)" end="(785, 48)">
                                        <AtomNode start="(785, 19)" end="(785, 20)" leading="" trailing="" val="["/>
                                        <NullNode start="(785, 20)" end="(785, 47)">
                                          <OtherNode start="(785, 20)" end="(785, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(785, 20)" end="(785, 33)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(785, 33)" end="(785, 34)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(785, 35)" end="(785, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(785, 35)" end="(785, 47)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(785, 47)" end="(785, 48)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(786, 5)" end="(786, 51)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  ∀ {i : Nat},&#10;    findIdx? p xs = some i →&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = true&#10;      | none =&amp;gt; false = true&#10;i : Nat&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = some i&#10;⊢ match (x :: xs)[i]? with&#10;  | some a =&amp;gt; p a = true&#10;  | none =&amp;gt; false = true" state_after="no goals" tactic="split at w &amp;lt;;&amp;gt; cases i &amp;lt;;&amp;gt; simp_all [succ_inj]">
                                      <OtherNode start="(786, 5)" end="(786, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                                        <OtherNode start="(786, 5)" end="(786, 15)" kind="Lean.Parser.Tactic.split">
                                          <AtomNode start="(786, 5)" end="(786, 10)" leading="" trailing=" " val="split"/>
                                          <NullNode/>
                                          <NullNode start="(786, 11)" end="(786, 15)">
                                            <OtherNode start="(786, 11)" end="(786, 15)" kind="Lean.Parser.Tactic.location">
                                              <AtomNode start="(786, 11)" end="(786, 13)" leading="" trailing=" " val="at"/>
                                              <OtherNode start="(786, 14)" end="(786, 15)" kind="Lean.Parser.Tactic.locationHyp">
                                                <NullNode start="(786, 14)" end="(786, 15)">
                                                  <IdentNode start="(786, 14)" end="(786, 15)" leading="" trailing=" " raw_val="w" val="w"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(786, 16)" end="(786, 19)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                        <OtherNode start="(786, 20)" end="(786, 27)" kind="Lean.Parser.Tactic.cases">
                                          <AtomNode start="(786, 20)" end="(786, 25)" leading="" trailing=" " val="cases"/>
                                          <NullNode start="(786, 26)" end="(786, 27)">
                                            <OtherNode start="(786, 26)" end="(786, 27)" kind="Lean.Parser.Tactic.elimTarget">
                                              <NullNode/>
                                              <IdentNode start="(786, 26)" end="(786, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(786, 28)" end="(786, 31)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(786, 32)" end="(786, 51)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(786, 32)" end="(786, 40)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(786, 41)" end="(786, 51)">
                                          <AtomNode start="(786, 41)" end="(786, 42)" leading="" trailing="" val="["/>
                                          <NullNode start="(786, 42)" end="(786, 50)">
                                            <OtherNode start="(786, 42)" end="(786, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(786, 42)" end="(786, 50)" leading="" trailing="" raw_val="succ_inj" val="succ_inj" full_name="Nat.succ_inj" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(786, 50)" end="(786, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(788, 1)" end="(789, 51)" name="findIdx?_of_eq_some" full_name="List.findIdx?_of_eq_some">
      <CommandDeclmodifiersNode start="(788, 1)" end="(788, 58)">
        <NullNode/>
        <NullNode start="(788, 1)" end="(788, 58)">
          <OtherNode start="(788, 1)" end="(788, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(788, 1)" end="(788, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(788, 3)" end="(788, 57)">
              <OtherNode start="(788, 3)" end="(788, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(788, 3)" end="(788, 57)" kind="Lean.deprecated">
                  <AtomNode start="(788, 3)" end="(788, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(788, 14)" end="(788, 33)">
                    <IdentNode start="(788, 14)" end="(788, 33)" leading="" trailing=" " raw_val="of_findIdx?_eq_some" val="of_findIdx?_eq_some" full_name="List.of_findIdx?_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(780, 9)" def_end="(780, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(788, 34)" end="(788, 57)">
                    <AtomNode start="(788, 34)" end="(788, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(788, 35)" end="(788, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(788, 41)" end="(788, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(788, 44)" end="(788, 56)" kind="str">
                      <AtomNode start="(788, 44)" end="(788, 56)" leading="" trailing="" val="&amp;quot;2025-02-02&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(788, 56)" end="(788, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(788, 57)" end="(788, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(789, 1)" end="(789, 51)" name="findIdx?_of_eq_some">
        <AtomNode start="(789, 1)" end="(789, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(789, 8)" end="(789, 27)">
          <IdentNode start="(789, 8)" end="(789, 27)" leading="" trailing=" " raw_val="findIdx?_of_eq_some" val="findIdx?_of_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(789, 28)" end="(789, 51)">
          <AtomNode start="(789, 28)" end="(789, 30)" leading="" trailing=" " val=":="/>
          <OtherNode start="(789, 31)" end="(789, 51)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(789, 31)" end="(789, 32)" leading="" trailing="" val="@"/>
            <IdentNode start="(789, 32)" end="(789, 51)" leading="" trailing="&#10;&#10;" raw_val="of_findIdx?_eq_some" val="of_findIdx?_eq_some" full_name="List.of_findIdx?_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(780, 9)" def_end="(780, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(791, 1)" end="(804, 30)" name="of_findIdx?_eq_none" full_name="List.of_findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(791, 1)" end="(804, 30)" name="of_findIdx?_eq_none" full_name="List.of_findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(791, 1)" end="(791, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(791, 9)" end="(791, 28)">
          <IdentNode start="(791, 9)" end="(791, 28)" leading="" trailing=" " raw_val="of_findIdx?_eq_none" val="of_findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(791, 29)" end="(792, 66)">
          <NullNode start="(791, 29)" end="(791, 84)">
            <OtherNode start="(791, 29)" end="(791, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(791, 29)" end="(791, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(791, 30)" end="(791, 32)">
                <IdentNode start="(791, 30)" end="(791, 32)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(791, 33)" end="(791, 41)">
                <AtomNode start="(791, 33)" end="(791, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(791, 35)" end="(791, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(791, 35)" end="(791, 39)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(791, 40)" end="(791, 41)">
                    <IdentNode start="(791, 40)" end="(791, 41)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(791, 41)" end="(791, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(791, 43)" end="(791, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(791, 43)" end="(791, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(791, 44)" end="(791, 45)">
                <IdentNode start="(791, 44)" end="(791, 45)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(791, 46)" end="(791, 56)">
                <AtomNode start="(791, 46)" end="(791, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(791, 48)" end="(791, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(791, 48)" end="(791, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(791, 50)" end="(791, 51)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(791, 52)" end="(791, 56)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(791, 56)" end="(791, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(791, 58)" end="(791, 84)">
              <AtomNode start="(791, 58)" end="(791, 59)" leading="" trailing="" val="("/>
              <NullNode start="(791, 59)" end="(791, 60)">
                <IdentNode start="(791, 59)" end="(791, 60)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(791, 61)" end="(791, 83)">
                <AtomNode start="(791, 61)" end="(791, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(791, 63)" end="(791, 83)" kind="«term_=_»">
                  <OtherNode start="(791, 63)" end="(791, 76)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(791, 63)" end="(791, 74)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                    <NullNode start="(791, 75)" end="(791, 76)">
                      <IdentNode start="(791, 75)" end="(791, 76)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(791, 77)" end="(791, 78)" leading="" trailing=" " val="="/>
                  <IdentNode start="(791, 79)" end="(791, 83)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(791, 83)" end="(791, 84)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(791, 85)" end="(792, 66)">
            <AtomNode start="(791, 85)" end="(791, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(792, 5)" end="(792, 66)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(792, 5)" end="(792, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(792, 7)" end="(792, 8)">
                <IdentNode start="(792, 7)" end="(792, 8)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(792, 9)" end="(792, 14)">
                <TermTypespecNode start="(792, 9)" end="(792, 14)">
                  <AtomNode start="(792, 9)" end="(792, 10)" leading="" trailing=" " val=":"/>
                  <IdentNode start="(792, 11)" end="(792, 14)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </TermTypespecNode>
              </NullNode>
              <AtomNode start="(792, 14)" end="(792, 15)" leading="" trailing=" " val=","/>
              <OtherNode start="(792, 16)" end="(792, 66)" kind="Lean.Parser.Term.match">
                <AtomNode start="(792, 16)" end="(792, 21)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(792, 22)" end="(792, 28)">
                  <OtherNode start="(792, 22)" end="(792, 28)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(792, 22)" end="(792, 28)" kind="«term__[_]_?»">
                      <IdentNode start="(792, 22)" end="(792, 24)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <GroupNode/>
                      <AtomNode start="(792, 24)" end="(792, 25)" leading="" trailing="" val="["/>
                      <IdentNode start="(792, 25)" end="(792, 26)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(792, 26)" end="(792, 27)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(792, 27)" end="(792, 28)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(792, 29)" end="(792, 33)" leading="" trailing=" " val="with"/>
                <OtherNode start="(792, 34)" end="(792, 66)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(792, 34)" end="(792, 66)">
                    <OtherNode start="(792, 34)" end="(792, 51)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(792, 34)" end="(792, 35)" leading="" trailing=" " val="|"/>
                      <NullNode start="(792, 36)" end="(792, 42)">
                        <NullNode start="(792, 36)" end="(792, 42)">
                          <OtherNode start="(792, 36)" end="(792, 42)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(792, 36)" end="(792, 40)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(792, 41)" end="(792, 42)">
                              <IdentNode start="(792, 41)" end="(792, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(792, 43)" end="(792, 45)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(792, 46)" end="(792, 51)" kind="«term¬_»">
                        <AtomNode start="(792, 46)" end="(792, 47)" leading="" trailing=" " val="¬"/>
                        <OtherNode start="(792, 48)" end="(792, 51)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(792, 48)" end="(792, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(792, 50)" end="(792, 51)">
                            <IdentNode start="(792, 50)" end="(792, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(792, 52)" end="(792, 66)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(792, 52)" end="(792, 53)" leading="" trailing=" " val="|"/>
                      <NullNode start="(792, 54)" end="(792, 58)">
                        <NullNode start="(792, 54)" end="(792, 58)">
                          <IdentNode start="(792, 54)" end="(792, 58)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(792, 59)" end="(792, 61)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(792, 62)" end="(792, 66)" leading="" trailing=" " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(792, 67)" end="(804, 30)">
          <AtomNode start="(792, 67)" end="(792, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(792, 70)" end="(804, 30)">
            <AtomNode start="(792, 70)" end="(792, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(793, 3)" end="(804, 30)">
              <TacticTacticseq1IndentedNode start="(793, 3)" end="(804, 30)">
                <NullNode start="(793, 3)" end="(804, 30)">
                  <OtherNode start="(793, 3)" end="(793, 10)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;w : findIdx? p xs = none&#10;⊢ ∀ (i : Nat),&#10;    match xs[i]? with&#10;    | some a =&amp;gt; ¬p a = true&#10;    | none =&amp;gt; true = true" state_after="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;w : findIdx? p xs = none&#10;i : Nat&#10;⊢ match xs[i]? with&#10;  | some a =&amp;gt; ¬p a = true&#10;  | none =&amp;gt; true = true" tactic="intro i">
                    <AtomNode start="(793, 3)" end="(793, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(793, 9)" end="(793, 10)">
                      <IdentNode start="(793, 9)" end="(793, 10)" leading="" trailing="&#10;  " raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(794, 3)" end="(804, 30)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;w : findIdx? p xs = none&#10;i : Nat&#10;⊢ match xs[i]? with&#10;  | some a =&amp;gt; ¬p a = true&#10;  | none =&amp;gt; true = true" state_after="no goals" tactic="induction xs generalizing i with&#10;| nil =&amp;gt; simp_all&#10;| cons x xs ih =&amp;gt;&#10;  simp_all only [Bool.not_eq_true, findIdx?_cons, Nat.zero_add]&#10;  cases i with&#10;  | zero =&amp;gt;&#10;    split at w &amp;lt;;&amp;gt; simp_all&#10;  | succ i =&amp;gt;&#10;    simp only [getElem?_cons_succ]&#10;    apply ih&#10;    split at w &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(794, 3)" end="(794, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(794, 13)" end="(794, 15)">
                      <OtherNode start="(794, 13)" end="(794, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(794, 13)" end="(794, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(794, 16)" end="(794, 30)">
                      <AtomNode start="(794, 16)" end="(794, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(794, 29)" end="(794, 30)">
                        <IdentNode start="(794, 29)" end="(794, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(794, 31)" end="(804, 30)">
                      <OtherNode start="(794, 31)" end="(804, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(794, 31)" end="(794, 35)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(795, 3)" end="(804, 30)">
                          <OtherNode start="(795, 3)" end="(795, 20)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(795, 3)" end="(795, 8)">
                              <OtherNode start="(795, 3)" end="(795, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(795, 3)" end="(795, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(795, 5)" end="(795, 8)">
                                  <NullNode/>
                                  <IdentNode start="(795, 5)" end="(795, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(795, 9)" end="(795, 20)">
                              <AtomNode start="(795, 9)" end="(795, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(795, 12)" end="(795, 20)">
                                <TacticTacticseq1IndentedNode start="(795, 12)" end="(795, 20)">
                                  <NullNode start="(795, 12)" end="(795, 20)">
                                    <OtherNode start="(795, 12)" end="(795, 20)" kind="Lean.Parser.Tactic.simpAll" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;w : findIdx? p [] = none&#10;i : Nat&#10;⊢ match [][i]? with&#10;  | some a =&amp;gt; ¬p a = true&#10;  | none =&amp;gt; true = true" state_after="no goals" tactic="simp_all">
                                      <AtomNode start="(795, 12)" end="(795, 20)" leading="" trailing="&#10;  " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(796, 3)" end="(804, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(796, 3)" end="(796, 17)">
                              <OtherNode start="(796, 3)" end="(796, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(796, 3)" end="(796, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(796, 5)" end="(796, 9)">
                                  <NullNode/>
                                  <IdentNode start="(796, 5)" end="(796, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(796, 10)" end="(796, 17)">
                                  <IdentNode start="(796, 10)" end="(796, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(796, 12)" end="(796, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(796, 15)" end="(796, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(796, 18)" end="(804, 30)">
                              <AtomNode start="(796, 18)" end="(796, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(797, 5)" end="(804, 30)">
                                <TacticTacticseq1IndentedNode start="(797, 5)" end="(804, 30)">
                                  <NullNode start="(797, 5)" end="(804, 30)">
                                    <OtherNode start="(797, 5)" end="(797, 66)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; ¬p a = true&#10;      | none =&amp;gt; true = true&#10;w : findIdx? p (x :: xs) = none&#10;i : Nat&#10;⊢ match (x :: xs)[i]? with&#10;  | some a =&amp;gt; ¬p a = true&#10;  | none =&amp;gt; true = true" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;i : Nat&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;⊢ match (x :: xs)[i]? with&#10;  | some a =&amp;gt; p a = false&#10;  | none =&amp;gt; True" tactic="simp_all only [Bool.not_eq_true, findIdx?_cons, Nat.zero_add]">
                                      <AtomNode start="(797, 5)" end="(797, 13)" leading="" trailing=" " val="simp_all"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(797, 14)" end="(797, 18)">
                                        <AtomNode start="(797, 14)" end="(797, 18)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(797, 19)" end="(797, 66)">
                                        <AtomNode start="(797, 19)" end="(797, 20)" leading="" trailing="" val="["/>
                                        <NullNode start="(797, 20)" end="(797, 65)">
                                          <OtherNode start="(797, 20)" end="(797, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(797, 20)" end="(797, 36)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(797, 36)" end="(797, 37)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(797, 38)" end="(797, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(797, 38)" end="(797, 51)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(797, 51)" end="(797, 52)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(797, 53)" end="(797, 65)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(797, 53)" end="(797, 65)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(797, 65)" end="(797, 66)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(798, 5)" end="(804, 30)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;i : Nat&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;⊢ match (x :: xs)[i]? with&#10;  | some a =&amp;gt; p a = false&#10;  | none =&amp;gt; True" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt;&#10;  split at w &amp;lt;;&amp;gt; simp_all&#10;| succ i =&amp;gt;&#10;  simp only [getElem?_cons_succ]&#10;  apply ih&#10;  split at w &amp;lt;;&amp;gt; simp_all">
                                      <AtomNode start="(798, 5)" end="(798, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(798, 11)" end="(798, 12)">
                                        <OtherNode start="(798, 11)" end="(798, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(798, 11)" end="(798, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(798, 13)" end="(804, 30)">
                                        <OtherNode start="(798, 13)" end="(804, 30)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(798, 13)" end="(798, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(799, 5)" end="(804, 30)">
                                            <OtherNode start="(799, 5)" end="(800, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(799, 5)" end="(799, 11)">
                                                <OtherNode start="(799, 5)" end="(799, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(799, 5)" end="(799, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(799, 7)" end="(799, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(799, 7)" end="(799, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(799, 12)" end="(800, 30)">
                                                <AtomNode start="(799, 12)" end="(799, 14)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(800, 7)" end="(800, 30)">
                                                  <TacticTacticseq1IndentedNode start="(800, 7)" end="(800, 30)">
                                                    <NullNode start="(800, 7)" end="(800, 30)">
                                                      <OtherNode start="(800, 7)" end="(800, 30)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.zero&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;⊢ match (x :: xs)[0]? with&#10;  | some a =&amp;gt; p a = false&#10;  | none =&amp;gt; True" state_after="no goals" tactic="split at w &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(800, 7)" end="(800, 17)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(800, 7)" end="(800, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode start="(800, 13)" end="(800, 17)">
                                                            <OtherNode start="(800, 13)" end="(800, 17)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(800, 13)" end="(800, 15)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(800, 16)" end="(800, 17)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(800, 16)" end="(800, 17)">
                                                            <IdentNode start="(800, 16)" end="(800, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(800, 18)" end="(800, 21)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(800, 22)" end="(800, 30)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(800, 22)" end="(800, 30)" leading="" trailing="&#10;    " val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(801, 5)" end="(804, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(801, 5)" end="(801, 13)">
                                                <OtherNode start="(801, 5)" end="(801, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(801, 5)" end="(801, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(801, 7)" end="(801, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(801, 7)" end="(801, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(801, 12)" end="(801, 13)">
                                                    <IdentNode start="(801, 12)" end="(801, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(801, 14)" end="(804, 30)">
                                                <AtomNode start="(801, 14)" end="(801, 16)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(802, 7)" end="(804, 30)">
                                                  <TacticTacticseq1IndentedNode start="(802, 7)" end="(804, 30)">
                                                    <NullNode start="(802, 7)" end="(804, 30)">
                                                      <OtherNode start="(802, 7)" end="(802, 37)" kind="Lean.Parser.Tactic.simp" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;i : Nat&#10;⊢ match (x :: xs)[i + 1]? with&#10;  | some a =&amp;gt; p a = false&#10;  | none =&amp;gt; True" state_after="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;i : Nat&#10;⊢ match xs[i]? with&#10;  | some a =&amp;gt; p a = false&#10;  | none =&amp;gt; True" tactic="simp only [getElem?_cons_succ]">
                                                        <AtomNode start="(802, 7)" end="(802, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(802, 12)" end="(802, 16)">
                                                          <AtomNode start="(802, 12)" end="(802, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(802, 17)" end="(802, 37)">
                                                          <AtomNode start="(802, 17)" end="(802, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(802, 18)" end="(802, 36)">
                                                            <OtherNode start="(802, 18)" end="(802, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(802, 18)" end="(802, 36)" leading="" trailing="" raw_val="getElem?_cons_succ" val="getElem?_cons_succ" full_name="List.getElem?_cons_succ" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(802, 36)" end="(802, 37)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(803, 7)" end="(803, 15)" kind="Lean.Parser.Tactic.apply" state_before="case cons.succ&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;i : Nat&#10;⊢ match xs[i]? with&#10;  | some a =&amp;gt; p a = false&#10;  | none =&amp;gt; True" state_after="case cons.succ.w&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;i : Nat&#10;⊢ findIdx? p xs = none" tactic="apply ih">
                                                        <AtomNode start="(803, 7)" end="(803, 12)" leading="" trailing=" " val="apply"/>
                                                        <IdentNode start="(803, 13)" end="(803, 15)" leading="" trailing="&#10;      " raw_val="ih" val="ih"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(804, 7)" end="(804, 30)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.succ.w&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs = none →&#10;    ∀ (i : Nat),&#10;      match xs[i]? with&#10;      | some a =&amp;gt; p a = false&#10;      | none =&amp;gt; True&#10;w : (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) = none&#10;i : Nat&#10;⊢ findIdx? p xs = none" state_after="no goals" tactic="split at w &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(804, 7)" end="(804, 17)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(804, 7)" end="(804, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode start="(804, 13)" end="(804, 17)">
                                                            <OtherNode start="(804, 13)" end="(804, 17)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(804, 13)" end="(804, 15)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(804, 16)" end="(804, 17)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(804, 16)" end="(804, 17)">
                                                            <IdentNode start="(804, 16)" end="(804, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(804, 18)" end="(804, 21)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(804, 22)" end="(804, 30)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(804, 22)" end="(804, 30)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(806, 1)" end="(807, 51)" name="findIdx?_of_eq_none" full_name="List.findIdx?_of_eq_none">
      <CommandDeclmodifiersNode start="(806, 1)" end="(806, 58)">
        <NullNode/>
        <NullNode start="(806, 1)" end="(806, 58)">
          <OtherNode start="(806, 1)" end="(806, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(806, 1)" end="(806, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(806, 3)" end="(806, 57)">
              <OtherNode start="(806, 3)" end="(806, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(806, 3)" end="(806, 57)" kind="Lean.deprecated">
                  <AtomNode start="(806, 3)" end="(806, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(806, 14)" end="(806, 33)">
                    <IdentNode start="(806, 14)" end="(806, 33)" leading="" trailing=" " raw_val="of_findIdx?_eq_none" val="of_findIdx?_eq_none" full_name="List.of_findIdx?_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(791, 9)" def_end="(791, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(806, 34)" end="(806, 57)">
                    <AtomNode start="(806, 34)" end="(806, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(806, 35)" end="(806, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(806, 41)" end="(806, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(806, 44)" end="(806, 56)" kind="str">
                      <AtomNode start="(806, 44)" end="(806, 56)" leading="" trailing="" val="&amp;quot;2025-02-02&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(806, 56)" end="(806, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(806, 57)" end="(806, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(807, 1)" end="(807, 51)" name="findIdx?_of_eq_none">
        <AtomNode start="(807, 1)" end="(807, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(807, 8)" end="(807, 27)">
          <IdentNode start="(807, 8)" end="(807, 27)" leading="" trailing=" " raw_val="findIdx?_of_eq_none" val="findIdx?_of_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(807, 28)" end="(807, 51)">
          <AtomNode start="(807, 28)" end="(807, 30)" leading="" trailing=" " val=":="/>
          <OtherNode start="(807, 31)" end="(807, 51)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(807, 31)" end="(807, 32)" leading="" trailing="" val="@"/>
            <IdentNode start="(807, 32)" end="(807, 51)" leading="" trailing="&#10;&#10;" raw_val="of_findIdx?_eq_none" val="of_findIdx?_eq_none" full_name="List.of_findIdx?_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(791, 9)" def_end="(791, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(809, 1)" end="(814, 23)" name="findIdx?_map" full_name="List.findIdx?_map">
      <CommandDeclmodifiersNode start="(809, 1)" end="(809, 8)">
        <NullNode/>
        <NullNode start="(809, 1)" end="(809, 8)">
          <OtherNode start="(809, 1)" end="(809, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(809, 1)" end="(809, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(809, 3)" end="(809, 7)">
              <OtherNode start="(809, 3)" end="(809, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(809, 3)" end="(809, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(809, 3)" end="(809, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(809, 7)" end="(809, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(809, 9)" end="(814, 23)" name="findIdx?_map" full_name="List.findIdx?_map" _is_private_decl="False">
        <AtomNode start="(809, 9)" end="(809, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(809, 17)" end="(809, 29)">
          <IdentNode start="(809, 17)" end="(809, 29)" leading="" trailing=" " raw_val="findIdx?_map" val="findIdx?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(809, 30)" end="(809, 98)">
          <NullNode start="(809, 30)" end="(809, 54)">
            <OtherNode start="(809, 30)" end="(809, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(809, 30)" end="(809, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(809, 31)" end="(809, 32)">
                <IdentNode start="(809, 31)" end="(809, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(809, 33)" end="(809, 40)">
                <AtomNode start="(809, 33)" end="(809, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(809, 35)" end="(809, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(809, 35)" end="(809, 36)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(809, 37)" end="(809, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(809, 39)" end="(809, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(809, 40)" end="(809, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(809, 42)" end="(809, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(809, 42)" end="(809, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(809, 43)" end="(809, 44)">
                <IdentNode start="(809, 43)" end="(809, 44)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(809, 45)" end="(809, 53)">
                <AtomNode start="(809, 45)" end="(809, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(809, 47)" end="(809, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(809, 47)" end="(809, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(809, 52)" end="(809, 53)">
                    <IdentNode start="(809, 52)" end="(809, 53)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(809, 53)" end="(809, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(809, 55)" end="(809, 98)">
            <AtomNode start="(809, 55)" end="(809, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(809, 57)" end="(809, 98)" kind="«term_=_»">
              <OtherNode start="(809, 57)" end="(809, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(809, 57)" end="(809, 65)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(809, 66)" end="(809, 77)">
                  <IdentNode start="(809, 66)" end="(809, 67)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(809, 68)" end="(809, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(809, 68)" end="(809, 69)" leading="" trailing="" val="("/>
                    <OtherNode start="(809, 69)" end="(809, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(809, 69)" end="(809, 74)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(809, 75)" end="(809, 76)">
                        <IdentNode start="(809, 75)" end="(809, 76)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(809, 76)" end="(809, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(809, 78)" end="(809, 79)" leading="" trailing=" " val="="/>
              <OtherNode start="(809, 80)" end="(809, 98)" kind="Lean.Parser.Term.app">
                <IdentNode start="(809, 80)" end="(809, 90)" leading="" trailing=" " raw_val="l.findIdx?" val="l.findIdx?"/>
                <NullNode start="(809, 91)" end="(809, 98)">
                  <OtherNode start="(809, 91)" end="(809, 98)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(809, 91)" end="(809, 92)" leading="" trailing="" val="("/>
                    <OtherNode start="(809, 92)" end="(809, 97)" kind="«term_∘_»">
                      <IdentNode start="(809, 92)" end="(809, 93)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(809, 94)" end="(809, 95)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(809, 96)" end="(809, 97)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(809, 97)" end="(809, 98)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(809, 99)" end="(814, 23)">
          <AtomNode start="(809, 99)" end="(809, 101)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(809, 102)" end="(814, 23)">
            <AtomNode start="(809, 102)" end="(809, 104)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(810, 3)" end="(814, 23)">
              <TacticTacticseq1IndentedNode start="(810, 3)" end="(814, 23)">
                <NullNode start="(810, 3)" end="(814, 23)">
                  <OtherNode start="(810, 3)" end="(814, 23)" kind="Lean.Parser.Tactic.induction" state_before="β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;l : List β&#10;⊢ findIdx? p (map f l) = findIdx? (p ∘ f) l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [map_cons, findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(810, 3)" end="(810, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(810, 13)" end="(810, 14)">
                      <OtherNode start="(810, 13)" end="(810, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(810, 13)" end="(810, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(810, 15)" end="(814, 23)">
                      <OtherNode start="(810, 15)" end="(814, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(810, 15)" end="(810, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(811, 3)" end="(814, 23)">
                          <OtherNode start="(811, 3)" end="(811, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(811, 3)" end="(811, 8)">
                              <OtherNode start="(811, 3)" end="(811, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(811, 3)" end="(811, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(811, 5)" end="(811, 8)">
                                  <NullNode/>
                                  <IdentNode start="(811, 5)" end="(811, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(811, 9)" end="(811, 16)">
                              <AtomNode start="(811, 9)" end="(811, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(811, 12)" end="(811, 16)">
                                <TacticTacticseq1IndentedNode start="(811, 12)" end="(811, 16)">
                                  <NullNode start="(811, 12)" end="(811, 16)">
                                    <OtherNode start="(811, 12)" end="(811, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;⊢ findIdx? p (map f []) = findIdx? (p ∘ f) []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(811, 12)" end="(811, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(812, 3)" end="(814, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(812, 3)" end="(812, 17)">
                              <OtherNode start="(812, 3)" end="(812, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(812, 3)" end="(812, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(812, 5)" end="(812, 9)">
                                  <NullNode/>
                                  <IdentNode start="(812, 5)" end="(812, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(812, 10)" end="(812, 17)">
                                  <IdentNode start="(812, 10)" end="(812, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(812, 12)" end="(812, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(812, 15)" end="(812, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(812, 18)" end="(814, 23)">
                              <AtomNode start="(812, 18)" end="(812, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(813, 5)" end="(814, 23)">
                                <TacticTacticseq1IndentedNode start="(813, 5)" end="(814, 23)">
                                  <NullNode start="(813, 5)" end="(814, 23)">
                                    <OtherNode start="(813, 5)" end="(813, 40)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;x : β&#10;xs : List β&#10;ih : findIdx? p (map f xs) = findIdx? (p ∘ f) xs&#10;⊢ findIdx? p (map f (x :: xs)) = findIdx? (p ∘ f) (x :: xs)" state_after="case cons&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;x : β&#10;xs : List β&#10;ih : findIdx? p (map f xs) = findIdx? (p ∘ f) xs&#10;⊢ (if p (f x) = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p (map f xs))) =&#10;    if (p ∘ f) x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? (p ∘ f) xs)" tactic="simp only [map_cons, findIdx?_cons]">
                                      <AtomNode start="(813, 5)" end="(813, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(813, 10)" end="(813, 14)">
                                        <AtomNode start="(813, 10)" end="(813, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(813, 15)" end="(813, 40)">
                                        <AtomNode start="(813, 15)" end="(813, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(813, 16)" end="(813, 39)">
                                          <OtherNode start="(813, 16)" end="(813, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(813, 16)" end="(813, 24)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(813, 24)" end="(813, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(813, 26)" end="(813, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(813, 26)" end="(813, 39)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(813, 39)" end="(813, 40)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(814, 5)" end="(814, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;β : Type u_1&#10;α : Type u_2&#10;p : α → Bool&#10;f : β → α&#10;x : β&#10;xs : List β&#10;ih : findIdx? p (map f xs) = findIdx? (p ∘ f) xs&#10;⊢ (if p (f x) = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p (map f xs))) =&#10;    if (p ∘ f) x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? (p ∘ f) xs)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(814, 5)" end="(814, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(814, 5)" end="(814, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(814, 11)" end="(814, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(814, 15)" end="(814, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(814, 15)" end="(814, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(816, 1)" end="(820, 74)" name="findIdx?_append" full_name="List.findIdx?_append">
      <CommandDeclmodifiersNode start="(816, 1)" end="(816, 8)">
        <NullNode/>
        <NullNode start="(816, 1)" end="(816, 8)">
          <OtherNode start="(816, 1)" end="(816, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(816, 1)" end="(816, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(816, 3)" end="(816, 7)">
              <OtherNode start="(816, 3)" end="(816, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(816, 3)" end="(816, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(816, 3)" end="(816, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(816, 7)" end="(816, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(816, 9)" end="(820, 74)" name="findIdx?_append" full_name="List.findIdx?_append" _is_private_decl="False">
        <AtomNode start="(816, 9)" end="(816, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(816, 17)" end="(816, 32)">
          <IdentNode start="(816, 17)" end="(816, 32)" leading="" trailing=" " raw_val="findIdx?_append" val="findIdx?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(816, 33)" end="(818, 70)">
          <NullNode/>
          <TermTypespecNode start="(816, 33)" end="(818, 70)">
            <AtomNode start="(816, 33)" end="(816, 34)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(817, 5)" end="(818, 70)" kind="«term_=_»">
              <OtherNode start="(817, 5)" end="(817, 35)" kind="Lean.Parser.Term.app">
                <OtherNode start="(817, 5)" end="(817, 33)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(817, 5)" end="(817, 24)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(817, 5)" end="(817, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(817, 6)" end="(817, 14)" kind="«term_++_»">
                      <IdentNode start="(817, 6)" end="(817, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(817, 9)" end="(817, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(817, 12)" end="(817, 14)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(817, 15)" end="(817, 16)" leading="" trailing=" " val=":"/>
                    <NullNode start="(817, 17)" end="(817, 23)">
                      <OtherNode start="(817, 17)" end="(817, 23)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(817, 17)" end="(817, 21)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(817, 22)" end="(817, 23)">
                          <IdentNode start="(817, 22)" end="(817, 23)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(817, 23)" end="(817, 24)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(817, 24)" end="(817, 25)" leading="" trailing="" val="."/>
                  <IdentNode start="(817, 25)" end="(817, 33)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(817, 34)" end="(817, 35)">
                  <IdentNode start="(817, 34)" end="(817, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(817, 36)" end="(817, 37)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(818, 7)" end="(818, 70)" kind="Lean.Parser.Term.app">
                <OtherNode start="(818, 7)" end="(818, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(818, 7)" end="(818, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(818, 7)" end="(818, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(818, 8)" end="(818, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(818, 8)" end="(818, 19)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(818, 20)" end="(818, 21)">
                        <IdentNode start="(818, 20)" end="(818, 21)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(818, 21)" end="(818, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(818, 22)" end="(818, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(818, 23)" end="(818, 25)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(818, 26)" end="(818, 70)">
                  <OtherNode start="(818, 26)" end="(818, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(818, 26)" end="(818, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(818, 27)" end="(818, 69)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(818, 27)" end="(818, 46)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(818, 27)" end="(818, 42)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(818, 27)" end="(818, 28)" leading="" trailing="" val="("/>
                          <OtherNode start="(818, 28)" end="(818, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(818, 28)" end="(818, 39)" leading="" trailing=" " raw_val="ys.findIdx?" val="ys.findIdx?"/>
                            <NullNode start="(818, 40)" end="(818, 41)">
                              <IdentNode start="(818, 40)" end="(818, 41)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(818, 41)" end="(818, 42)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(818, 42)" end="(818, 43)" leading="" trailing="" val="."/>
                        <IdentNode start="(818, 43)" end="(818, 46)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(818, 47)" end="(818, 69)">
                        <OtherNode start="(818, 47)" end="(818, 69)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(818, 47)" end="(818, 50)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(818, 51)" end="(818, 69)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(818, 51)" end="(818, 52)">
                              <IdentNode start="(818, 51)" end="(818, 52)" leading="" trailing=" " raw_val="i" val="i"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(818, 53)" end="(818, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(818, 56)" end="(818, 69)" kind="«term_+_»">
                              <IdentNode start="(818, 56)" end="(818, 57)" leading="" trailing=" " raw_val="i" val="i"/>
                              <AtomNode start="(818, 58)" end="(818, 59)" leading="" trailing=" " val="+"/>
                              <IdentNode start="(818, 60)" end="(818, 69)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(818, 69)" end="(818, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(818, 71)" end="(820, 74)">
          <AtomNode start="(818, 71)" end="(818, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(818, 74)" end="(820, 74)">
            <AtomNode start="(818, 74)" end="(818, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(819, 3)" end="(820, 74)">
              <TacticTacticseq1IndentedNode start="(819, 3)" end="(820, 74)">
                <NullNode start="(819, 3)" end="(820, 74)">
                  <OtherNode start="(819, 3)" end="(820, 74)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;⊢ findIdx? p (xs ++ ys) = (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys))" state_after="no goals" tactic="induction xs with simp [findIdx?_cons]&#10;| cons _ _ _ =&amp;gt; split &amp;lt;;&amp;gt; simp_all [Option.map_or, Option.map_map]; rfl">
                    <AtomNode start="(819, 3)" end="(819, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(819, 13)" end="(819, 15)">
                      <OtherNode start="(819, 13)" end="(819, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(819, 13)" end="(819, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(819, 16)" end="(820, 74)">
                      <OtherNode start="(819, 16)" end="(820, 74)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(819, 16)" end="(819, 20)" leading="" trailing=" " val="with"/>
                        <NullNode start="(819, 21)" end="(819, 41)">
                          <OtherNode start="(819, 21)" end="(819, 41)" kind="Lean.Parser.Tactic.simp">
                            <AtomNode start="(819, 21)" end="(819, 25)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(819, 26)" end="(819, 41)">
                              <AtomNode start="(819, 26)" end="(819, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(819, 27)" end="(819, 40)">
                                <OtherNode start="(819, 27)" end="(819, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(819, 27)" end="(819, 40)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(819, 40)" end="(819, 41)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(820, 3)" end="(820, 74)">
                          <OtherNode start="(820, 3)" end="(820, 74)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(820, 3)" end="(820, 15)">
                              <OtherNode start="(820, 3)" end="(820, 15)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(820, 3)" end="(820, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(820, 5)" end="(820, 9)">
                                  <NullNode/>
                                  <IdentNode start="(820, 5)" end="(820, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(820, 10)" end="(820, 15)">
                                  <TermHoleNode start="(820, 10)" end="(820, 11)">
                                    <AtomNode start="(820, 10)" end="(820, 11)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(820, 12)" end="(820, 13)">
                                    <AtomNode start="(820, 12)" end="(820, 13)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                  <TermHoleNode start="(820, 14)" end="(820, 15)">
                                    <AtomNode start="(820, 14)" end="(820, 15)" leading="" trailing=" " val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(820, 16)" end="(820, 74)">
                              <AtomNode start="(820, 16)" end="(820, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(820, 19)" end="(820, 74)">
                                <TacticTacticseq1IndentedNode start="(820, 19)" end="(820, 74)">
                                  <NullNode start="(820, 19)" end="(820, 74)">
                                    <OtherNode start="(820, 19)" end="(820, 69)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;ys : List α&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : findIdx? p (tail✝ ++ ys) = (findIdx? p tail✝).or (Option.map (fun i =&amp;gt; i + tail✝.length) (findIdx? p ys))&#10;⊢ (if p head✝ = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p (tail✝ ++ ys))) =&#10;    (if p head✝ = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p tail✝)).or&#10;      (Option.map (fun i =&amp;gt; i + (tail✝.length + 1)) (findIdx? p ys))" state_after="case cons.isFalse&#10;α : Type u_1&#10;ys : List α&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : findIdx? p (tail✝ ++ ys) = (findIdx? p tail✝).or (Option.map (fun i =&amp;gt; i + tail✝.length) (findIdx? p ys))&#10;h✝ : p head✝ = false&#10;⊢ (Option.map (fun i =&amp;gt; i + 1) (findIdx? p tail✝)).or&#10;      (Option.map ((fun i =&amp;gt; i + 1) ∘ fun i =&amp;gt; i + tail✝.length) (findIdx? p ys)) =&#10;    (Option.map (fun i =&amp;gt; i + 1) (findIdx? p tail✝)).or (Option.map (fun i =&amp;gt; i + (tail✝.length + 1)) (findIdx? p ys))" tactic="split &amp;lt;;&amp;gt; simp_all [Option.map_or, Option.map_map]">
                                      <OtherNode start="(820, 19)" end="(820, 24)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(820, 19)" end="(820, 24)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(820, 25)" end="(820, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(820, 29)" end="(820, 69)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(820, 29)" end="(820, 37)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(820, 38)" end="(820, 69)">
                                          <AtomNode start="(820, 38)" end="(820, 39)" leading="" trailing="" val="["/>
                                          <NullNode start="(820, 39)" end="(820, 68)">
                                            <OtherNode start="(820, 39)" end="(820, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(820, 39)" end="(820, 52)" leading="" trailing="" raw_val="Option.map_or" val="Option.map_or" full_name="Option.map_or" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                            </OtherNode>
                                            <AtomNode start="(820, 52)" end="(820, 53)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(820, 54)" end="(820, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(820, 54)" end="(820, 68)" leading="" trailing="" raw_val="Option.map_map" val="Option.map_map" full_name="Option.map_map" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(820, 68)" end="(820, 69)" leading="" trailing="" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(820, 69)" end="(820, 70)" leading="" trailing=" " val=";"/>
                                    <OtherNode start="(820, 71)" end="(820, 74)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case cons.isFalse&#10;α : Type u_1&#10;ys : List α&#10;p : α → Bool&#10;head✝ : α&#10;tail✝ : List α&#10;tail_ih✝ : findIdx? p (tail✝ ++ ys) = (findIdx? p tail✝).or (Option.map (fun i =&amp;gt; i + tail✝.length) (findIdx? p ys))&#10;h✝ : p head✝ = false&#10;⊢ (Option.map (fun i =&amp;gt; i + 1) (findIdx? p tail✝)).or&#10;      (Option.map ((fun i =&amp;gt; i + 1) ∘ fun i =&amp;gt; i + tail✝.length) (findIdx? p ys)) =&#10;    (Option.map (fun i =&amp;gt; i + 1) (findIdx? p tail✝)).or (Option.map (fun i =&amp;gt; i + (tail✝.length + 1)) (findIdx? p ys))" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(820, 71)" end="(820, 74)" leading="" trailing="&#10;&#10;" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(822, 1)" end="(836, 60)" name="findIdx?_flatten" full_name="List.findIdx?_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(822, 1)" end="(836, 60)" name="findIdx?_flatten" full_name="List.findIdx?_flatten" _is_private_decl="False">
        <AtomNode start="(822, 1)" end="(822, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(822, 9)" end="(822, 25)">
          <IdentNode start="(822, 9)" end="(822, 25)" leading="" trailing=" " raw_val="findIdx?_flatten" val="findIdx?_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(822, 26)" end="(826, 52)">
          <NullNode start="(822, 26)" end="(822, 60)">
            <OtherNode start="(822, 26)" end="(822, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(822, 26)" end="(822, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(822, 27)" end="(822, 28)">
                <IdentNode start="(822, 27)" end="(822, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(822, 29)" end="(822, 44)">
                <AtomNode start="(822, 29)" end="(822, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(822, 31)" end="(822, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(822, 31)" end="(822, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(822, 36)" end="(822, 44)">
                    <OtherNode start="(822, 36)" end="(822, 44)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(822, 36)" end="(822, 37)" leading="" trailing="" val="("/>
                      <OtherNode start="(822, 37)" end="(822, 43)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(822, 37)" end="(822, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(822, 42)" end="(822, 43)">
                          <IdentNode start="(822, 42)" end="(822, 43)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(822, 43)" end="(822, 44)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(822, 44)" end="(822, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(822, 46)" end="(822, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(822, 46)" end="(822, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(822, 47)" end="(822, 48)">
                <IdentNode start="(822, 47)" end="(822, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(822, 49)" end="(822, 59)">
                <AtomNode start="(822, 49)" end="(822, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(822, 51)" end="(822, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(822, 51)" end="(822, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(822, 53)" end="(822, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(822, 55)" end="(822, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(822, 59)" end="(822, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(822, 61)" end="(826, 52)">
            <AtomNode start="(822, 61)" end="(822, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(823, 5)" end="(826, 52)" kind="«term_=_»">
              <OtherNode start="(823, 5)" end="(823, 25)" kind="Lean.Parser.Term.app">
                <IdentNode start="(823, 5)" end="(823, 23)" leading="" trailing=" " raw_val="l.flatten.findIdx?" val="l.flatten.findIdx?"/>
                <NullNode start="(823, 24)" end="(823, 25)">
                  <IdentNode start="(823, 24)" end="(823, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(823, 26)" end="(823, 27)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(824, 7)" end="(826, 52)" kind="Lean.Parser.Term.app">
                <OtherNode start="(824, 7)" end="(824, 33)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(824, 7)" end="(824, 29)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(824, 7)" end="(824, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(824, 8)" end="(824, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(824, 8)" end="(824, 18)" leading="" trailing=" " raw_val="l.findIdx?" val="l.findIdx?"/>
                      <NullNode start="(824, 19)" end="(824, 28)">
                        <OtherNode start="(824, 19)" end="(824, 28)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(824, 19)" end="(824, 20)" leading="" trailing="" val="("/>
                          <OtherNode start="(824, 20)" end="(824, 27)" kind="Lean.Parser.Term.app">
                            <OtherNode start="(824, 20)" end="(824, 25)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(824, 20)" end="(824, 21)" kind="Lean.Parser.Term.cdot">
                                <AtomNode start="(824, 20)" end="(824, 21)" leading="" trailing="" val="·"/>
                              </OtherNode>
                              <AtomNode start="(824, 21)" end="(824, 22)" leading="" trailing="" val="."/>
                              <IdentNode start="(824, 22)" end="(824, 25)" leading="" trailing=" " raw_val="any" val="any" full_name="List.any" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                            </OtherNode>
                            <NullNode start="(824, 26)" end="(824, 27)">
                              <IdentNode start="(824, 26)" end="(824, 27)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(824, 27)" end="(824, 28)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(824, 28)" end="(824, 29)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(824, 29)" end="(824, 30)" leading="" trailing="" val="."/>
                  <IdentNode start="(824, 30)" end="(824, 33)" leading="" trailing="&#10;        " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(825, 9)" end="(826, 52)">
                  <OtherNode start="(825, 9)" end="(826, 52)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(825, 9)" end="(825, 12)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(825, 13)" end="(826, 52)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(825, 13)" end="(825, 14)">
                        <IdentNode start="(825, 13)" end="(825, 14)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(825, 15)" end="(825, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(825, 18)" end="(826, 52)" kind="«term_+_»">
                        <OtherNode start="(825, 18)" end="(825, 50)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(825, 18)" end="(825, 46)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(825, 18)" end="(825, 19)" leading="" trailing="" val="("/>
                            <OtherNode start="(825, 19)" end="(825, 45)" kind="Lean.Parser.Term.app">
                              <OtherNode start="(825, 19)" end="(825, 33)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(825, 19)" end="(825, 29)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(825, 19)" end="(825, 20)" leading="" trailing="" val="("/>
                                  <OtherNode start="(825, 20)" end="(825, 28)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(825, 20)" end="(825, 26)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                                    <NullNode start="(825, 27)" end="(825, 28)">
                                      <IdentNode start="(825, 27)" end="(825, 28)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(825, 28)" end="(825, 29)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(825, 29)" end="(825, 30)" leading="" trailing="" val="."/>
                                <IdentNode start="(825, 30)" end="(825, 33)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              </OtherNode>
                              <NullNode start="(825, 34)" end="(825, 45)">
                                <IdentNode start="(825, 34)" end="(825, 45)" leading="" trailing="" raw_val="List.length" val="List.length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(825, 45)" end="(825, 46)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(825, 46)" end="(825, 47)" leading="" trailing="" val="."/>
                          <IdentNode start="(825, 47)" end="(825, 50)" leading="" trailing=" " raw_val="sum" val="sum" full_name="List.sum" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(825, 51)" end="(825, 52)" leading="" trailing="&#10;          " val="+"/>
                        <OtherNode start="(826, 11)" end="(826, 52)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(826, 11)" end="(826, 50)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(826, 11)" end="(826, 45)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(826, 11)" end="(826, 12)" leading="" trailing="" val="("/>
                              <OtherNode start="(826, 12)" end="(826, 44)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(826, 12)" end="(826, 21)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(826, 12)" end="(826, 17)" kind="«term__[_]_?»">
                                    <IdentNode start="(826, 12)" end="(826, 13)" leading="" trailing="" raw_val="l" val="l"/>
                                    <GroupNode/>
                                    <AtomNode start="(826, 13)" end="(826, 14)" leading="" trailing="" val="["/>
                                    <IdentNode start="(826, 14)" end="(826, 15)" leading="" trailing="" raw_val="i" val="i"/>
                                    <AtomNode start="(826, 15)" end="(826, 16)" leading="" trailing="" val="]"/>
                                    <GroupNode/>
                                    <AtomNode start="(826, 16)" end="(826, 17)" leading="" trailing="" val="?"/>
                                  </OtherNode>
                                  <AtomNode start="(826, 17)" end="(826, 18)" leading="" trailing="" val="."/>
                                  <IdentNode start="(826, 18)" end="(826, 21)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </OtherNode>
                                <NullNode start="(826, 22)" end="(826, 44)">
                                  <OtherNode start="(826, 22)" end="(826, 44)" kind="Lean.Parser.Term.fun">
                                    <AtomNode start="(826, 22)" end="(826, 25)" leading="" trailing=" " val="fun"/>
                                    <OtherNode start="(826, 26)" end="(826, 44)" kind="Lean.Parser.Term.basicFun">
                                      <NullNode start="(826, 26)" end="(826, 28)">
                                        <IdentNode start="(826, 26)" end="(826, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                      </NullNode>
                                      <NullNode/>
                                      <AtomNode start="(826, 29)" end="(826, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <OtherNode start="(826, 32)" end="(826, 44)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(826, 32)" end="(826, 42)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                                        <NullNode start="(826, 43)" end="(826, 44)">
                                          <IdentNode start="(826, 43)" end="(826, 44)" leading="" trailing="" raw_val="p" val="p"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(826, 44)" end="(826, 45)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(826, 45)" end="(826, 46)" leading="" trailing="" val="."/>
                            <IdentNode start="(826, 46)" end="(826, 50)" leading="" trailing=" " raw_val="getD" val="getD" full_name="Option.getD" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </OtherNode>
                          <NullNode start="(826, 51)" end="(826, 52)">
                            <OtherNode start="(826, 51)" end="(826, 52)" kind="num">
                              <AtomNode start="(826, 51)" end="(826, 52)" leading="" trailing=" " val="0"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(826, 53)" end="(836, 60)">
          <AtomNode start="(826, 53)" end="(826, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(826, 56)" end="(836, 60)">
            <AtomNode start="(826, 56)" end="(826, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(827, 3)" end="(836, 60)">
              <TacticTacticseq1IndentedNode start="(827, 3)" end="(836, 60)">
                <NullNode start="(827, 3)" end="(836, 60)">
                  <OtherNode start="(827, 3)" end="(836, 60)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List (List α)&#10;p : α → Bool&#10;⊢ findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons xs l ih =&amp;gt;&#10;  rw [flatten_cons, findIdx?_append, ih, findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · simp only [any_eq_true] at h&#10;    rw [Option.or_of_isSome (by simp_all [findIdx?_isSome])]&#10;    simp_all [findIdx?_eq_some_of_exists]&#10;  · rw [Option.or_of_isNone (by simp_all [findIdx?_isNone])]&#10;    simp [Function.comp_def, Nat.add_comm, Nat.add_assoc]">
                    <AtomNode start="(827, 3)" end="(827, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(827, 13)" end="(827, 14)">
                      <OtherNode start="(827, 13)" end="(827, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(827, 13)" end="(827, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(827, 15)" end="(836, 60)">
                      <OtherNode start="(827, 15)" end="(836, 60)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(827, 15)" end="(827, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(828, 3)" end="(836, 60)">
                          <OtherNode start="(828, 3)" end="(828, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(828, 3)" end="(828, 8)">
                              <OtherNode start="(828, 3)" end="(828, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(828, 3)" end="(828, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(828, 5)" end="(828, 8)">
                                  <NullNode/>
                                  <IdentNode start="(828, 5)" end="(828, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(828, 9)" end="(828, 16)">
                              <AtomNode start="(828, 9)" end="(828, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(828, 12)" end="(828, 16)">
                                <TacticTacticseq1IndentedNode start="(828, 12)" end="(828, 16)">
                                  <NullNode start="(828, 12)" end="(828, 16)">
                                    <OtherNode start="(828, 12)" end="(828, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx? p [].flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i [])).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) [][i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(828, 12)" end="(828, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(829, 3)" end="(836, 60)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(829, 3)" end="(829, 17)">
                              <OtherNode start="(829, 3)" end="(829, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(829, 3)" end="(829, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(829, 5)" end="(829, 9)">
                                  <NullNode/>
                                  <IdentNode start="(829, 5)" end="(829, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(829, 10)" end="(829, 17)">
                                  <IdentNode start="(829, 10)" end="(829, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(829, 13)" end="(829, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(829, 15)" end="(829, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(829, 18)" end="(836, 60)">
                              <AtomNode start="(829, 18)" end="(829, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(830, 5)" end="(836, 60)">
                                <TacticTacticseq1IndentedNode start="(830, 5)" end="(836, 60)">
                                  <NullNode start="(830, 5)" end="(836, 60)">
                                    <OtherNode start="(830, 5)" end="(830, 58)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;⊢ findIdx? p (xs :: l).flatten =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) (xs :: l))" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (if xs.any p = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" tactic="rw [flatten_cons, findIdx?_append, ih, findIdx?_cons]">
                                      <AtomNode start="(830, 5)" end="(830, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(830, 8)" end="(830, 58)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(830, 8)" end="(830, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(830, 9)" end="(830, 57)">
                                          <OtherNode start="(830, 9)" end="(830, 21)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(830, 9)" end="(830, 21)" leading="" trailing="" raw_val="flatten_cons" val="flatten_cons" full_name="List.flatten_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(830, 21)" end="(830, 22)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(830, 23)" end="(830, 38)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(830, 23)" end="(830, 38)" leading="" trailing="" raw_val="findIdx?_append" val="findIdx?_append" full_name="List.findIdx?_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(816, 17)" def_end="(816, 32)"/>
                                          </OtherNode>
                                          <AtomNode start="(830, 38)" end="(830, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(830, 40)" end="(830, 42)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(830, 40)" end="(830, 42)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(830, 42)" end="(830, 43)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(830, 44)" end="(830, 57)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(830, 44)" end="(830, 57)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(830, 57)" end="(830, 58)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(831, 5)" end="(831, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (if xs.any p = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                      <OtherNode start="(831, 5)" end="(831, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(831, 5)" end="(831, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(831, 11)" end="(831, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(831, 15)" end="(831, 25)" kind="Lean.Parser.Tactic.renameI">
                                        <AtomNode start="(831, 15)" end="(831, 23)" leading="" trailing=" " val="rename_i"/>
                                        <NullNode start="(831, 24)" end="(831, 25)">
                                          <LeanBinderidentNode start="(831, 24)" end="(831, 25)">
                                            <IdentNode start="(831, 24)" end="(831, 25)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                          </LeanBinderidentNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(832, 5)" end="(834, 44)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" tactic="· simp only [any_eq_true] at h&#10;  rw [Option.or_of_isSome (by simp_all [findIdx?_isSome])]&#10;  simp_all [findIdx?_eq_some_of_exists]">
                                      <OtherNode start="(832, 5)" end="(832, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(832, 5)" end="(832, 6)" kind="patternIgnore">
                                          <OtherNode start="(832, 5)" end="(832, 6)" kind="token.«· »">
                                            <AtomNode start="(832, 5)" end="(832, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(832, 7)" end="(834, 44)">
                                        <TacticTacticseq1IndentedNode start="(832, 7)" end="(834, 44)">
                                          <NullNode start="(832, 7)" end="(834, 44)">
                                            <OtherNode start="(832, 7)" end="(832, 35)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)" tactic="simp only [any_eq_true] at h">
                                              <AtomNode start="(832, 7)" end="(832, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(832, 12)" end="(832, 16)">
                                                <AtomNode start="(832, 12)" end="(832, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(832, 17)" end="(832, 30)">
                                                <AtomNode start="(832, 17)" end="(832, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(832, 18)" end="(832, 29)">
                                                  <OtherNode start="(832, 18)" end="(832, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(832, 18)" end="(832, 29)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(832, 29)" end="(832, 30)" leading="" trailing=" " val="]"/>
                                              </NullNode>
                                              <NullNode start="(832, 31)" end="(832, 35)">
                                                <OtherNode start="(832, 31)" end="(832, 35)" kind="Lean.Parser.Tactic.location">
                                                  <AtomNode start="(832, 31)" end="(832, 33)" leading="" trailing=" " val="at"/>
                                                  <OtherNode start="(832, 34)" end="(832, 35)" kind="Lean.Parser.Tactic.locationHyp">
                                                    <NullNode start="(832, 34)" end="(832, 35)">
                                                      <IdentNode start="(832, 34)" end="(832, 35)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(833, 7)" end="(833, 63)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx? p xs =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)" tactic="rw [Option.or_of_isSome (by simp_all [findIdx?_isSome])]">
                                              <AtomNode start="(833, 7)" end="(833, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(833, 10)" end="(833, 63)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(833, 10)" end="(833, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(833, 11)" end="(833, 62)">
                                                  <OtherNode start="(833, 11)" end="(833, 62)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(833, 11)" end="(833, 62)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(833, 11)" end="(833, 30)" leading="" trailing=" " raw_val="Option.or_of_isSome" val="Option.or_of_isSome" full_name="Option.or_of_isSome" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                      <NullNode start="(833, 31)" end="(833, 62)">
                                                        <OtherNode start="(833, 31)" end="(833, 62)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(833, 31)" end="(833, 32)" leading="" trailing="" val="("/>
                                                          <TermBytacticNode start="(833, 32)" end="(833, 61)">
                                                            <AtomNode start="(833, 32)" end="(833, 34)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(833, 35)" end="(833, 61)">
                                                            <TacticTacticseq1IndentedNode start="(833, 35)" end="(833, 61)">
                                                            <NullNode start="(833, 35)" end="(833, 61)">
                                                            <OtherNode start="(833, 35)" end="(833, 61)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ (findIdx? p xs).isSome = true" state_after="no goals" tactic="simp_all [findIdx?_isSome]">
                                                            <AtomNode start="(833, 35)" end="(833, 43)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(833, 44)" end="(833, 61)">
                                                            <AtomNode start="(833, 44)" end="(833, 45)" leading="" trailing="" val="["/>
                                                            <NullNode start="(833, 45)" end="(833, 60)">
                                                            <OtherNode start="(833, 45)" end="(833, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(833, 45)" end="(833, 60)" leading="" trailing="" raw_val="findIdx?_isSome" val="findIdx?_isSome" full_name="List.findIdx?_isSome" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(695, 9)" def_end="(695, 24)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(833, 60)" end="(833, 61)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(833, 61)" end="(833, 62)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(833, 62)" end="(833, 63)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(834, 7)" end="(834, 44)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ∃ x, x ∈ xs ∧ p x = true&#10;⊢ findIdx? p xs =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (some 0)" state_after="no goals" tactic="simp_all [findIdx?_eq_some_of_exists]">
                                              <AtomNode start="(834, 7)" end="(834, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(834, 16)" end="(834, 44)">
                                                <AtomNode start="(834, 16)" end="(834, 17)" leading="" trailing="" val="["/>
                                                <NullNode start="(834, 17)" end="(834, 43)">
                                                  <OtherNode start="(834, 17)" end="(834, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(834, 17)" end="(834, 43)" leading="" trailing="" raw_val="findIdx?_eq_some_of_exists" val="findIdx?_eq_some_of_exists" full_name="List.findIdx?_eq_some_of_exists" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(729, 9)" def_end="(729, 35)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(834, 43)" end="(834, 44)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(835, 5)" end="(836, 60)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" state_after="no goals" tactic="· rw [Option.or_of_isNone (by simp_all [findIdx?_isNone])]&#10;  simp [Function.comp_def, Nat.add_comm, Nat.add_assoc]">
                                      <OtherNode start="(835, 5)" end="(835, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(835, 5)" end="(835, 6)" kind="patternIgnore">
                                          <OtherNode start="(835, 5)" end="(835, 6)" kind="token.«· »">
                                            <AtomNode start="(835, 5)" end="(835, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(835, 7)" end="(836, 60)">
                                        <TacticTacticseq1IndentedNode start="(835, 7)" end="(836, 60)">
                                          <NullNode start="(835, 7)" end="(836, 60)">
                                            <OtherNode start="(835, 7)" end="(835, 63)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ (findIdx? p xs).or&#10;      (Option.map (fun i =&amp;gt; i + xs.length)&#10;        (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;          (findIdx? (fun x =&amp;gt; x.any p) l))) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ Option.map (fun i =&amp;gt; i + xs.length)&#10;      (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;        (findIdx? (fun x =&amp;gt; x.any p) l)) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" tactic="rw [Option.or_of_isNone (by simp_all [findIdx?_isNone])]">
                                              <AtomNode start="(835, 7)" end="(835, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(835, 10)" end="(835, 63)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(835, 10)" end="(835, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(835, 11)" end="(835, 62)">
                                                  <OtherNode start="(835, 11)" end="(835, 62)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(835, 11)" end="(835, 62)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(835, 11)" end="(835, 30)" leading="" trailing=" " raw_val="Option.or_of_isNone" val="Option.or_of_isNone" full_name="Option.or_of_isNone" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                                      <NullNode start="(835, 31)" end="(835, 62)">
                                                        <OtherNode start="(835, 31)" end="(835, 62)" kind="Lean.Parser.Term.paren">
                                                          <AtomNode start="(835, 31)" end="(835, 32)" leading="" trailing="" val="("/>
                                                          <TermBytacticNode start="(835, 32)" end="(835, 61)">
                                                            <AtomNode start="(835, 32)" end="(835, 34)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(835, 35)" end="(835, 61)">
                                                            <TacticTacticseq1IndentedNode start="(835, 35)" end="(835, 61)">
                                                            <NullNode start="(835, 35)" end="(835, 61)">
                                                            <OtherNode start="(835, 35)" end="(835, 61)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ (findIdx? p xs).isNone = true" state_after="no goals" tactic="simp_all [findIdx?_isNone]">
                                                            <AtomNode start="(835, 35)" end="(835, 43)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(835, 44)" end="(835, 61)">
                                                            <AtomNode start="(835, 44)" end="(835, 45)" leading="" trailing="" val="["/>
                                                            <NullNode start="(835, 45)" end="(835, 60)">
                                                            <OtherNode start="(835, 45)" end="(835, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(835, 45)" end="(835, 60)" leading="" trailing="" raw_val="findIdx?_isNone" val="findIdx?_isNone" full_name="List.findIdx?_isNone" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(704, 9)" def_end="(704, 24)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(835, 60)" end="(835, 61)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                          </TermBytacticNode>
                                                          <AtomNode start="(835, 61)" end="(835, 62)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(835, 62)" end="(835, 63)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(836, 7)" end="(836, 60)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;xs : List α&#10;l : List (List α)&#10;ih :&#10;  findIdx? p l.flatten =&#10;    Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;      (findIdx? (fun x =&amp;gt; x.any p) l)&#10;h : ¬xs.any p = true&#10;⊢ Option.map (fun i =&amp;gt; i + xs.length)&#10;      (Option.map (fun i =&amp;gt; (map length (take i l)).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) l[i]?).getD 0)&#10;        (findIdx? (fun x =&amp;gt; x.any p) l)) =&#10;    Option.map&#10;      (fun i =&amp;gt; (map length (take i (xs :: l))).sum + (Option.map (fun xs =&amp;gt; findIdx p xs) (xs :: l)[i]?).getD 0)&#10;      (Option.map (fun i =&amp;gt; i + 1) (findIdx? (fun x =&amp;gt; x.any p) l))" state_after="no goals" tactic="simp [Function.comp_def, Nat.add_comm, Nat.add_assoc]">
                                              <AtomNode start="(836, 7)" end="(836, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(836, 12)" end="(836, 60)">
                                                <AtomNode start="(836, 12)" end="(836, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(836, 13)" end="(836, 59)">
                                                  <OtherNode start="(836, 13)" end="(836, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(836, 13)" end="(836, 30)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(836, 30)" end="(836, 31)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(836, 32)" end="(836, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(836, 32)" end="(836, 44)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(836, 44)" end="(836, 45)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(836, 46)" end="(836, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(836, 46)" end="(836, 59)" leading="" trailing="" raw_val="Nat.add_assoc" val="Nat.add_assoc" full_name="Nat.add_assoc" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(836, 59)" end="(836, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(838, 1)" end="(844, 23)" name="findIdx?_replicate" full_name="List.findIdx?_replicate">
      <CommandDeclmodifiersNode start="(838, 1)" end="(838, 8)">
        <NullNode/>
        <NullNode start="(838, 1)" end="(838, 8)">
          <OtherNode start="(838, 1)" end="(838, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(838, 1)" end="(838, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(838, 3)" end="(838, 7)">
              <OtherNode start="(838, 3)" end="(838, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(838, 3)" end="(838, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(838, 3)" end="(838, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(838, 7)" end="(838, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(838, 9)" end="(844, 23)" name="findIdx?_replicate" full_name="List.findIdx?_replicate" _is_private_decl="False">
        <AtomNode start="(838, 9)" end="(838, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(838, 17)" end="(838, 35)">
          <IdentNode start="(838, 17)" end="(838, 35)" leading="" trailing=" " raw_val="findIdx?_replicate" val="findIdx?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(838, 36)" end="(839, 70)">
          <NullNode/>
          <TermTypespecNode start="(838, 36)" end="(839, 70)">
            <AtomNode start="(838, 36)" end="(838, 37)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(839, 5)" end="(839, 70)" kind="«term_=_»">
              <OtherNode start="(839, 5)" end="(839, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(839, 5)" end="(839, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(839, 5)" end="(839, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(839, 5)" end="(839, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(839, 6)" end="(839, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(839, 6)" end="(839, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(839, 16)" end="(839, 19)">
                        <IdentNode start="(839, 16)" end="(839, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(839, 18)" end="(839, 19)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(839, 19)" end="(839, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(839, 20)" end="(839, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(839, 21)" end="(839, 29)" leading="" trailing=" " raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(839, 30)" end="(839, 31)">
                  <IdentNode start="(839, 30)" end="(839, 31)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(839, 32)" end="(839, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(839, 34)" end="(839, 70)" kind="termIfThenElse">
                <AtomNode start="(839, 34)" end="(839, 36)" leading="" trailing=" " val="if"/>
                <OtherNode start="(839, 37)" end="(839, 48)" kind="«term_∧_»">
                  <OtherNode start="(839, 37)" end="(839, 42)" kind="«term_&amp;lt;_»">
                    <OtherNode start="(839, 37)" end="(839, 38)" kind="num">
                      <AtomNode start="(839, 37)" end="(839, 38)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                    <AtomNode start="(839, 39)" end="(839, 40)" leading="" trailing=" " val="&amp;lt;"/>
                    <IdentNode start="(839, 41)" end="(839, 42)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(839, 43)" end="(839, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(839, 45)" end="(839, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(839, 45)" end="(839, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(839, 47)" end="(839, 48)">
                      <IdentNode start="(839, 47)" end="(839, 48)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(839, 49)" end="(839, 53)" leading="" trailing=" " val="then"/>
                <OtherNode start="(839, 54)" end="(839, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(839, 54)" end="(839, 58)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(839, 59)" end="(839, 60)">
                    <OtherNode start="(839, 59)" end="(839, 60)" kind="num">
                      <AtomNode start="(839, 59)" end="(839, 60)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(839, 61)" end="(839, 65)" leading="" trailing=" " val="else"/>
                <IdentNode start="(839, 66)" end="(839, 70)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(839, 71)" end="(844, 23)">
          <AtomNode start="(839, 71)" end="(839, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(839, 74)" end="(844, 23)">
            <AtomNode start="(839, 74)" end="(839, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(840, 3)" end="(844, 23)">
              <TacticTacticseq1IndentedNode start="(840, 3)" end="(844, 23)">
                <NullNode start="(840, 3)" end="(844, 23)">
                  <OtherNode start="(840, 3)" end="(844, 23)" kind="Lean.Parser.Tactic.cases" state_before="n : Nat&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ findIdx? p (replicate n a) = if 0 &amp;lt; n ∧ p a = true then some 0 else none" state_after="no goals" tactic="cases n with&#10;| zero =&amp;gt; simp&#10;| succ n =&amp;gt;&#10;  simp only [replicate, findIdx?_cons, Nat.zero_add, zero_lt_succ, true_and]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(840, 3)" end="(840, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(840, 9)" end="(840, 10)">
                      <OtherNode start="(840, 9)" end="(840, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(840, 9)" end="(840, 10)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(840, 11)" end="(844, 23)">
                      <OtherNode start="(840, 11)" end="(844, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(840, 11)" end="(840, 15)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(841, 3)" end="(844, 23)">
                          <OtherNode start="(841, 3)" end="(841, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(841, 3)" end="(841, 9)">
                              <OtherNode start="(841, 3)" end="(841, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(841, 3)" end="(841, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(841, 5)" end="(841, 9)">
                                  <NullNode/>
                                  <IdentNode start="(841, 5)" end="(841, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(841, 10)" end="(841, 17)">
                              <AtomNode start="(841, 10)" end="(841, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(841, 13)" end="(841, 17)">
                                <TacticTacticseq1IndentedNode start="(841, 13)" end="(841, 17)">
                                  <NullNode start="(841, 13)" end="(841, 17)">
                                    <OtherNode start="(841, 13)" end="(841, 17)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;⊢ findIdx? p (replicate 0 a) = if 0 &amp;lt; 0 ∧ p a = true then some 0 else none" state_after="no goals" tactic="simp">
                                      <AtomNode start="(841, 13)" end="(841, 17)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(842, 3)" end="(844, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(842, 3)" end="(842, 11)">
                              <OtherNode start="(842, 3)" end="(842, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(842, 3)" end="(842, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(842, 5)" end="(842, 9)">
                                  <NullNode/>
                                  <IdentNode start="(842, 5)" end="(842, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(842, 10)" end="(842, 11)">
                                  <IdentNode start="(842, 10)" end="(842, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(842, 12)" end="(844, 23)">
                              <AtomNode start="(842, 12)" end="(842, 14)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(843, 5)" end="(844, 23)">
                                <TacticTacticseq1IndentedNode start="(843, 5)" end="(844, 23)">
                                  <NullNode start="(843, 5)" end="(844, 23)">
                                    <OtherNode start="(843, 5)" end="(843, 79)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;n : Nat&#10;⊢ findIdx? p (replicate (n + 1) a) = if 0 &amp;lt; n + 1 ∧ p a = true then some 0 else none" state_after="case succ&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;n : Nat&#10;⊢ (if p a = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p (replicate n a))) =&#10;    if p a = true then some 0 else none" tactic="simp only [replicate, findIdx?_cons, Nat.zero_add, zero_lt_succ, true_and]">
                                      <AtomNode start="(843, 5)" end="(843, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(843, 10)" end="(843, 14)">
                                        <AtomNode start="(843, 10)" end="(843, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(843, 15)" end="(843, 79)">
                                        <AtomNode start="(843, 15)" end="(843, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(843, 16)" end="(843, 78)">
                                          <OtherNode start="(843, 16)" end="(843, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(843, 16)" end="(843, 25)" leading="" trailing="" raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(843, 25)" end="(843, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(843, 27)" end="(843, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(843, 27)" end="(843, 40)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(843, 40)" end="(843, 41)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(843, 42)" end="(843, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(843, 42)" end="(843, 54)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(843, 54)" end="(843, 55)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(843, 56)" end="(843, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(843, 56)" end="(843, 68)" leading="" trailing="" raw_val="zero_lt_succ" val="zero_lt_succ" full_name="Nat.zero_lt_succ" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(843, 68)" end="(843, 69)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(843, 70)" end="(843, 78)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(843, 70)" end="(843, 78)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(843, 78)" end="(843, 79)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(844, 5)" end="(844, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;α✝ : Type u_1&#10;a : α✝&#10;p : α✝ → Bool&#10;n : Nat&#10;⊢ (if p a = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p (replicate n a))) =&#10;    if p a = true then some 0 else none" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(844, 5)" end="(844, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(844, 5)" end="(844, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(844, 11)" end="(844, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(844, 15)" end="(844, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(844, 15)" end="(844, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(846, 1)" end="(856, 46)" name="findIdx?_eq_findSome?_zipIdx" full_name="List.findIdx?_eq_findSome?_zipIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(846, 1)" end="(856, 46)" name="findIdx?_eq_findSome?_zipIdx" full_name="List.findIdx?_eq_findSome?_zipIdx" _is_private_decl="False">
        <AtomNode start="(846, 1)" end="(846, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(846, 9)" end="(846, 37)">
          <IdentNode start="(846, 9)" end="(846, 37)" leading="" trailing=" " raw_val="findIdx?_eq_findSome?_zipIdx" val="findIdx?_eq_findSome?_zipIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(846, 38)" end="(847, 83)">
          <NullNode start="(846, 38)" end="(846, 66)">
            <OtherNode start="(846, 38)" end="(846, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(846, 38)" end="(846, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(846, 39)" end="(846, 41)">
                <IdentNode start="(846, 39)" end="(846, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(846, 42)" end="(846, 50)">
                <AtomNode start="(846, 42)" end="(846, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(846, 44)" end="(846, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(846, 44)" end="(846, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(846, 49)" end="(846, 50)">
                    <IdentNode start="(846, 49)" end="(846, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(846, 50)" end="(846, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(846, 52)" end="(846, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(846, 52)" end="(846, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(846, 53)" end="(846, 54)">
                <IdentNode start="(846, 53)" end="(846, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(846, 55)" end="(846, 65)">
                <AtomNode start="(846, 55)" end="(846, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(846, 57)" end="(846, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(846, 57)" end="(846, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(846, 59)" end="(846, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(846, 61)" end="(846, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(846, 65)" end="(846, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(846, 67)" end="(847, 83)">
            <AtomNode start="(846, 67)" end="(846, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(847, 5)" end="(847, 83)" kind="«term_=_»">
              <OtherNode start="(847, 5)" end="(847, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(847, 5)" end="(847, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(847, 17)" end="(847, 18)">
                  <IdentNode start="(847, 17)" end="(847, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(847, 19)" end="(847, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(847, 21)" end="(847, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(847, 21)" end="(847, 40)" leading="" trailing=" " raw_val="xs.zipIdx.findSome?" val="xs.zipIdx.findSome?"/>
                <NullNode start="(847, 41)" end="(847, 83)">
                  <OtherNode start="(847, 41)" end="(847, 83)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(847, 41)" end="(847, 44)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(847, 45)" end="(847, 83)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(847, 45)" end="(847, 51)">
                        <OtherNode start="(847, 45)" end="(847, 51)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(847, 45)" end="(847, 46)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(847, 46)" end="(847, 50)">
                            <IdentNode start="(847, 46)" end="(847, 47)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(847, 47)" end="(847, 48)" leading="" trailing=" " val=","/>
                            <IdentNode start="(847, 49)" end="(847, 50)" leading="" trailing="" raw_val="i" val="i"/>
                          </NullNode>
                          <AtomNode start="(847, 50)" end="(847, 51)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(847, 52)" end="(847, 54)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(847, 55)" end="(847, 83)" kind="termIfThenElse">
                        <AtomNode start="(847, 55)" end="(847, 57)" leading="" trailing=" " val="if"/>
                        <OtherNode start="(847, 58)" end="(847, 61)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(847, 58)" end="(847, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(847, 60)" end="(847, 61)">
                            <IdentNode start="(847, 60)" end="(847, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(847, 62)" end="(847, 66)" leading="" trailing=" " val="then"/>
                        <OtherNode start="(847, 67)" end="(847, 73)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(847, 67)" end="(847, 71)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(847, 72)" end="(847, 73)">
                            <IdentNode start="(847, 72)" end="(847, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(847, 74)" end="(847, 78)" leading="" trailing=" " val="else"/>
                        <IdentNode start="(847, 79)" end="(847, 83)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(847, 84)" end="(856, 46)">
          <AtomNode start="(847, 84)" end="(847, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(847, 87)" end="(856, 46)">
            <AtomNode start="(847, 87)" end="(847, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(848, 3)" end="(856, 46)">
              <TacticTacticseq1IndentedNode start="(848, 3)" end="(856, 46)">
                <NullNode start="(848, 3)" end="(856, 46)">
                  <OtherNode start="(848, 3)" end="(856, 46)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons, Nat.zero_add, zipIdx]&#10;  split&#10;  · simp_all&#10;  · simp_all only [zipIdx_cons, ite_false, Option.isNone_none, findSome?_cons_of_isNone, reduceCtorEq]&#10;    rw [← map_snd_add_zipIdx_eq_zipIdx (n := 1) (k := 0)]&#10;    simp [Function.comp_def, findSome?_map]">
                    <AtomNode start="(848, 3)" end="(848, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(848, 13)" end="(848, 15)">
                      <OtherNode start="(848, 13)" end="(848, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(848, 13)" end="(848, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(848, 16)" end="(856, 46)">
                      <OtherNode start="(848, 16)" end="(856, 46)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(848, 16)" end="(848, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(849, 3)" end="(856, 46)">
                          <OtherNode start="(849, 3)" end="(849, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(849, 3)" end="(849, 8)">
                              <OtherNode start="(849, 3)" end="(849, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(849, 3)" end="(849, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(849, 5)" end="(849, 8)">
                                  <NullNode/>
                                  <IdentNode start="(849, 5)" end="(849, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(849, 9)" end="(849, 16)">
                              <AtomNode start="(849, 9)" end="(849, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(849, 12)" end="(849, 16)">
                                <TacticTacticseq1IndentedNode start="(849, 12)" end="(849, 16)">
                                  <NullNode start="(849, 12)" end="(849, 16)">
                                    <OtherNode start="(849, 12)" end="(849, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx? p [] =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      [].zipIdx" state_after="no goals" tactic="simp">
                                      <AtomNode start="(849, 12)" end="(849, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(850, 3)" end="(856, 46)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(850, 3)" end="(850, 17)">
                              <OtherNode start="(850, 3)" end="(850, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(850, 3)" end="(850, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(850, 5)" end="(850, 9)">
                                  <NullNode/>
                                  <IdentNode start="(850, 5)" end="(850, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(850, 10)" end="(850, 17)">
                                  <IdentNode start="(850, 10)" end="(850, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(850, 12)" end="(850, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(850, 15)" end="(850, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(850, 18)" end="(856, 46)">
                              <AtomNode start="(850, 18)" end="(850, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(851, 5)" end="(856, 46)">
                                <TacticTacticseq1IndentedNode start="(851, 5)" end="(856, 46)">
                                  <NullNode start="(851, 5)" end="(856, 46)">
                                    <OtherNode start="(851, 5)" end="(851, 52)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;⊢ findIdx? p (x :: xs) =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      (x :: xs).zipIdx" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" tactic="simp only [findIdx?_cons, Nat.zero_add, zipIdx]">
                                      <AtomNode start="(851, 5)" end="(851, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(851, 10)" end="(851, 14)">
                                        <AtomNode start="(851, 10)" end="(851, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(851, 15)" end="(851, 52)">
                                        <AtomNode start="(851, 15)" end="(851, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(851, 16)" end="(851, 51)">
                                          <OtherNode start="(851, 16)" end="(851, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(851, 16)" end="(851, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(851, 29)" end="(851, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(851, 31)" end="(851, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(851, 31)" end="(851, 43)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(851, 43)" end="(851, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(851, 45)" end="(851, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(851, 45)" end="(851, 51)" leading="" trailing="" raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(851, 51)" end="(851, 52)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(852, 5)" end="(852, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : p x = true&#10;⊢ some 0 = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" tactic="split">
                                      <AtomNode start="(852, 5)" end="(852, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(853, 5)" end="(853, 15)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : p x = true&#10;⊢ some 0 = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" tactic="· simp_all">
                                      <OtherNode start="(853, 5)" end="(853, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(853, 5)" end="(853, 6)" kind="patternIgnore">
                                          <OtherNode start="(853, 5)" end="(853, 6)" kind="token.«· »">
                                            <AtomNode start="(853, 5)" end="(853, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(853, 7)" end="(853, 15)">
                                        <TacticTacticseq1IndentedNode start="(853, 7)" end="(853, 15)">
                                          <NullNode start="(853, 7)" end="(853, 15)">
                                            <OtherNode start="(853, 7)" end="(853, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : p x = true&#10;⊢ some 0 = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(853, 7)" end="(853, 15)" leading="" trailing="&#10;    " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(854, 5)" end="(856, 46)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" state_after="no goals" tactic="· simp_all only [zipIdx_cons, ite_false, Option.isNone_none, findSome?_cons_of_isNone, reduceCtorEq]&#10;  rw [← map_snd_add_zipIdx_eq_zipIdx (n := 1) (k := 0)]&#10;  simp [Function.comp_def, findSome?_map]">
                                      <OtherNode start="(854, 5)" end="(854, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(854, 5)" end="(854, 6)" kind="patternIgnore">
                                          <OtherNode start="(854, 5)" end="(854, 6)" kind="token.«· »">
                                            <AtomNode start="(854, 5)" end="(854, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(854, 7)" end="(856, 46)">
                                        <TacticTacticseq1IndentedNode start="(854, 7)" end="(856, 46)">
                                          <NullNode start="(854, 7)" end="(856, 46)">
                                            <OtherNode start="(854, 7)" end="(854, 105)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    findSome?&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | (a, i) =&amp;gt; if p a = true then some i else none)&#10;      xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) ((x, 0) :: xs.zipIdx 1)" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) (xs.zipIdx 1)" tactic="simp_all only [zipIdx_cons, ite_false, Option.isNone_none, findSome?_cons_of_isNone, reduceCtorEq]">
                                              <AtomNode start="(854, 7)" end="(854, 15)" leading="" trailing=" " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(854, 16)" end="(854, 20)">
                                                <AtomNode start="(854, 16)" end="(854, 20)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(854, 21)" end="(854, 105)">
                                                <AtomNode start="(854, 21)" end="(854, 22)" leading="" trailing="" val="["/>
                                                <NullNode start="(854, 22)" end="(854, 104)">
                                                  <OtherNode start="(854, 22)" end="(854, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(854, 22)" end="(854, 33)" leading="" trailing="" raw_val="zipIdx_cons" val="zipIdx_cons" full_name="List.zipIdx_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(854, 33)" end="(854, 34)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(854, 35)" end="(854, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(854, 35)" end="(854, 44)" leading="" trailing="" raw_val="ite_false" val="ite_false" full_name="ite_false" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(854, 44)" end="(854, 45)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(854, 46)" end="(854, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(854, 46)" end="(854, 64)" leading="" trailing="" raw_val="Option.isNone_none" val="Option.isNone_none" full_name="Option.isNone_none" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(854, 64)" end="(854, 65)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(854, 66)" end="(854, 90)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(854, 66)" end="(854, 90)" leading="" trailing="" raw_val="findSome?_cons_of_isNone" val="findSome?_cons_of_isNone" full_name="List.findSome?_cons_of_isNone" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(35, 17)" def_end="(35, 41)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(854, 90)" end="(854, 91)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(854, 92)" end="(854, 104)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(854, 92)" end="(854, 104)" leading="" trailing="" raw_val="reduceCtorEq" val="reduceCtorEq"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(854, 104)" end="(854, 105)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(855, 7)" end="(855, 60)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) (xs.zipIdx 1)" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) (map (Prod.map id fun x =&amp;gt; x + 1) xs.zipIdx)" tactic="rw [← map_snd_add_zipIdx_eq_zipIdx (n := 1) (k := 0)]">
                                              <AtomNode start="(855, 7)" end="(855, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(855, 10)" end="(855, 60)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(855, 10)" end="(855, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(855, 11)" end="(855, 59)">
                                                  <OtherNode start="(855, 11)" end="(855, 59)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode start="(855, 11)" end="(855, 12)">
                                                      <OtherNode start="(855, 11)" end="(855, 12)" kind="patternIgnore">
                                                        <OtherNode start="(855, 11)" end="(855, 12)" kind="token.«← »">
                                                          <AtomNode start="(855, 11)" end="(855, 12)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <OtherNode start="(855, 13)" end="(855, 59)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(855, 13)" end="(855, 41)" leading="" trailing=" " raw_val="map_snd_add_zipIdx_eq_zipIdx" val="map_snd_add_zipIdx_eq_zipIdx" full_name="List.map_snd_add_zipIdx_eq_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                                      <NullNode start="(855, 42)" end="(855, 59)">
                                                        <OtherNode start="(855, 42)" end="(855, 50)" kind="Lean.Parser.Term.namedArgument">
                                                          <AtomNode start="(855, 42)" end="(855, 43)" leading="" trailing="" val="("/>
                                                          <IdentNode start="(855, 43)" end="(855, 44)" leading="" trailing=" " raw_val="n" val="n"/>
                                                          <AtomNode start="(855, 45)" end="(855, 47)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(855, 48)" end="(855, 49)" kind="num">
                                                            <AtomNode start="(855, 48)" end="(855, 49)" leading="" trailing="" val="1"/>
                                                          </OtherNode>
                                                          <AtomNode start="(855, 49)" end="(855, 50)" leading="" trailing=" " val=")"/>
                                                        </OtherNode>
                                                        <OtherNode start="(855, 51)" end="(855, 59)" kind="Lean.Parser.Term.namedArgument">
                                                          <AtomNode start="(855, 51)" end="(855, 52)" leading="" trailing="" val="("/>
                                                          <IdentNode start="(855, 52)" end="(855, 53)" leading="" trailing=" " raw_val="k" val="k"/>
                                                          <AtomNode start="(855, 54)" end="(855, 56)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(855, 57)" end="(855, 58)" kind="num">
                                                            <AtomNode start="(855, 57)" end="(855, 58)" leading="" trailing="" val="0"/>
                                                          </OtherNode>
                                                          <AtomNode start="(855, 58)" end="(855, 59)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(855, 59)" end="(855, 60)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(856, 7)" end="(856, 46)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx? p xs = findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) xs.zipIdx) =&#10;    findSome? (fun x =&amp;gt; if p x.fst = true then some x.snd else none) (map (Prod.map id fun x =&amp;gt; x + 1) xs.zipIdx)" state_after="no goals" tactic="simp [Function.comp_def, findSome?_map]">
                                              <AtomNode start="(856, 7)" end="(856, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(856, 12)" end="(856, 46)">
                                                <AtomNode start="(856, 12)" end="(856, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(856, 13)" end="(856, 45)">
                                                  <OtherNode start="(856, 13)" end="(856, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(856, 13)" end="(856, 30)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(856, 30)" end="(856, 31)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(856, 32)" end="(856, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(856, 32)" end="(856, 45)" leading="" trailing="" raw_val="findSome?_map" val="findSome?_map" full_name="List.findSome?_map" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(133, 9)" def_end="(133, 22)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(856, 45)" end="(856, 46)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(858, 1)" end="(867, 34)" name="findIdx?_eq_fst_find?_zipIdx" full_name="List.findIdx?_eq_fst_find?_zipIdx">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(858, 1)" end="(867, 34)" name="findIdx?_eq_fst_find?_zipIdx" full_name="List.findIdx?_eq_fst_find?_zipIdx" _is_private_decl="False">
        <AtomNode start="(858, 1)" end="(858, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(858, 9)" end="(858, 37)">
          <IdentNode start="(858, 9)" end="(858, 37)" leading="" trailing=" " raw_val="findIdx?_eq_fst_find?_zipIdx" val="findIdx?_eq_fst_find?_zipIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(858, 38)" end="(859, 66)">
          <NullNode start="(858, 38)" end="(858, 66)">
            <OtherNode start="(858, 38)" end="(858, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(858, 38)" end="(858, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(858, 39)" end="(858, 41)">
                <IdentNode start="(858, 39)" end="(858, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(858, 42)" end="(858, 50)">
                <AtomNode start="(858, 42)" end="(858, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(858, 44)" end="(858, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(858, 44)" end="(858, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(858, 49)" end="(858, 50)">
                    <IdentNode start="(858, 49)" end="(858, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(858, 50)" end="(858, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(858, 52)" end="(858, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(858, 52)" end="(858, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(858, 53)" end="(858, 54)">
                <IdentNode start="(858, 53)" end="(858, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(858, 55)" end="(858, 65)">
                <AtomNode start="(858, 55)" end="(858, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(858, 57)" end="(858, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(858, 57)" end="(858, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(858, 59)" end="(858, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(858, 61)" end="(858, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(858, 65)" end="(858, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(858, 67)" end="(859, 66)">
            <AtomNode start="(858, 67)" end="(858, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(859, 5)" end="(859, 66)" kind="«term_=_»">
              <OtherNode start="(859, 5)" end="(859, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(859, 5)" end="(859, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(859, 17)" end="(859, 18)">
                  <IdentNode start="(859, 17)" end="(859, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(859, 19)" end="(859, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(859, 21)" end="(859, 66)" kind="Lean.Parser.Term.app">
                <OtherNode start="(859, 21)" end="(859, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(859, 21)" end="(859, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(859, 21)" end="(859, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(859, 22)" end="(859, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(859, 22)" end="(859, 37)" leading="" trailing=" " raw_val="xs.zipIdx.find?" val="xs.zipIdx.find?"/>
                      <NullNode start="(859, 38)" end="(859, 55)">
                        <OtherNode start="(859, 38)" end="(859, 55)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(859, 38)" end="(859, 41)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(859, 42)" end="(859, 55)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(859, 42)" end="(859, 48)">
                              <OtherNode start="(859, 42)" end="(859, 48)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(859, 42)" end="(859, 43)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(859, 43)" end="(859, 47)">
                                  <IdentNode start="(859, 43)" end="(859, 44)" leading="" trailing="" raw_val="x" val="x"/>
                                  <AtomNode start="(859, 44)" end="(859, 45)" leading="" trailing=" " val=","/>
                                  <TermHoleNode start="(859, 46)" end="(859, 47)">
                                    <AtomNode start="(859, 46)" end="(859, 47)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </NullNode>
                                <AtomNode start="(859, 47)" end="(859, 48)" leading="" trailing=" " val="⟩"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(859, 49)" end="(859, 51)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(859, 52)" end="(859, 55)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(859, 52)" end="(859, 53)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(859, 54)" end="(859, 55)">
                                <IdentNode start="(859, 54)" end="(859, 55)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(859, 55)" end="(859, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(859, 56)" end="(859, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(859, 57)" end="(859, 60)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(859, 61)" end="(859, 66)">
                  <OtherNode start="(859, 61)" end="(859, 66)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(859, 61)" end="(859, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(859, 62)" end="(859, 65)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(859, 62)" end="(859, 63)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(859, 62)" end="(859, 63)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(859, 63)" end="(859, 64)" leading="" trailing="" val="."/>
                      <OtherNode start="(859, 64)" end="(859, 65)" kind="fieldIdx">
                        <AtomNode start="(859, 64)" end="(859, 65)" leading="" trailing="" val="2"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(859, 65)" end="(859, 66)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(859, 67)" end="(867, 34)">
          <AtomNode start="(859, 67)" end="(859, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(859, 70)" end="(867, 34)">
            <AtomNode start="(859, 70)" end="(859, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(860, 3)" end="(867, 34)">
              <TacticTacticseq1IndentedNode start="(860, 3)" end="(867, 34)">
                <NullNode start="(860, 3)" end="(867, 34)">
                  <OtherNode start="(860, 3)" end="(867, 34)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx?_cons, Nat.zero_add, zipIdx_cons]&#10;  split&#10;  · simp_all&#10;  · rw [ih, ← map_snd_add_zipIdx_eq_zipIdx (n := 1) (k := 0)]&#10;    simp [Function.comp_def, *]">
                    <AtomNode start="(860, 3)" end="(860, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(860, 13)" end="(860, 15)">
                      <OtherNode start="(860, 13)" end="(860, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(860, 13)" end="(860, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(860, 16)" end="(867, 34)">
                      <OtherNode start="(860, 16)" end="(867, 34)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(860, 16)" end="(860, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(861, 3)" end="(867, 34)">
                          <OtherNode start="(861, 3)" end="(861, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(861, 3)" end="(861, 8)">
                              <OtherNode start="(861, 3)" end="(861, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(861, 3)" end="(861, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(861, 5)" end="(861, 8)">
                                  <NullNode/>
                                  <IdentNode start="(861, 5)" end="(861, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(861, 9)" end="(861, 16)">
                              <AtomNode start="(861, 9)" end="(861, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(861, 12)" end="(861, 16)">
                                <TacticTacticseq1IndentedNode start="(861, 12)" end="(861, 16)">
                                  <NullNode start="(861, 12)" end="(861, 16)">
                                    <OtherNode start="(861, 12)" end="(861, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx? p [] =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        [].zipIdx)" state_after="no goals" tactic="simp">
                                      <AtomNode start="(861, 12)" end="(861, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(862, 3)" end="(867, 34)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(862, 3)" end="(862, 17)">
                              <OtherNode start="(862, 3)" end="(862, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(862, 3)" end="(862, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(862, 5)" end="(862, 9)">
                                  <NullNode/>
                                  <IdentNode start="(862, 5)" end="(862, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(862, 10)" end="(862, 17)">
                                  <IdentNode start="(862, 10)" end="(862, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(862, 12)" end="(862, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(862, 15)" end="(862, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(862, 18)" end="(867, 34)">
                              <AtomNode start="(862, 18)" end="(862, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(863, 5)" end="(867, 34)">
                                <TacticTacticseq1IndentedNode start="(863, 5)" end="(867, 34)">
                                  <NullNode start="(863, 5)" end="(867, 34)">
                                    <OtherNode start="(863, 5)" end="(863, 57)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;⊢ findIdx? p (x :: xs) =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        (x :: xs).zipIdx)" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" tactic="simp only [findIdx?_cons, Nat.zero_add, zipIdx_cons]">
                                      <AtomNode start="(863, 5)" end="(863, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(863, 10)" end="(863, 14)">
                                        <AtomNode start="(863, 10)" end="(863, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(863, 15)" end="(863, 57)">
                                        <AtomNode start="(863, 15)" end="(863, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(863, 16)" end="(863, 56)">
                                          <OtherNode start="(863, 16)" end="(863, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(863, 16)" end="(863, 29)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                          <AtomNode start="(863, 29)" end="(863, 30)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(863, 31)" end="(863, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(863, 31)" end="(863, 43)" leading="" trailing="" raw_val="Nat.zero_add" val="Nat.zero_add" full_name="Nat.zero_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(863, 43)" end="(863, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(863, 45)" end="(863, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(863, 45)" end="(863, 56)" leading="" trailing="" raw_val="zipIdx_cons" val="zipIdx_cons" full_name="List.zipIdx_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(863, 56)" end="(863, 57)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(864, 5)" end="(864, 10)" kind="Lean.Parser.Tactic.split" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" state_after="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : p x = true&#10;⊢ some 0 = Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" tactic="split">
                                      <AtomNode start="(864, 5)" end="(864, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(865, 5)" end="(865, 15)" kind="Lean.cdot" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : p x = true&#10;⊢ some 0 = Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))&#10;&#10;case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" tactic="· simp_all">
                                      <OtherNode start="(865, 5)" end="(865, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(865, 5)" end="(865, 6)" kind="patternIgnore">
                                          <OtherNode start="(865, 5)" end="(865, 6)" kind="token.«· »">
                                            <AtomNode start="(865, 5)" end="(865, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(865, 7)" end="(865, 15)">
                                        <TacticTacticseq1IndentedNode start="(865, 7)" end="(865, 15)">
                                          <NullNode start="(865, 7)" end="(865, 15)">
                                            <OtherNode start="(865, 7)" end="(865, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : p x = true&#10;⊢ some 0 = Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" state_after="no goals" tactic="simp_all">
                                              <AtomNode start="(865, 7)" end="(865, 15)" leading="" trailing="&#10;    " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(866, 5)" end="(867, 34)" kind="Lean.cdot" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" state_after="no goals" tactic="· rw [ih, ← map_snd_add_zipIdx_eq_zipIdx (n := 1) (k := 0)]&#10;  simp [Function.comp_def, *]">
                                      <OtherNode start="(866, 5)" end="(866, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(866, 5)" end="(866, 6)" kind="patternIgnore">
                                          <OtherNode start="(866, 5)" end="(866, 6)" kind="token.«· »">
                                            <AtomNode start="(866, 5)" end="(866, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(866, 7)" end="(867, 34)">
                                        <TacticTacticseq1IndentedNode start="(866, 7)" end="(867, 34)">
                                          <NullNode start="(866, 7)" end="(867, 34)">
                                            <OtherNode start="(866, 7)" end="(866, 64)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: xs.zipIdx 1))" state_after="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1)&#10;      (Option.map (fun x =&amp;gt; x.snd)&#10;        (find?&#10;          (fun x =&amp;gt;&#10;            match x with&#10;            | (x, snd) =&amp;gt; p x)&#10;          xs.zipIdx)) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: map (Prod.map id fun x =&amp;gt; x + 1) xs.zipIdx))" tactic="rw [ih, ← map_snd_add_zipIdx_eq_zipIdx (n := 1) (k := 0)]">
                                              <AtomNode start="(866, 7)" end="(866, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(866, 10)" end="(866, 64)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(866, 10)" end="(866, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(866, 11)" end="(866, 63)">
                                                  <OtherNode start="(866, 11)" end="(866, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(866, 11)" end="(866, 13)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                  </OtherNode>
                                                  <AtomNode start="(866, 13)" end="(866, 14)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(866, 15)" end="(866, 63)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode start="(866, 15)" end="(866, 16)">
                                                      <OtherNode start="(866, 15)" end="(866, 16)" kind="patternIgnore">
                                                        <OtherNode start="(866, 15)" end="(866, 16)" kind="token.«← »">
                                                          <AtomNode start="(866, 15)" end="(866, 16)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <OtherNode start="(866, 17)" end="(866, 63)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(866, 17)" end="(866, 45)" leading="" trailing=" " raw_val="map_snd_add_zipIdx_eq_zipIdx" val="map_snd_add_zipIdx_eq_zipIdx" full_name="List.map_snd_add_zipIdx_eq_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                                      <NullNode start="(866, 46)" end="(866, 63)">
                                                        <OtherNode start="(866, 46)" end="(866, 54)" kind="Lean.Parser.Term.namedArgument">
                                                          <AtomNode start="(866, 46)" end="(866, 47)" leading="" trailing="" val="("/>
                                                          <IdentNode start="(866, 47)" end="(866, 48)" leading="" trailing=" " raw_val="n" val="n"/>
                                                          <AtomNode start="(866, 49)" end="(866, 51)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(866, 52)" end="(866, 53)" kind="num">
                                                            <AtomNode start="(866, 52)" end="(866, 53)" leading="" trailing="" val="1"/>
                                                          </OtherNode>
                                                          <AtomNode start="(866, 53)" end="(866, 54)" leading="" trailing=" " val=")"/>
                                                        </OtherNode>
                                                        <OtherNode start="(866, 55)" end="(866, 63)" kind="Lean.Parser.Term.namedArgument">
                                                          <AtomNode start="(866, 55)" end="(866, 56)" leading="" trailing="" val="("/>
                                                          <IdentNode start="(866, 56)" end="(866, 57)" leading="" trailing=" " raw_val="k" val="k"/>
                                                          <AtomNode start="(866, 58)" end="(866, 60)" leading="" trailing=" " val=":="/>
                                                          <OtherNode start="(866, 61)" end="(866, 62)" kind="num">
                                                            <AtomNode start="(866, 61)" end="(866, 62)" leading="" trailing="" val="0"/>
                                                          </OtherNode>
                                                          <AtomNode start="(866, 62)" end="(866, 63)" leading="" trailing="" val=")"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(866, 63)" end="(866, 64)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(867, 7)" end="(867, 34)" kind="Lean.Parser.Tactic.simp" state_before="case cons.isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih :&#10;  findIdx? p xs =&#10;    Option.map (fun x =&amp;gt; x.snd)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | (x, snd) =&amp;gt; p x)&#10;        xs.zipIdx)&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1)&#10;      (Option.map (fun x =&amp;gt; x.snd)&#10;        (find?&#10;          (fun x =&amp;gt;&#10;            match x with&#10;            | (x, snd) =&amp;gt; p x)&#10;          xs.zipIdx)) =&#10;    Option.map (fun x =&amp;gt; x.snd) (find? (fun x =&amp;gt; p x.fst) ((x, 0) :: map (Prod.map id fun x =&amp;gt; x + 1) xs.zipIdx))" state_after="no goals" tactic="simp [Function.comp_def, *]">
                                              <AtomNode start="(867, 7)" end="(867, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(867, 12)" end="(867, 34)">
                                                <AtomNode start="(867, 12)" end="(867, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(867, 13)" end="(867, 33)">
                                                  <OtherNode start="(867, 13)" end="(867, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(867, 13)" end="(867, 30)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(867, 30)" end="(867, 31)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(867, 32)" end="(867, 33)" kind="Lean.Parser.Tactic.simpStar">
                                                    <AtomNode start="(867, 32)" end="(867, 33)" leading="" trailing="" val="*"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(867, 33)" end="(867, 34)" leading="" trailing="&#10;&#10;-- See also `findIdx_le_findIdx`.&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(870, 1)" end="(879, 13)" name="findIdx?_eq_none_of_findIdx?_eq_none" full_name="List.findIdx?_eq_none_of_findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(870, 1)" end="(879, 13)" name="findIdx?_eq_none_of_findIdx?_eq_none" full_name="List.findIdx?_eq_none_of_findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(870, 1)" end="(870, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(870, 9)" end="(870, 45)">
          <IdentNode start="(870, 9)" end="(870, 45)" leading="" trailing=" " raw_val="findIdx?_eq_none_of_findIdx?_eq_none" val="findIdx?_eq_none_of_findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(870, 46)" end="(871, 48)">
          <NullNode start="(870, 46)" end="(870, 102)">
            <OtherNode start="(870, 46)" end="(870, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(870, 46)" end="(870, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(870, 47)" end="(870, 49)">
                <IdentNode start="(870, 47)" end="(870, 49)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(870, 50)" end="(870, 58)">
                <AtomNode start="(870, 50)" end="(870, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(870, 52)" end="(870, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(870, 52)" end="(870, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(870, 57)" end="(870, 58)">
                    <IdentNode start="(870, 57)" end="(870, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(870, 58)" end="(870, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(870, 60)" end="(870, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(870, 60)" end="(870, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(870, 61)" end="(870, 64)">
                <IdentNode start="(870, 61)" end="(870, 62)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(870, 63)" end="(870, 64)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(870, 65)" end="(870, 75)">
                <AtomNode start="(870, 65)" end="(870, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(870, 67)" end="(870, 75)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(870, 67)" end="(870, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(870, 69)" end="(870, 70)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(870, 71)" end="(870, 75)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(870, 75)" end="(870, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(870, 77)" end="(870, 102)">
              <AtomNode start="(870, 77)" end="(870, 78)" leading="" trailing="" val="("/>
              <NullNode start="(870, 78)" end="(870, 79)">
                <IdentNode start="(870, 78)" end="(870, 79)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(870, 80)" end="(870, 101)">
                <AtomNode start="(870, 80)" end="(870, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(870, 82)" end="(870, 101)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(870, 82)" end="(870, 83)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(870, 84)" end="(870, 85)">
                    <IdentNode start="(870, 84)" end="(870, 85)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(870, 86)" end="(870, 90)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(870, 86)" end="(870, 87)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(870, 88)" end="(870, 90)" leading="" trailing="" raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(870, 90)" end="(870, 91)" leading="" trailing=" " val=","/>
                  <OtherNode start="(870, 92)" end="(870, 101)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(870, 92)" end="(870, 95)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(870, 92)" end="(870, 93)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(870, 94)" end="(870, 95)">
                        <IdentNode start="(870, 94)" end="(870, 95)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(870, 96)" end="(870, 97)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(870, 98)" end="(870, 101)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(870, 98)" end="(870, 99)" leading="" trailing=" " raw_val="q" val="q"/>
                      <NullNode start="(870, 100)" end="(870, 101)">
                        <IdentNode start="(870, 100)" end="(870, 101)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(870, 101)" end="(870, 102)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(870, 103)" end="(871, 48)">
            <AtomNode start="(870, 103)" end="(870, 104)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(871, 5)" end="(871, 48)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(871, 5)" end="(871, 25)" kind="«term_=_»">
                <OtherNode start="(871, 5)" end="(871, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(871, 5)" end="(871, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(871, 17)" end="(871, 18)">
                    <IdentNode start="(871, 17)" end="(871, 18)" leading="" trailing=" " raw_val="q" val="q"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(871, 19)" end="(871, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(871, 21)" end="(871, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(871, 26)" end="(871, 27)" leading="" trailing=" " val="→"/>
              <OtherNode start="(871, 28)" end="(871, 48)" kind="«term_=_»">
                <OtherNode start="(871, 28)" end="(871, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(871, 28)" end="(871, 39)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                  <NullNode start="(871, 40)" end="(871, 41)">
                    <IdentNode start="(871, 40)" end="(871, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(871, 42)" end="(871, 43)" leading="" trailing=" " val="="/>
                <IdentNode start="(871, 44)" end="(871, 48)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(871, 49)" end="(879, 13)">
          <AtomNode start="(871, 49)" end="(871, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(871, 52)" end="(879, 13)">
            <AtomNode start="(871, 52)" end="(871, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(872, 3)" end="(879, 13)">
              <TacticTacticseq1IndentedNode start="(872, 3)" end="(879, 13)">
                <NullNode start="(872, 3)" end="(879, 13)">
                  <OtherNode start="(872, 3)" end="(872, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;⊢ findIdx? q xs = none → findIdx? p xs = none" state_after="α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;⊢ (∀ (x : α), x ∈ xs → q x = false) → ∀ (x : α), x ∈ xs → p x = false" tactic="simp only [findIdx?_eq_none_iff]">
                    <AtomNode start="(872, 3)" end="(872, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(872, 8)" end="(872, 12)">
                      <AtomNode start="(872, 8)" end="(872, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(872, 13)" end="(872, 35)">
                      <AtomNode start="(872, 13)" end="(872, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(872, 14)" end="(872, 34)">
                        <OtherNode start="(872, 14)" end="(872, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(872, 14)" end="(872, 34)" leading="" trailing="" raw_val="findIdx?_eq_none_iff" val="findIdx?_eq_none_iff" full_name="List.findIdx?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(686, 9)" def_end="(686, 29)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(872, 34)" end="(872, 35)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(873, 3)" end="(873, 14)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;⊢ (∀ (x : α), x ∈ xs → q x = false) → ∀ (x : α), x ∈ xs → p x = false" state_after="α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;⊢ p x = false" tactic="intro h x m">
                    <AtomNode start="(873, 3)" end="(873, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(873, 9)" end="(873, 14)">
                      <IdentNode start="(873, 9)" end="(873, 10)" leading="" trailing=" " raw_val="h" val="h"/>
                      <IdentNode start="(873, 11)" end="(873, 12)" leading="" trailing=" " raw_val="x" val="x"/>
                      <IdentNode start="(873, 13)" end="(873, 14)" leading="" trailing="&#10;  " raw_val="m" val="m"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(874, 3)" end="(874, 16)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;⊢ p x = false" state_after="case false&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = false&#10;⊢ false = false&#10;&#10;case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ true = false" tactic="cases z : p x">
                    <AtomNode start="(874, 3)" end="(874, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(874, 9)" end="(874, 16)">
                      <OtherNode start="(874, 9)" end="(874, 16)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode start="(874, 9)" end="(874, 12)">
                          <LeanBinderidentNode start="(874, 9)" end="(874, 10)">
                            <IdentNode start="(874, 9)" end="(874, 10)" leading="" trailing=" " raw_val="z" val="z"/>
                          </LeanBinderidentNode>
                          <AtomNode start="(874, 11)" end="(874, 12)" leading="" trailing=" " val=":"/>
                        </NullNode>
                        <OtherNode start="(874, 13)" end="(874, 16)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(874, 13)" end="(874, 14)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(874, 15)" end="(874, 16)">
                            <IdentNode start="(874, 15)" end="(874, 16)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(875, 3)" end="(875, 8)" kind="Lean.cdot" state_before="case false&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = false&#10;⊢ false = false&#10;&#10;case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ true = false" state_after="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ true = false" tactic="· rfl">
                    <OtherNode start="(875, 3)" end="(875, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(875, 3)" end="(875, 4)" kind="patternIgnore">
                        <OtherNode start="(875, 3)" end="(875, 4)" kind="token.«· »">
                          <AtomNode start="(875, 3)" end="(875, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(875, 5)" end="(875, 8)">
                      <TacticTacticseq1IndentedNode start="(875, 5)" end="(875, 8)">
                        <NullNode start="(875, 5)" end="(875, 8)">
                          <OtherNode start="(875, 5)" end="(875, 8)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case false&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = false&#10;⊢ false = false" state_after="no goals" tactic="rfl">
                            <AtomNode start="(875, 5)" end="(875, 8)" leading="" trailing="&#10;  " val="rfl"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(876, 3)" end="(879, 13)" kind="Lean.cdot" state_before="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ true = false" state_after="no goals" tactic="· exfalso&#10;  specialize w x m z&#10;  specialize h x m&#10;  simp_all">
                    <OtherNode start="(876, 3)" end="(876, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(876, 3)" end="(876, 4)" kind="patternIgnore">
                        <OtherNode start="(876, 3)" end="(876, 4)" kind="token.«· »">
                          <AtomNode start="(876, 3)" end="(876, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(876, 5)" end="(879, 13)">
                      <TacticTacticseq1IndentedNode start="(876, 5)" end="(879, 13)">
                        <NullNode start="(876, 5)" end="(879, 13)">
                          <OtherNode start="(876, 5)" end="(876, 12)" kind="Lean.Parser.Tactic.tacticExfalso" state_before="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ true = false" state_after="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ False" tactic="exfalso">
                            <AtomNode start="(876, 5)" end="(876, 12)" leading="" trailing="&#10;    " val="exfalso"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(877, 5)" end="(877, 23)" kind="Lean.Parser.Tactic.specialize" state_before="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;w : ∀ (x : α), x ∈ xs → p x = true → q x = true&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;⊢ False" state_after="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;w : q x = true&#10;⊢ False" tactic="specialize w x m z">
                            <AtomNode start="(877, 5)" end="(877, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(877, 16)" end="(877, 23)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(877, 16)" end="(877, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(877, 18)" end="(877, 23)">
                                <IdentNode start="(877, 18)" end="(877, 19)" leading="" trailing=" " raw_val="x" val="x"/>
                                <IdentNode start="(877, 20)" end="(877, 21)" leading="" trailing=" " raw_val="m" val="m"/>
                                <IdentNode start="(877, 22)" end="(877, 23)" leading="" trailing="&#10;    " raw_val="z" val="z"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(878, 5)" end="(878, 21)" kind="Lean.Parser.Tactic.specialize" state_before="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;h : ∀ (x : α), x ∈ xs → q x = false&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;w : q x = true&#10;⊢ False" state_after="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;w : q x = true&#10;h : q x = false&#10;⊢ False" tactic="specialize h x m">
                            <AtomNode start="(878, 5)" end="(878, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(878, 16)" end="(878, 21)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(878, 16)" end="(878, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                              <NullNode start="(878, 18)" end="(878, 21)">
                                <IdentNode start="(878, 18)" end="(878, 19)" leading="" trailing=" " raw_val="x" val="x"/>
                                <IdentNode start="(878, 20)" end="(878, 21)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(879, 5)" end="(879, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case true&#10;α : Type u_1&#10;xs : List α&#10;p q : α → Bool&#10;x : α&#10;m : x ∈ xs&#10;z : p x = true&#10;w : q x = true&#10;h : q x = false&#10;⊢ False" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(879, 5)" end="(879, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(881, 1)" end="(885, 24)" name="Sublist.findIdx?_isSome" full_name="List.Sublist.findIdx?_isSome">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(881, 1)" end="(885, 24)" name="Sublist.findIdx?_isSome" full_name="List.Sublist.findIdx?_isSome" _is_private_decl="False">
        <AtomNode start="(881, 1)" end="(881, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(881, 9)" end="(881, 32)">
          <IdentNode start="(881, 9)" end="(881, 32)" leading="" trailing=" " raw_val="Sublist.findIdx?_isSome" val="Sublist.findIdx?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(881, 33)" end="(882, 52)">
          <NullNode start="(881, 33)" end="(881, 64)">
            <OtherNode start="(881, 33)" end="(881, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(881, 33)" end="(881, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(881, 34)" end="(881, 39)">
                <IdentNode start="(881, 34)" end="(881, 36)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(881, 37)" end="(881, 39)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(881, 40)" end="(881, 48)">
                <AtomNode start="(881, 40)" end="(881, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(881, 42)" end="(881, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(881, 42)" end="(881, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(881, 47)" end="(881, 48)">
                    <IdentNode start="(881, 47)" end="(881, 48)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(881, 48)" end="(881, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(881, 50)" end="(881, 64)">
              <AtomNode start="(881, 50)" end="(881, 51)" leading="" trailing="" val="("/>
              <NullNode start="(881, 51)" end="(881, 52)">
                <IdentNode start="(881, 51)" end="(881, 52)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(881, 53)" end="(881, 63)">
                <AtomNode start="(881, 53)" end="(881, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(881, 55)" end="(881, 63)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(881, 55)" end="(881, 57)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(881, 58)" end="(881, 60)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(881, 61)" end="(881, 63)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(881, 63)" end="(881, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(881, 65)" end="(882, 52)">
            <AtomNode start="(881, 65)" end="(881, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(882, 5)" end="(882, 52)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(882, 5)" end="(882, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(882, 5)" end="(882, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(882, 5)" end="(882, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(882, 6)" end="(882, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(882, 6)" end="(882, 17)" leading="" trailing=" " raw_val="l₁.findIdx?" val="l₁.findIdx?"/>
                    <NullNode start="(882, 18)" end="(882, 19)">
                      <IdentNode start="(882, 18)" end="(882, 19)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(882, 19)" end="(882, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(882, 20)" end="(882, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(882, 21)" end="(882, 27)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(882, 28)" end="(882, 29)" leading="" trailing=" " val="→"/>
              <OtherNode start="(882, 30)" end="(882, 52)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(882, 30)" end="(882, 45)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(882, 30)" end="(882, 31)" leading="" trailing="" val="("/>
                  <OtherNode start="(882, 31)" end="(882, 44)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(882, 31)" end="(882, 42)" leading="" trailing=" " raw_val="l₂.findIdx?" val="l₂.findIdx?"/>
                    <NullNode start="(882, 43)" end="(882, 44)">
                      <IdentNode start="(882, 43)" end="(882, 44)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(882, 44)" end="(882, 45)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(882, 45)" end="(882, 46)" leading="" trailing="" val="."/>
                <IdentNode start="(882, 46)" end="(882, 52)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(882, 53)" end="(885, 24)">
          <AtomNode start="(882, 53)" end="(882, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(882, 56)" end="(885, 24)">
            <AtomNode start="(882, 56)" end="(882, 58)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(883, 3)" end="(885, 24)">
              <TacticTacticseq1IndentedNode start="(883, 3)" end="(885, 24)">
                <NullNode start="(883, 3)" end="(885, 24)">
                  <OtherNode start="(883, 3)" end="(883, 48)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (findIdx? p l₁).isSome = true → (findIdx? p l₂).isSome = true" state_after="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∃ x, x ∈ l₁ ∧ p x = true) → ∃ x, x ∈ l₂ ∧ p x = true" tactic="simp only [List.findIdx?_isSome, any_eq_true]">
                    <AtomNode start="(883, 3)" end="(883, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(883, 8)" end="(883, 12)">
                      <AtomNode start="(883, 8)" end="(883, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(883, 13)" end="(883, 48)">
                      <AtomNode start="(883, 13)" end="(883, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(883, 14)" end="(883, 47)">
                        <OtherNode start="(883, 14)" end="(883, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(883, 14)" end="(883, 34)" leading="" trailing="" raw_val="List.findIdx?_isSome" val="List.findIdx?_isSome" full_name="List.findIdx?_isSome" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(695, 9)" def_end="(695, 24)"/>
                        </OtherNode>
                        <AtomNode start="(883, 34)" end="(883, 35)" leading="" trailing=" " val=","/>
                        <OtherNode start="(883, 36)" end="(883, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(883, 36)" end="(883, 47)" leading="" trailing="" raw_val="any_eq_true" val="any_eq_true" full_name="List.any_eq_true" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(883, 47)" end="(883, 48)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(884, 3)" end="(884, 19)" kind="Lean.Parser.Tactic.rintro" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∃ x, x ∈ l₁ ∧ p x = true) → ∃ x, x ∈ l₂ ∧ p x = true" state_after="case intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;w : α&#10;m : w ∈ l₁&#10;q : p w = true&#10;⊢ ∃ x, x ∈ l₂ ∧ p x = true" tactic="rintro ⟨w, m, q⟩">
                    <AtomNode start="(884, 3)" end="(884, 9)" leading="" trailing=" " val="rintro"/>
                    <NullNode start="(884, 10)" end="(884, 19)">
                      <OtherNode start="(884, 10)" end="(884, 19)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(884, 10)" end="(884, 19)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                          <AtomNode start="(884, 10)" end="(884, 11)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(884, 11)" end="(884, 18)">
                            <OtherNode start="(884, 11)" end="(884, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                              <OtherNode start="(884, 11)" end="(884, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(884, 11)" end="(884, 12)">
                                  <OtherNode start="(884, 11)" end="(884, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(884, 11)" end="(884, 12)" leading="" trailing="" raw_val="w" val="w"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(884, 12)" end="(884, 13)" leading="" trailing=" " val=","/>
                            <OtherNode start="(884, 14)" end="(884, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                              <OtherNode start="(884, 14)" end="(884, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(884, 14)" end="(884, 15)">
                                  <OtherNode start="(884, 14)" end="(884, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(884, 14)" end="(884, 15)" leading="" trailing="" raw_val="m" val="m"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(884, 15)" end="(884, 16)" leading="" trailing=" " val=","/>
                            <OtherNode start="(884, 17)" end="(884, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                              <OtherNode start="(884, 17)" end="(884, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(884, 17)" end="(884, 18)">
                                  <OtherNode start="(884, 17)" end="(884, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                    <IdentNode start="(884, 17)" end="(884, 18)" leading="" trailing="" raw_val="q" val="q"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(884, 18)" end="(884, 19)" leading="" trailing="&#10;  " val="⟩"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(885, 3)" end="(885, 24)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro&#10;α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;w : α&#10;m : w ∈ l₁&#10;q : p w = true&#10;⊢ ∃ x, x ∈ l₂ ∧ p x = true" state_after="no goals" tactic="exact ⟨w, h.mem m, q⟩">
                    <AtomNode start="(885, 3)" end="(885, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(885, 9)" end="(885, 24)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(885, 9)" end="(885, 10)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(885, 10)" end="(885, 23)">
                        <IdentNode start="(885, 10)" end="(885, 11)" leading="" trailing="" raw_val="w" val="w"/>
                        <AtomNode start="(885, 11)" end="(885, 12)" leading="" trailing=" " val=","/>
                        <OtherNode start="(885, 13)" end="(885, 20)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(885, 13)" end="(885, 18)" leading="" trailing=" " raw_val="h.mem" val="h.mem"/>
                          <NullNode start="(885, 19)" end="(885, 20)">
                            <IdentNode start="(885, 19)" end="(885, 20)" leading="" trailing="" raw_val="m" val="m"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(885, 20)" end="(885, 21)" leading="" trailing=" " val=","/>
                        <IdentNode start="(885, 22)" end="(885, 23)" leading="" trailing="" raw_val="q" val="q"/>
                      </NullNode>
                      <AtomNode start="(885, 23)" end="(885, 24)" leading="" trailing="&#10;&#10;" val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(887, 1)" end="(890, 35)" name="Sublist.findIdx?_eq_none" full_name="List.Sublist.findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(887, 1)" end="(890, 35)" name="Sublist.findIdx?_eq_none" full_name="List.Sublist.findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(887, 1)" end="(887, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(887, 9)" end="(887, 33)">
          <IdentNode start="(887, 9)" end="(887, 33)" leading="" trailing=" " raw_val="Sublist.findIdx?_eq_none" val="Sublist.findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(887, 34)" end="(888, 48)">
          <NullNode start="(887, 34)" end="(887, 65)">
            <OtherNode start="(887, 34)" end="(887, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(887, 34)" end="(887, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(887, 35)" end="(887, 40)">
                <IdentNode start="(887, 35)" end="(887, 37)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(887, 38)" end="(887, 40)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(887, 41)" end="(887, 49)">
                <AtomNode start="(887, 41)" end="(887, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(887, 43)" end="(887, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(887, 43)" end="(887, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(887, 48)" end="(887, 49)">
                    <IdentNode start="(887, 48)" end="(887, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(887, 49)" end="(887, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(887, 51)" end="(887, 65)">
              <AtomNode start="(887, 51)" end="(887, 52)" leading="" trailing="" val="("/>
              <NullNode start="(887, 52)" end="(887, 53)">
                <IdentNode start="(887, 52)" end="(887, 53)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(887, 54)" end="(887, 64)">
                <AtomNode start="(887, 54)" end="(887, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(887, 56)" end="(887, 64)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(887, 56)" end="(887, 58)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(887, 59)" end="(887, 61)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(887, 62)" end="(887, 64)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(887, 64)" end="(887, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(887, 66)" end="(888, 48)">
            <AtomNode start="(887, 66)" end="(887, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(888, 5)" end="(888, 48)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(888, 5)" end="(888, 25)" kind="«term_=_»">
                <OtherNode start="(888, 5)" end="(888, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(888, 5)" end="(888, 16)" leading="" trailing=" " raw_val="l₂.findIdx?" val="l₂.findIdx?"/>
                  <NullNode start="(888, 17)" end="(888, 18)">
                    <IdentNode start="(888, 17)" end="(888, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(888, 19)" end="(888, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(888, 21)" end="(888, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(888, 26)" end="(888, 27)" leading="" trailing=" " val="→"/>
              <OtherNode start="(888, 28)" end="(888, 48)" kind="«term_=_»">
                <OtherNode start="(888, 28)" end="(888, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(888, 28)" end="(888, 39)" leading="" trailing=" " raw_val="l₁.findIdx?" val="l₁.findIdx?"/>
                  <NullNode start="(888, 40)" end="(888, 41)">
                    <IdentNode start="(888, 40)" end="(888, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(888, 42)" end="(888, 43)" leading="" trailing=" " val="="/>
                <IdentNode start="(888, 44)" end="(888, 48)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(888, 49)" end="(890, 35)">
          <AtomNode start="(888, 49)" end="(888, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(888, 52)" end="(890, 35)">
            <AtomNode start="(888, 52)" end="(888, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(889, 3)" end="(890, 35)">
              <TacticTacticseq1IndentedNode start="(889, 3)" end="(890, 35)">
                <NullNode start="(889, 3)" end="(890, 35)">
                  <OtherNode start="(889, 3)" end="(889, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ findIdx? p l₂ = none → findIdx? p l₁ = none" state_after="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∀ (x : α), x ∈ l₂ → p x = false) → ∀ (x : α), x ∈ l₁ → p x = false" tactic="simp only [findIdx?_eq_none_iff]">
                    <AtomNode start="(889, 3)" end="(889, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(889, 8)" end="(889, 12)">
                      <AtomNode start="(889, 8)" end="(889, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(889, 13)" end="(889, 35)">
                      <AtomNode start="(889, 13)" end="(889, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(889, 14)" end="(889, 34)">
                        <OtherNode start="(889, 14)" end="(889, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(889, 14)" end="(889, 34)" leading="" trailing="" raw_val="findIdx?_eq_none_iff" val="findIdx?_eq_none_iff" full_name="List.findIdx?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(686, 9)" def_end="(686, 29)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(889, 34)" end="(889, 35)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(890, 3)" end="(890, 35)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;p : α → Bool&#10;l₁ l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (∀ (x : α), x ∈ l₂ → p x = false) → ∀ (x : α), x ∈ l₁ → p x = false" state_after="no goals" tactic="exact fun w x m =&amp;gt; w x (h.mem m)">
                    <AtomNode start="(890, 3)" end="(890, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(890, 9)" end="(890, 35)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(890, 9)" end="(890, 12)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(890, 13)" end="(890, 35)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(890, 13)" end="(890, 18)">
                          <IdentNode start="(890, 13)" end="(890, 14)" leading="" trailing=" " raw_val="w" val="w"/>
                          <IdentNode start="(890, 15)" end="(890, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(890, 17)" end="(890, 18)" leading="" trailing=" " raw_val="m" val="m"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(890, 19)" end="(890, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(890, 22)" end="(890, 35)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(890, 22)" end="(890, 23)" leading="" trailing=" " raw_val="w" val="w"/>
                          <NullNode start="(890, 24)" end="(890, 35)">
                            <IdentNode start="(890, 24)" end="(890, 25)" leading="" trailing=" " raw_val="x" val="x"/>
                            <OtherNode start="(890, 26)" end="(890, 35)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(890, 26)" end="(890, 27)" leading="" trailing="" val="("/>
                              <OtherNode start="(890, 27)" end="(890, 34)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(890, 27)" end="(890, 32)" leading="" trailing=" " raw_val="h.mem" val="h.mem"/>
                                <NullNode start="(890, 33)" end="(890, 34)">
                                  <IdentNode start="(890, 33)" end="(890, 34)" leading="" trailing="" raw_val="m" val="m"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(890, 34)" end="(890, 35)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(892, 1)" end="(897, 28)" name="IsPrefix.findIdx?_eq_some" full_name="List.IsPrefix.findIdx?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(892, 1)" end="(897, 28)" name="IsPrefix.findIdx?_eq_some" full_name="List.IsPrefix.findIdx?_eq_some" _is_private_decl="False">
        <AtomNode start="(892, 1)" end="(892, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(892, 9)" end="(892, 34)">
          <IdentNode start="(892, 9)" end="(892, 34)" leading="" trailing=" " raw_val="IsPrefix.findIdx?_eq_some" val="IsPrefix.findIdx?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(892, 35)" end="(893, 62)">
          <NullNode start="(892, 35)" end="(892, 82)">
            <OtherNode start="(892, 35)" end="(892, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(892, 35)" end="(892, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(892, 36)" end="(892, 41)">
                <IdentNode start="(892, 36)" end="(892, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(892, 39)" end="(892, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(892, 42)" end="(892, 50)">
                <AtomNode start="(892, 42)" end="(892, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(892, 44)" end="(892, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(892, 44)" end="(892, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(892, 49)" end="(892, 50)">
                    <IdentNode start="(892, 49)" end="(892, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(892, 50)" end="(892, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(892, 52)" end="(892, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(892, 52)" end="(892, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(892, 53)" end="(892, 54)">
                <IdentNode start="(892, 53)" end="(892, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(892, 55)" end="(892, 65)">
                <AtomNode start="(892, 55)" end="(892, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(892, 57)" end="(892, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(892, 57)" end="(892, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(892, 59)" end="(892, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(892, 61)" end="(892, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(892, 65)" end="(892, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(892, 67)" end="(892, 82)">
              <AtomNode start="(892, 67)" end="(892, 68)" leading="" trailing="" val="("/>
              <NullNode start="(892, 68)" end="(892, 69)">
                <IdentNode start="(892, 68)" end="(892, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(892, 70)" end="(892, 81)">
                <AtomNode start="(892, 70)" end="(892, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(892, 72)" end="(892, 81)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(892, 72)" end="(892, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(892, 75)" end="(892, 78)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(892, 79)" end="(892, 81)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(892, 81)" end="(892, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(892, 83)" end="(893, 62)">
            <AtomNode start="(892, 83)" end="(892, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(893, 5)" end="(893, 62)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(893, 5)" end="(893, 32)" kind="«term_=_»">
                <OtherNode start="(893, 5)" end="(893, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(893, 5)" end="(893, 18)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(893, 19)" end="(893, 23)">
                    <IdentNode start="(893, 19)" end="(893, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(893, 21)" end="(893, 23)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(893, 24)" end="(893, 25)" leading="" trailing=" " val="="/>
                <OtherNode start="(893, 26)" end="(893, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(893, 26)" end="(893, 30)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(893, 31)" end="(893, 32)">
                    <IdentNode start="(893, 31)" end="(893, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(893, 33)" end="(893, 34)" leading="" trailing=" " val="→"/>
              <OtherNode start="(893, 35)" end="(893, 62)" kind="«term_=_»">
                <OtherNode start="(893, 35)" end="(893, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(893, 35)" end="(893, 48)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(893, 49)" end="(893, 53)">
                    <IdentNode start="(893, 49)" end="(893, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(893, 51)" end="(893, 53)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(893, 54)" end="(893, 55)" leading="" trailing=" " val="="/>
                <OtherNode start="(893, 56)" end="(893, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(893, 56)" end="(893, 60)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(893, 61)" end="(893, 62)">
                    <IdentNode start="(893, 61)" end="(893, 62)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(893, 63)" end="(897, 28)">
          <AtomNode start="(893, 63)" end="(893, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(893, 66)" end="(897, 28)">
            <AtomNode start="(893, 66)" end="(893, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(894, 3)" end="(897, 28)">
              <TacticTacticseq1IndentedNode start="(894, 3)" end="(897, 28)">
                <NullNode start="(894, 3)" end="(897, 28)">
                  <OtherNode start="(894, 3)" end="(894, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;i : Nat&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ findIdx? p l₁ = some i → findIdx? p l₂ = some i" state_after="α : Type u_1&#10;i : Nat&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ findIdx? p l₁ = some i → findIdx? p l₂ = some i" tactic="rw [IsPrefix] at h">
                    <AtomNode start="(894, 3)" end="(894, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(894, 6)" end="(894, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(894, 6)" end="(894, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(894, 7)" end="(894, 15)">
                        <OtherNode start="(894, 7)" end="(894, 15)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(894, 7)" end="(894, 15)" leading="" trailing="" raw_val="IsPrefix" val="IsPrefix" full_name="List.IsPrefix" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(894, 15)" end="(894, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(894, 17)" end="(894, 21)">
                      <OtherNode start="(894, 17)" end="(894, 21)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(894, 17)" end="(894, 19)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(894, 20)" end="(894, 21)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(894, 20)" end="(894, 21)">
                            <IdentNode start="(894, 20)" end="(894, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(895, 3)" end="(895, 23)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;i : Nat&#10;l₁ l₂ : List α&#10;p : α → Bool&#10;h : ∃ t, l₁ ++ t = l₂&#10;⊢ findIdx? p l₁ = some i → findIdx? p l₂ = some i" state_after="case intro&#10;α : Type u_1&#10;i : Nat&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ findIdx? p l₁ = some i → findIdx? p (l₁ ++ t) = some i" tactic="obtain ⟨t, rfl⟩ := h">
                    <AtomNode start="(895, 3)" end="(895, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(895, 10)" end="(895, 18)">
                      <OtherNode start="(895, 10)" end="(895, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(895, 10)" end="(895, 18)">
                          <OtherNode start="(895, 10)" end="(895, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(895, 10)" end="(895, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(895, 11)" end="(895, 17)">
                              <OtherNode start="(895, 11)" end="(895, 12)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(895, 11)" end="(895, 12)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(895, 11)" end="(895, 12)">
                                    <OtherNode start="(895, 11)" end="(895, 12)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(895, 11)" end="(895, 12)" leading="" trailing="" raw_val="t" val="t"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(895, 12)" end="(895, 13)" leading="" trailing=" " val=","/>
                              <OtherNode start="(895, 14)" end="(895, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(895, 14)" end="(895, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(895, 14)" end="(895, 17)">
                                    <OtherNode start="(895, 14)" end="(895, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(895, 14)" end="(895, 17)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(895, 17)" end="(895, 18)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(895, 19)" end="(895, 23)">
                      <AtomNode start="(895, 19)" end="(895, 21)" leading="" trailing=" " val=":="/>
                      <NullNode start="(895, 22)" end="(895, 23)">
                        <IdentNode start="(895, 22)" end="(895, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(896, 3)" end="(896, 10)" kind="Lean.Parser.Tactic.intro" state_before="case intro&#10;α : Type u_1&#10;i : Nat&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;⊢ findIdx? p l₁ = some i → findIdx? p (l₁ ++ t) = some i" state_after="case intro&#10;α : Type u_1&#10;i : Nat&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h : findIdx? p l₁ = some i&#10;⊢ findIdx? p (l₁ ++ t) = some i" tactic="intro h">
                    <AtomNode start="(896, 3)" end="(896, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(896, 9)" end="(896, 10)">
                      <IdentNode start="(896, 9)" end="(896, 10)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(897, 3)" end="(897, 28)" kind="Lean.Parser.Tactic.simp" state_before="case intro&#10;α : Type u_1&#10;i : Nat&#10;l₁ : List α&#10;p : α → Bool&#10;t : List α&#10;h : findIdx? p l₁ = some i&#10;⊢ findIdx? p (l₁ ++ t) = some i" state_after="no goals" tactic="simp [findIdx?_append, h]">
                    <AtomNode start="(897, 3)" end="(897, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(897, 8)" end="(897, 28)">
                      <AtomNode start="(897, 8)" end="(897, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(897, 9)" end="(897, 27)">
                        <OtherNode start="(897, 9)" end="(897, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(897, 9)" end="(897, 24)" leading="" trailing="" raw_val="findIdx?_append" val="findIdx?_append" full_name="List.findIdx?_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(816, 17)" def_end="(816, 32)"/>
                        </OtherNode>
                        <AtomNode start="(897, 24)" end="(897, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(897, 26)" end="(897, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(897, 26)" end="(897, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(897, 27)" end="(897, 28)" leading="" trailing="&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(898, 1)" end="(900, 29)" name="IsPrefix.findIdx?_eq_none" full_name="List.IsPrefix.findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(898, 1)" end="(900, 29)" name="IsPrefix.findIdx?_eq_none" full_name="List.IsPrefix.findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(898, 1)" end="(898, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(898, 9)" end="(898, 34)">
          <IdentNode start="(898, 9)" end="(898, 34)" leading="" trailing=" " raw_val="IsPrefix.findIdx?_eq_none" val="IsPrefix.findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(898, 35)" end="(899, 58)">
          <NullNode start="(898, 35)" end="(898, 82)">
            <OtherNode start="(898, 35)" end="(898, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(898, 35)" end="(898, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(898, 36)" end="(898, 41)">
                <IdentNode start="(898, 36)" end="(898, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(898, 39)" end="(898, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(898, 42)" end="(898, 50)">
                <AtomNode start="(898, 42)" end="(898, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(898, 44)" end="(898, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(898, 44)" end="(898, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(898, 49)" end="(898, 50)">
                    <IdentNode start="(898, 49)" end="(898, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(898, 50)" end="(898, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(898, 52)" end="(898, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(898, 52)" end="(898, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(898, 53)" end="(898, 54)">
                <IdentNode start="(898, 53)" end="(898, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(898, 55)" end="(898, 65)">
                <AtomNode start="(898, 55)" end="(898, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(898, 57)" end="(898, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(898, 57)" end="(898, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(898, 59)" end="(898, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(898, 61)" end="(898, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(898, 65)" end="(898, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(898, 67)" end="(898, 82)">
              <AtomNode start="(898, 67)" end="(898, 68)" leading="" trailing="" val="("/>
              <NullNode start="(898, 68)" end="(898, 69)">
                <IdentNode start="(898, 68)" end="(898, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(898, 70)" end="(898, 81)">
                <AtomNode start="(898, 70)" end="(898, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(898, 72)" end="(898, 81)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(898, 72)" end="(898, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(898, 75)" end="(898, 78)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(898, 79)" end="(898, 81)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(898, 81)" end="(898, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(898, 83)" end="(899, 58)">
            <AtomNode start="(898, 83)" end="(898, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(899, 5)" end="(899, 58)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(899, 5)" end="(899, 30)" kind="«term_=_»">
                <OtherNode start="(899, 5)" end="(899, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(899, 5)" end="(899, 18)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(899, 19)" end="(899, 23)">
                    <IdentNode start="(899, 19)" end="(899, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(899, 21)" end="(899, 23)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(899, 24)" end="(899, 25)" leading="" trailing=" " val="="/>
                <IdentNode start="(899, 26)" end="(899, 30)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(899, 31)" end="(899, 32)" leading="" trailing=" " val="→"/>
              <OtherNode start="(899, 33)" end="(899, 58)" kind="«term_=_»">
                <OtherNode start="(899, 33)" end="(899, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(899, 33)" end="(899, 46)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(899, 47)" end="(899, 51)">
                    <IdentNode start="(899, 47)" end="(899, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(899, 49)" end="(899, 51)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(899, 52)" end="(899, 53)" leading="" trailing=" " val="="/>
                <IdentNode start="(899, 54)" end="(899, 58)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(899, 59)" end="(900, 29)">
          <AtomNode start="(899, 59)" end="(899, 61)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(900, 3)" end="(900, 29)" leading="" trailing="&#10;" raw_val="h.sublist.findIdx?_eq_none" val="h.sublist.findIdx?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(901, 1)" end="(903, 29)" name="IsSuffix.findIdx?_eq_none" full_name="List.IsSuffix.findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(901, 1)" end="(903, 29)" name="IsSuffix.findIdx?_eq_none" full_name="List.IsSuffix.findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(901, 1)" end="(901, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(901, 9)" end="(901, 34)">
          <IdentNode start="(901, 9)" end="(901, 34)" leading="" trailing=" " raw_val="IsSuffix.findIdx?_eq_none" val="IsSuffix.findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(901, 35)" end="(902, 58)">
          <NullNode start="(901, 35)" end="(901, 82)">
            <OtherNode start="(901, 35)" end="(901, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(901, 35)" end="(901, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(901, 36)" end="(901, 41)">
                <IdentNode start="(901, 36)" end="(901, 38)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(901, 39)" end="(901, 41)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(901, 42)" end="(901, 50)">
                <AtomNode start="(901, 42)" end="(901, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(901, 44)" end="(901, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(901, 44)" end="(901, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(901, 49)" end="(901, 50)">
                    <IdentNode start="(901, 49)" end="(901, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(901, 50)" end="(901, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(901, 52)" end="(901, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(901, 52)" end="(901, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(901, 53)" end="(901, 54)">
                <IdentNode start="(901, 53)" end="(901, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(901, 55)" end="(901, 65)">
                <AtomNode start="(901, 55)" end="(901, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(901, 57)" end="(901, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(901, 57)" end="(901, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(901, 59)" end="(901, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(901, 61)" end="(901, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(901, 65)" end="(901, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(901, 67)" end="(901, 82)">
              <AtomNode start="(901, 67)" end="(901, 68)" leading="" trailing="" val="("/>
              <NullNode start="(901, 68)" end="(901, 69)">
                <IdentNode start="(901, 68)" end="(901, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(901, 70)" end="(901, 81)">
                <AtomNode start="(901, 70)" end="(901, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(901, 72)" end="(901, 81)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(901, 72)" end="(901, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(901, 75)" end="(901, 78)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(901, 79)" end="(901, 81)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(901, 81)" end="(901, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(901, 83)" end="(902, 58)">
            <AtomNode start="(901, 83)" end="(901, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(902, 5)" end="(902, 58)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(902, 5)" end="(902, 30)" kind="«term_=_»">
                <OtherNode start="(902, 5)" end="(902, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(902, 5)" end="(902, 18)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(902, 19)" end="(902, 23)">
                    <IdentNode start="(902, 19)" end="(902, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(902, 21)" end="(902, 23)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(902, 24)" end="(902, 25)" leading="" trailing=" " val="="/>
                <IdentNode start="(902, 26)" end="(902, 30)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(902, 31)" end="(902, 32)" leading="" trailing=" " val="→"/>
              <OtherNode start="(902, 33)" end="(902, 58)" kind="«term_=_»">
                <OtherNode start="(902, 33)" end="(902, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(902, 33)" end="(902, 46)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(902, 47)" end="(902, 51)">
                    <IdentNode start="(902, 47)" end="(902, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(902, 49)" end="(902, 51)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(902, 52)" end="(902, 53)" leading="" trailing=" " val="="/>
                <IdentNode start="(902, 54)" end="(902, 58)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(902, 59)" end="(903, 29)">
          <AtomNode start="(902, 59)" end="(902, 61)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(903, 3)" end="(903, 29)" leading="" trailing="&#10;" raw_val="h.sublist.findIdx?_eq_none" val="h.sublist.findIdx?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(904, 1)" end="(906, 29)" name="IsInfix.findIdx?_eq_none" full_name="List.IsInfix.findIdx?_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(904, 1)" end="(906, 29)" name="IsInfix.findIdx?_eq_none" full_name="List.IsInfix.findIdx?_eq_none" _is_private_decl="False">
        <AtomNode start="(904, 1)" end="(904, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(904, 9)" end="(904, 33)">
          <IdentNode start="(904, 9)" end="(904, 33)" leading="" trailing=" " raw_val="IsInfix.findIdx?_eq_none" val="IsInfix.findIdx?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(904, 34)" end="(905, 58)">
          <NullNode start="(904, 34)" end="(904, 82)">
            <OtherNode start="(904, 34)" end="(904, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(904, 34)" end="(904, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(904, 35)" end="(904, 40)">
                <IdentNode start="(904, 35)" end="(904, 37)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(904, 38)" end="(904, 40)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(904, 41)" end="(904, 49)">
                <AtomNode start="(904, 41)" end="(904, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(904, 43)" end="(904, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(904, 43)" end="(904, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(904, 48)" end="(904, 49)">
                    <IdentNode start="(904, 48)" end="(904, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(904, 49)" end="(904, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(904, 51)" end="(904, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(904, 51)" end="(904, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(904, 52)" end="(904, 53)">
                <IdentNode start="(904, 52)" end="(904, 53)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(904, 54)" end="(904, 64)">
                <AtomNode start="(904, 54)" end="(904, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(904, 56)" end="(904, 64)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(904, 56)" end="(904, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(904, 58)" end="(904, 59)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(904, 60)" end="(904, 64)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(904, 64)" end="(904, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(904, 66)" end="(904, 82)">
              <AtomNode start="(904, 66)" end="(904, 67)" leading="" trailing="" val="("/>
              <NullNode start="(904, 67)" end="(904, 68)">
                <IdentNode start="(904, 67)" end="(904, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(904, 69)" end="(904, 81)">
                <AtomNode start="(904, 69)" end="(904, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(904, 71)" end="(904, 81)" kind="List.«term_&amp;lt;:+:_»">
                  <IdentNode start="(904, 71)" end="(904, 73)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(904, 74)" end="(904, 78)" leading="" trailing=" " val="&amp;lt;:+:"/>
                  <IdentNode start="(904, 79)" end="(904, 81)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(904, 81)" end="(904, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(904, 83)" end="(905, 58)">
            <AtomNode start="(904, 83)" end="(904, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(905, 5)" end="(905, 58)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(905, 5)" end="(905, 30)" kind="«term_=_»">
                <OtherNode start="(905, 5)" end="(905, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(905, 5)" end="(905, 18)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(905, 19)" end="(905, 23)">
                    <IdentNode start="(905, 19)" end="(905, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(905, 21)" end="(905, 23)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(905, 24)" end="(905, 25)" leading="" trailing=" " val="="/>
                <IdentNode start="(905, 26)" end="(905, 30)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(905, 31)" end="(905, 32)" leading="" trailing=" " val="→"/>
              <OtherNode start="(905, 33)" end="(905, 58)" kind="«term_=_»">
                <OtherNode start="(905, 33)" end="(905, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(905, 33)" end="(905, 46)" leading="" trailing=" " raw_val="List.findIdx?" val="List.findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(905, 47)" end="(905, 51)">
                    <IdentNode start="(905, 47)" end="(905, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(905, 49)" end="(905, 51)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(905, 52)" end="(905, 53)" leading="" trailing=" " val="="/>
                <IdentNode start="(905, 54)" end="(905, 58)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(905, 59)" end="(906, 29)">
          <AtomNode start="(905, 59)" end="(905, 61)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(906, 3)" end="(906, 29)" leading="" trailing="&#10;&#10;" raw_val="h.sublist.findIdx?_eq_none" val="h.sublist.findIdx?_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(908, 1)" end="(914, 28)" name="findIdx_eq_getD_findIdx?" full_name="List.findIdx_eq_getD_findIdx?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(908, 1)" end="(914, 28)" name="findIdx_eq_getD_findIdx?" full_name="List.findIdx_eq_getD_findIdx?" _is_private_decl="False">
        <AtomNode start="(908, 1)" end="(908, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(908, 9)" end="(908, 33)">
          <IdentNode start="(908, 9)" end="(908, 33)" leading="" trailing=" " raw_val="findIdx_eq_getD_findIdx?" val="findIdx_eq_getD_findIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(908, 34)" end="(909, 50)">
          <NullNode start="(908, 34)" end="(908, 62)">
            <OtherNode start="(908, 34)" end="(908, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(908, 34)" end="(908, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(908, 35)" end="(908, 37)">
                <IdentNode start="(908, 35)" end="(908, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(908, 38)" end="(908, 46)">
                <AtomNode start="(908, 38)" end="(908, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(908, 40)" end="(908, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(908, 40)" end="(908, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(908, 45)" end="(908, 46)">
                    <IdentNode start="(908, 45)" end="(908, 46)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(908, 46)" end="(908, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(908, 48)" end="(908, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(908, 48)" end="(908, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(908, 49)" end="(908, 50)">
                <IdentNode start="(908, 49)" end="(908, 50)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(908, 51)" end="(908, 61)">
                <AtomNode start="(908, 51)" end="(908, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(908, 53)" end="(908, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(908, 53)" end="(908, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(908, 55)" end="(908, 56)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(908, 57)" end="(908, 61)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(908, 61)" end="(908, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(908, 63)" end="(909, 50)">
            <AtomNode start="(908, 63)" end="(908, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(909, 5)" end="(909, 50)" kind="«term_=_»">
              <OtherNode start="(909, 5)" end="(909, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(909, 5)" end="(909, 15)" leading="" trailing=" " raw_val="xs.findIdx" val="xs.findIdx"/>
                <NullNode start="(909, 16)" end="(909, 17)">
                  <IdentNode start="(909, 16)" end="(909, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(909, 18)" end="(909, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(909, 20)" end="(909, 50)" kind="Lean.Parser.Term.app">
                <OtherNode start="(909, 20)" end="(909, 40)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(909, 20)" end="(909, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(909, 20)" end="(909, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(909, 21)" end="(909, 34)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(909, 21)" end="(909, 32)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(909, 33)" end="(909, 34)">
                        <IdentNode start="(909, 33)" end="(909, 34)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(909, 34)" end="(909, 35)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(909, 35)" end="(909, 36)" leading="" trailing="" val="."/>
                  <IdentNode start="(909, 36)" end="(909, 40)" leading="" trailing=" " raw_val="getD" val="getD" full_name="Option.getD" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(909, 41)" end="(909, 50)">
                  <IdentNode start="(909, 41)" end="(909, 50)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(909, 51)" end="(914, 28)">
          <AtomNode start="(909, 51)" end="(909, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(909, 54)" end="(914, 28)">
            <AtomNode start="(909, 54)" end="(909, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(910, 3)" end="(914, 28)">
              <TacticTacticseq1IndentedNode start="(910, 3)" end="(914, 28)">
                <NullNode start="(910, 3)" end="(914, 28)">
                  <OtherNode start="(910, 3)" end="(914, 28)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx p xs = (findIdx? p xs).getD xs.length" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findIdx_cons, findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all [ih]">
                    <AtomNode start="(910, 3)" end="(910, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(910, 13)" end="(910, 15)">
                      <OtherNode start="(910, 13)" end="(910, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(910, 13)" end="(910, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(910, 16)" end="(914, 28)">
                      <OtherNode start="(910, 16)" end="(914, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(910, 16)" end="(910, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(911, 3)" end="(914, 28)">
                          <OtherNode start="(911, 3)" end="(911, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(911, 3)" end="(911, 8)">
                              <OtherNode start="(911, 3)" end="(911, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(911, 3)" end="(911, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(911, 5)" end="(911, 8)">
                                  <NullNode/>
                                  <IdentNode start="(911, 5)" end="(911, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(911, 9)" end="(911, 16)">
                              <AtomNode start="(911, 9)" end="(911, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(911, 12)" end="(911, 16)">
                                <TacticTacticseq1IndentedNode start="(911, 12)" end="(911, 16)">
                                  <NullNode start="(911, 12)" end="(911, 16)">
                                    <OtherNode start="(911, 12)" end="(911, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findIdx p [] = (findIdx? p []).getD [].length" state_after="no goals" tactic="simp">
                                      <AtomNode start="(911, 12)" end="(911, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(912, 3)" end="(914, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(912, 3)" end="(912, 17)">
                              <OtherNode start="(912, 3)" end="(912, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(912, 3)" end="(912, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(912, 5)" end="(912, 9)">
                                  <NullNode/>
                                  <IdentNode start="(912, 5)" end="(912, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(912, 10)" end="(912, 17)">
                                  <IdentNode start="(912, 10)" end="(912, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(912, 12)" end="(912, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(912, 15)" end="(912, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(912, 18)" end="(914, 28)">
                              <AtomNode start="(912, 18)" end="(912, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(913, 5)" end="(914, 28)">
                                <TacticTacticseq1IndentedNode start="(913, 5)" end="(914, 28)">
                                  <NullNode start="(913, 5)" end="(914, 28)">
                                    <OtherNode start="(913, 5)" end="(913, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = (findIdx? p xs).getD xs.length&#10;⊢ findIdx p (x :: xs) = (findIdx? p (x :: xs)).getD (x :: xs).length" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = (findIdx? p xs).getD xs.length&#10;⊢ (bif p x then 0 else findIdx p xs + 1) =&#10;    (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)).getD (x :: xs).length" tactic="simp only [findIdx_cons, findIdx?_cons]">
                                      <AtomNode start="(913, 5)" end="(913, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(913, 10)" end="(913, 14)">
                                        <AtomNode start="(913, 10)" end="(913, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(913, 15)" end="(913, 44)">
                                        <AtomNode start="(913, 15)" end="(913, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(913, 16)" end="(913, 43)">
                                          <OtherNode start="(913, 16)" end="(913, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(913, 16)" end="(913, 28)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                                          </OtherNode>
                                          <AtomNode start="(913, 28)" end="(913, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(913, 30)" end="(913, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(913, 30)" end="(913, 43)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(913, 43)" end="(913, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(914, 5)" end="(914, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : findIdx p xs = (findIdx? p xs).getD xs.length&#10;⊢ (bif p x then 0 else findIdx p xs + 1) =&#10;    (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)).getD (x :: xs).length" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [ih]">
                                      <OtherNode start="(914, 5)" end="(914, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(914, 5)" end="(914, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(914, 11)" end="(914, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(914, 15)" end="(914, 28)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(914, 15)" end="(914, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(914, 24)" end="(914, 28)">
                                          <AtomNode start="(914, 24)" end="(914, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(914, 25)" end="(914, 27)">
                                            <OtherNode start="(914, 25)" end="(914, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(914, 25)" end="(914, 27)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(914, 27)" end="(914, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(916, 1)" end="(924, 43)" name="findIdx?_subtype" full_name="List.findIdx?_subtype">
      <CommandDeclmodifiersNode start="(916, 1)" end="(916, 8)">
        <NullNode/>
        <NullNode start="(916, 1)" end="(916, 8)">
          <OtherNode start="(916, 1)" end="(916, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(916, 1)" end="(916, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(916, 3)" end="(916, 7)">
              <OtherNode start="(916, 3)" end="(916, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(916, 3)" end="(916, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(916, 3)" end="(916, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(916, 7)" end="(916, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(916, 9)" end="(924, 43)" name="findIdx?_subtype" full_name="List.findIdx?_subtype" _is_private_decl="False">
        <AtomNode start="(916, 9)" end="(916, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(916, 17)" end="(916, 33)">
          <IdentNode start="(916, 17)" end="(916, 33)" leading="" trailing=" " raw_val="findIdx?_subtype" val="findIdx?_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(916, 34)" end="(918, 41)">
          <NullNode start="(916, 34)" end="(917, 74)">
            <OtherNode start="(916, 34)" end="(916, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(916, 34)" end="(916, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(916, 35)" end="(916, 36)">
                <IdentNode start="(916, 35)" end="(916, 36)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(916, 37)" end="(916, 47)">
                <AtomNode start="(916, 37)" end="(916, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(916, 39)" end="(916, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(916, 39)" end="(916, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(916, 41)" end="(916, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(916, 43)" end="(916, 47)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(916, 43)" end="(916, 47)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(916, 47)" end="(916, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(916, 49)" end="(916, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(916, 49)" end="(916, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(916, 50)" end="(916, 51)">
                <IdentNode start="(916, 50)" end="(916, 51)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(916, 52)" end="(916, 71)">
                <AtomNode start="(916, 52)" end="(916, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(916, 54)" end="(916, 71)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(916, 54)" end="(916, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(916, 59)" end="(916, 71)">
                    <OtherNode start="(916, 59)" end="(916, 71)" kind="«term{_:_//_}»">
                      <AtomNode start="(916, 59)" end="(916, 60)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(916, 61)" end="(916, 62)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(916, 63)" end="(916, 65)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(916, 66)" end="(916, 69)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(916, 66)" end="(916, 67)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(916, 68)" end="(916, 69)">
                          <IdentNode start="(916, 68)" end="(916, 69)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(916, 70)" end="(916, 71)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(916, 71)" end="(916, 72)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(917, 5)" end="(917, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(917, 5)" end="(917, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(917, 6)" end="(917, 7)">
                <IdentNode start="(917, 6)" end="(917, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(917, 8)" end="(917, 29)">
                <AtomNode start="(917, 8)" end="(917, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(917, 10)" end="(917, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(917, 10)" end="(917, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(917, 10)" end="(917, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(917, 12)" end="(917, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(917, 14)" end="(917, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(917, 17)" end="(917, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(917, 17)" end="(917, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(917, 19)" end="(917, 20)">
                        <IdentNode start="(917, 19)" end="(917, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(917, 21)" end="(917, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(917, 23)" end="(917, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(917, 25)" end="(917, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(917, 29)" end="(917, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(917, 31)" end="(917, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(917, 31)" end="(917, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(917, 32)" end="(917, 33)">
                <IdentNode start="(917, 32)" end="(917, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(917, 34)" end="(917, 44)">
                <AtomNode start="(917, 34)" end="(917, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(917, 36)" end="(917, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(917, 36)" end="(917, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(917, 38)" end="(917, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(917, 40)" end="(917, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(917, 44)" end="(917, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(917, 46)" end="(917, 74)">
              <AtomNode start="(917, 46)" end="(917, 47)" leading="" trailing="" val="("/>
              <NullNode start="(917, 47)" end="(917, 49)">
                <IdentNode start="(917, 47)" end="(917, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(917, 50)" end="(917, 73)">
                <AtomNode start="(917, 50)" end="(917, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(917, 52)" end="(917, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(917, 52)" end="(917, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(917, 54)" end="(917, 57)">
                    <IdentNode start="(917, 54)" end="(917, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(917, 56)" end="(917, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(917, 57)" end="(917, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(917, 59)" end="(917, 73)" kind="«term_=_»">
                    <OtherNode start="(917, 59)" end="(917, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(917, 59)" end="(917, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(917, 61)" end="(917, 67)">
                        <OtherNode start="(917, 61)" end="(917, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(917, 61)" end="(917, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(917, 62)" end="(917, 66)">
                            <IdentNode start="(917, 62)" end="(917, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(917, 63)" end="(917, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(917, 65)" end="(917, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(917, 66)" end="(917, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(917, 68)" end="(917, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(917, 70)" end="(917, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(917, 70)" end="(917, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(917, 72)" end="(917, 73)">
                        <IdentNode start="(917, 72)" end="(917, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(917, 73)" end="(917, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(917, 75)" end="(918, 41)">
            <AtomNode start="(917, 75)" end="(917, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(918, 5)" end="(918, 41)" kind="«term_=_»">
              <OtherNode start="(918, 5)" end="(918, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(918, 5)" end="(918, 15)" leading="" trailing=" " raw_val="l.findIdx?" val="l.findIdx?"/>
                <NullNode start="(918, 16)" end="(918, 17)">
                  <IdentNode start="(918, 16)" end="(918, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(918, 18)" end="(918, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(918, 20)" end="(918, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(918, 20)" end="(918, 39)" leading="" trailing=" " raw_val="l.unattach.findIdx?" val="l.unattach.findIdx?"/>
                <NullNode start="(918, 40)" end="(918, 41)">
                  <IdentNode start="(918, 40)" end="(918, 41)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(918, 42)" end="(924, 43)">
          <AtomNode start="(918, 42)" end="(918, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(918, 45)" end="(924, 43)">
            <AtomNode start="(918, 45)" end="(918, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(919, 3)" end="(924, 43)">
              <TacticTacticseq1IndentedNode start="(919, 3)" end="(924, 43)">
                <NullNode start="(919, 3)" end="(924, 43)">
                  <OtherNode start="(919, 3)" end="(919, 18)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx? f l = findIdx? g l.unattach" state_after="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx? f l = findIdx? g (map (fun x =&amp;gt; x.val) l)" tactic="unfold unattach">
                    <AtomNode start="(919, 3)" end="(919, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(919, 10)" end="(919, 18)">
                      <IdentNode start="(919, 10)" end="(919, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(920, 3)" end="(924, 43)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx? f l = findIdx? g (map (fun x =&amp;gt; x.val) l)" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp [hf, findIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp [ih, Function.comp_def]">
                    <AtomNode start="(920, 3)" end="(920, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(920, 13)" end="(920, 14)">
                      <OtherNode start="(920, 13)" end="(920, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(920, 13)" end="(920, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(920, 15)" end="(924, 43)">
                      <OtherNode start="(920, 15)" end="(924, 43)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(920, 15)" end="(920, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(921, 3)" end="(924, 43)">
                          <OtherNode start="(921, 3)" end="(921, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(921, 3)" end="(921, 8)">
                              <OtherNode start="(921, 3)" end="(921, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(921, 3)" end="(921, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(921, 5)" end="(921, 8)">
                                  <NullNode/>
                                  <IdentNode start="(921, 5)" end="(921, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(921, 9)" end="(921, 16)">
                              <AtomNode start="(921, 9)" end="(921, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(921, 12)" end="(921, 16)">
                                <TacticTacticseq1IndentedNode start="(921, 12)" end="(921, 16)">
                                  <NullNode start="(921, 12)" end="(921, 16)">
                                    <OtherNode start="(921, 12)" end="(921, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findIdx? f [] = findIdx? g (map (fun x =&amp;gt; x.val) [])" state_after="no goals" tactic="simp">
                                      <AtomNode start="(921, 12)" end="(921, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(922, 3)" end="(924, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(922, 3)" end="(922, 16)">
                              <OtherNode start="(922, 3)" end="(922, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(922, 3)" end="(922, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(922, 5)" end="(922, 9)">
                                  <NullNode/>
                                  <IdentNode start="(922, 5)" end="(922, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(922, 10)" end="(922, 16)">
                                  <IdentNode start="(922, 10)" end="(922, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(922, 12)" end="(922, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(922, 14)" end="(922, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(922, 17)" end="(924, 43)">
                              <AtomNode start="(922, 17)" end="(922, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(923, 5)" end="(924, 43)">
                                <TacticTacticseq1IndentedNode start="(923, 5)" end="(924, 43)">
                                  <NullNode start="(923, 5)" end="(924, 43)">
                                    <OtherNode start="(923, 5)" end="(923, 29)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findIdx? f l = findIdx? g (map (fun x =&amp;gt; x.val) l)&#10;⊢ findIdx? f (a :: l) = findIdx? g (map (fun x =&amp;gt; x.val) (a :: l))" state_after="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findIdx? f l = findIdx? g (map (fun x =&amp;gt; x.val) l)&#10;⊢ (if g a.val = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? f l)) =&#10;    if g a.val = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? g l.unattach)" tactic="simp [hf, findIdx?_cons]">
                                      <AtomNode start="(923, 5)" end="(923, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(923, 10)" end="(923, 29)">
                                        <AtomNode start="(923, 10)" end="(923, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(923, 11)" end="(923, 28)">
                                          <OtherNode start="(923, 11)" end="(923, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(923, 11)" end="(923, 13)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                          <AtomNode start="(923, 13)" end="(923, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(923, 15)" end="(923, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(923, 15)" end="(923, 28)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(923, 28)" end="(923, 29)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(924, 5)" end="(924, 43)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findIdx? f l = findIdx? g (map (fun x =&amp;gt; x.val) l)&#10;⊢ (if g a.val = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? f l)) =&#10;    if g a.val = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? g l.unattach)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [ih, Function.comp_def]">
                                      <OtherNode start="(924, 5)" end="(924, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(924, 5)" end="(924, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(924, 11)" end="(924, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(924, 15)" end="(924, 43)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(924, 15)" end="(924, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(924, 20)" end="(924, 43)">
                                          <AtomNode start="(924, 20)" end="(924, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(924, 21)" end="(924, 42)">
                                            <OtherNode start="(924, 21)" end="(924, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(924, 21)" end="(924, 23)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                            <AtomNode start="(924, 23)" end="(924, 24)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(924, 25)" end="(924, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(924, 25)" end="(924, 42)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(924, 42)" end="(924, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(926, 1)" end="(926, 23)" comment="### findFinIdx? -/">
      <AtomNode start="(926, 1)" end="(926, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(926, 5)" end="(926, 23)" leading="" trailing="&#10;&#10;" val="### findFinIdx? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(928, 1)" end="(928, 80)" name="findFinIdx?_nil" full_name="List.findFinIdx?_nil">
      <CommandDeclmodifiersNode start="(928, 1)" end="(928, 8)">
        <NullNode/>
        <NullNode start="(928, 1)" end="(928, 8)">
          <OtherNode start="(928, 1)" end="(928, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(928, 1)" end="(928, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(928, 3)" end="(928, 7)">
              <OtherNode start="(928, 3)" end="(928, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(928, 3)" end="(928, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(928, 3)" end="(928, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(928, 7)" end="(928, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(928, 9)" end="(928, 80)" name="findFinIdx?_nil" full_name="List.findFinIdx?_nil" _is_private_decl="False">
        <AtomNode start="(928, 9)" end="(928, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(928, 17)" end="(928, 32)">
          <IdentNode start="(928, 17)" end="(928, 32)" leading="" trailing=" " raw_val="findFinIdx?_nil" val="findFinIdx?_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(928, 33)" end="(928, 73)">
          <NullNode start="(928, 33)" end="(928, 47)">
            <OtherNode start="(928, 33)" end="(928, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(928, 33)" end="(928, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(928, 34)" end="(928, 35)">
                <IdentNode start="(928, 34)" end="(928, 35)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(928, 36)" end="(928, 46)">
                <AtomNode start="(928, 36)" end="(928, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(928, 38)" end="(928, 46)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(928, 38)" end="(928, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(928, 40)" end="(928, 41)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(928, 42)" end="(928, 46)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(928, 46)" end="(928, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(928, 48)" end="(928, 73)">
            <AtomNode start="(928, 48)" end="(928, 49)" leading="" trailing=" " val=":"/>
            <OtherNode start="(928, 50)" end="(928, 73)" kind="«term_=_»">
              <OtherNode start="(928, 50)" end="(928, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(928, 50)" end="(928, 61)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(928, 62)" end="(928, 66)">
                  <IdentNode start="(928, 62)" end="(928, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(928, 64)" end="(928, 66)" kind="«term[_]»">
                    <AtomNode start="(928, 64)" end="(928, 65)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(928, 65)" end="(928, 66)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(928, 67)" end="(928, 68)" leading="" trailing=" " val="="/>
              <IdentNode start="(928, 69)" end="(928, 73)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(928, 74)" end="(928, 80)">
          <AtomNode start="(928, 74)" end="(928, 76)" leading="" trailing=" " val=":="/>
          <IdentNode start="(928, 77)" end="(928, 80)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(930, 1)" end="(940, 49)" name="findIdx?_go_eq_map_findFinIdx?_go_val" full_name="List.findIdx?_go_eq_map_findFinIdx?_go_val">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(930, 1)" end="(940, 49)" name="findIdx?_go_eq_map_findFinIdx?_go_val" full_name="List.findIdx?_go_eq_map_findFinIdx?_go_val" _is_private_decl="False">
        <AtomNode start="(930, 1)" end="(930, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(930, 9)" end="(930, 46)">
          <IdentNode start="(930, 9)" end="(930, 46)" leading="" trailing=" " raw_val="findIdx?_go_eq_map_findFinIdx?_go_val" val="findIdx?_go_eq_map_findFinIdx?_go_val"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(930, 47)" end="(932, 51)">
          <NullNode start="(930, 47)" end="(930, 89)">
            <OtherNode start="(930, 47)" end="(930, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(930, 47)" end="(930, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(930, 48)" end="(930, 50)">
                <IdentNode start="(930, 48)" end="(930, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(930, 51)" end="(930, 59)">
                <AtomNode start="(930, 51)" end="(930, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(930, 53)" end="(930, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(930, 53)" end="(930, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(930, 58)" end="(930, 59)">
                    <IdentNode start="(930, 58)" end="(930, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(930, 59)" end="(930, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(930, 61)" end="(930, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(930, 61)" end="(930, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(930, 62)" end="(930, 63)">
                <IdentNode start="(930, 62)" end="(930, 63)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(930, 64)" end="(930, 74)">
                <AtomNode start="(930, 64)" end="(930, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(930, 66)" end="(930, 74)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(930, 66)" end="(930, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(930, 68)" end="(930, 69)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(930, 70)" end="(930, 74)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(930, 74)" end="(930, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(930, 76)" end="(930, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(930, 76)" end="(930, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(930, 77)" end="(930, 78)">
                <IdentNode start="(930, 77)" end="(930, 78)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(930, 79)" end="(930, 84)">
                <AtomNode start="(930, 79)" end="(930, 80)" leading="" trailing=" " val=":"/>
                <IdentNode start="(930, 81)" end="(930, 84)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(930, 84)" end="(930, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(930, 86)" end="(930, 89)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(930, 86)" end="(930, 87)" leading="" trailing="" val="{"/>
              <NullNode start="(930, 87)" end="(930, 88)">
                <IdentNode start="(930, 87)" end="(930, 88)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(930, 88)" end="(930, 89)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(930, 90)" end="(932, 51)">
            <AtomNode start="(930, 90)" end="(930, 91)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(931, 5)" end="(932, 51)" kind="«term_=_»">
              <OtherNode start="(931, 5)" end="(931, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(931, 5)" end="(931, 21)" leading="" trailing=" " raw_val="List.findIdx?.go" val="List.findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(931, 22)" end="(931, 28)">
                  <IdentNode start="(931, 22)" end="(931, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(931, 24)" end="(931, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(931, 27)" end="(931, 28)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(931, 29)" end="(931, 30)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(932, 7)" end="(932, 51)" kind="Lean.Parser.Term.app">
                <OtherNode start="(932, 7)" end="(932, 43)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(932, 7)" end="(932, 39)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(932, 7)" end="(932, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(932, 8)" end="(932, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(932, 8)" end="(932, 27)" leading="" trailing=" " raw_val="List.findFinIdx?.go" val="List.findFinIdx?.go" full_name="List.findFinIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(932, 28)" end="(932, 38)">
                        <IdentNode start="(932, 28)" end="(932, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                        <IdentNode start="(932, 30)" end="(932, 31)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(932, 32)" end="(932, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <IdentNode start="(932, 35)" end="(932, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(932, 37)" end="(932, 38)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(932, 38)" end="(932, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(932, 39)" end="(932, 40)" leading="" trailing="" val="."/>
                  <IdentNode start="(932, 40)" end="(932, 43)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(932, 44)" end="(932, 51)">
                  <OtherNode start="(932, 44)" end="(932, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(932, 44)" end="(932, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(932, 45)" end="(932, 50)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(932, 45)" end="(932, 46)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(932, 45)" end="(932, 46)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(932, 46)" end="(932, 47)" leading="" trailing="" val="."/>
                      <IdentNode start="(932, 47)" end="(932, 50)" leading="" trailing="" raw_val="val" val="val" full_name="Fin.val" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(932, 50)" end="(932, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(932, 52)" end="(940, 49)">
          <AtomNode start="(932, 52)" end="(932, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(932, 55)" end="(940, 49)">
            <AtomNode start="(932, 55)" end="(932, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(933, 3)" end="(940, 49)">
              <TacticTacticseq1IndentedNode start="(933, 3)" end="(940, 49)">
                <NullNode start="(933, 3)" end="(940, 49)">
                  <OtherNode start="(933, 3)" end="(933, 21)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;l xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : xs.length + i = l.length&#10;⊢ findIdx?.go p xs i = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l xs i h)" state_after="α : Type u_1&#10;l xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : xs.length + i = l.length&#10;⊢ (match xs, i with&#10;    | [], x =&amp;gt; none&#10;    | a :: l, i =&amp;gt; if p a = true then some i else findIdx?.go p l (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l xs i h)" tactic="unfold findIdx?.go">
                    <AtomNode start="(933, 3)" end="(933, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(933, 10)" end="(933, 21)">
                      <IdentNode start="(933, 10)" end="(933, 21)" leading="" trailing="&#10;  " raw_val="findIdx?.go" val="findIdx?.go" full_name="List.findIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(934, 3)" end="(934, 24)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;l xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : xs.length + i = l.length&#10;⊢ (match xs, i with&#10;    | [], x =&amp;gt; none&#10;    | a :: l, i =&amp;gt; if p a = true then some i else findIdx?.go p l (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l xs i h)" state_after="α : Type u_1&#10;l xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : xs.length + i = l.length&#10;⊢ (match xs, i with&#10;    | [], x =&amp;gt; none&#10;    | a :: l, i =&amp;gt; if p a = true then some i else findIdx?.go p l (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match xs, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" tactic="unfold findFinIdx?.go">
                    <AtomNode start="(934, 3)" end="(934, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(934, 10)" end="(934, 24)">
                      <IdentNode start="(934, 10)" end="(934, 24)" leading="" trailing="&#10;  " raw_val="findFinIdx?.go" val="findFinIdx?.go" full_name="List.findFinIdx?.go" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(935, 3)" end="(935, 8)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;l xs : List α&#10;p : α → Bool&#10;i : Nat&#10;h : xs.length + i = l.length&#10;⊢ (match xs, i with&#10;    | [], x =&amp;gt; none&#10;    | a :: l, i =&amp;gt; if p a = true then some i else findIdx?.go p l (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match xs, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" state_after="case h_1&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;h : [].length + i = l.length&#10;⊢ none =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match [], i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)&#10;&#10;case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match a✝ :: l✝, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" tactic="split">
                    <AtomNode start="(935, 3)" end="(935, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(936, 3)" end="(936, 13)" kind="Lean.cdot" state_before="case h_1&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;h : [].length + i = l.length&#10;⊢ none =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match [], i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)&#10;&#10;case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match a✝ :: l✝, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" state_after="case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match a✝ :: l✝, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" tactic="· simp_all">
                    <OtherNode start="(936, 3)" end="(936, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(936, 3)" end="(936, 4)" kind="patternIgnore">
                        <OtherNode start="(936, 3)" end="(936, 4)" kind="token.«· »">
                          <AtomNode start="(936, 3)" end="(936, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(936, 5)" end="(936, 13)">
                      <TacticTacticseq1IndentedNode start="(936, 5)" end="(936, 13)">
                        <NullNode start="(936, 5)" end="(936, 13)">
                          <OtherNode start="(936, 5)" end="(936, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case h_1&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;h : [].length + i = l.length&#10;⊢ none =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match [], i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(936, 5)" end="(936, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(937, 3)" end="(940, 49)" kind="Lean.cdot" state_before="case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match a✝ :: l✝, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" state_after="no goals" tactic="· simp only&#10;  split&#10;  · simp&#10;  · rw [findIdx?_go_eq_map_findFinIdx?_go_val]">
                    <OtherNode start="(937, 3)" end="(937, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(937, 3)" end="(937, 4)" kind="patternIgnore">
                        <OtherNode start="(937, 3)" end="(937, 4)" kind="token.«· »">
                          <AtomNode start="(937, 3)" end="(937, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(937, 5)" end="(940, 49)">
                      <TacticTacticseq1IndentedNode start="(937, 5)" end="(940, 49)">
                        <NullNode start="(937, 5)" end="(940, 49)">
                          <OtherNode start="(937, 5)" end="(937, 14)" kind="Lean.Parser.Tactic.simp" state_before="case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x)&#10;      (match a✝ :: l✝, i, h with&#10;      | [], x, x_1 =&amp;gt; none&#10;      | a :: l_1, i, h =&amp;gt; if p a = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l_1 (i + 1) ⋯)" state_after="case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x) (if p a✝ = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l✝ (i + 1) ⋯)" tactic="simp only">
                            <AtomNode start="(937, 5)" end="(937, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(937, 10)" end="(937, 14)">
                              <AtomNode start="(937, 10)" end="(937, 14)" leading="" trailing="&#10;    " val="only"/>
                            </NullNode>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(938, 5)" end="(938, 10)" kind="Lean.Parser.Tactic.split" state_before="case h_2&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;⊢ (if p a✝ = true then some i else findIdx?.go p l✝ (i + 1)) =&#10;    Option.map (fun x =&amp;gt; ↑x) (if p a✝ = true then some ⟨i, ⋯⟩ else findFinIdx?.go p l l✝ (i + 1) ⋯)" state_after="case h_2.isTrue&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : p a✝ = true&#10;⊢ some i = Option.map (fun x =&amp;gt; ↑x) (some ⟨i, ⋯⟩)&#10;&#10;case h_2.isFalse&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : ¬p a✝ = true&#10;⊢ findIdx?.go p l✝ (i + 1) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l l✝ (i + 1) ⋯)" tactic="split">
                            <AtomNode start="(938, 5)" end="(938, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(939, 5)" end="(939, 11)" kind="Lean.cdot" state_before="case h_2.isTrue&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : p a✝ = true&#10;⊢ some i = Option.map (fun x =&amp;gt; ↑x) (some ⟨i, ⋯⟩)&#10;&#10;case h_2.isFalse&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : ¬p a✝ = true&#10;⊢ findIdx?.go p l✝ (i + 1) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l l✝ (i + 1) ⋯)" state_after="case h_2.isFalse&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : ¬p a✝ = true&#10;⊢ findIdx?.go p l✝ (i + 1) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l l✝ (i + 1) ⋯)" tactic="· simp">
                            <OtherNode start="(939, 5)" end="(939, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(939, 5)" end="(939, 6)" kind="patternIgnore">
                                <OtherNode start="(939, 5)" end="(939, 6)" kind="token.«· »">
                                  <AtomNode start="(939, 5)" end="(939, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(939, 7)" end="(939, 11)">
                              <TacticTacticseq1IndentedNode start="(939, 7)" end="(939, 11)">
                                <NullNode start="(939, 7)" end="(939, 11)">
                                  <OtherNode start="(939, 7)" end="(939, 11)" kind="Lean.Parser.Tactic.simp" state_before="case h_2.isTrue&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : p a✝ = true&#10;⊢ some i = Option.map (fun x =&amp;gt; ↑x) (some ⟨i, ⋯⟩)" state_after="no goals" tactic="simp">
                                    <AtomNode start="(939, 7)" end="(939, 11)" leading="" trailing="&#10;    " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(940, 5)" end="(940, 49)" kind="Lean.cdot" state_before="case h_2.isFalse&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : ¬p a✝ = true&#10;⊢ findIdx?.go p l✝ (i + 1) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l l✝ (i + 1) ⋯)" state_after="no goals" tactic="· rw [findIdx?_go_eq_map_findFinIdx?_go_val]">
                            <OtherNode start="(940, 5)" end="(940, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(940, 5)" end="(940, 6)" kind="patternIgnore">
                                <OtherNode start="(940, 5)" end="(940, 6)" kind="token.«· »">
                                  <AtomNode start="(940, 5)" end="(940, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(940, 7)" end="(940, 49)">
                              <TacticTacticseq1IndentedNode start="(940, 7)" end="(940, 49)">
                                <NullNode start="(940, 7)" end="(940, 49)">
                                  <OtherNode start="(940, 7)" end="(940, 49)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h_2.isFalse&#10;α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;i : Nat&#10;x✝¹ : List α&#10;x✝ : Nat&#10;a✝ : α&#10;l✝ : List α&#10;h : (a✝ :: l✝).length + i = l.length&#10;h✝ : ¬p a✝ = true&#10;⊢ findIdx?.go p l✝ (i + 1) = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p l l✝ (i + 1) ⋯)" state_after="no goals" tactic="rw [findIdx?_go_eq_map_findFinIdx?_go_val]">
                                    <AtomNode start="(940, 7)" end="(940, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(940, 10)" end="(940, 49)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(940, 10)" end="(940, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(940, 11)" end="(940, 48)">
                                        <OtherNode start="(940, 11)" end="(940, 48)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(940, 11)" end="(940, 48)" leading="" trailing="" raw_val="findIdx?_go_eq_map_findFinIdx?_go_val" val="findIdx?_go_eq_map_findFinIdx?_go_val" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(940, 48)" end="(940, 49)" leading="" trailing="&#10;&#10;" val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(942, 1)" end="(945, 45)" name="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(942, 1)" end="(945, 45)" name="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" _is_private_decl="False">
        <AtomNode start="(942, 1)" end="(942, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(942, 9)" end="(942, 40)">
          <IdentNode start="(942, 9)" end="(942, 40)" leading="" trailing=" " raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(942, 41)" end="(943, 51)">
          <NullNode start="(942, 41)" end="(942, 69)">
            <OtherNode start="(942, 41)" end="(942, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(942, 41)" end="(942, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(942, 42)" end="(942, 44)">
                <IdentNode start="(942, 42)" end="(942, 44)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(942, 45)" end="(942, 53)">
                <AtomNode start="(942, 45)" end="(942, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(942, 47)" end="(942, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(942, 47)" end="(942, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(942, 52)" end="(942, 53)">
                    <IdentNode start="(942, 52)" end="(942, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(942, 53)" end="(942, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(942, 55)" end="(942, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(942, 55)" end="(942, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(942, 56)" end="(942, 57)">
                <IdentNode start="(942, 56)" end="(942, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(942, 58)" end="(942, 68)">
                <AtomNode start="(942, 58)" end="(942, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(942, 60)" end="(942, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(942, 60)" end="(942, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(942, 62)" end="(942, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(942, 64)" end="(942, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(942, 68)" end="(942, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(942, 70)" end="(943, 51)">
            <AtomNode start="(942, 70)" end="(942, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(943, 5)" end="(943, 51)" kind="«term_=_»">
              <OtherNode start="(943, 5)" end="(943, 18)" kind="Lean.Parser.Term.app">
                <IdentNode start="(943, 5)" end="(943, 16)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                <NullNode start="(943, 17)" end="(943, 18)">
                  <IdentNode start="(943, 17)" end="(943, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(943, 19)" end="(943, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(943, 21)" end="(943, 51)" kind="Lean.Parser.Term.app">
                <OtherNode start="(943, 21)" end="(943, 43)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(943, 21)" end="(943, 39)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(943, 21)" end="(943, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(943, 22)" end="(943, 38)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(943, 22)" end="(943, 36)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                      <NullNode start="(943, 37)" end="(943, 38)">
                        <IdentNode start="(943, 37)" end="(943, 38)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(943, 38)" end="(943, 39)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(943, 39)" end="(943, 40)" leading="" trailing="" val="."/>
                  <IdentNode start="(943, 40)" end="(943, 43)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(943, 44)" end="(943, 51)">
                  <OtherNode start="(943, 44)" end="(943, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(943, 44)" end="(943, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(943, 45)" end="(943, 50)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(943, 45)" end="(943, 46)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(943, 45)" end="(943, 46)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(943, 46)" end="(943, 47)" leading="" trailing="" val="."/>
                      <IdentNode start="(943, 47)" end="(943, 50)" leading="" trailing="" raw_val="val" val="val" full_name="Fin.val" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(943, 50)" end="(943, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(943, 52)" end="(945, 45)">
          <AtomNode start="(943, 52)" end="(943, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(943, 55)" end="(945, 45)">
            <AtomNode start="(943, 55)" end="(943, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(944, 3)" end="(945, 45)">
              <TacticTacticseq1IndentedNode start="(944, 3)" end="(945, 45)">
                <NullNode start="(944, 3)" end="(945, 45)">
                  <OtherNode start="(944, 3)" end="(944, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx? p xs = Option.map (fun x =&amp;gt; ↑x) (findFinIdx? p xs)" state_after="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx?.go p xs 0 = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p xs xs 0 ⋯)" tactic="simp [findIdx?, findFinIdx?]">
                    <AtomNode start="(944, 3)" end="(944, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(944, 8)" end="(944, 31)">
                      <AtomNode start="(944, 8)" end="(944, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(944, 9)" end="(944, 30)">
                        <OtherNode start="(944, 9)" end="(944, 17)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(944, 9)" end="(944, 17)" leading="" trailing="" raw_val="findIdx?" val="findIdx?" full_name="List.findIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(944, 17)" end="(944, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(944, 19)" end="(944, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(944, 19)" end="(944, 30)" leading="" trailing="" raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(944, 30)" end="(944, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(945, 3)" end="(945, 45)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findIdx?.go p xs 0 = Option.map (fun x =&amp;gt; ↑x) (findFinIdx?.go p xs xs 0 ⋯)" state_after="no goals" tactic="rw [findIdx?_go_eq_map_findFinIdx?_go_val]">
                    <AtomNode start="(945, 3)" end="(945, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(945, 6)" end="(945, 45)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(945, 6)" end="(945, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(945, 7)" end="(945, 44)">
                        <OtherNode start="(945, 7)" end="(945, 44)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(945, 7)" end="(945, 44)" leading="" trailing="" raw_val="findIdx?_go_eq_map_findFinIdx?_go_val" val="findIdx?_go_eq_map_findFinIdx?_go_val" full_name="List.findIdx?_go_eq_map_findFinIdx?_go_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(930, 9)" def_end="(930, 46)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(945, 44)" end="(945, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(947, 1)" end="(952, 58)" name="findFinIdx?_eq_pmap_findIdx?" full_name="List.findFinIdx?_eq_pmap_findIdx?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(947, 1)" end="(952, 58)" name="findFinIdx?_eq_pmap_findIdx?" full_name="List.findFinIdx?_eq_pmap_findIdx?" _is_private_decl="False">
        <AtomNode start="(947, 1)" end="(947, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(947, 9)" end="(947, 37)">
          <IdentNode start="(947, 9)" end="(947, 37)" leading="" trailing=" " raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(947, 38)" end="(951, 23)">
          <NullNode start="(947, 38)" end="(947, 66)">
            <OtherNode start="(947, 38)" end="(947, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(947, 38)" end="(947, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(947, 39)" end="(947, 41)">
                <IdentNode start="(947, 39)" end="(947, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(947, 42)" end="(947, 50)">
                <AtomNode start="(947, 42)" end="(947, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(947, 44)" end="(947, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(947, 44)" end="(947, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(947, 49)" end="(947, 50)">
                    <IdentNode start="(947, 49)" end="(947, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(947, 50)" end="(947, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(947, 52)" end="(947, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(947, 52)" end="(947, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(947, 53)" end="(947, 54)">
                <IdentNode start="(947, 53)" end="(947, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(947, 55)" end="(947, 65)">
                <AtomNode start="(947, 55)" end="(947, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(947, 57)" end="(947, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(947, 57)" end="(947, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(947, 59)" end="(947, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(947, 61)" end="(947, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(947, 65)" end="(947, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(947, 67)" end="(951, 23)">
            <AtomNode start="(947, 67)" end="(947, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(948, 5)" end="(951, 23)" kind="«term_=_»">
              <OtherNode start="(948, 5)" end="(948, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(948, 5)" end="(948, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                <NullNode start="(948, 20)" end="(948, 21)">
                  <IdentNode start="(948, 20)" end="(948, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(948, 22)" end="(948, 23)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(949, 7)" end="(951, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(949, 7)" end="(949, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(949, 7)" end="(949, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(949, 7)" end="(949, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(949, 8)" end="(949, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(949, 8)" end="(949, 19)" leading="" trailing=" " raw_val="xs.findIdx?" val="xs.findIdx?"/>
                      <NullNode start="(949, 20)" end="(949, 21)">
                        <IdentNode start="(949, 20)" end="(949, 21)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(949, 21)" end="(949, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(949, 22)" end="(949, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(949, 23)" end="(949, 27)" leading="" trailing="&#10;        " raw_val="pmap" val="pmap" full_name="Option.pmap" mod_name="Init.Data.Option.Instances" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Instances.lean"/>
                </OtherNode>
                <NullNode start="(950, 9)" end="(951, 23)">
                  <OtherNode start="(950, 9)" end="(950, 86)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(950, 9)" end="(950, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(950, 10)" end="(950, 85)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(950, 10)" end="(950, 13)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(950, 14)" end="(950, 85)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(950, 14)" end="(950, 17)">
                          <IdentNode start="(950, 14)" end="(950, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(950, 16)" end="(950, 17)" leading="" trailing=" " raw_val="m" val="m"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(950, 18)" end="(950, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        <TermBytacticNode start="(950, 21)" end="(950, 85)">
                          <AtomNode start="(950, 21)" end="(950, 23)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(950, 24)" end="(950, 85)">
                            <TacticTacticseq1IndentedNode start="(950, 24)" end="(950, 85)">
                              <NullNode start="(950, 24)" end="(950, 85)">
                                <OtherNode start="(950, 24)" end="(950, 64)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.232602&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;m : findIdx? p xs = some i&#10;⊢ Fin xs.length" state_after="α : Type ?u.232602&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;m : ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ Fin xs.length" tactic="simp [findIdx?_eq_some_iff_getElem] at m">
                                  <AtomNode start="(950, 24)" end="(950, 28)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(950, 29)" end="(950, 59)">
                                    <AtomNode start="(950, 29)" end="(950, 30)" leading="" trailing="" val="["/>
                                    <NullNode start="(950, 30)" end="(950, 58)">
                                      <OtherNode start="(950, 30)" end="(950, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(950, 30)" end="(950, 58)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_getElem" val="findIdx?_eq_some_iff_getElem" full_name="List.findIdx?_eq_some_iff_getElem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(748, 9)" def_end="(748, 37)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(950, 58)" end="(950, 59)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(950, 60)" end="(950, 64)">
                                    <OtherNode start="(950, 60)" end="(950, 64)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(950, 60)" end="(950, 62)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(950, 63)" end="(950, 64)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(950, 63)" end="(950, 64)">
                                          <IdentNode start="(950, 63)" end="(950, 64)" leading="" trailing="" raw_val="m" val="m"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(950, 64)" end="(950, 65)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(950, 66)" end="(950, 85)" kind="Lean.Parser.Tactic.exact" state_before="α : Type ?u.232602&#10;xs : List α&#10;p : α → Bool&#10;i : Nat&#10;m : ∃ h, p xs[i] = true ∧ ∀ (j : Nat) (hji : j &amp;lt; i), p xs[j] = false&#10;⊢ Fin xs.length" state_after="no goals" tactic="exact ⟨i, m.choose⟩">
                                  <AtomNode start="(950, 66)" end="(950, 71)" leading="" trailing=" " val="exact"/>
                                  <OtherNode start="(950, 72)" end="(950, 85)" kind="Lean.Parser.Term.anonymousCtor">
                                    <AtomNode start="(950, 72)" end="(950, 73)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(950, 73)" end="(950, 84)">
                                      <IdentNode start="(950, 73)" end="(950, 74)" leading="" trailing="" raw_val="i" val="i"/>
                                      <AtomNode start="(950, 74)" end="(950, 75)" leading="" trailing=" " val=","/>
                                      <IdentNode start="(950, 76)" end="(950, 84)" leading="" trailing="" raw_val="m.choose" val="m.choose"/>
                                    </NullNode>
                                    <AtomNode start="(950, 84)" end="(950, 85)" leading="" trailing="" val="⟩"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(950, 85)" end="(950, 86)" leading="" trailing="&#10;        " val=")"/>
                  </OtherNode>
                  <OtherNode start="(951, 9)" end="(951, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(951, 9)" end="(951, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(951, 10)" end="(951, 22)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(951, 10)" end="(951, 13)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(951, 14)" end="(951, 22)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(951, 14)" end="(951, 17)">
                          <IdentNode start="(951, 14)" end="(951, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                          <IdentNode start="(951, 16)" end="(951, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(951, 18)" end="(951, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        <IdentNode start="(951, 21)" end="(951, 22)" leading="" trailing="" raw_val="h" val="h"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(951, 22)" end="(951, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(951, 24)" end="(952, 58)">
          <AtomNode start="(951, 24)" end="(951, 26)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(951, 27)" end="(952, 58)">
            <AtomNode start="(951, 27)" end="(951, 29)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(952, 3)" end="(952, 58)">
              <TacticTacticseq1IndentedNode start="(952, 3)" end="(952, 58)">
                <NullNode start="(952, 3)" end="(952, 58)">
                  <OtherNode start="(952, 3)" end="(952, 58)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;⊢ findFinIdx? p xs = Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯" state_after="no goals" tactic="simp [findIdx?_eq_map_findFinIdx?_val, Option.pmap_map]">
                    <AtomNode start="(952, 3)" end="(952, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(952, 8)" end="(952, 58)">
                      <AtomNode start="(952, 8)" end="(952, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(952, 9)" end="(952, 57)">
                        <OtherNode start="(952, 9)" end="(952, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(952, 9)" end="(952, 40)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(942, 9)" def_end="(942, 40)"/>
                        </OtherNode>
                        <AtomNode start="(952, 40)" end="(952, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(952, 42)" end="(952, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(952, 42)" end="(952, 57)" leading="" trailing="" raw_val="Option.pmap_map" val="Option.pmap_map" full_name="Option.pmap_map" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(952, 57)" end="(952, 58)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(954, 1)" end="(962, 29)" name="findFinIdx?_cons" full_name="List.findFinIdx?_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(954, 1)" end="(962, 29)" name="findFinIdx?_cons" full_name="List.findFinIdx?_cons" _is_private_decl="False">
        <AtomNode start="(954, 1)" end="(954, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(954, 9)" end="(954, 25)">
          <IdentNode start="(954, 9)" end="(954, 25)" leading="" trailing=" " raw_val="findFinIdx?_cons" val="findFinIdx?_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(954, 26)" end="(955, 86)">
          <NullNode start="(954, 26)" end="(954, 62)">
            <OtherNode start="(954, 26)" end="(954, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(954, 26)" end="(954, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(954, 27)" end="(954, 28)">
                <IdentNode start="(954, 27)" end="(954, 28)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(954, 29)" end="(954, 39)">
                <AtomNode start="(954, 29)" end="(954, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(954, 31)" end="(954, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(954, 31)" end="(954, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(954, 33)" end="(954, 34)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(954, 35)" end="(954, 39)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(954, 39)" end="(954, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(954, 41)" end="(954, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(954, 41)" end="(954, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(954, 42)" end="(954, 43)">
                <IdentNode start="(954, 42)" end="(954, 43)" leading="" trailing=" " raw_val="x" val="x"/>
              </NullNode>
              <NullNode start="(954, 44)" end="(954, 47)">
                <AtomNode start="(954, 44)" end="(954, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(954, 46)" end="(954, 47)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(954, 47)" end="(954, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(954, 49)" end="(954, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(954, 49)" end="(954, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(954, 50)" end="(954, 52)">
                <IdentNode start="(954, 50)" end="(954, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(954, 53)" end="(954, 61)">
                <AtomNode start="(954, 53)" end="(954, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(954, 55)" end="(954, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(954, 55)" end="(954, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(954, 60)" end="(954, 61)">
                    <IdentNode start="(954, 60)" end="(954, 61)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(954, 61)" end="(954, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(954, 63)" end="(955, 86)">
            <AtomNode start="(954, 63)" end="(954, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(955, 5)" end="(955, 86)" kind="«term_=_»">
              <OtherNode start="(955, 5)" end="(955, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(955, 5)" end="(955, 16)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(955, 17)" end="(955, 28)">
                  <IdentNode start="(955, 17)" end="(955, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(955, 19)" end="(955, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(955, 19)" end="(955, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(955, 20)" end="(955, 27)" kind="«term_::_»">
                      <IdentNode start="(955, 20)" end="(955, 21)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(955, 22)" end="(955, 24)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(955, 25)" end="(955, 27)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(955, 27)" end="(955, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(955, 29)" end="(955, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(955, 31)" end="(955, 86)" kind="termIfThenElse">
                <AtomNode start="(955, 31)" end="(955, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(955, 34)" end="(955, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(955, 34)" end="(955, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(955, 36)" end="(955, 37)">
                    <IdentNode start="(955, 36)" end="(955, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(955, 38)" end="(955, 42)" leading="" trailing=" " val="then"/>
                <OtherNode start="(955, 43)" end="(955, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(955, 43)" end="(955, 47)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(955, 48)" end="(955, 49)">
                    <OtherNode start="(955, 48)" end="(955, 49)" kind="num">
                      <AtomNode start="(955, 48)" end="(955, 49)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(955, 50)" end="(955, 54)" leading="" trailing=" " val="else"/>
                <OtherNode start="(955, 55)" end="(955, 86)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(955, 55)" end="(955, 77)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(955, 55)" end="(955, 73)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(955, 55)" end="(955, 56)" leading="" trailing="" val="("/>
                      <OtherNode start="(955, 56)" end="(955, 72)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(955, 56)" end="(955, 67)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        <NullNode start="(955, 68)" end="(955, 72)">
                          <IdentNode start="(955, 68)" end="(955, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                          <IdentNode start="(955, 70)" end="(955, 72)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(955, 72)" end="(955, 73)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(955, 73)" end="(955, 74)" leading="" trailing="" val="."/>
                    <IdentNode start="(955, 74)" end="(955, 77)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <NullNode start="(955, 78)" end="(955, 86)">
                    <IdentNode start="(955, 78)" end="(955, 86)" leading="" trailing=" " raw_val="Fin.succ" val="Fin.succ" full_name="Fin.succ" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(955, 87)" end="(962, 29)">
          <AtomNode start="(955, 87)" end="(955, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(955, 90)" end="(962, 29)">
            <AtomNode start="(955, 90)" end="(955, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(956, 3)" end="(962, 29)">
              <TacticTacticseq1IndentedNode start="(956, 3)" end="(962, 29)">
                <NullNode start="(956, 3)" end="(962, 29)">
                  <OtherNode start="(956, 3)" end="(956, 75)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ findFinIdx? p (x :: xs) = if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs)" state_after="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ Option.map Fin.val (findFinIdx? p (x :: xs)) =&#10;    Option.map Fin.val (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs))" tactic="rw [← Option.map_inj_right (f := Fin.val) (fun a b =&amp;gt; Fin.eq_of_val_eq)]">
                    <AtomNode start="(956, 3)" end="(956, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(956, 6)" end="(956, 75)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(956, 6)" end="(956, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(956, 7)" end="(956, 74)">
                        <OtherNode start="(956, 7)" end="(956, 74)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(956, 7)" end="(956, 8)">
                            <OtherNode start="(956, 7)" end="(956, 8)" kind="patternIgnore">
                              <OtherNode start="(956, 7)" end="(956, 8)" kind="token.«← »">
                                <AtomNode start="(956, 7)" end="(956, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <OtherNode start="(956, 9)" end="(956, 74)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(956, 9)" end="(956, 29)" leading="" trailing=" " raw_val="Option.map_inj_right" val="Option.map_inj_right" full_name="Option.map_inj_right" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                            <NullNode start="(956, 30)" end="(956, 74)">
                              <OtherNode start="(956, 30)" end="(956, 44)" kind="Lean.Parser.Term.namedArgument">
                                <AtomNode start="(956, 30)" end="(956, 31)" leading="" trailing="" val="("/>
                                <IdentNode start="(956, 31)" end="(956, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                                <AtomNode start="(956, 33)" end="(956, 35)" leading="" trailing=" " val=":="/>
                                <IdentNode start="(956, 36)" end="(956, 43)" leading="" trailing="" raw_val="Fin.val" val="Fin.val" full_name="Fin.val" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <AtomNode start="(956, 43)" end="(956, 44)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <OtherNode start="(956, 45)" end="(956, 74)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(956, 45)" end="(956, 46)" leading="" trailing="" val="("/>
                                <OtherNode start="(956, 46)" end="(956, 73)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(956, 46)" end="(956, 49)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(956, 50)" end="(956, 73)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(956, 50)" end="(956, 53)">
                                      <IdentNode start="(956, 50)" end="(956, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(956, 52)" end="(956, 53)" leading="" trailing=" " raw_val="b" val="b"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(956, 54)" end="(956, 56)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <IdentNode start="(956, 57)" end="(956, 73)" leading="" trailing="" raw_val="Fin.eq_of_val_eq" val="Fin.eq_of_val_eq" full_name="Fin.eq_of_val_eq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(956, 73)" end="(956, 74)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(956, 74)" end="(956, 75)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(957, 3)" end="(957, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ Option.map Fin.val (findFinIdx? p (x :: xs)) =&#10;    Option.map Fin.val (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs))" state_after="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ findIdx? p (x :: xs) = Option.map Fin.val (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs))" tactic="rw [← findIdx?_eq_map_findFinIdx?_val]">
                    <AtomNode start="(957, 3)" end="(957, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(957, 6)" end="(957, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(957, 6)" end="(957, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(957, 7)" end="(957, 40)">
                        <OtherNode start="(957, 7)" end="(957, 40)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(957, 7)" end="(957, 8)">
                            <OtherNode start="(957, 7)" end="(957, 8)" kind="patternIgnore">
                              <OtherNode start="(957, 7)" end="(957, 8)" kind="token.«← »">
                                <AtomNode start="(957, 7)" end="(957, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(957, 9)" end="(957, 40)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(942, 9)" def_end="(942, 40)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(957, 40)" end="(957, 41)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(958, 3)" end="(958, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ findIdx? p (x :: xs) = Option.map Fin.val (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs))" state_after="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) =&#10;    Option.map Fin.val (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs))" tactic="rw [findIdx?_cons]">
                    <AtomNode start="(958, 3)" end="(958, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(958, 6)" end="(958, 21)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(958, 6)" end="(958, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(958, 7)" end="(958, 20)">
                        <OtherNode start="(958, 7)" end="(958, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(958, 7)" end="(958, 20)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(958, 20)" end="(958, 21)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(959, 3)" end="(959, 8)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;⊢ (if p x = true then some 0 else Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs)) =&#10;    Option.map Fin.val (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs))" state_after="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : p x = true&#10;⊢ some 0 = Option.map Fin.val (some 0)&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" tactic="split">
                    <AtomNode start="(959, 3)" end="(959, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(960, 3)" end="(960, 9)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : p x = true&#10;⊢ some 0 = Option.map Fin.val (some 0)&#10;&#10;case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" tactic="· simp">
                    <OtherNode start="(960, 3)" end="(960, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(960, 3)" end="(960, 4)" kind="patternIgnore">
                        <OtherNode start="(960, 3)" end="(960, 4)" kind="token.«· »">
                          <AtomNode start="(960, 3)" end="(960, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(960, 5)" end="(960, 9)">
                      <TacticTacticseq1IndentedNode start="(960, 5)" end="(960, 9)">
                        <NullNode start="(960, 5)" end="(960, 9)">
                          <OtherNode start="(960, 5)" end="(960, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : p x = true&#10;⊢ some 0 = Option.map Fin.val (some 0)" state_after="no goals" tactic="simp">
                            <AtomNode start="(960, 5)" end="(960, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(961, 3)" end="(962, 29)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" state_after="no goals" tactic="· rw [findIdx?_eq_map_findFinIdx?_val]&#10;  simp [Function.comp_def]">
                    <OtherNode start="(961, 3)" end="(961, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(961, 3)" end="(961, 4)" kind="patternIgnore">
                        <OtherNode start="(961, 3)" end="(961, 4)" kind="token.«· »">
                          <AtomNode start="(961, 3)" end="(961, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(961, 5)" end="(962, 29)">
                      <TacticTacticseq1IndentedNode start="(961, 5)" end="(962, 29)">
                        <NullNode start="(961, 5)" end="(962, 29)">
                          <OtherNode start="(961, 5)" end="(961, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (findIdx? p xs) = Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" state_after="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun x =&amp;gt; ↑x) (findFinIdx? p xs)) =&#10;    Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" tactic="rw [findIdx?_eq_map_findFinIdx?_val]">
                            <AtomNode start="(961, 5)" end="(961, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(961, 8)" end="(961, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(961, 8)" end="(961, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(961, 9)" end="(961, 40)">
                                <OtherNode start="(961, 9)" end="(961, 40)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(961, 9)" end="(961, 40)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(942, 9)" def_end="(942, 40)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(961, 40)" end="(961, 41)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(962, 5)" end="(962, 29)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;h✝ : ¬p x = true&#10;⊢ Option.map (fun i =&amp;gt; i + 1) (Option.map (fun x =&amp;gt; ↑x) (findFinIdx? p xs)) =&#10;    Option.map Fin.val (Option.map Fin.succ (findFinIdx? p xs))" state_after="no goals" tactic="simp [Function.comp_def]">
                            <AtomNode start="(962, 5)" end="(962, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(962, 10)" end="(962, 29)">
                              <AtomNode start="(962, 10)" end="(962, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(962, 11)" end="(962, 28)">
                                <OtherNode start="(962, 11)" end="(962, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(962, 11)" end="(962, 28)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(962, 28)" end="(962, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(964, 1)" end="(971, 13)" name="findFinIdx?_append" full_name="List.findFinIdx?_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(964, 1)" end="(971, 13)" name="findFinIdx?_append" full_name="List.findFinIdx?_append" _is_private_decl="False">
        <AtomNode start="(964, 1)" end="(964, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(964, 9)" end="(964, 27)">
          <IdentNode start="(964, 9)" end="(964, 27)" leading="" trailing=" " raw_val="findFinIdx?_append" val="findFinIdx?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(964, 28)" end="(967, 84)">
          <NullNode start="(964, 28)" end="(964, 59)">
            <OtherNode start="(964, 28)" end="(964, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(964, 28)" end="(964, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(964, 29)" end="(964, 34)">
                <IdentNode start="(964, 29)" end="(964, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(964, 32)" end="(964, 34)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(964, 35)" end="(964, 43)">
                <AtomNode start="(964, 35)" end="(964, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(964, 37)" end="(964, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(964, 37)" end="(964, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(964, 42)" end="(964, 43)">
                    <IdentNode start="(964, 42)" end="(964, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(964, 43)" end="(964, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(964, 45)" end="(964, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(964, 45)" end="(964, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(964, 46)" end="(964, 47)">
                <IdentNode start="(964, 46)" end="(964, 47)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(964, 48)" end="(964, 58)">
                <AtomNode start="(964, 48)" end="(964, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(964, 50)" end="(964, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(964, 50)" end="(964, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(964, 52)" end="(964, 53)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(964, 54)" end="(964, 58)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(964, 58)" end="(964, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(964, 60)" end="(967, 84)">
            <AtomNode start="(964, 60)" end="(964, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(965, 5)" end="(967, 84)" kind="«term_=_»">
              <OtherNode start="(965, 5)" end="(965, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(965, 5)" end="(965, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(965, 5)" end="(965, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(965, 5)" end="(965, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(965, 6)" end="(965, 14)" kind="«term_++_»">
                      <IdentNode start="(965, 6)" end="(965, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(965, 9)" end="(965, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(965, 12)" end="(965, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(965, 14)" end="(965, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(965, 15)" end="(965, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(965, 16)" end="(965, 27)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(965, 28)" end="(965, 29)">
                  <IdentNode start="(965, 28)" end="(965, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(965, 30)" end="(965, 31)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(966, 7)" end="(967, 84)" kind="Lean.Parser.Term.app">
                <OtherNode start="(966, 7)" end="(966, 57)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(966, 7)" end="(966, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(966, 7)" end="(966, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(966, 8)" end="(966, 53)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(966, 8)" end="(966, 30)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(966, 8)" end="(966, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(966, 8)" end="(966, 9)" leading="" trailing="" val="("/>
                          <OtherNode start="(966, 9)" end="(966, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(966, 9)" end="(966, 23)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                            <NullNode start="(966, 24)" end="(966, 25)">
                              <IdentNode start="(966, 24)" end="(966, 25)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(966, 25)" end="(966, 26)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(966, 26)" end="(966, 27)" leading="" trailing="" val="."/>
                        <IdentNode start="(966, 27)" end="(966, 30)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(966, 31)" end="(966, 53)">
                        <OtherNode start="(966, 31)" end="(966, 53)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(966, 31)" end="(966, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(966, 32)" end="(966, 52)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(966, 32)" end="(966, 42)" leading="" trailing=" " raw_val="Fin.castLE" val="Fin.castLE" full_name="Fin.castLE" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(966, 43)" end="(966, 52)">
                              <OtherNode start="(966, 43)" end="(966, 52)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(966, 43)" end="(966, 44)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(966, 44)" end="(966, 51)">
                                  <AtomNode start="(966, 44)" end="(966, 46)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(966, 47)" end="(966, 51)">
                                    <TacticTacticseq1IndentedNode start="(966, 47)" end="(966, 51)">
                                      <NullNode start="(966, 47)" end="(966, 51)">
                                        <OtherNode start="(966, 47)" end="(966, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.236253&#10;xs ys : List α&#10;p : α → Bool&#10;⊢ xs.length ≤ (xs ++ ys).length" state_after="no goals" tactic="simp">
                                          <AtomNode start="(966, 47)" end="(966, 51)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(966, 51)" end="(966, 52)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(966, 52)" end="(966, 53)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(966, 53)" end="(966, 54)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(966, 54)" end="(966, 55)" leading="" trailing="" val="."/>
                  <IdentNode start="(966, 55)" end="(966, 57)" leading="" trailing="&#10;        " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(967, 9)" end="(967, 84)">
                  <OtherNode start="(967, 9)" end="(967, 84)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(967, 9)" end="(967, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(967, 10)" end="(967, 83)" kind="Lean.Parser.Term.pipeProj">
                      <OtherNode start="(967, 10)" end="(967, 55)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(967, 10)" end="(967, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(967, 10)" end="(967, 28)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(967, 10)" end="(967, 11)" leading="" trailing="" val="("/>
                            <OtherNode start="(967, 11)" end="(967, 27)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(967, 11)" end="(967, 25)" leading="" trailing=" " raw_val="ys.findFinIdx?" val="ys.findFinIdx?"/>
                              <NullNode start="(967, 26)" end="(967, 27)">
                                <IdentNode start="(967, 26)" end="(967, 27)" leading="" trailing="" raw_val="p" val="p"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(967, 27)" end="(967, 28)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(967, 28)" end="(967, 29)" leading="" trailing="" val="."/>
                          <IdentNode start="(967, 29)" end="(967, 32)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <NullNode start="(967, 33)" end="(967, 55)">
                          <OtherNode start="(967, 33)" end="(967, 55)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(967, 33)" end="(967, 34)" leading="" trailing="" val="("/>
                            <OtherNode start="(967, 34)" end="(967, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(967, 34)" end="(967, 44)" leading="" trailing=" " raw_val="Fin.natAdd" val="Fin.natAdd" full_name="Fin.natAdd" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                              <NullNode start="(967, 45)" end="(967, 54)">
                                <IdentNode start="(967, 45)" end="(967, 54)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(967, 54)" end="(967, 55)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(967, 56)" end="(967, 59)" leading="" trailing="" val="|&amp;gt;."/>
                      <IdentNode start="(967, 59)" end="(967, 62)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(967, 63)" end="(967, 83)">
                        <OtherNode start="(967, 63)" end="(967, 83)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(967, 63)" end="(967, 64)" leading="" trailing="" val="("/>
                          <OtherNode start="(967, 64)" end="(967, 82)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(967, 64)" end="(967, 72)" leading="" trailing=" " raw_val="Fin.cast" val="Fin.cast" full_name="Fin.cast" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(967, 73)" end="(967, 82)">
                              <OtherNode start="(967, 73)" end="(967, 82)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(967, 73)" end="(967, 74)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(967, 74)" end="(967, 81)">
                                  <AtomNode start="(967, 74)" end="(967, 76)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(967, 77)" end="(967, 81)">
                                    <TacticTacticseq1IndentedNode start="(967, 77)" end="(967, 81)">
                                      <NullNode start="(967, 77)" end="(967, 81)">
                                        <OtherNode start="(967, 77)" end="(967, 81)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.236253&#10;xs ys : List α&#10;p : α → Bool&#10;⊢ xs.length + ys.length = (xs ++ ys).length" state_after="no goals" tactic="simp">
                                          <AtomNode start="(967, 77)" end="(967, 81)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(967, 81)" end="(967, 82)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(967, 82)" end="(967, 83)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(967, 83)" end="(967, 84)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(967, 85)" end="(971, 13)">
          <AtomNode start="(967, 85)" end="(967, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(967, 88)" end="(971, 13)">
            <AtomNode start="(967, 88)" end="(967, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(968, 3)" end="(971, 13)">
              <TacticTacticseq1IndentedNode start="(968, 3)" end="(971, 13)">
                <NullNode start="(968, 3)" end="(971, 13)">
                  <OtherNode start="(968, 3)" end="(968, 76)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;⊢ findFinIdx? p (xs ++ ys) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p xs)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (findFinIdx? p ys)))" state_after="α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;⊢ (match findIdx? p xs, ⋯ with&#10;    | none, h =&amp;gt; Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) ⋯&#10;    | some a, h =&amp;gt; some ⟨a, ⋯⟩) =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" tactic="simp only [findFinIdx?_eq_pmap_findIdx?, findIdx?_append, Option.pmap_or]">
                    <AtomNode start="(968, 3)" end="(968, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(968, 8)" end="(968, 12)">
                      <AtomNode start="(968, 8)" end="(968, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(968, 13)" end="(968, 76)">
                      <AtomNode start="(968, 13)" end="(968, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(968, 14)" end="(968, 75)">
                        <OtherNode start="(968, 14)" end="(968, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(968, 14)" end="(968, 42)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="List.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(947, 9)" def_end="(947, 37)"/>
                        </OtherNode>
                        <AtomNode start="(968, 42)" end="(968, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(968, 44)" end="(968, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(968, 44)" end="(968, 59)" leading="" trailing="" raw_val="findIdx?_append" val="findIdx?_append" full_name="List.findIdx?_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(816, 17)" def_end="(816, 32)"/>
                        </OtherNode>
                        <AtomNode start="(968, 59)" end="(968, 60)" leading="" trailing=" " val=","/>
                        <OtherNode start="(968, 61)" end="(968, 75)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(968, 61)" end="(968, 75)" leading="" trailing="" raw_val="Option.pmap_or" val="Option.pmap_or" full_name="Option.pmap_or" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(968, 75)" end="(968, 76)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(969, 3)" end="(969, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;⊢ (match findIdx? p xs, ⋯ with&#10;    | none, h =&amp;gt; Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) ⋯&#10;    | some a, h =&amp;gt; some ⟨a, ⋯⟩) =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="case h_1&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    none.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = none&#10;heq✝ : HEq ⋯ h✝&#10;⊢ Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) ⋯ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))&#10;&#10;case h_2&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" tactic="split &amp;lt;;&amp;gt; rename_i h _">
                    <OtherNode start="(969, 3)" end="(969, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(969, 3)" end="(969, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(969, 9)" end="(969, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(969, 13)" end="(969, 25)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(969, 13)" end="(969, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(969, 22)" end="(969, 25)">
                        <LeanBinderidentNode start="(969, 22)" end="(969, 23)">
                          <IdentNode start="(969, 22)" end="(969, 23)" leading="" trailing=" " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(969, 24)" end="(969, 25)">
                          <TermHoleNode start="(969, 24)" end="(969, 25)">
                            <AtomNode start="(969, 24)" end="(969, 25)" leading="" trailing="&#10;  " val="_"/>
                          </TermHoleNode>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(970, 3)" end="(970, 61)" kind="Lean.cdot" state_before="case h_1&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    none.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = none&#10;heq✝ : HEq ⋯ h✝&#10;⊢ Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) ⋯ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))&#10;&#10;case h_2&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="case h_2&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" tactic="· simp [h, Option.pmap_map, Option.map_pmap, Nat.add_comm]">
                    <OtherNode start="(970, 3)" end="(970, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(970, 3)" end="(970, 4)" kind="patternIgnore">
                        <OtherNode start="(970, 3)" end="(970, 4)" kind="token.«· »">
                          <AtomNode start="(970, 3)" end="(970, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(970, 5)" end="(970, 61)">
                      <TacticTacticseq1IndentedNode start="(970, 5)" end="(970, 61)">
                        <NullNode start="(970, 5)" end="(970, 61)">
                          <OtherNode start="(970, 5)" end="(970, 61)" kind="Lean.Parser.Tactic.simp" state_before="case h_1&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    none.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = none&#10;heq✝ : HEq ⋯ h✝&#10;⊢ Option.pmap (fun x h =&amp;gt; ⟨x, ⋯⟩) (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) ⋯ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="no goals" tactic="simp [h, Option.pmap_map, Option.map_pmap, Nat.add_comm]">
                            <AtomNode start="(970, 5)" end="(970, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(970, 10)" end="(970, 61)">
                              <AtomNode start="(970, 10)" end="(970, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(970, 11)" end="(970, 60)">
                                <OtherNode start="(970, 11)" end="(970, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(970, 11)" end="(970, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                                <AtomNode start="(970, 12)" end="(970, 13)" leading="" trailing=" " val=","/>
                                <OtherNode start="(970, 14)" end="(970, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(970, 14)" end="(970, 29)" leading="" trailing="" raw_val="Option.pmap_map" val="Option.pmap_map" full_name="Option.pmap_map" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(970, 29)" end="(970, 30)" leading="" trailing=" " val=","/>
                                <OtherNode start="(970, 31)" end="(970, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(970, 31)" end="(970, 46)" leading="" trailing="" raw_val="Option.map_pmap" val="Option.map_pmap" full_name="Option.map_pmap" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(970, 46)" end="(970, 47)" leading="" trailing=" " val=","/>
                                <OtherNode start="(970, 48)" end="(970, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(970, 48)" end="(970, 60)" leading="" trailing="" raw_val="Nat.add_comm" val="Nat.add_comm" full_name="Nat.add_comm" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(970, 60)" end="(970, 61)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(971, 3)" end="(971, 13)" kind="Lean.cdot" state_before="case h_2&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="no goals" tactic="· simp [h]">
                    <OtherNode start="(971, 3)" end="(971, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(971, 3)" end="(971, 4)" kind="patternIgnore">
                        <OtherNode start="(971, 3)" end="(971, 4)" kind="token.«· »">
                          <AtomNode start="(971, 3)" end="(971, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(971, 5)" end="(971, 13)">
                      <TacticTacticseq1IndentedNode start="(971, 5)" end="(971, 13)">
                        <NullNode start="(971, 5)" end="(971, 13)">
                          <OtherNode start="(971, 5)" end="(971, 13)" kind="Lean.Parser.Tactic.simp" state_before="case h_2&#10;α : Type u_1&#10;xs ys : List α&#10;p : α → Bool&#10;o✝ : Option Nat&#10;h✝¹ :&#10;  ∀ (a : Nat),&#10;    o✝.or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;a✝ : Nat&#10;h✝ :&#10;  ∀ (a : Nat),&#10;    (some a✝).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a →&#10;      (findIdx? p xs).or (Option.map (fun i =&amp;gt; i + xs.length) (findIdx? p ys)) = some a&#10;h : findIdx? p xs = some a✝&#10;heq✝ : HEq ⋯ h✝&#10;⊢ some ⟨a✝, ⋯⟩ =&#10;    (Option.map (Fin.castLE ⋯) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p xs) ⋯)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.length) (Option.pmap (fun i m =&amp;gt; ⟨i, ⋯⟩) (findIdx? p ys) ⋯)))" state_after="no goals" tactic="simp [h]">
                            <AtomNode start="(971, 5)" end="(971, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(971, 10)" end="(971, 13)">
                              <AtomNode start="(971, 10)" end="(971, 11)" leading="" trailing="" val="["/>
                              <NullNode start="(971, 11)" end="(971, 12)">
                                <OtherNode start="(971, 11)" end="(971, 12)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(971, 11)" end="(971, 12)" leading="" trailing="" raw_val="h" val="h"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(971, 12)" end="(971, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(973, 1)" end="(975, 43)" name="findFinIdx?_singleton" full_name="List.findFinIdx?_singleton">
      <CommandDeclmodifiersNode start="(973, 1)" end="(973, 8)">
        <NullNode/>
        <NullNode start="(973, 1)" end="(973, 8)">
          <OtherNode start="(973, 1)" end="(973, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(973, 1)" end="(973, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(973, 3)" end="(973, 7)">
              <OtherNode start="(973, 3)" end="(973, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(973, 3)" end="(973, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(973, 3)" end="(973, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(973, 7)" end="(973, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(973, 9)" end="(975, 43)" name="findFinIdx?_singleton" full_name="List.findFinIdx?_singleton" _is_private_decl="False">
        <AtomNode start="(973, 9)" end="(973, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(973, 17)" end="(973, 38)">
          <IdentNode start="(973, 17)" end="(973, 38)" leading="" trailing=" " raw_val="findFinIdx?_singleton" val="findFinIdx?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(973, 39)" end="(974, 64)">
          <NullNode start="(973, 39)" end="(973, 61)">
            <OtherNode start="(973, 39)" end="(973, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(973, 39)" end="(973, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(973, 40)" end="(973, 41)">
                <IdentNode start="(973, 40)" end="(973, 41)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(973, 42)" end="(973, 45)">
                <AtomNode start="(973, 42)" end="(973, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(973, 44)" end="(973, 45)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(973, 45)" end="(973, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(973, 47)" end="(973, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(973, 47)" end="(973, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(973, 48)" end="(973, 49)">
                <IdentNode start="(973, 48)" end="(973, 49)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(973, 50)" end="(973, 60)">
                <AtomNode start="(973, 50)" end="(973, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(973, 52)" end="(973, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(973, 52)" end="(973, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(973, 54)" end="(973, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(973, 56)" end="(973, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(973, 60)" end="(973, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(973, 62)" end="(974, 64)">
            <AtomNode start="(973, 62)" end="(973, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(974, 5)" end="(974, 64)" kind="«term_=_»">
              <OtherNode start="(974, 5)" end="(974, 22)" kind="Lean.Parser.Term.app">
                <OtherNode start="(974, 5)" end="(974, 20)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(974, 5)" end="(974, 8)" kind="«term[_]»">
                    <AtomNode start="(974, 5)" end="(974, 6)" leading="" trailing="" val="["/>
                    <NullNode start="(974, 6)" end="(974, 7)">
                      <IdentNode start="(974, 6)" end="(974, 7)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(974, 7)" end="(974, 8)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(974, 8)" end="(974, 9)" leading="" trailing="" val="."/>
                  <IdentNode start="(974, 9)" end="(974, 20)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="List.findFinIdx?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(974, 21)" end="(974, 22)">
                  <IdentNode start="(974, 21)" end="(974, 22)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(974, 23)" end="(974, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(974, 25)" end="(974, 64)" kind="termIfThenElse">
                <AtomNode start="(974, 25)" end="(974, 27)" leading="" trailing=" " val="if"/>
                <OtherNode start="(974, 28)" end="(974, 31)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(974, 28)" end="(974, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(974, 30)" end="(974, 31)">
                    <IdentNode start="(974, 30)" end="(974, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(974, 32)" end="(974, 36)" leading="" trailing=" " val="then"/>
                <OtherNode start="(974, 37)" end="(974, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(974, 37)" end="(974, 41)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(974, 42)" end="(974, 54)">
                    <OtherNode start="(974, 42)" end="(974, 54)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(974, 42)" end="(974, 43)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(974, 43)" end="(974, 53)">
                        <OtherNode start="(974, 43)" end="(974, 44)" kind="num">
                          <AtomNode start="(974, 43)" end="(974, 44)" leading="" trailing="" val="0"/>
                        </OtherNode>
                        <AtomNode start="(974, 44)" end="(974, 45)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(974, 46)" end="(974, 53)">
                          <AtomNode start="(974, 46)" end="(974, 48)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(974, 49)" end="(974, 53)">
                            <TacticTacticseq1IndentedNode start="(974, 49)" end="(974, 53)">
                              <NullNode start="(974, 49)" end="(974, 53)">
                                <OtherNode start="(974, 49)" end="(974, 53)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.241465&#10;a : α&#10;p : α → Bool&#10;⊢ 0 &amp;lt; [a].length" state_after="no goals" tactic="simp">
                                  <AtomNode start="(974, 49)" end="(974, 53)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(974, 53)" end="(974, 54)" leading="" trailing=" " val="⟩"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(974, 55)" end="(974, 59)" leading="" trailing=" " val="else"/>
                <IdentNode start="(974, 60)" end="(974, 64)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(974, 65)" end="(975, 43)">
          <AtomNode start="(974, 65)" end="(974, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(974, 68)" end="(975, 43)">
            <AtomNode start="(974, 68)" end="(974, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(975, 3)" end="(975, 43)">
              <TacticTacticseq1IndentedNode start="(975, 3)" end="(975, 43)">
                <NullNode start="(975, 3)" end="(975, 43)">
                  <OtherNode start="(975, 3)" end="(975, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ findFinIdx? p [a] = if p a = true then some ⟨0, ⋯⟩ else none" state_after="no goals" tactic="simp [findFinIdx?_cons, findFinIdx?_nil]">
                    <AtomNode start="(975, 3)" end="(975, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(975, 8)" end="(975, 43)">
                      <AtomNode start="(975, 8)" end="(975, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(975, 9)" end="(975, 42)">
                        <OtherNode start="(975, 9)" end="(975, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(975, 9)" end="(975, 25)" leading="" trailing="" raw_val="findFinIdx?_cons" val="findFinIdx?_cons" full_name="List.findFinIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(954, 9)" def_end="(954, 25)"/>
                        </OtherNode>
                        <AtomNode start="(975, 25)" end="(975, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(975, 27)" end="(975, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(975, 27)" end="(975, 42)" leading="" trailing="" raw_val="findFinIdx?_nil" val="findFinIdx?_nil" full_name="List.findFinIdx?_nil" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(928, 17)" def_end="(928, 32)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(975, 42)" end="(975, 43)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(977, 1)" end="(979, 38)" name="findFinIdx?_eq_none_iff" full_name="List.findFinIdx?_eq_none_iff">
      <CommandDeclmodifiersNode start="(977, 1)" end="(977, 8)">
        <NullNode/>
        <NullNode start="(977, 1)" end="(977, 8)">
          <OtherNode start="(977, 1)" end="(977, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(977, 1)" end="(977, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(977, 3)" end="(977, 7)">
              <OtherNode start="(977, 3)" end="(977, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(977, 3)" end="(977, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(977, 3)" end="(977, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(977, 7)" end="(977, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(977, 9)" end="(979, 38)" name="findFinIdx?_eq_none_iff" full_name="List.findFinIdx?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(977, 9)" end="(977, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(977, 17)" end="(977, 40)">
          <IdentNode start="(977, 17)" end="(977, 40)" leading="" trailing=" " raw_val="findFinIdx?_eq_none_iff" val="findFinIdx?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(977, 41)" end="(978, 44)">
          <NullNode start="(977, 41)" end="(977, 68)">
            <OtherNode start="(977, 41)" end="(977, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(977, 41)" end="(977, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(977, 42)" end="(977, 43)">
                <IdentNode start="(977, 42)" end="(977, 43)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(977, 44)" end="(977, 52)">
                <AtomNode start="(977, 44)" end="(977, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(977, 46)" end="(977, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(977, 46)" end="(977, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(977, 51)" end="(977, 52)">
                    <IdentNode start="(977, 51)" end="(977, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(977, 52)" end="(977, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(977, 54)" end="(977, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(977, 54)" end="(977, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(977, 55)" end="(977, 56)">
                <IdentNode start="(977, 55)" end="(977, 56)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(977, 57)" end="(977, 67)">
                <AtomNode start="(977, 57)" end="(977, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(977, 59)" end="(977, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(977, 59)" end="(977, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(977, 61)" end="(977, 62)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(977, 63)" end="(977, 67)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(977, 67)" end="(977, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(977, 69)" end="(978, 44)">
            <AtomNode start="(977, 69)" end="(977, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(978, 5)" end="(978, 44)" kind="«term_↔_»">
              <OtherNode start="(978, 5)" end="(978, 27)" kind="«term_=_»">
                <OtherNode start="(978, 5)" end="(978, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(978, 5)" end="(978, 18)" leading="" trailing=" " raw_val="l.findFinIdx?" val="l.findFinIdx?"/>
                  <NullNode start="(978, 19)" end="(978, 20)">
                    <IdentNode start="(978, 19)" end="(978, 20)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(978, 21)" end="(978, 22)" leading="" trailing=" " val="="/>
                <IdentNode start="(978, 23)" end="(978, 27)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(978, 28)" end="(978, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(978, 30)" end="(978, 44)" kind="Lean.«term∀__,_»">
                <AtomNode start="(978, 30)" end="(978, 31)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(978, 32)" end="(978, 33)">
                  <IdentNode start="(978, 32)" end="(978, 33)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(978, 34)" end="(978, 37)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(978, 34)" end="(978, 35)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(978, 36)" end="(978, 37)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(978, 37)" end="(978, 38)" leading="" trailing=" " val=","/>
                <OtherNode start="(978, 39)" end="(978, 44)" kind="«term¬_»">
                  <AtomNode start="(978, 39)" end="(978, 40)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(978, 41)" end="(978, 44)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(978, 41)" end="(978, 42)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(978, 43)" end="(978, 44)">
                      <IdentNode start="(978, 43)" end="(978, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(978, 45)" end="(979, 38)">
          <AtomNode start="(978, 45)" end="(978, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(978, 48)" end="(979, 38)">
            <AtomNode start="(978, 48)" end="(978, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(979, 3)" end="(979, 38)">
              <TacticTacticseq1IndentedNode start="(979, 3)" end="(979, 38)">
                <NullNode start="(979, 3)" end="(979, 38)">
                  <OtherNode start="(979, 3)" end="(979, 38)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;⊢ findFinIdx? p l = none ↔ ∀ (x : α), x ∈ l → ¬p x = true" state_after="no goals" tactic="simp [findFinIdx?_eq_pmap_findIdx?]">
                    <AtomNode start="(979, 3)" end="(979, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(979, 8)" end="(979, 38)">
                      <AtomNode start="(979, 8)" end="(979, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(979, 9)" end="(979, 37)">
                        <OtherNode start="(979, 9)" end="(979, 37)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(979, 9)" end="(979, 37)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="List.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(947, 9)" def_end="(947, 37)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(979, 37)" end="(979, 38)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(981, 1)" end="(991, 63)" name="findFinIdx?_eq_some_iff" full_name="List.findFinIdx?_eq_some_iff">
      <CommandDeclmodifiersNode start="(981, 1)" end="(981, 8)">
        <NullNode/>
        <NullNode start="(981, 1)" end="(981, 8)">
          <OtherNode start="(981, 1)" end="(981, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(981, 1)" end="(981, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(981, 3)" end="(981, 7)">
              <OtherNode start="(981, 3)" end="(981, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(981, 3)" end="(981, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(981, 3)" end="(981, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(981, 7)" end="(981, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(982, 1)" end="(991, 63)" name="findFinIdx?_eq_some_iff" full_name="List.findFinIdx?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(982, 1)" end="(982, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(982, 9)" end="(982, 32)">
          <IdentNode start="(982, 9)" end="(982, 32)" leading="" trailing=" " raw_val="findFinIdx?_eq_some_iff" val="findFinIdx?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(982, 33)" end="(984, 69)">
          <NullNode start="(982, 33)" end="(982, 81)">
            <OtherNode start="(982, 33)" end="(982, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(982, 33)" end="(982, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(982, 34)" end="(982, 36)">
                <IdentNode start="(982, 34)" end="(982, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(982, 37)" end="(982, 45)">
                <AtomNode start="(982, 37)" end="(982, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(982, 39)" end="(982, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(982, 39)" end="(982, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(982, 44)" end="(982, 45)">
                    <IdentNode start="(982, 44)" end="(982, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(982, 45)" end="(982, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(982, 47)" end="(982, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(982, 47)" end="(982, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(982, 48)" end="(982, 49)">
                <IdentNode start="(982, 48)" end="(982, 49)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(982, 50)" end="(982, 60)">
                <AtomNode start="(982, 50)" end="(982, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(982, 52)" end="(982, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(982, 52)" end="(982, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(982, 54)" end="(982, 55)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(982, 56)" end="(982, 60)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(982, 60)" end="(982, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(982, 62)" end="(982, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(982, 62)" end="(982, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(982, 63)" end="(982, 64)">
                <IdentNode start="(982, 63)" end="(982, 64)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(982, 65)" end="(982, 80)">
                <AtomNode start="(982, 65)" end="(982, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(982, 67)" end="(982, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(982, 67)" end="(982, 70)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(982, 71)" end="(982, 80)">
                    <IdentNode start="(982, 71)" end="(982, 80)" leading="" trailing="" raw_val="xs.length" val="xs.length"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(982, 80)" end="(982, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(982, 82)" end="(984, 69)">
            <AtomNode start="(982, 82)" end="(982, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(983, 5)" end="(984, 69)" kind="«term_↔_»">
              <OtherNode start="(983, 5)" end="(983, 30)" kind="«term_=_»">
                <OtherNode start="(983, 5)" end="(983, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(983, 5)" end="(983, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                  <NullNode start="(983, 20)" end="(983, 21)">
                    <IdentNode start="(983, 20)" end="(983, 21)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(983, 22)" end="(983, 23)" leading="" trailing=" " val="="/>
                <OtherNode start="(983, 24)" end="(983, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(983, 24)" end="(983, 28)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(983, 29)" end="(983, 30)">
                    <IdentNode start="(983, 29)" end="(983, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(983, 31)" end="(983, 32)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(984, 7)" end="(984, 69)" kind="«term_∧_»">
                <OtherNode start="(984, 7)" end="(984, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(984, 7)" end="(984, 8)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(984, 9)" end="(984, 14)">
                    <OtherNode start="(984, 9)" end="(984, 14)" kind="«term__[_]»">
                      <IdentNode start="(984, 9)" end="(984, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(984, 11)" end="(984, 12)" leading="" trailing="" val="["/>
                      <IdentNode start="(984, 12)" end="(984, 13)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(984, 13)" end="(984, 14)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(984, 15)" end="(984, 16)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(984, 17)" end="(984, 69)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(984, 17)" end="(984, 18)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(984, 19)" end="(984, 34)">
                    <IdentNode start="(984, 19)" end="(984, 20)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(984, 21)" end="(984, 34)">
                      <AtomNode start="(984, 21)" end="(984, 22)" leading="" trailing="" val="("/>
                      <NullNode start="(984, 22)" end="(984, 25)">
                        <IdentNode start="(984, 22)" end="(984, 25)" leading="" trailing=" " raw_val="hji" val="hji"/>
                      </NullNode>
                      <NullNode start="(984, 26)" end="(984, 33)">
                        <AtomNode start="(984, 26)" end="(984, 27)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(984, 28)" end="(984, 33)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(984, 28)" end="(984, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(984, 30)" end="(984, 31)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(984, 32)" end="(984, 33)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(984, 33)" end="(984, 34)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(984, 34)" end="(984, 35)" leading="" trailing=" " val=","/>
                  <OtherNode start="(984, 36)" end="(984, 69)" kind="«term¬_»">
                    <AtomNode start="(984, 36)" end="(984, 37)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(984, 37)" end="(984, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(984, 37)" end="(984, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(984, 39)" end="(984, 69)">
                        <OtherNode start="(984, 39)" end="(984, 69)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(984, 39)" end="(984, 40)" leading="" trailing="" val="("/>
                          <OtherNode start="(984, 40)" end="(984, 68)" kind="«term__[_]'_»">
                            <IdentNode start="(984, 40)" end="(984, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                            <AtomNode start="(984, 42)" end="(984, 43)" leading="" trailing="" val="["/>
                            <IdentNode start="(984, 43)" end="(984, 44)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(984, 44)" end="(984, 46)" leading="" trailing="" val="]'"/>
                            <OtherNode start="(984, 46)" end="(984, 68)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(984, 46)" end="(984, 47)" leading="" trailing="" val="("/>
                              <OtherNode start="(984, 47)" end="(984, 67)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(984, 47)" end="(984, 59)" leading="" trailing=" " raw_val="Nat.lt_trans" val="Nat.lt_trans" full_name="Nat.lt_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(984, 60)" end="(984, 67)">
                                  <IdentNode start="(984, 60)" end="(984, 63)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                  <OtherNode start="(984, 64)" end="(984, 67)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(984, 64)" end="(984, 65)" leading="" trailing="" raw_val="i" val="i"/>
                                    <AtomNode start="(984, 65)" end="(984, 66)" leading="" trailing="" val="."/>
                                    <OtherNode start="(984, 66)" end="(984, 67)" kind="fieldIdx">
                                      <AtomNode start="(984, 66)" end="(984, 67)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(984, 67)" end="(984, 68)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(984, 68)" end="(984, 69)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(984, 70)" end="(991, 63)">
          <AtomNode start="(984, 70)" end="(984, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(984, 73)" end="(991, 63)">
            <AtomNode start="(984, 73)" end="(984, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(985, 3)" end="(991, 63)">
              <TacticTacticseq1IndentedNode start="(985, 3)" end="(991, 63)">
                <NullNode start="(985, 3)" end="(991, 63)">
                  <OtherNode start="(985, 3)" end="(986, 73)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ findFinIdx? p xs = some i ↔ p xs[i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), ¬p xs[j] = true" state_after="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) ↔ p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false" tactic="simp only [findFinIdx?_eq_pmap_findIdx?, Option.pmap_eq_some_iff, findIdx?_eq_some_iff_getElem,&#10;  Bool.not_eq_true, exists_and_left, and_exists_self, Fin.getElem_fin]">
                    <AtomNode start="(985, 3)" end="(985, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(985, 8)" end="(985, 12)">
                      <AtomNode start="(985, 8)" end="(985, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(985, 13)" end="(986, 73)">
                      <AtomNode start="(985, 13)" end="(985, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(985, 14)" end="(986, 72)">
                        <OtherNode start="(985, 14)" end="(985, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(985, 14)" end="(985, 42)" leading="" trailing="" raw_val="findFinIdx?_eq_pmap_findIdx?" val="findFinIdx?_eq_pmap_findIdx?" full_name="List.findFinIdx?_eq_pmap_findIdx?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(947, 9)" def_end="(947, 37)"/>
                        </OtherNode>
                        <AtomNode start="(985, 42)" end="(985, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(985, 44)" end="(985, 67)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(985, 44)" end="(985, 67)" leading="" trailing="" raw_val="Option.pmap_eq_some_iff" val="Option.pmap_eq_some_iff" full_name="Option.pmap_eq_some_iff" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(985, 67)" end="(985, 68)" leading="" trailing=" " val=","/>
                        <OtherNode start="(985, 69)" end="(985, 97)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(985, 69)" end="(985, 97)" leading="" trailing="" raw_val="findIdx?_eq_some_iff_getElem" val="findIdx?_eq_some_iff_getElem" full_name="List.findIdx?_eq_some_iff_getElem" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(748, 9)" def_end="(748, 37)"/>
                        </OtherNode>
                        <AtomNode start="(985, 97)" end="(985, 98)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(986, 5)" end="(986, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(986, 5)" end="(986, 21)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(986, 21)" end="(986, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(986, 23)" end="(986, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(986, 23)" end="(986, 38)" leading="" trailing="" raw_val="exists_and_left" val="exists_and_left" full_name="exists_and_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(986, 38)" end="(986, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(986, 40)" end="(986, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(986, 40)" end="(986, 55)" leading="" trailing="" raw_val="and_exists_self" val="and_exists_self" full_name="and_exists_self" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(986, 55)" end="(986, 56)" leading="" trailing=" " val=","/>
                        <OtherNode start="(986, 57)" end="(986, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(986, 57)" end="(986, 72)" leading="" trailing="" raw_val="Fin.getElem_fin" val="Fin.getElem_fin" full_name="Fin.getElem_fin" mod_name="Init.GetElem" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/GetElem.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(986, 72)" end="(986, 73)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(987, 3)" end="(987, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) ↔ p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false" state_after="case mp&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) → p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false&#10;&#10;case mpr&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" tactic="constructor">
                    <AtomNode start="(987, 3)" end="(987, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(988, 3)" end="(989, 53)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) → p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false&#10;&#10;case mpr&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" state_after="case mpr&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" tactic="· rintro ⟨a, ⟨h, w₁, w₂⟩, rfl⟩&#10;  exact ⟨w₁, fun j hji =&amp;gt; by simpa using w₂ j hji⟩">
                    <OtherNode start="(988, 3)" end="(988, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(988, 3)" end="(988, 4)" kind="patternIgnore">
                        <OtherNode start="(988, 3)" end="(988, 4)" kind="token.«· »">
                          <AtomNode start="(988, 3)" end="(988, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(988, 5)" end="(989, 53)">
                      <TacticTacticseq1IndentedNode start="(988, 5)" end="(989, 53)">
                        <NullNode start="(988, 5)" end="(989, 53)">
                          <OtherNode start="(988, 5)" end="(988, 33)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (∃ a x, i = ⟨a, ⋯⟩) → p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false" state_after="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;w₁ : p xs[a] = true&#10;w₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ p xs[↑⟨a, ⋯⟩] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; ⟨a, ⋯⟩), p xs[↑j] = false" tactic="rintro ⟨a, ⟨h, w₁, w₂⟩, rfl⟩">
                            <AtomNode start="(988, 5)" end="(988, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(988, 12)" end="(988, 33)">
                              <OtherNode start="(988, 12)" end="(988, 33)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(988, 12)" end="(988, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(988, 12)" end="(988, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(988, 13)" end="(988, 32)">
                                    <OtherNode start="(988, 13)" end="(988, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(988, 13)" end="(988, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(988, 13)" end="(988, 14)">
                                          <OtherNode start="(988, 13)" end="(988, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(988, 13)" end="(988, 14)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(988, 14)" end="(988, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(988, 16)" end="(988, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(988, 16)" end="(988, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(988, 16)" end="(988, 27)">
                                          <OtherNode start="(988, 16)" end="(988, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(988, 16)" end="(988, 17)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(988, 17)" end="(988, 26)">
                                              <OtherNode start="(988, 17)" end="(988, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(988, 17)" end="(988, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(988, 17)" end="(988, 18)">
                                                    <OtherNode start="(988, 17)" end="(988, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(988, 17)" end="(988, 18)" leading="" trailing="" raw_val="h" val="h"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(988, 18)" end="(988, 19)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(988, 20)" end="(988, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(988, 20)" end="(988, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(988, 20)" end="(988, 22)">
                                                    <OtherNode start="(988, 20)" end="(988, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(988, 20)" end="(988, 22)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(988, 22)" end="(988, 23)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(988, 24)" end="(988, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(988, 24)" end="(988, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(988, 24)" end="(988, 26)">
                                                    <OtherNode start="(988, 24)" end="(988, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(988, 24)" end="(988, 26)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(988, 26)" end="(988, 27)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(988, 27)" end="(988, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(988, 29)" end="(988, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(988, 29)" end="(988, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(988, 29)" end="(988, 32)">
                                          <OtherNode start="(988, 29)" end="(988, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(988, 29)" end="(988, 32)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(988, 32)" end="(988, 33)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(989, 5)" end="(989, 53)" kind="Lean.Parser.Tactic.exact" state_before="case mp.intro.intro.intro.intro&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;w₁ : p xs[a] = true&#10;w₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;⊢ p xs[↑⟨a, ⋯⟩] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; ⟨a, ⋯⟩), p xs[↑j] = false" state_after="no goals" tactic="exact ⟨w₁, fun j hji =&amp;gt; by simpa using w₂ j hji⟩">
                            <AtomNode start="(989, 5)" end="(989, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(989, 11)" end="(989, 53)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(989, 11)" end="(989, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(989, 12)" end="(989, 52)">
                                <IdentNode start="(989, 12)" end="(989, 14)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                <AtomNode start="(989, 14)" end="(989, 15)" leading="" trailing=" " val=","/>
                                <OtherNode start="(989, 16)" end="(989, 52)" kind="Lean.Parser.Term.fun">
                                  <AtomNode start="(989, 16)" end="(989, 19)" leading="" trailing=" " val="fun"/>
                                  <OtherNode start="(989, 20)" end="(989, 52)" kind="Lean.Parser.Term.basicFun">
                                    <NullNode start="(989, 20)" end="(989, 25)">
                                      <IdentNode start="(989, 20)" end="(989, 21)" leading="" trailing=" " raw_val="j" val="j"/>
                                      <IdentNode start="(989, 22)" end="(989, 25)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(989, 26)" end="(989, 28)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(989, 29)" end="(989, 52)">
                                      <AtomNode start="(989, 29)" end="(989, 31)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(989, 32)" end="(989, 52)">
                                        <TacticTacticseq1IndentedNode start="(989, 32)" end="(989, 52)">
                                          <NullNode start="(989, 32)" end="(989, 52)">
                                            <OtherNode start="(989, 32)" end="(989, 52)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;a : Nat&#10;h : a &amp;lt; xs.length&#10;w₁ : p xs[a] = true&#10;w₂ : ∀ (j : Nat) (hji : j &amp;lt; a), p xs[j] = false&#10;j : Fin xs.length&#10;hji : j &amp;lt; ⟨a, ⋯⟩&#10;⊢ p xs[↑j] = false" state_after="no goals" tactic="simpa using w₂ j hji">
                                              <AtomNode start="(989, 32)" end="(989, 37)" leading="" trailing=" " val="simpa"/>
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(989, 38)" end="(989, 52)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(989, 38)" end="(989, 52)">
                                                  <AtomNode start="(989, 38)" end="(989, 43)" leading="" trailing=" " val="using"/>
                                                  <OtherNode start="(989, 44)" end="(989, 52)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(989, 44)" end="(989, 46)" leading="" trailing=" " raw_val="w₂" val="w₂"/>
                                                    <NullNode start="(989, 47)" end="(989, 52)">
                                                      <IdentNode start="(989, 47)" end="(989, 48)" leading="" trailing=" " raw_val="j" val="j"/>
                                                      <IdentNode start="(989, 49)" end="(989, 52)" leading="" trailing="" raw_val="hji" val="hji"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(989, 52)" end="(989, 53)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(990, 3)" end="(991, 63)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" state_after="no goals" tactic="· rintro ⟨h, w⟩&#10;  exact ⟨i, ⟨i.2, h, fun j hji =&amp;gt; w ⟨j, by omega⟩ hji⟩, rfl⟩">
                    <OtherNode start="(990, 3)" end="(990, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(990, 3)" end="(990, 4)" kind="patternIgnore">
                        <OtherNode start="(990, 3)" end="(990, 4)" kind="token.«· »">
                          <AtomNode start="(990, 3)" end="(990, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(990, 5)" end="(991, 63)">
                      <TacticTacticseq1IndentedNode start="(990, 5)" end="(991, 63)">
                        <NullNode start="(990, 5)" end="(991, 63)">
                          <OtherNode start="(990, 5)" end="(990, 18)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;⊢ (p xs[↑i] = true ∧ ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false) → ∃ a x, i = ⟨a, ⋯⟩" state_after="case mpr.intro&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;h : p xs[↑i] = true&#10;w : ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false&#10;⊢ ∃ a x, i = ⟨a, ⋯⟩" tactic="rintro ⟨h, w⟩">
                            <AtomNode start="(990, 5)" end="(990, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(990, 12)" end="(990, 18)">
                              <OtherNode start="(990, 12)" end="(990, 18)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(990, 12)" end="(990, 18)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(990, 12)" end="(990, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(990, 13)" end="(990, 17)">
                                    <OtherNode start="(990, 13)" end="(990, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(990, 13)" end="(990, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(990, 13)" end="(990, 14)">
                                          <OtherNode start="(990, 13)" end="(990, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(990, 13)" end="(990, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(990, 14)" end="(990, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(990, 16)" end="(990, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(990, 16)" end="(990, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(990, 16)" end="(990, 17)">
                                          <OtherNode start="(990, 16)" end="(990, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(990, 16)" end="(990, 17)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(990, 17)" end="(990, 18)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(991, 5)" end="(991, 63)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro&#10;α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;h : p xs[↑i] = true&#10;w : ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false&#10;⊢ ∃ a x, i = ⟨a, ⋯⟩" state_after="no goals" tactic="exact ⟨i, ⟨i.2, h, fun j hji =&amp;gt; w ⟨j, by omega⟩ hji⟩, rfl⟩">
                            <AtomNode start="(991, 5)" end="(991, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(991, 11)" end="(991, 63)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(991, 11)" end="(991, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(991, 12)" end="(991, 62)">
                                <IdentNode start="(991, 12)" end="(991, 13)" leading="" trailing="" raw_val="i" val="i"/>
                                <AtomNode start="(991, 13)" end="(991, 14)" leading="" trailing=" " val=","/>
                                <OtherNode start="(991, 15)" end="(991, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(991, 15)" end="(991, 16)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(991, 16)" end="(991, 56)">
                                    <OtherNode start="(991, 16)" end="(991, 19)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(991, 16)" end="(991, 17)" leading="" trailing="" raw_val="i" val="i"/>
                                      <AtomNode start="(991, 17)" end="(991, 18)" leading="" trailing="" val="."/>
                                      <OtherNode start="(991, 18)" end="(991, 19)" kind="fieldIdx">
                                        <AtomNode start="(991, 18)" end="(991, 19)" leading="" trailing="" val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(991, 19)" end="(991, 20)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(991, 21)" end="(991, 22)" leading="" trailing="" raw_val="h" val="h"/>
                                    <AtomNode start="(991, 22)" end="(991, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(991, 24)" end="(991, 56)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(991, 24)" end="(991, 27)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(991, 28)" end="(991, 56)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(991, 28)" end="(991, 33)">
                                          <IdentNode start="(991, 28)" end="(991, 29)" leading="" trailing=" " raw_val="j" val="j"/>
                                          <IdentNode start="(991, 30)" end="(991, 33)" leading="" trailing=" " raw_val="hji" val="hji"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(991, 34)" end="(991, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <OtherNode start="(991, 37)" end="(991, 56)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(991, 37)" end="(991, 38)" leading="" trailing=" " raw_val="w" val="w"/>
                                          <NullNode start="(991, 39)" end="(991, 56)">
                                            <OtherNode start="(991, 39)" end="(991, 52)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(991, 39)" end="(991, 40)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(991, 40)" end="(991, 51)">
                                                <IdentNode start="(991, 40)" end="(991, 41)" leading="" trailing="" raw_val="j" val="j"/>
                                                <AtomNode start="(991, 41)" end="(991, 42)" leading="" trailing=" " val=","/>
                                                <TermBytacticNode start="(991, 43)" end="(991, 51)">
                                                  <AtomNode start="(991, 43)" end="(991, 45)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(991, 46)" end="(991, 51)">
                                                    <TacticTacticseq1IndentedNode start="(991, 46)" end="(991, 51)">
                                                      <NullNode start="(991, 46)" end="(991, 51)">
                                                        <OtherNode start="(991, 46)" end="(991, 51)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;xs : List α&#10;p : α → Bool&#10;i : Fin xs.length&#10;h : p xs[↑i] = true&#10;w : ∀ (j : Fin xs.length) (hji : j &amp;lt; i), p xs[↑j] = false&#10;j : Nat&#10;hji : j &amp;lt; ↑i&#10;⊢ j &amp;lt; xs.length" state_after="no goals" tactic="omega">
                                                          <AtomNode start="(991, 46)" end="(991, 51)" leading="" trailing="" val="omega"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </NullNode>
                                              <AtomNode start="(991, 51)" end="(991, 52)" leading="" trailing=" " val="⟩"/>
                                            </OtherNode>
                                            <IdentNode start="(991, 53)" end="(991, 56)" leading="" trailing="" raw_val="hji" val="hji"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(991, 56)" end="(991, 57)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(991, 57)" end="(991, 58)" leading="" trailing=" " val=","/>
                                <IdentNode start="(991, 59)" end="(991, 62)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(991, 62)" end="(991, 63)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(993, 1)" end="(1000, 23)" name="isSome_findFinIdx?" full_name="List.isSome_findFinIdx?">
      <CommandDeclmodifiersNode start="(993, 1)" end="(993, 8)">
        <NullNode/>
        <NullNode start="(993, 1)" end="(993, 8)">
          <OtherNode start="(993, 1)" end="(993, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(993, 1)" end="(993, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(993, 3)" end="(993, 7)">
              <OtherNode start="(993, 3)" end="(993, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(993, 3)" end="(993, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(993, 3)" end="(993, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(993, 7)" end="(993, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(994, 1)" end="(1000, 23)" name="isSome_findFinIdx?" full_name="List.isSome_findFinIdx?" _is_private_decl="False">
        <AtomNode start="(994, 1)" end="(994, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(994, 9)" end="(994, 27)">
          <IdentNode start="(994, 9)" end="(994, 27)" leading="" trailing=" " raw_val="isSome_findFinIdx?" val="isSome_findFinIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(994, 28)" end="(995, 39)">
          <NullNode start="(994, 28)" end="(994, 55)">
            <OtherNode start="(994, 28)" end="(994, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(994, 28)" end="(994, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(994, 29)" end="(994, 30)">
                <IdentNode start="(994, 29)" end="(994, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(994, 31)" end="(994, 39)">
                <AtomNode start="(994, 31)" end="(994, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(994, 33)" end="(994, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(994, 33)" end="(994, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(994, 38)" end="(994, 39)">
                    <IdentNode start="(994, 38)" end="(994, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(994, 39)" end="(994, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(994, 41)" end="(994, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(994, 41)" end="(994, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(994, 42)" end="(994, 43)">
                <IdentNode start="(994, 42)" end="(994, 43)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(994, 44)" end="(994, 54)">
                <AtomNode start="(994, 44)" end="(994, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(994, 46)" end="(994, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(994, 46)" end="(994, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(994, 48)" end="(994, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(994, 50)" end="(994, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(994, 54)" end="(994, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(994, 56)" end="(995, 39)">
            <AtomNode start="(994, 56)" end="(994, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(995, 5)" end="(995, 39)" kind="«term_=_»">
              <OtherNode start="(995, 5)" end="(995, 29)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(995, 5)" end="(995, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(995, 5)" end="(995, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(995, 6)" end="(995, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(995, 6)" end="(995, 19)" leading="" trailing=" " raw_val="l.findFinIdx?" val="l.findFinIdx?"/>
                    <NullNode start="(995, 20)" end="(995, 21)">
                      <IdentNode start="(995, 20)" end="(995, 21)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(995, 21)" end="(995, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(995, 22)" end="(995, 23)" leading="" trailing="" val="."/>
                <IdentNode start="(995, 23)" end="(995, 29)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(995, 30)" end="(995, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(995, 32)" end="(995, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(995, 32)" end="(995, 37)" leading="" trailing=" " raw_val="l.any" val="l.any"/>
                <NullNode start="(995, 38)" end="(995, 39)">
                  <IdentNode start="(995, 38)" end="(995, 39)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(995, 40)" end="(1000, 23)">
          <AtomNode start="(995, 40)" end="(995, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(995, 43)" end="(1000, 23)">
            <AtomNode start="(995, 43)" end="(995, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(996, 3)" end="(1000, 23)">
              <TacticTacticseq1IndentedNode start="(996, 3)" end="(1000, 23)">
                <NullNode start="(996, 3)" end="(1000, 23)">
                  <OtherNode start="(996, 3)" end="(1000, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;⊢ (findFinIdx? p l).isSome = l.any p" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findFinIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(996, 3)" end="(996, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(996, 13)" end="(996, 14)">
                      <OtherNode start="(996, 13)" end="(996, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(996, 13)" end="(996, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(996, 15)" end="(1000, 23)">
                      <OtherNode start="(996, 15)" end="(1000, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(996, 15)" end="(996, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(997, 3)" end="(1000, 23)">
                          <OtherNode start="(997, 3)" end="(997, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(997, 3)" end="(997, 8)">
                              <OtherNode start="(997, 3)" end="(997, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(997, 3)" end="(997, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(997, 5)" end="(997, 8)">
                                  <NullNode/>
                                  <IdentNode start="(997, 5)" end="(997, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(997, 9)" end="(997, 16)">
                              <AtomNode start="(997, 9)" end="(997, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(997, 12)" end="(997, 16)">
                                <TacticTacticseq1IndentedNode start="(997, 12)" end="(997, 16)">
                                  <NullNode start="(997, 12)" end="(997, 16)">
                                    <OtherNode start="(997, 12)" end="(997, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ (findFinIdx? p []).isSome = [].any p" state_after="no goals" tactic="simp">
                                      <AtomNode start="(997, 12)" end="(997, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(998, 3)" end="(1000, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(998, 3)" end="(998, 17)">
                              <OtherNode start="(998, 3)" end="(998, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(998, 3)" end="(998, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(998, 5)" end="(998, 9)">
                                  <NullNode/>
                                  <IdentNode start="(998, 5)" end="(998, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(998, 10)" end="(998, 17)">
                                  <IdentNode start="(998, 10)" end="(998, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(998, 12)" end="(998, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(998, 15)" end="(998, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(998, 18)" end="(1000, 23)">
                              <AtomNode start="(998, 18)" end="(998, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(999, 5)" end="(1000, 23)">
                                <TacticTacticseq1IndentedNode start="(999, 5)" end="(1000, 23)">
                                  <NullNode start="(999, 5)" end="(1000, 23)">
                                    <OtherNode start="(999, 5)" end="(999, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findFinIdx? p xs).isSome = xs.any p&#10;⊢ (findFinIdx? p (x :: xs)).isSome = (x :: xs).any p" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findFinIdx? p xs).isSome = xs.any p&#10;⊢ (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs)).isSome = (x :: xs).any p" tactic="simp only [findFinIdx?_cons]">
                                      <AtomNode start="(999, 5)" end="(999, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(999, 10)" end="(999, 14)">
                                        <AtomNode start="(999, 10)" end="(999, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(999, 15)" end="(999, 33)">
                                        <AtomNode start="(999, 15)" end="(999, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(999, 16)" end="(999, 32)">
                                          <OtherNode start="(999, 16)" end="(999, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(999, 16)" end="(999, 32)" leading="" trailing="" raw_val="findFinIdx?_cons" val="findFinIdx?_cons" full_name="List.findFinIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(954, 9)" def_end="(954, 25)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(999, 32)" end="(999, 33)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1000, 5)" end="(1000, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findFinIdx? p xs).isSome = xs.any p&#10;⊢ (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs)).isSome = (x :: xs).any p" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(1000, 5)" end="(1000, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1000, 5)" end="(1000, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1000, 11)" end="(1000, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1000, 15)" end="(1000, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1000, 15)" end="(1000, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1002, 1)" end="(1009, 23)" name="isNone_findFinIdx?" full_name="List.isNone_findFinIdx?">
      <CommandDeclmodifiersNode start="(1002, 1)" end="(1002, 8)">
        <NullNode/>
        <NullNode start="(1002, 1)" end="(1002, 8)">
          <OtherNode start="(1002, 1)" end="(1002, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1002, 1)" end="(1002, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1002, 3)" end="(1002, 7)">
              <OtherNode start="(1002, 3)" end="(1002, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1002, 3)" end="(1002, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1002, 3)" end="(1002, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1002, 7)" end="(1002, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1003, 1)" end="(1009, 23)" name="isNone_findFinIdx?" full_name="List.isNone_findFinIdx?" _is_private_decl="False">
        <AtomNode start="(1003, 1)" end="(1003, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1003, 9)" end="(1003, 27)">
          <IdentNode start="(1003, 9)" end="(1003, 27)" leading="" trailing=" " raw_val="isNone_findFinIdx?" val="isNone_findFinIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1003, 28)" end="(1004, 54)">
          <NullNode start="(1003, 28)" end="(1003, 55)">
            <OtherNode start="(1003, 28)" end="(1003, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1003, 28)" end="(1003, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(1003, 29)" end="(1003, 30)">
                <IdentNode start="(1003, 29)" end="(1003, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1003, 31)" end="(1003, 39)">
                <AtomNode start="(1003, 31)" end="(1003, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1003, 33)" end="(1003, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1003, 33)" end="(1003, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1003, 38)" end="(1003, 39)">
                    <IdentNode start="(1003, 38)" end="(1003, 39)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1003, 39)" end="(1003, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1003, 41)" end="(1003, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1003, 41)" end="(1003, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(1003, 42)" end="(1003, 43)">
                <IdentNode start="(1003, 42)" end="(1003, 43)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(1003, 44)" end="(1003, 54)">
                <AtomNode start="(1003, 44)" end="(1003, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1003, 46)" end="(1003, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(1003, 46)" end="(1003, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(1003, 48)" end="(1003, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(1003, 50)" end="(1003, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1003, 54)" end="(1003, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1003, 56)" end="(1004, 54)">
            <AtomNode start="(1003, 56)" end="(1003, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1004, 5)" end="(1004, 54)" kind="«term_=_»">
              <OtherNode start="(1004, 5)" end="(1004, 29)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1004, 5)" end="(1004, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1004, 5)" end="(1004, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1004, 6)" end="(1004, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1004, 6)" end="(1004, 19)" leading="" trailing=" " raw_val="l.findFinIdx?" val="l.findFinIdx?"/>
                    <NullNode start="(1004, 20)" end="(1004, 21)">
                      <IdentNode start="(1004, 20)" end="(1004, 21)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1004, 21)" end="(1004, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1004, 22)" end="(1004, 23)" leading="" trailing="" val="."/>
                <IdentNode start="(1004, 23)" end="(1004, 29)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1004, 30)" end="(1004, 31)" leading="" trailing=" " val="="/>
              <OtherNode start="(1004, 32)" end="(1004, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1004, 32)" end="(1004, 37)" leading="" trailing=" " raw_val="l.all" val="l.all"/>
                <NullNode start="(1004, 38)" end="(1004, 54)">
                  <OtherNode start="(1004, 38)" end="(1004, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1004, 38)" end="(1004, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(1004, 39)" end="(1004, 53)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(1004, 39)" end="(1004, 42)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(1004, 43)" end="(1004, 53)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(1004, 43)" end="(1004, 44)">
                          <IdentNode start="(1004, 43)" end="(1004, 44)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(1004, 45)" end="(1004, 47)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(1004, 48)" end="(1004, 53)" kind="«term¬_»">
                          <AtomNode start="(1004, 48)" end="(1004, 49)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(1004, 50)" end="(1004, 53)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(1004, 50)" end="(1004, 51)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(1004, 52)" end="(1004, 53)">
                              <IdentNode start="(1004, 52)" end="(1004, 53)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(1004, 53)" end="(1004, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1004, 55)" end="(1009, 23)">
          <AtomNode start="(1004, 55)" end="(1004, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1004, 58)" end="(1009, 23)">
            <AtomNode start="(1004, 58)" end="(1004, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1005, 3)" end="(1009, 23)">
              <TacticTacticseq1IndentedNode start="(1005, 3)" end="(1009, 23)">
                <NullNode start="(1005, 3)" end="(1009, 23)">
                  <OtherNode start="(1005, 3)" end="(1009, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;⊢ (findFinIdx? p l).isNone = l.all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [findFinIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(1005, 3)" end="(1005, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1005, 13)" end="(1005, 14)">
                      <OtherNode start="(1005, 13)" end="(1005, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1005, 13)" end="(1005, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1005, 15)" end="(1009, 23)">
                      <OtherNode start="(1005, 15)" end="(1009, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1005, 15)" end="(1005, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1006, 3)" end="(1009, 23)">
                          <OtherNode start="(1006, 3)" end="(1006, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1006, 3)" end="(1006, 8)">
                              <OtherNode start="(1006, 3)" end="(1006, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1006, 3)" end="(1006, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1006, 5)" end="(1006, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1006, 5)" end="(1006, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1006, 9)" end="(1006, 16)">
                              <AtomNode start="(1006, 9)" end="(1006, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1006, 12)" end="(1006, 16)">
                                <TacticTacticseq1IndentedNode start="(1006, 12)" end="(1006, 16)">
                                  <NullNode start="(1006, 12)" end="(1006, 16)">
                                    <OtherNode start="(1006, 12)" end="(1006, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ (findFinIdx? p []).isNone = [].all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1006, 12)" end="(1006, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1007, 3)" end="(1009, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1007, 3)" end="(1007, 17)">
                              <OtherNode start="(1007, 3)" end="(1007, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1007, 3)" end="(1007, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1007, 5)" end="(1007, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1007, 5)" end="(1007, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1007, 10)" end="(1007, 17)">
                                  <IdentNode start="(1007, 10)" end="(1007, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1007, 12)" end="(1007, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1007, 15)" end="(1007, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1007, 18)" end="(1009, 23)">
                              <AtomNode start="(1007, 18)" end="(1007, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1008, 5)" end="(1009, 23)">
                                <TacticTacticseq1IndentedNode start="(1008, 5)" end="(1009, 23)">
                                  <NullNode start="(1008, 5)" end="(1009, 23)">
                                    <OtherNode start="(1008, 5)" end="(1008, 33)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findFinIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true&#10;⊢ (findFinIdx? p (x :: xs)).isNone = (x :: xs).all fun x =&amp;gt; decide ¬p x = true" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findFinIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true&#10;⊢ (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs)).isNone =&#10;    (x :: xs).all fun x =&amp;gt; decide ¬p x = true" tactic="simp only [findFinIdx?_cons]">
                                      <AtomNode start="(1008, 5)" end="(1008, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1008, 10)" end="(1008, 14)">
                                        <AtomNode start="(1008, 10)" end="(1008, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1008, 15)" end="(1008, 33)">
                                        <AtomNode start="(1008, 15)" end="(1008, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1008, 16)" end="(1008, 32)">
                                          <OtherNode start="(1008, 16)" end="(1008, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1008, 16)" end="(1008, 32)" leading="" trailing="" raw_val="findFinIdx?_cons" val="findFinIdx?_cons" full_name="List.findFinIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(954, 9)" def_end="(954, 25)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1008, 32)" end="(1008, 33)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1009, 5)" end="(1009, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;xs : List α&#10;ih : (findFinIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true&#10;⊢ (if p x = true then some 0 else Option.map Fin.succ (findFinIdx? p xs)).isNone =&#10;    (x :: xs).all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(1009, 5)" end="(1009, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1009, 5)" end="(1009, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1009, 11)" end="(1009, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1009, 15)" end="(1009, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1009, 15)" end="(1009, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1011, 1)" end="(1019, 43)" name="findFinIdx?_subtype" full_name="List.findFinIdx?_subtype">
      <CommandDeclmodifiersNode start="(1011, 1)" end="(1011, 8)">
        <NullNode/>
        <NullNode start="(1011, 1)" end="(1011, 8)">
          <OtherNode start="(1011, 1)" end="(1011, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1011, 1)" end="(1011, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1011, 3)" end="(1011, 7)">
              <OtherNode start="(1011, 3)" end="(1011, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1011, 3)" end="(1011, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1011, 3)" end="(1011, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1011, 7)" end="(1011, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1011, 9)" end="(1019, 43)" name="findFinIdx?_subtype" full_name="List.findFinIdx?_subtype" _is_private_decl="False">
        <AtomNode start="(1011, 9)" end="(1011, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1011, 17)" end="(1011, 36)">
          <IdentNode start="(1011, 17)" end="(1011, 36)" leading="" trailing=" " raw_val="findFinIdx?_subtype" val="findFinIdx?_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1011, 37)" end="(1013, 81)">
          <NullNode start="(1011, 37)" end="(1012, 74)">
            <OtherNode start="(1011, 37)" end="(1011, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1011, 37)" end="(1011, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(1011, 38)" end="(1011, 39)">
                <IdentNode start="(1011, 38)" end="(1011, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(1011, 40)" end="(1011, 50)">
                <AtomNode start="(1011, 40)" end="(1011, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1011, 42)" end="(1011, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(1011, 42)" end="(1011, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(1011, 44)" end="(1011, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(1011, 46)" end="(1011, 50)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(1011, 46)" end="(1011, 50)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1011, 50)" end="(1011, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1011, 52)" end="(1011, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1011, 52)" end="(1011, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(1011, 53)" end="(1011, 54)">
                <IdentNode start="(1011, 53)" end="(1011, 54)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1011, 55)" end="(1011, 74)">
                <AtomNode start="(1011, 55)" end="(1011, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1011, 57)" end="(1011, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1011, 57)" end="(1011, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1011, 62)" end="(1011, 74)">
                    <OtherNode start="(1011, 62)" end="(1011, 74)" kind="«term{_:_//_}»">
                      <AtomNode start="(1011, 62)" end="(1011, 63)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(1011, 64)" end="(1011, 65)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(1011, 66)" end="(1011, 68)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(1011, 69)" end="(1011, 72)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(1011, 69)" end="(1011, 70)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(1011, 71)" end="(1011, 72)">
                          <IdentNode start="(1011, 71)" end="(1011, 72)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(1011, 73)" end="(1011, 74)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1011, 74)" end="(1011, 75)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(1012, 5)" end="(1012, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1012, 5)" end="(1012, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(1012, 6)" end="(1012, 7)">
                <IdentNode start="(1012, 6)" end="(1012, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(1012, 8)" end="(1012, 29)">
                <AtomNode start="(1012, 8)" end="(1012, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1012, 10)" end="(1012, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(1012, 10)" end="(1012, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(1012, 10)" end="(1012, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(1012, 12)" end="(1012, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(1012, 14)" end="(1012, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(1012, 17)" end="(1012, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1012, 17)" end="(1012, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(1012, 19)" end="(1012, 20)">
                        <IdentNode start="(1012, 19)" end="(1012, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1012, 21)" end="(1012, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(1012, 23)" end="(1012, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(1012, 25)" end="(1012, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1012, 29)" end="(1012, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1012, 31)" end="(1012, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1012, 31)" end="(1012, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(1012, 32)" end="(1012, 33)">
                <IdentNode start="(1012, 32)" end="(1012, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(1012, 34)" end="(1012, 44)">
                <AtomNode start="(1012, 34)" end="(1012, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1012, 36)" end="(1012, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(1012, 36)" end="(1012, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(1012, 38)" end="(1012, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(1012, 40)" end="(1012, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1012, 44)" end="(1012, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1012, 46)" end="(1012, 74)">
              <AtomNode start="(1012, 46)" end="(1012, 47)" leading="" trailing="" val="("/>
              <NullNode start="(1012, 47)" end="(1012, 49)">
                <IdentNode start="(1012, 47)" end="(1012, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(1012, 50)" end="(1012, 73)">
                <AtomNode start="(1012, 50)" end="(1012, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1012, 52)" end="(1012, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(1012, 52)" end="(1012, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(1012, 54)" end="(1012, 57)">
                    <IdentNode start="(1012, 54)" end="(1012, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(1012, 56)" end="(1012, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(1012, 57)" end="(1012, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(1012, 59)" end="(1012, 73)" kind="«term_=_»">
                    <OtherNode start="(1012, 59)" end="(1012, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1012, 59)" end="(1012, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(1012, 61)" end="(1012, 67)">
                        <OtherNode start="(1012, 61)" end="(1012, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(1012, 61)" end="(1012, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(1012, 62)" end="(1012, 66)">
                            <IdentNode start="(1012, 62)" end="(1012, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(1012, 63)" end="(1012, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(1012, 65)" end="(1012, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(1012, 66)" end="(1012, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1012, 68)" end="(1012, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(1012, 70)" end="(1012, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1012, 70)" end="(1012, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(1012, 72)" end="(1012, 73)">
                        <IdentNode start="(1012, 72)" end="(1012, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1012, 73)" end="(1012, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1012, 75)" end="(1013, 81)">
            <AtomNode start="(1012, 75)" end="(1012, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1013, 5)" end="(1013, 81)" kind="«term_=_»">
              <OtherNode start="(1013, 5)" end="(1013, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1013, 5)" end="(1013, 18)" leading="" trailing=" " raw_val="l.findFinIdx?" val="l.findFinIdx?"/>
                <NullNode start="(1013, 19)" end="(1013, 20)">
                  <IdentNode start="(1013, 19)" end="(1013, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1013, 21)" end="(1013, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(1013, 23)" end="(1013, 81)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1013, 23)" end="(1013, 53)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1013, 23)" end="(1013, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1013, 23)" end="(1013, 24)" leading="" trailing="" val="("/>
                    <OtherNode start="(1013, 24)" end="(1013, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1013, 24)" end="(1013, 46)" leading="" trailing=" " raw_val="l.unattach.findFinIdx?" val="l.unattach.findFinIdx?"/>
                      <NullNode start="(1013, 47)" end="(1013, 48)">
                        <IdentNode start="(1013, 47)" end="(1013, 48)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1013, 48)" end="(1013, 49)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1013, 49)" end="(1013, 50)" leading="" trailing="" val="."/>
                  <IdentNode start="(1013, 50)" end="(1013, 53)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(1013, 54)" end="(1013, 81)">
                  <OtherNode start="(1013, 54)" end="(1013, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1013, 54)" end="(1013, 55)" leading="" trailing="" val="("/>
                    <OtherNode start="(1013, 55)" end="(1013, 80)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(1013, 55)" end="(1013, 58)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(1013, 59)" end="(1013, 80)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(1013, 59)" end="(1013, 60)">
                          <IdentNode start="(1013, 59)" end="(1013, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(1013, 61)" end="(1013, 63)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(1013, 64)" end="(1013, 80)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(1013, 64)" end="(1013, 70)" leading="" trailing=" " raw_val="i.cast" val="i.cast"/>
                          <NullNode start="(1013, 71)" end="(1013, 80)">
                            <OtherNode start="(1013, 71)" end="(1013, 80)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(1013, 71)" end="(1013, 72)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(1013, 72)" end="(1013, 79)">
                                <AtomNode start="(1013, 72)" end="(1013, 74)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(1013, 75)" end="(1013, 79)">
                                  <TacticTacticseq1IndentedNode start="(1013, 75)" end="(1013, 79)">
                                    <NullNode start="(1013, 75)" end="(1013, 79)">
                                      <OtherNode start="(1013, 75)" end="(1013, 79)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.249165&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;i : Fin l.unattach.length&#10;⊢ l.unattach.length = l.length" state_after="no goals" tactic="simp">
                                        <AtomNode start="(1013, 75)" end="(1013, 79)" leading="" trailing="" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(1013, 79)" end="(1013, 80)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(1013, 80)" end="(1013, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1013, 82)" end="(1019, 43)">
          <AtomNode start="(1013, 82)" end="(1013, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1013, 85)" end="(1019, 43)">
            <AtomNode start="(1013, 85)" end="(1013, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1014, 3)" end="(1019, 43)">
              <TacticTacticseq1IndentedNode start="(1014, 3)" end="(1019, 43)">
                <NullNode start="(1014, 3)" end="(1019, 43)">
                  <OtherNode start="(1014, 3)" end="(1014, 18)" kind="Lean.Parser.Tactic.unfold" state_before="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findFinIdx? f l = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g l.unattach)" state_after="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findFinIdx? f l = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) l))" tactic="unfold unattach">
                    <AtomNode start="(1014, 3)" end="(1014, 9)" leading="" trailing=" " val="unfold"/>
                    <NullNode start="(1014, 10)" end="(1014, 18)">
                      <IdentNode start="(1014, 10)" end="(1014, 18)" leading="" trailing="&#10;  " raw_val="unattach" val="unattach" full_name="List.unattach" mod_name="Init.Data.List.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Attach.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1015, 3)" end="(1019, 43)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Prop&#10;l : List { x // p x }&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findFinIdx? f l = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) l))" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons a l ih =&amp;gt;&#10;  simp [hf, findFinIdx?_cons]&#10;  split &amp;lt;;&amp;gt; simp [ih, Function.comp_def]">
                    <AtomNode start="(1015, 3)" end="(1015, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1015, 13)" end="(1015, 14)">
                      <OtherNode start="(1015, 13)" end="(1015, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1015, 13)" end="(1015, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1015, 15)" end="(1019, 43)">
                      <OtherNode start="(1015, 15)" end="(1019, 43)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1015, 15)" end="(1015, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1016, 3)" end="(1019, 43)">
                          <OtherNode start="(1016, 3)" end="(1016, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1016, 3)" end="(1016, 8)">
                              <OtherNode start="(1016, 3)" end="(1016, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1016, 3)" end="(1016, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1016, 5)" end="(1016, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1016, 5)" end="(1016, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1016, 9)" end="(1016, 16)">
                              <AtomNode start="(1016, 9)" end="(1016, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1016, 12)" end="(1016, 16)">
                                <TacticTacticseq1IndentedNode start="(1016, 12)" end="(1016, 16)">
                                  <NullNode start="(1016, 12)" end="(1016, 16)">
                                    <OtherNode start="(1016, 12)" end="(1016, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findFinIdx? f [] = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) []))" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1016, 12)" end="(1016, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1017, 3)" end="(1019, 43)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1017, 3)" end="(1017, 16)">
                              <OtherNode start="(1017, 3)" end="(1017, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1017, 3)" end="(1017, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1017, 5)" end="(1017, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1017, 5)" end="(1017, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1017, 10)" end="(1017, 16)">
                                  <IdentNode start="(1017, 10)" end="(1017, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <IdentNode start="(1017, 12)" end="(1017, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(1017, 14)" end="(1017, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1017, 17)" end="(1019, 43)">
                              <AtomNode start="(1017, 17)" end="(1017, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1018, 5)" end="(1019, 43)">
                                <TacticTacticseq1IndentedNode start="(1018, 5)" end="(1019, 43)">
                                  <NullNode start="(1018, 5)" end="(1019, 43)">
                                    <OtherNode start="(1018, 5)" end="(1018, 32)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findFinIdx? f l = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) l))&#10;⊢ findFinIdx? f (a :: l) = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) (a :: l)))" state_after="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findFinIdx? f l = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) l))&#10;⊢ (if g a.val = true then some 0 else Option.map Fin.succ (findFinIdx? f l)) =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i)&#10;      (if g a.val = true then some 0 else Option.map Fin.succ (findFinIdx? g (map (fun x =&amp;gt; x.val) l)))" tactic="simp [hf, findFinIdx?_cons]">
                                      <AtomNode start="(1018, 5)" end="(1018, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(1018, 10)" end="(1018, 32)">
                                        <AtomNode start="(1018, 10)" end="(1018, 11)" leading="" trailing="" val="["/>
                                        <NullNode start="(1018, 11)" end="(1018, 31)">
                                          <OtherNode start="(1018, 11)" end="(1018, 13)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1018, 11)" end="(1018, 13)" leading="" trailing="" raw_val="hf" val="hf"/>
                                          </OtherNode>
                                          <AtomNode start="(1018, 13)" end="(1018, 14)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(1018, 15)" end="(1018, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1018, 15)" end="(1018, 31)" leading="" trailing="" raw_val="findFinIdx?_cons" val="findFinIdx?_cons" full_name="List.findFinIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(954, 9)" def_end="(954, 25)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1018, 31)" end="(1018, 32)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1019, 5)" end="(1019, 43)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;a : { x // p x }&#10;l : List { x // p x }&#10;ih : findFinIdx? f l = Option.map (fun i =&amp;gt; Fin.cast ⋯ i) (findFinIdx? g (map (fun x =&amp;gt; x.val) l))&#10;⊢ (if g a.val = true then some 0 else Option.map Fin.succ (findFinIdx? f l)) =&#10;    Option.map (fun i =&amp;gt; Fin.cast ⋯ i)&#10;      (if g a.val = true then some 0 else Option.map Fin.succ (findFinIdx? g (map (fun x =&amp;gt; x.val) l)))" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [ih, Function.comp_def]">
                                      <OtherNode start="(1019, 5)" end="(1019, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1019, 5)" end="(1019, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1019, 11)" end="(1019, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1019, 15)" end="(1019, 43)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(1019, 15)" end="(1019, 19)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(1019, 20)" end="(1019, 43)">
                                          <AtomNode start="(1019, 20)" end="(1019, 21)" leading="" trailing="" val="["/>
                                          <NullNode start="(1019, 21)" end="(1019, 42)">
                                            <OtherNode start="(1019, 21)" end="(1019, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(1019, 21)" end="(1019, 23)" leading="" trailing="" raw_val="ih" val="ih"/>
                                            </OtherNode>
                                            <AtomNode start="(1019, 23)" end="(1019, 24)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(1019, 25)" end="(1019, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(1019, 25)" end="(1019, 42)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(1019, 42)" end="(1019, 43)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(1022, 1)" end="(1026, 3)" comment="### idxOf&#10;&#10;The verification API for `idxOf` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx` (and proved using them).&#10;-/">
      <AtomNode start="(1022, 1)" end="(1022, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(1022, 5)" end="(1026, 3)" leading="" trailing="&#10;&#10;" val="### idxOf&#10;&#10;The verification API for `idxOf` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx` (and proved using them).&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(1028, 1)" end="(1031, 22)" name="idxOf_cons" full_name="List.idxOf_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1028, 1)" end="(1031, 22)" name="idxOf_cons" full_name="List.idxOf_cons" _is_private_decl="False">
        <AtomNode start="(1028, 1)" end="(1028, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1028, 9)" end="(1028, 19)">
          <IdentNode start="(1028, 9)" end="(1028, 19)" leading="" trailing=" " raw_val="idxOf_cons" val="idxOf_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1028, 20)" end="(1029, 71)">
          <NullNode start="(1028, 20)" end="(1028, 27)">
            <OtherNode start="(1028, 20)" end="(1028, 27)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1028, 20)" end="(1028, 21)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1028, 21)" end="(1028, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1028, 21)" end="(1028, 24)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1028, 25)" end="(1028, 26)">
                  <IdentNode start="(1028, 25)" end="(1028, 26)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1028, 26)" end="(1028, 27)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1028, 28)" end="(1029, 71)">
            <AtomNode start="(1028, 28)" end="(1028, 29)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1029, 5)" end="(1029, 71)" kind="«term_=_»">
              <OtherNode start="(1029, 5)" end="(1029, 31)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1029, 5)" end="(1029, 29)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1029, 5)" end="(1029, 23)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(1029, 5)" end="(1029, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1029, 6)" end="(1029, 13)" kind="«term_::_»">
                      <IdentNode start="(1029, 6)" end="(1029, 7)" leading="" trailing=" " raw_val="x" val="x"/>
                      <AtomNode start="(1029, 8)" end="(1029, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(1029, 11)" end="(1029, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(1029, 14)" end="(1029, 15)" leading="" trailing=" " val=":"/>
                    <NullNode start="(1029, 16)" end="(1029, 22)">
                      <OtherNode start="(1029, 16)" end="(1029, 22)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(1029, 16)" end="(1029, 20)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(1029, 21)" end="(1029, 22)">
                          <IdentNode start="(1029, 21)" end="(1029, 22)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(1029, 22)" end="(1029, 23)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1029, 23)" end="(1029, 24)" leading="" trailing="" val="."/>
                  <IdentNode start="(1029, 24)" end="(1029, 29)" leading="" trailing=" " raw_val="idxOf" val="idxOf" full_name="List.idxOf" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1029, 30)" end="(1029, 31)">
                  <IdentNode start="(1029, 30)" end="(1029, 31)" leading="" trailing=" " raw_val="y" val="y"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1029, 32)" end="(1029, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(1029, 34)" end="(1029, 71)" kind="boolIfThenElse">
                <AtomNode start="(1029, 34)" end="(1029, 37)" leading="" trailing=" " val="bif"/>
                <OtherNode start="(1029, 38)" end="(1029, 44)" kind="«term_==_»">
                  <IdentNode start="(1029, 38)" end="(1029, 39)" leading="" trailing=" " raw_val="x" val="x"/>
                  <AtomNode start="(1029, 40)" end="(1029, 42)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(1029, 43)" end="(1029, 44)" leading="" trailing=" " raw_val="y" val="y"/>
                </OtherNode>
                <AtomNode start="(1029, 45)" end="(1029, 49)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1029, 50)" end="(1029, 51)" kind="num">
                  <AtomNode start="(1029, 50)" end="(1029, 51)" leading="" trailing=" " val="0"/>
                </OtherNode>
                <AtomNode start="(1029, 52)" end="(1029, 56)" leading="" trailing=" " val="else"/>
                <OtherNode start="(1029, 57)" end="(1029, 71)" kind="«term_+_»">
                  <OtherNode start="(1029, 57)" end="(1029, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1029, 57)" end="(1029, 65)" leading="" trailing=" " raw_val="xs.idxOf" val="xs.idxOf"/>
                    <NullNode start="(1029, 66)" end="(1029, 67)">
                      <IdentNode start="(1029, 66)" end="(1029, 67)" leading="" trailing=" " raw_val="y" val="y"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1029, 68)" end="(1029, 69)" leading="" trailing=" " val="+"/>
                  <OtherNode start="(1029, 70)" end="(1029, 71)" kind="num">
                    <AtomNode start="(1029, 70)" end="(1029, 71)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1029, 72)" end="(1031, 22)">
          <AtomNode start="(1029, 72)" end="(1029, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1029, 75)" end="(1031, 22)">
            <AtomNode start="(1029, 75)" end="(1029, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1030, 3)" end="(1031, 22)">
              <TacticTacticseq1IndentedNode start="(1030, 3)" end="(1031, 22)">
                <NullNode start="(1030, 3)" end="(1031, 22)">
                  <OtherNode start="(1030, 3)" end="(1030, 16)" kind="Lean.Parser.Tactic.dsimp" state_before="α : Type u_1&#10;x : α&#10;xs : List α&#10;y : α&#10;inst✝ : BEq α&#10;⊢ idxOf y (x :: xs) = bif x == y then 0 else idxOf y xs + 1" state_after="α : Type u_1&#10;x : α&#10;xs : List α&#10;y : α&#10;inst✝ : BEq α&#10;⊢ findIdx (fun x =&amp;gt; x == y) (x :: xs) = bif x == y then 0 else findIdx (fun x =&amp;gt; x == y) xs + 1" tactic="dsimp [idxOf]">
                    <AtomNode start="(1030, 3)" end="(1030, 8)" leading="" trailing=" " val="dsimp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1030, 9)" end="(1030, 16)">
                      <AtomNode start="(1030, 9)" end="(1030, 10)" leading="" trailing="" val="["/>
                      <NullNode start="(1030, 10)" end="(1030, 15)">
                        <OtherNode start="(1030, 10)" end="(1030, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1030, 10)" end="(1030, 15)" leading="" trailing="" raw_val="idxOf" val="idxOf" full_name="List.idxOf" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1030, 15)" end="(1030, 16)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1031, 3)" end="(1031, 22)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x : α&#10;xs : List α&#10;y : α&#10;inst✝ : BEq α&#10;⊢ findIdx (fun x =&amp;gt; x == y) (x :: xs) = bif x == y then 0 else findIdx (fun x =&amp;gt; x == y) xs + 1" state_after="no goals" tactic="simp [findIdx_cons]">
                    <AtomNode start="(1031, 3)" end="(1031, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1031, 8)" end="(1031, 22)">
                      <AtomNode start="(1031, 8)" end="(1031, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1031, 9)" end="(1031, 21)">
                        <OtherNode start="(1031, 9)" end="(1031, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1031, 9)" end="(1031, 21)" leading="" trailing="" raw_val="findIdx_cons" val="findIdx_cons" full_name="List.findIdx_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(507, 9)" def_end="(507, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1031, 21)" end="(1031, 22)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1033, 1)" end="(1034, 35)" name="indexOf_cons" full_name="List.indexOf_cons">
      <CommandDeclmodifiersNode start="(1033, 1)" end="(1033, 49)">
        <NullNode/>
        <NullNode start="(1033, 1)" end="(1033, 49)">
          <OtherNode start="(1033, 1)" end="(1033, 49)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1033, 1)" end="(1033, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1033, 3)" end="(1033, 48)">
              <OtherNode start="(1033, 3)" end="(1033, 48)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1033, 3)" end="(1033, 48)" kind="Lean.deprecated">
                  <AtomNode start="(1033, 3)" end="(1033, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1033, 14)" end="(1033, 24)">
                    <IdentNode start="(1033, 14)" end="(1033, 24)" leading="" trailing=" " raw_val="idxOf_cons" val="idxOf_cons" full_name="List.idxOf_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1028, 9)" def_end="(1028, 19)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1033, 25)" end="(1033, 48)">
                    <AtomNode start="(1033, 25)" end="(1033, 26)" leading="" trailing="" val="("/>
                    <AtomNode start="(1033, 26)" end="(1033, 31)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1033, 32)" end="(1033, 34)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1033, 35)" end="(1033, 47)" kind="str">
                      <AtomNode start="(1033, 35)" end="(1033, 47)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1033, 47)" end="(1033, 48)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1033, 48)" end="(1033, 49)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1034, 1)" end="(1034, 35)" name="indexOf_cons">
        <AtomNode start="(1034, 1)" end="(1034, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1034, 8)" end="(1034, 20)">
          <IdentNode start="(1034, 8)" end="(1034, 20)" leading="" trailing=" " raw_val="indexOf_cons" val="indexOf_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1034, 21)" end="(1034, 35)">
          <AtomNode start="(1034, 21)" end="(1034, 23)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1034, 24)" end="(1034, 35)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1034, 24)" end="(1034, 25)" leading="" trailing="" val="@"/>
            <IdentNode start="(1034, 25)" end="(1034, 35)" leading="" trailing="&#10;&#10;" raw_val="idxOf_cons" val="idxOf_cons" full_name="List.idxOf_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1028, 9)" def_end="(1028, 19)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1036, 1)" end="(1037, 20)" name="idxOf_cons_self" full_name="List.idxOf_cons_self">
      <CommandDeclmodifiersNode start="(1036, 1)" end="(1036, 8)">
        <NullNode/>
        <NullNode start="(1036, 1)" end="(1036, 8)">
          <OtherNode start="(1036, 1)" end="(1036, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1036, 1)" end="(1036, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1036, 3)" end="(1036, 7)">
              <OtherNode start="(1036, 3)" end="(1036, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1036, 3)" end="(1036, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1036, 3)" end="(1036, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1036, 7)" end="(1036, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1036, 9)" end="(1037, 20)" name="idxOf_cons_self" full_name="List.idxOf_cons_self" _is_private_decl="False">
        <AtomNode start="(1036, 9)" end="(1036, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1036, 17)" end="(1036, 32)">
          <IdentNode start="(1036, 17)" end="(1036, 32)" leading="" trailing=" " raw_val="idxOf_cons_self" val="idxOf_cons_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1036, 33)" end="(1036, 88)">
          <NullNode start="(1036, 33)" end="(1036, 65)">
            <OtherNode start="(1036, 33)" end="(1036, 40)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1036, 33)" end="(1036, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1036, 34)" end="(1036, 39)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1036, 34)" end="(1036, 37)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1036, 38)" end="(1036, 39)">
                  <IdentNode start="(1036, 38)" end="(1036, 39)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1036, 39)" end="(1036, 40)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1036, 41)" end="(1036, 52)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1036, 41)" end="(1036, 42)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1036, 42)" end="(1036, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1036, 42)" end="(1036, 49)" leading="" trailing=" " raw_val="ReflBEq" val="ReflBEq" full_name="ReflBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1036, 50)" end="(1036, 51)">
                  <IdentNode start="(1036, 50)" end="(1036, 51)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1036, 51)" end="(1036, 52)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1036, 53)" end="(1036, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1036, 53)" end="(1036, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(1036, 54)" end="(1036, 55)">
                <IdentNode start="(1036, 54)" end="(1036, 55)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1036, 56)" end="(1036, 64)">
                <AtomNode start="(1036, 56)" end="(1036, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1036, 58)" end="(1036, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1036, 58)" end="(1036, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1036, 63)" end="(1036, 64)">
                    <IdentNode start="(1036, 63)" end="(1036, 64)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1036, 64)" end="(1036, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1036, 66)" end="(1036, 88)">
            <AtomNode start="(1036, 66)" end="(1036, 67)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1036, 68)" end="(1036, 88)" kind="«term_=_»">
              <OtherNode start="(1036, 68)" end="(1036, 84)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1036, 68)" end="(1036, 82)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1036, 68)" end="(1036, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1036, 68)" end="(1036, 69)" leading="" trailing="" val="("/>
                    <OtherNode start="(1036, 69)" end="(1036, 75)" kind="«term_::_»">
                      <IdentNode start="(1036, 69)" end="(1036, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(1036, 71)" end="(1036, 73)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(1036, 74)" end="(1036, 75)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(1036, 75)" end="(1036, 76)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1036, 76)" end="(1036, 77)" leading="" trailing="" val="."/>
                  <IdentNode start="(1036, 77)" end="(1036, 82)" leading="" trailing=" " raw_val="idxOf" val="idxOf" full_name="List.idxOf" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1036, 83)" end="(1036, 84)">
                  <IdentNode start="(1036, 83)" end="(1036, 84)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1036, 85)" end="(1036, 86)" leading="" trailing=" " val="="/>
              <OtherNode start="(1036, 87)" end="(1036, 88)" kind="num">
                <AtomNode start="(1036, 87)" end="(1036, 88)" leading="" trailing=" " val="0"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1036, 89)" end="(1037, 20)">
          <AtomNode start="(1036, 89)" end="(1036, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1036, 92)" end="(1037, 20)">
            <AtomNode start="(1036, 92)" end="(1036, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1037, 3)" end="(1037, 20)">
              <TacticTacticseq1IndentedNode start="(1037, 3)" end="(1037, 20)">
                <NullNode start="(1037, 3)" end="(1037, 20)">
                  <OtherNode start="(1037, 3)" end="(1037, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : ReflBEq α&#10;l : List α&#10;⊢ idxOf a (a :: l) = 0" state_after="no goals" tactic="simp [idxOf_cons]">
                    <AtomNode start="(1037, 3)" end="(1037, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1037, 8)" end="(1037, 20)">
                      <AtomNode start="(1037, 8)" end="(1037, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1037, 9)" end="(1037, 19)">
                        <OtherNode start="(1037, 9)" end="(1037, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1037, 9)" end="(1037, 19)" leading="" trailing="" raw_val="idxOf_cons" val="idxOf_cons" full_name="List.idxOf_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1028, 9)" def_end="(1028, 19)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1037, 19)" end="(1037, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1039, 1)" end="(1040, 45)" name="indexOf_cons_self" full_name="List.indexOf_cons_self">
      <CommandDeclmodifiersNode start="(1039, 1)" end="(1039, 54)">
        <NullNode/>
        <NullNode start="(1039, 1)" end="(1039, 54)">
          <OtherNode start="(1039, 1)" end="(1039, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1039, 1)" end="(1039, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1039, 3)" end="(1039, 53)">
              <OtherNode start="(1039, 3)" end="(1039, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1039, 3)" end="(1039, 53)" kind="Lean.deprecated">
                  <AtomNode start="(1039, 3)" end="(1039, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1039, 14)" end="(1039, 29)">
                    <IdentNode start="(1039, 14)" end="(1039, 29)" leading="" trailing=" " raw_val="idxOf_cons_self" val="idxOf_cons_self" full_name="List.idxOf_cons_self" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1036, 17)" def_end="(1036, 32)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1039, 30)" end="(1039, 53)">
                    <AtomNode start="(1039, 30)" end="(1039, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(1039, 31)" end="(1039, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1039, 37)" end="(1039, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1039, 40)" end="(1039, 52)" kind="str">
                      <AtomNode start="(1039, 40)" end="(1039, 52)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1039, 52)" end="(1039, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1039, 53)" end="(1039, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1040, 1)" end="(1040, 45)" name="indexOf_cons_self">
        <AtomNode start="(1040, 1)" end="(1040, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1040, 8)" end="(1040, 25)">
          <IdentNode start="(1040, 8)" end="(1040, 25)" leading="" trailing=" " raw_val="indexOf_cons_self" val="indexOf_cons_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1040, 26)" end="(1040, 45)">
          <AtomNode start="(1040, 26)" end="(1040, 28)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1040, 29)" end="(1040, 45)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1040, 29)" end="(1040, 30)" leading="" trailing="" val="@"/>
            <IdentNode start="(1040, 30)" end="(1040, 45)" leading="" trailing="&#10;&#10;" raw_val="idxOf_cons_self" val="idxOf_cons_self" full_name="List.idxOf_cons_self" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1036, 17)" def_end="(1036, 32)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1042, 1)" end="(1049, 18)" name="idxOf_append" full_name="List.idxOf_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1042, 1)" end="(1049, 18)" name="idxOf_append" full_name="List.idxOf_append" _is_private_decl="False">
        <AtomNode start="(1042, 1)" end="(1042, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1042, 9)" end="(1042, 21)">
          <IdentNode start="(1042, 9)" end="(1042, 21)" leading="" trailing=" " raw_val="idxOf_append" val="idxOf_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1042, 22)" end="(1043, 79)">
          <NullNode start="(1042, 22)" end="(1042, 68)">
            <OtherNode start="(1042, 22)" end="(1042, 29)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1042, 22)" end="(1042, 23)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1042, 23)" end="(1042, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1042, 23)" end="(1042, 26)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1042, 27)" end="(1042, 28)">
                  <IdentNode start="(1042, 27)" end="(1042, 28)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1042, 28)" end="(1042, 29)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1042, 30)" end="(1042, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1042, 30)" end="(1042, 31)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1042, 31)" end="(1042, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1042, 31)" end="(1042, 40)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1042, 41)" end="(1042, 42)">
                  <IdentNode start="(1042, 41)" end="(1042, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1042, 42)" end="(1042, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1042, 44)" end="(1042, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1042, 44)" end="(1042, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(1042, 45)" end="(1042, 50)">
                <IdentNode start="(1042, 45)" end="(1042, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1042, 48)" end="(1042, 50)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1042, 51)" end="(1042, 59)">
                <AtomNode start="(1042, 51)" end="(1042, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1042, 53)" end="(1042, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1042, 53)" end="(1042, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1042, 58)" end="(1042, 59)">
                    <IdentNode start="(1042, 58)" end="(1042, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1042, 59)" end="(1042, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1042, 61)" end="(1042, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1042, 61)" end="(1042, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(1042, 62)" end="(1042, 63)">
                <IdentNode start="(1042, 62)" end="(1042, 63)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1042, 64)" end="(1042, 67)">
                <AtomNode start="(1042, 64)" end="(1042, 65)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1042, 66)" end="(1042, 67)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1042, 67)" end="(1042, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1042, 69)" end="(1043, 79)">
            <AtomNode start="(1042, 69)" end="(1042, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1043, 5)" end="(1043, 79)" kind="«term_=_»">
              <OtherNode start="(1043, 5)" end="(1043, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1043, 5)" end="(1043, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1043, 5)" end="(1043, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1043, 5)" end="(1043, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1043, 6)" end="(1043, 14)" kind="«term_++_»">
                      <IdentNode start="(1043, 6)" end="(1043, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(1043, 9)" end="(1043, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(1043, 12)" end="(1043, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(1043, 14)" end="(1043, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1043, 15)" end="(1043, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(1043, 16)" end="(1043, 21)" leading="" trailing=" " raw_val="idxOf" val="idxOf" full_name="List.idxOf" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1043, 22)" end="(1043, 23)">
                  <IdentNode start="(1043, 22)" end="(1043, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1043, 24)" end="(1043, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(1043, 26)" end="(1043, 79)" kind="termIfThenElse">
                <AtomNode start="(1043, 26)" end="(1043, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1043, 29)" end="(1043, 35)" kind="«term_∈_»">
                  <IdentNode start="(1043, 29)" end="(1043, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1043, 31)" end="(1043, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(1043, 33)" end="(1043, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                </OtherNode>
                <AtomNode start="(1043, 36)" end="(1043, 40)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1043, 41)" end="(1043, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1043, 41)" end="(1043, 49)" leading="" trailing=" " raw_val="l₁.idxOf" val="l₁.idxOf"/>
                  <NullNode start="(1043, 50)" end="(1043, 51)">
                    <IdentNode start="(1043, 50)" end="(1043, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1043, 52)" end="(1043, 56)" leading="" trailing=" " val="else"/>
                <OtherNode start="(1043, 57)" end="(1043, 79)" kind="«term_+_»">
                  <OtherNode start="(1043, 57)" end="(1043, 67)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1043, 57)" end="(1043, 65)" leading="" trailing=" " raw_val="l₂.idxOf" val="l₂.idxOf"/>
                    <NullNode start="(1043, 66)" end="(1043, 67)">
                      <IdentNode start="(1043, 66)" end="(1043, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1043, 68)" end="(1043, 69)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(1043, 70)" end="(1043, 79)" leading="" trailing=" " raw_val="l₁.length" val="l₁.length"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1043, 80)" end="(1049, 18)">
          <AtomNode start="(1043, 80)" end="(1043, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1043, 83)" end="(1049, 18)">
            <AtomNode start="(1043, 83)" end="(1043, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1044, 3)" end="(1049, 18)">
              <TacticTacticseq1IndentedNode start="(1044, 3)" end="(1049, 18)">
                <NullNode start="(1044, 3)" end="(1049, 18)">
                  <OtherNode start="(1044, 3)" end="(1044, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;⊢ idxOf a (l₁ ++ l₂) = if a ∈ l₁ then idxOf a l₁ else idxOf a l₂ + l₁.length" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;⊢ (if findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length then findIdx (fun x =&amp;gt; x == a) l₁&#10;    else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length) =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" tactic="rw [idxOf, findIdx_append]">
                    <AtomNode start="(1044, 3)" end="(1044, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(1044, 6)" end="(1044, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(1044, 6)" end="(1044, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(1044, 7)" end="(1044, 28)">
                        <OtherNode start="(1044, 7)" end="(1044, 12)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(1044, 7)" end="(1044, 12)" leading="" trailing="" raw_val="idxOf" val="idxOf" full_name="List.idxOf" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1044, 12)" end="(1044, 13)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1044, 14)" end="(1044, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(1044, 14)" end="(1044, 28)" leading="" trailing="" raw_val="findIdx_append" val="findIdx_append" full_name="List.findIdx_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(632, 9)" def_end="(632, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1044, 28)" end="(1044, 29)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1045, 3)" end="(1045, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;⊢ (if findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length then findIdx (fun x =&amp;gt; x == a) l₁&#10;    else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length) =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" state_after="case isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₁ =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length&#10;&#10;case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" tactic="split &amp;lt;;&amp;gt; rename_i h">
                    <OtherNode start="(1045, 3)" end="(1045, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(1045, 3)" end="(1045, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(1045, 9)" end="(1045, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(1045, 13)" end="(1045, 23)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(1045, 13)" end="(1045, 21)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(1045, 22)" end="(1045, 23)">
                        <LeanBinderidentNode start="(1045, 22)" end="(1045, 23)">
                          <IdentNode start="(1045, 22)" end="(1045, 23)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1046, 3)" end="(1047, 18)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₁ =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length&#10;&#10;case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" state_after="case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" tactic="· rw [if_pos]&#10;  simpa using h">
                    <OtherNode start="(1046, 3)" end="(1046, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1046, 3)" end="(1046, 4)" kind="patternIgnore">
                        <OtherNode start="(1046, 3)" end="(1046, 4)" kind="token.«· »">
                          <AtomNode start="(1046, 3)" end="(1046, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1046, 5)" end="(1047, 18)">
                      <TacticTacticseq1IndentedNode start="(1046, 5)" end="(1047, 18)">
                        <NullNode start="(1046, 5)" end="(1047, 18)">
                          <OtherNode start="(1046, 5)" end="(1046, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₁ =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" state_after="case isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ a ∈ l₁" tactic="rw [if_pos]">
                            <AtomNode start="(1046, 5)" end="(1046, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(1046, 8)" end="(1046, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(1046, 8)" end="(1046, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(1046, 9)" end="(1046, 15)">
                                <OtherNode start="(1046, 9)" end="(1046, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(1046, 9)" end="(1046, 15)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(1046, 15)" end="(1046, 16)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1047, 5)" end="(1047, 18)" kind="Lean.Parser.Tactic.simpa" state_before="case isTrue.hc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ a ∈ l₁" state_after="no goals" tactic="simpa using h">
                            <AtomNode start="(1047, 5)" end="(1047, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(1047, 11)" end="(1047, 18)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(1047, 11)" end="(1047, 18)">
                                <AtomNode start="(1047, 11)" end="(1047, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(1047, 17)" end="(1047, 18)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1048, 3)" end="(1049, 18)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" state_after="no goals" tactic="· rw [if_neg]&#10;  simpa using h">
                    <OtherNode start="(1048, 3)" end="(1048, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1048, 3)" end="(1048, 4)" kind="patternIgnore">
                        <OtherNode start="(1048, 3)" end="(1048, 4)" kind="token.«· »">
                          <AtomNode start="(1048, 3)" end="(1048, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1048, 5)" end="(1049, 18)">
                      <TacticTacticseq1IndentedNode start="(1048, 5)" end="(1049, 18)">
                        <NullNode start="(1048, 5)" end="(1049, 18)">
                          <OtherNode start="(1048, 5)" end="(1048, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length =&#10;    if a ∈ l₁ then findIdx (fun x =&amp;gt; x == a) l₁ else findIdx (fun x =&amp;gt; x == a) l₂ + l₁.length" state_after="case isFalse.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ ¬a ∈ l₁" tactic="rw [if_neg]">
                            <AtomNode start="(1048, 5)" end="(1048, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(1048, 8)" end="(1048, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(1048, 8)" end="(1048, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(1048, 9)" end="(1048, 15)">
                                <OtherNode start="(1048, 9)" end="(1048, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(1048, 9)" end="(1048, 15)" leading="" trailing="" raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(1048, 15)" end="(1048, 16)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1049, 5)" end="(1049, 18)" kind="Lean.Parser.Tactic.simpa" state_before="case isFalse.hnc&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l₁ l₂ : List α&#10;a : α&#10;h : ¬findIdx (fun x =&amp;gt; x == a) l₁ &amp;lt; l₁.length&#10;⊢ ¬a ∈ l₁" state_after="no goals" tactic="simpa using h">
                            <AtomNode start="(1049, 5)" end="(1049, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(1049, 11)" end="(1049, 18)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(1049, 11)" end="(1049, 18)">
                                <AtomNode start="(1049, 11)" end="(1049, 16)" leading="" trailing=" " val="using"/>
                                <IdentNode start="(1049, 17)" end="(1049, 18)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1051, 1)" end="(1052, 39)" name="indexOf_append" full_name="List.indexOf_append">
      <CommandDeclmodifiersNode start="(1051, 1)" end="(1051, 51)">
        <NullNode/>
        <NullNode start="(1051, 1)" end="(1051, 51)">
          <OtherNode start="(1051, 1)" end="(1051, 51)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1051, 1)" end="(1051, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1051, 3)" end="(1051, 50)">
              <OtherNode start="(1051, 3)" end="(1051, 50)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1051, 3)" end="(1051, 50)" kind="Lean.deprecated">
                  <AtomNode start="(1051, 3)" end="(1051, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1051, 14)" end="(1051, 26)">
                    <IdentNode start="(1051, 14)" end="(1051, 26)" leading="" trailing=" " raw_val="idxOf_append" val="idxOf_append" full_name="List.idxOf_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1042, 9)" def_end="(1042, 21)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1051, 27)" end="(1051, 50)">
                    <AtomNode start="(1051, 27)" end="(1051, 28)" leading="" trailing="" val="("/>
                    <AtomNode start="(1051, 28)" end="(1051, 33)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1051, 34)" end="(1051, 36)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1051, 37)" end="(1051, 49)" kind="str">
                      <AtomNode start="(1051, 37)" end="(1051, 49)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1051, 49)" end="(1051, 50)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1051, 50)" end="(1051, 51)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1052, 1)" end="(1052, 39)" name="indexOf_append">
        <AtomNode start="(1052, 1)" end="(1052, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1052, 8)" end="(1052, 22)">
          <IdentNode start="(1052, 8)" end="(1052, 22)" leading="" trailing=" " raw_val="indexOf_append" val="indexOf_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1052, 23)" end="(1052, 39)">
          <AtomNode start="(1052, 23)" end="(1052, 25)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1052, 26)" end="(1052, 39)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1052, 26)" end="(1052, 27)" leading="" trailing="" val="@"/>
            <IdentNode start="(1052, 27)" end="(1052, 39)" leading="" trailing="&#10;&#10;" raw_val="idxOf_append" val="idxOf_append" full_name="List.idxOf_append" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1042, 9)" def_end="(1042, 21)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1054, 1)" end="(1060, 23)" name="idxOf_eq_length" full_name="List.idxOf_eq_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1054, 1)" end="(1060, 23)" name="idxOf_eq_length" full_name="List.idxOf_eq_length" _is_private_decl="False">
        <AtomNode start="(1054, 1)" end="(1054, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1054, 9)" end="(1054, 24)">
          <IdentNode start="(1054, 9)" end="(1054, 24)" leading="" trailing=" " raw_val="idxOf_eq_length" val="idxOf_eq_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1054, 25)" end="(1054, 94)">
          <NullNode start="(1054, 25)" end="(1054, 71)">
            <OtherNode start="(1054, 25)" end="(1054, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1054, 25)" end="(1054, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1054, 26)" end="(1054, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1054, 26)" end="(1054, 29)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1054, 30)" end="(1054, 31)">
                  <IdentNode start="(1054, 30)" end="(1054, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1054, 31)" end="(1054, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1054, 33)" end="(1054, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1054, 33)" end="(1054, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1054, 34)" end="(1054, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1054, 34)" end="(1054, 43)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1054, 44)" end="(1054, 45)">
                  <IdentNode start="(1054, 44)" end="(1054, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1054, 45)" end="(1054, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1054, 47)" end="(1054, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1054, 47)" end="(1054, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(1054, 48)" end="(1054, 49)">
                <IdentNode start="(1054, 48)" end="(1054, 49)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1054, 50)" end="(1054, 58)">
                <AtomNode start="(1054, 50)" end="(1054, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1054, 52)" end="(1054, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1054, 52)" end="(1054, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1054, 57)" end="(1054, 58)">
                    <IdentNode start="(1054, 57)" end="(1054, 58)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1054, 58)" end="(1054, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1054, 60)" end="(1054, 71)">
              <AtomNode start="(1054, 60)" end="(1054, 61)" leading="" trailing="" val="("/>
              <NullNode start="(1054, 61)" end="(1054, 62)">
                <IdentNode start="(1054, 61)" end="(1054, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1054, 63)" end="(1054, 70)">
                <AtomNode start="(1054, 63)" end="(1054, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1054, 65)" end="(1054, 70)" kind="«term_∉_»">
                  <IdentNode start="(1054, 65)" end="(1054, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1054, 67)" end="(1054, 68)" leading="" trailing=" " val="∉"/>
                  <IdentNode start="(1054, 69)" end="(1054, 70)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1054, 70)" end="(1054, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1054, 72)" end="(1054, 94)">
            <AtomNode start="(1054, 72)" end="(1054, 73)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1054, 74)" end="(1054, 94)" kind="«term_=_»">
              <OtherNode start="(1054, 74)" end="(1054, 83)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1054, 74)" end="(1054, 81)" leading="" trailing=" " raw_val="l.idxOf" val="l.idxOf"/>
                <NullNode start="(1054, 82)" end="(1054, 83)">
                  <IdentNode start="(1054, 82)" end="(1054, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1054, 84)" end="(1054, 85)" leading="" trailing=" " val="="/>
              <IdentNode start="(1054, 86)" end="(1054, 94)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1054, 95)" end="(1060, 23)">
          <AtomNode start="(1054, 95)" end="(1054, 97)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1054, 98)" end="(1060, 23)">
            <AtomNode start="(1054, 98)" end="(1054, 100)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1055, 3)" end="(1060, 23)">
              <TacticTacticseq1IndentedNode start="(1055, 3)" end="(1060, 23)">
                <NullNode start="(1055, 3)" end="(1060, 23)">
                  <OtherNode start="(1055, 3)" end="(1060, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;h : ¬a ∈ l&#10;⊢ idxOf a l = l.length" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; rfl&#10;| cons x xs ih =&amp;gt;&#10;  simp only [mem_cons, not_or] at h&#10;  simp only [idxOf_cons, cond_eq_if, beq_iff_eq]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(1055, 3)" end="(1055, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1055, 13)" end="(1055, 14)">
                      <OtherNode start="(1055, 13)" end="(1055, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1055, 13)" end="(1055, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1055, 15)" end="(1060, 23)">
                      <OtherNode start="(1055, 15)" end="(1060, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1055, 15)" end="(1055, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1056, 3)" end="(1060, 23)">
                          <OtherNode start="(1056, 3)" end="(1056, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1056, 3)" end="(1056, 8)">
                              <OtherNode start="(1056, 3)" end="(1056, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1056, 3)" end="(1056, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1056, 5)" end="(1056, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1056, 5)" end="(1056, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1056, 9)" end="(1056, 15)">
                              <AtomNode start="(1056, 9)" end="(1056, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1056, 12)" end="(1056, 15)">
                                <TacticTacticseq1IndentedNode start="(1056, 12)" end="(1056, 15)">
                                  <NullNode start="(1056, 12)" end="(1056, 15)">
                                    <OtherNode start="(1056, 12)" end="(1056, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;h : ¬a ∈ []&#10;⊢ idxOf a [] = [].length" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(1056, 12)" end="(1056, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1057, 3)" end="(1060, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1057, 3)" end="(1057, 17)">
                              <OtherNode start="(1057, 3)" end="(1057, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1057, 3)" end="(1057, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1057, 5)" end="(1057, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1057, 5)" end="(1057, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1057, 10)" end="(1057, 17)">
                                  <IdentNode start="(1057, 10)" end="(1057, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1057, 12)" end="(1057, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1057, 15)" end="(1057, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1057, 18)" end="(1060, 23)">
                              <AtomNode start="(1057, 18)" end="(1057, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1058, 5)" end="(1060, 23)">
                                <TacticTacticseq1IndentedNode start="(1058, 5)" end="(1060, 23)">
                                  <NullNode start="(1058, 5)" end="(1060, 23)">
                                    <OtherNode start="(1058, 5)" end="(1058, 38)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;x : α&#10;xs : List α&#10;ih : ¬a ∈ xs → idxOf a xs = xs.length&#10;h : ¬a ∈ x :: xs&#10;⊢ idxOf a (x :: xs) = (x :: xs).length" state_after="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;x : α&#10;xs : List α&#10;ih : ¬a ∈ xs → idxOf a xs = xs.length&#10;h : ¬a = x ∧ ¬a ∈ xs&#10;⊢ idxOf a (x :: xs) = (x :: xs).length" tactic="simp only [mem_cons, not_or] at h">
                                      <AtomNode start="(1058, 5)" end="(1058, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1058, 10)" end="(1058, 14)">
                                        <AtomNode start="(1058, 10)" end="(1058, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1058, 15)" end="(1058, 33)">
                                        <AtomNode start="(1058, 15)" end="(1058, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1058, 16)" end="(1058, 32)">
                                          <OtherNode start="(1058, 16)" end="(1058, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1058, 16)" end="(1058, 24)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(1058, 24)" end="(1058, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(1058, 26)" end="(1058, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1058, 26)" end="(1058, 32)" leading="" trailing="" raw_val="not_or" val="not_or" full_name="not_or" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1058, 32)" end="(1058, 33)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(1058, 34)" end="(1058, 38)">
                                        <OtherNode start="(1058, 34)" end="(1058, 38)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(1058, 34)" end="(1058, 36)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(1058, 37)" end="(1058, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(1058, 37)" end="(1058, 38)">
                                              <IdentNode start="(1058, 37)" end="(1058, 38)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1059, 5)" end="(1059, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;x : α&#10;xs : List α&#10;ih : ¬a ∈ xs → idxOf a xs = xs.length&#10;h : ¬a = x ∧ ¬a ∈ xs&#10;⊢ idxOf a (x :: xs) = (x :: xs).length" state_after="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;x : α&#10;xs : List α&#10;ih : ¬a ∈ xs → idxOf a xs = xs.length&#10;h : ¬a = x ∧ ¬a ∈ xs&#10;⊢ (if (x == a) = true then 0 else idxOf a xs + 1) = (x :: xs).length" tactic="simp only [idxOf_cons, cond_eq_if, beq_iff_eq]">
                                      <AtomNode start="(1059, 5)" end="(1059, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1059, 10)" end="(1059, 14)">
                                        <AtomNode start="(1059, 10)" end="(1059, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1059, 15)" end="(1059, 51)">
                                        <AtomNode start="(1059, 15)" end="(1059, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1059, 16)" end="(1059, 50)">
                                          <OtherNode start="(1059, 16)" end="(1059, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1059, 16)" end="(1059, 26)" leading="" trailing="" raw_val="idxOf_cons" val="idxOf_cons" full_name="List.idxOf_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1028, 9)" def_end="(1028, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(1059, 26)" end="(1059, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(1059, 28)" end="(1059, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1059, 28)" end="(1059, 38)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(1059, 38)" end="(1059, 39)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(1059, 40)" end="(1059, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1059, 40)" end="(1059, 50)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1059, 50)" end="(1059, 51)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1060, 5)" end="(1060, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;x : α&#10;xs : List α&#10;ih : ¬a ∈ xs → idxOf a xs = xs.length&#10;h : ¬a = x ∧ ¬a ∈ xs&#10;⊢ (if (x == a) = true then 0 else idxOf a xs + 1) = (x :: xs).length" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(1060, 5)" end="(1060, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1060, 5)" end="(1060, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1060, 11)" end="(1060, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1060, 15)" end="(1060, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1060, 15)" end="(1060, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1062, 1)" end="(1063, 45)" name="indexOf_eq_length" full_name="List.indexOf_eq_length">
      <CommandDeclmodifiersNode start="(1062, 1)" end="(1062, 54)">
        <NullNode/>
        <NullNode start="(1062, 1)" end="(1062, 54)">
          <OtherNode start="(1062, 1)" end="(1062, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1062, 1)" end="(1062, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1062, 3)" end="(1062, 53)">
              <OtherNode start="(1062, 3)" end="(1062, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1062, 3)" end="(1062, 53)" kind="Lean.deprecated">
                  <AtomNode start="(1062, 3)" end="(1062, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1062, 14)" end="(1062, 29)">
                    <IdentNode start="(1062, 14)" end="(1062, 29)" leading="" trailing=" " raw_val="idxOf_eq_length" val="idxOf_eq_length" full_name="List.idxOf_eq_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1054, 9)" def_end="(1054, 24)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1062, 30)" end="(1062, 53)">
                    <AtomNode start="(1062, 30)" end="(1062, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(1062, 31)" end="(1062, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1062, 37)" end="(1062, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1062, 40)" end="(1062, 52)" kind="str">
                      <AtomNode start="(1062, 40)" end="(1062, 52)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1062, 52)" end="(1062, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1062, 53)" end="(1062, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1063, 1)" end="(1063, 45)" name="indexOf_eq_length">
        <AtomNode start="(1063, 1)" end="(1063, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1063, 8)" end="(1063, 25)">
          <IdentNode start="(1063, 8)" end="(1063, 25)" leading="" trailing=" " raw_val="indexOf_eq_length" val="indexOf_eq_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1063, 26)" end="(1063, 45)">
          <AtomNode start="(1063, 26)" end="(1063, 28)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1063, 29)" end="(1063, 45)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1063, 29)" end="(1063, 30)" leading="" trailing="" val="@"/>
            <IdentNode start="(1063, 30)" end="(1063, 45)" leading="" trailing="&#10;&#10;" raw_val="idxOf_eq_length" val="idxOf_eq_length" full_name="List.idxOf_eq_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1054, 9)" def_end="(1054, 24)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1065, 1)" end="(1076, 40)" name="idxOf_lt_length" full_name="List.idxOf_lt_length">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1065, 1)" end="(1076, 40)" name="idxOf_lt_length" full_name="List.idxOf_lt_length" _is_private_decl="False">
        <AtomNode start="(1065, 1)" end="(1065, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1065, 9)" end="(1065, 24)">
          <IdentNode start="(1065, 9)" end="(1065, 24)" leading="" trailing=" " raw_val="idxOf_lt_length" val="idxOf_lt_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1065, 25)" end="(1065, 93)">
          <NullNode start="(1065, 25)" end="(1065, 70)">
            <OtherNode start="(1065, 25)" end="(1065, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1065, 25)" end="(1065, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1065, 26)" end="(1065, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1065, 26)" end="(1065, 29)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1065, 30)" end="(1065, 31)">
                  <IdentNode start="(1065, 30)" end="(1065, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1065, 31)" end="(1065, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1065, 33)" end="(1065, 45)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1065, 33)" end="(1065, 34)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1065, 34)" end="(1065, 44)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1065, 34)" end="(1065, 42)" leading="" trailing=" " raw_val="EquivBEq" val="EquivBEq" full_name="EquivBEq" mod_name="Init.Data.BEq" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/BEq.lean"/>
                <NullNode start="(1065, 43)" end="(1065, 44)">
                  <IdentNode start="(1065, 43)" end="(1065, 44)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1065, 44)" end="(1065, 45)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1065, 46)" end="(1065, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1065, 46)" end="(1065, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(1065, 47)" end="(1065, 48)">
                <IdentNode start="(1065, 47)" end="(1065, 48)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1065, 49)" end="(1065, 57)">
                <AtomNode start="(1065, 49)" end="(1065, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1065, 51)" end="(1065, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1065, 51)" end="(1065, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1065, 56)" end="(1065, 57)">
                    <IdentNode start="(1065, 56)" end="(1065, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1065, 57)" end="(1065, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1065, 59)" end="(1065, 70)">
              <AtomNode start="(1065, 59)" end="(1065, 60)" leading="" trailing="" val="("/>
              <NullNode start="(1065, 60)" end="(1065, 61)">
                <IdentNode start="(1065, 60)" end="(1065, 61)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1065, 62)" end="(1065, 69)">
                <AtomNode start="(1065, 62)" end="(1065, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1065, 64)" end="(1065, 69)" kind="«term_∈_»">
                  <IdentNode start="(1065, 64)" end="(1065, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1065, 66)" end="(1065, 67)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(1065, 68)" end="(1065, 69)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1065, 69)" end="(1065, 70)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1065, 71)" end="(1065, 93)">
            <AtomNode start="(1065, 71)" end="(1065, 72)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1065, 73)" end="(1065, 93)" kind="«term_&amp;lt;_»">
              <OtherNode start="(1065, 73)" end="(1065, 82)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1065, 73)" end="(1065, 80)" leading="" trailing=" " raw_val="l.idxOf" val="l.idxOf"/>
                <NullNode start="(1065, 81)" end="(1065, 82)">
                  <IdentNode start="(1065, 81)" end="(1065, 82)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1065, 83)" end="(1065, 84)" leading="" trailing=" " val="&amp;lt;"/>
              <IdentNode start="(1065, 85)" end="(1065, 93)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1065, 94)" end="(1076, 40)">
          <AtomNode start="(1065, 94)" end="(1065, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1065, 97)" end="(1076, 40)">
            <AtomNode start="(1065, 97)" end="(1065, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1066, 3)" end="(1076, 40)">
              <TacticTacticseq1IndentedNode start="(1066, 3)" end="(1076, 40)">
                <NullNode start="(1066, 3)" end="(1076, 40)">
                  <OtherNode start="(1066, 3)" end="(1076, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;l : List α&#10;h : a ∈ l&#10;⊢ idxOf a l &amp;lt; l.length" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp at h&#10;| cons x xs ih =&amp;gt;&#10;  simp only [mem_cons] at h&#10;  obtain rfl | h := h&#10;  · simp&#10;  · simp only [idxOf_cons, cond_eq_if, beq_iff_eq, length_cons]&#10;    specialize ih h&#10;    split&#10;    · exact zero_lt_succ xs.length&#10;    · exact Nat.add_lt_add_right ih 1">
                    <AtomNode start="(1066, 3)" end="(1066, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1066, 13)" end="(1066, 14)">
                      <OtherNode start="(1066, 13)" end="(1066, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1066, 13)" end="(1066, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1066, 15)" end="(1076, 40)">
                      <OtherNode start="(1066, 15)" end="(1076, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1066, 15)" end="(1066, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1067, 3)" end="(1076, 40)">
                          <OtherNode start="(1067, 3)" end="(1067, 21)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1067, 3)" end="(1067, 8)">
                              <OtherNode start="(1067, 3)" end="(1067, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1067, 3)" end="(1067, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1067, 5)" end="(1067, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1067, 5)" end="(1067, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1067, 9)" end="(1067, 21)">
                              <AtomNode start="(1067, 9)" end="(1067, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1067, 12)" end="(1067, 21)">
                                <TacticTacticseq1IndentedNode start="(1067, 12)" end="(1067, 21)">
                                  <NullNode start="(1067, 12)" end="(1067, 21)">
                                    <OtherNode start="(1067, 12)" end="(1067, 21)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;h : a ∈ []&#10;⊢ idxOf a [] &amp;lt; [].length" state_after="no goals" tactic="simp at h">
                                      <AtomNode start="(1067, 12)" end="(1067, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(1067, 17)" end="(1067, 21)">
                                        <OtherNode start="(1067, 17)" end="(1067, 21)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(1067, 17)" end="(1067, 19)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(1067, 20)" end="(1067, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(1067, 20)" end="(1067, 21)">
                                              <IdentNode start="(1067, 20)" end="(1067, 21)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1068, 3)" end="(1076, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1068, 3)" end="(1068, 17)">
                              <OtherNode start="(1068, 3)" end="(1068, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1068, 3)" end="(1068, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1068, 5)" end="(1068, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1068, 5)" end="(1068, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1068, 10)" end="(1068, 17)">
                                  <IdentNode start="(1068, 10)" end="(1068, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1068, 12)" end="(1068, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1068, 15)" end="(1068, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1068, 18)" end="(1076, 40)">
                              <AtomNode start="(1068, 18)" end="(1068, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1069, 5)" end="(1076, 40)">
                                <TacticTacticseq1IndentedNode start="(1069, 5)" end="(1076, 40)">
                                  <NullNode start="(1069, 5)" end="(1076, 40)">
                                    <OtherNode start="(1069, 5)" end="(1069, 30)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ x :: xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" state_after="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a = x ∨ a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" tactic="simp only [mem_cons] at h">
                                      <AtomNode start="(1069, 5)" end="(1069, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1069, 10)" end="(1069, 14)">
                                        <AtomNode start="(1069, 10)" end="(1069, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1069, 15)" end="(1069, 25)">
                                        <AtomNode start="(1069, 15)" end="(1069, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1069, 16)" end="(1069, 24)">
                                          <OtherNode start="(1069, 16)" end="(1069, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1069, 16)" end="(1069, 24)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1069, 24)" end="(1069, 25)" leading="" trailing=" " val="]"/>
                                      </NullNode>
                                      <NullNode start="(1069, 26)" end="(1069, 30)">
                                        <OtherNode start="(1069, 26)" end="(1069, 30)" kind="Lean.Parser.Tactic.location">
                                          <AtomNode start="(1069, 26)" end="(1069, 28)" leading="" trailing=" " val="at"/>
                                          <OtherNode start="(1069, 29)" end="(1069, 30)" kind="Lean.Parser.Tactic.locationHyp">
                                            <NullNode start="(1069, 29)" end="(1069, 30)">
                                              <IdentNode start="(1069, 29)" end="(1069, 30)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1070, 5)" end="(1070, 24)" kind="Lean.Parser.Tactic.obtain" state_before="case cons&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a = x ∨ a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" state_after="case cons.inl&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;⊢ idxOf a (a :: xs) &amp;lt; (a :: xs).length&#10;&#10;case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" tactic="obtain rfl | h := h">
                                      <AtomNode start="(1070, 5)" end="(1070, 11)" leading="" trailing=" " val="obtain"/>
                                      <NullNode start="(1070, 12)" end="(1070, 19)">
                                        <OtherNode start="(1070, 12)" end="(1070, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(1070, 12)" end="(1070, 19)">
                                            <OtherNode start="(1070, 12)" end="(1070, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(1070, 12)" end="(1070, 15)" leading="" trailing=" " raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                            <AtomNode start="(1070, 16)" end="(1070, 17)" leading="" trailing=" " val="|"/>
                                            <OtherNode start="(1070, 18)" end="(1070, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(1070, 18)" end="(1070, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(1070, 20)" end="(1070, 24)">
                                        <AtomNode start="(1070, 20)" end="(1070, 22)" leading="" trailing=" " val=":="/>
                                        <NullNode start="(1070, 23)" end="(1070, 24)">
                                          <IdentNode start="(1070, 23)" end="(1070, 24)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                        </NullNode>
                                      </NullNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1071, 5)" end="(1071, 11)" kind="Lean.cdot" state_before="case cons.inl&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;⊢ idxOf a (a :: xs) &amp;lt; (a :: xs).length&#10;&#10;case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" state_after="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" tactic="· simp">
                                      <OtherNode start="(1071, 5)" end="(1071, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(1071, 5)" end="(1071, 6)" kind="patternIgnore">
                                          <OtherNode start="(1071, 5)" end="(1071, 6)" kind="token.«· »">
                                            <AtomNode start="(1071, 5)" end="(1071, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(1071, 7)" end="(1071, 11)">
                                        <TacticTacticseq1IndentedNode start="(1071, 7)" end="(1071, 11)">
                                          <NullNode start="(1071, 7)" end="(1071, 11)">
                                            <OtherNode start="(1071, 7)" end="(1071, 11)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inl&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;⊢ idxOf a (a :: xs) &amp;lt; (a :: xs).length" state_after="no goals" tactic="simp">
                                              <AtomNode start="(1071, 7)" end="(1071, 11)" leading="" trailing="&#10;    " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1072, 5)" end="(1076, 40)" kind="Lean.cdot" state_before="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" state_after="no goals" tactic="· simp only [idxOf_cons, cond_eq_if, beq_iff_eq, length_cons]&#10;  specialize ih h&#10;  split&#10;  · exact zero_lt_succ xs.length&#10;  · exact Nat.add_lt_add_right ih 1">
                                      <OtherNode start="(1072, 5)" end="(1072, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(1072, 5)" end="(1072, 6)" kind="patternIgnore">
                                          <OtherNode start="(1072, 5)" end="(1072, 6)" kind="token.«· »">
                                            <AtomNode start="(1072, 5)" end="(1072, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(1072, 7)" end="(1076, 40)">
                                        <TacticTacticseq1IndentedNode start="(1072, 7)" end="(1076, 40)">
                                          <NullNode start="(1072, 7)" end="(1076, 40)">
                                            <OtherNode start="(1072, 7)" end="(1072, 66)" kind="Lean.Parser.Tactic.simp" state_before="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ idxOf a (x :: xs) &amp;lt; (x :: xs).length" state_after="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ (if (x == a) = true then 0 else idxOf a xs + 1) &amp;lt; xs.length + 1" tactic="simp only [idxOf_cons, cond_eq_if, beq_iff_eq, length_cons]">
                                              <AtomNode start="(1072, 7)" end="(1072, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(1072, 12)" end="(1072, 16)">
                                                <AtomNode start="(1072, 12)" end="(1072, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(1072, 17)" end="(1072, 66)">
                                                <AtomNode start="(1072, 17)" end="(1072, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(1072, 18)" end="(1072, 65)">
                                                  <OtherNode start="(1072, 18)" end="(1072, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(1072, 18)" end="(1072, 28)" leading="" trailing="" raw_val="idxOf_cons" val="idxOf_cons" full_name="List.idxOf_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1028, 9)" def_end="(1028, 19)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(1072, 28)" end="(1072, 29)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(1072, 30)" end="(1072, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(1072, 30)" end="(1072, 40)" leading="" trailing="" raw_val="cond_eq_if" val="cond_eq_if" full_name="Bool.cond_eq_if" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(1072, 40)" end="(1072, 41)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(1072, 42)" end="(1072, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(1072, 42)" end="(1072, 52)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(1072, 52)" end="(1072, 53)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(1072, 54)" end="(1072, 65)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(1072, 54)" end="(1072, 65)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(1072, 65)" end="(1072, 66)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(1073, 7)" end="(1073, 22)" kind="Lean.Parser.Tactic.specialize" state_before="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;ih : a ∈ xs → idxOf a xs &amp;lt; xs.length&#10;h : a ∈ xs&#10;⊢ (if (x == a) = true then 0 else idxOf a xs + 1) &amp;lt; xs.length + 1" state_after="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;⊢ (if (x == a) = true then 0 else idxOf a xs + 1) &amp;lt; xs.length + 1" tactic="specialize ih h">
                                              <AtomNode start="(1073, 7)" end="(1073, 17)" leading="" trailing=" " val="specialize"/>
                                              <OtherNode start="(1073, 18)" end="(1073, 22)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(1073, 18)" end="(1073, 20)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                <NullNode start="(1073, 21)" end="(1073, 22)">
                                                  <IdentNode start="(1073, 21)" end="(1073, 22)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(1074, 7)" end="(1074, 12)" kind="Lean.Parser.Tactic.split" state_before="case cons.inr&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;⊢ (if (x == a) = true then 0 else idxOf a xs + 1) &amp;lt; xs.length + 1" state_after="case cons.inr.isTrue&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : (x == a) = true&#10;⊢ 0 &amp;lt; xs.length + 1&#10;&#10;case cons.inr.isFalse&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : ¬(x == a) = true&#10;⊢ idxOf a xs + 1 &amp;lt; xs.length + 1" tactic="split">
                                              <AtomNode start="(1074, 7)" end="(1074, 12)" leading="" trailing="&#10;      " val="split"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(1075, 7)" end="(1075, 37)" kind="Lean.cdot" state_before="case cons.inr.isTrue&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : (x == a) = true&#10;⊢ 0 &amp;lt; xs.length + 1&#10;&#10;case cons.inr.isFalse&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : ¬(x == a) = true&#10;⊢ idxOf a xs + 1 &amp;lt; xs.length + 1" state_after="case cons.inr.isFalse&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : ¬(x == a) = true&#10;⊢ idxOf a xs + 1 &amp;lt; xs.length + 1" tactic="· exact zero_lt_succ xs.length">
                                              <OtherNode start="(1075, 7)" end="(1075, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(1075, 7)" end="(1075, 8)" kind="patternIgnore">
                                                  <OtherNode start="(1075, 7)" end="(1075, 8)" kind="token.«· »">
                                                    <AtomNode start="(1075, 7)" end="(1075, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(1075, 9)" end="(1075, 37)">
                                                <TacticTacticseq1IndentedNode start="(1075, 9)" end="(1075, 37)">
                                                  <NullNode start="(1075, 9)" end="(1075, 37)">
                                                    <OtherNode start="(1075, 9)" end="(1075, 37)" kind="Lean.Parser.Tactic.exact" state_before="case cons.inr.isTrue&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : (x == a) = true&#10;⊢ 0 &amp;lt; xs.length + 1" state_after="no goals" tactic="exact zero_lt_succ xs.length">
                                                      <AtomNode start="(1075, 9)" end="(1075, 14)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(1075, 15)" end="(1075, 37)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(1075, 15)" end="(1075, 27)" leading="" trailing=" " raw_val="zero_lt_succ" val="zero_lt_succ" full_name="Nat.zero_lt_succ" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                        <NullNode start="(1075, 28)" end="(1075, 37)">
                                                          <IdentNode start="(1075, 28)" end="(1075, 37)" leading="" trailing="&#10;      " raw_val="xs.length" val="xs.length"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(1076, 7)" end="(1076, 40)" kind="Lean.cdot" state_before="case cons.inr.isFalse&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : ¬(x == a) = true&#10;⊢ idxOf a xs + 1 &amp;lt; xs.length + 1" state_after="no goals" tactic="· exact Nat.add_lt_add_right ih 1">
                                              <OtherNode start="(1076, 7)" end="(1076, 8)" kind="Lean.cdotTk">
                                                <OtherNode start="(1076, 7)" end="(1076, 8)" kind="patternIgnore">
                                                  <OtherNode start="(1076, 7)" end="(1076, 8)" kind="token.«· »">
                                                    <AtomNode start="(1076, 7)" end="(1076, 8)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(1076, 9)" end="(1076, 40)">
                                                <TacticTacticseq1IndentedNode start="(1076, 9)" end="(1076, 40)">
                                                  <NullNode start="(1076, 9)" end="(1076, 40)">
                                                    <OtherNode start="(1076, 9)" end="(1076, 40)" kind="Lean.Parser.Tactic.exact" state_before="case cons.inr.isFalse&#10;α : Type u_1&#10;a : α&#10;inst✝¹ : BEq α&#10;inst✝ : EquivBEq α&#10;x : α&#10;xs : List α&#10;h : a ∈ xs&#10;ih : idxOf a xs &amp;lt; xs.length&#10;h✝ : ¬(x == a) = true&#10;⊢ idxOf a xs + 1 &amp;lt; xs.length + 1" state_after="no goals" tactic="exact Nat.add_lt_add_right ih 1">
                                                      <AtomNode start="(1076, 9)" end="(1076, 14)" leading="" trailing=" " val="exact"/>
                                                      <OtherNode start="(1076, 15)" end="(1076, 40)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(1076, 15)" end="(1076, 35)" leading="" trailing=" " raw_val="Nat.add_lt_add_right" val="Nat.add_lt_add_right" full_name="Nat.add_lt_add_right" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                        <NullNode start="(1076, 36)" end="(1076, 40)">
                                                          <IdentNode start="(1076, 36)" end="(1076, 38)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                          <OtherNode start="(1076, 39)" end="(1076, 40)" kind="num">
                                                            <AtomNode start="(1076, 39)" end="(1076, 40)" leading="" trailing="&#10;&#10;" val="1"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1078, 1)" end="(1079, 45)" name="indexOf_lt_length" full_name="List.indexOf_lt_length">
      <CommandDeclmodifiersNode start="(1078, 1)" end="(1078, 54)">
        <NullNode/>
        <NullNode start="(1078, 1)" end="(1078, 54)">
          <OtherNode start="(1078, 1)" end="(1078, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1078, 1)" end="(1078, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1078, 3)" end="(1078, 53)">
              <OtherNode start="(1078, 3)" end="(1078, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1078, 3)" end="(1078, 53)" kind="Lean.deprecated">
                  <AtomNode start="(1078, 3)" end="(1078, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1078, 14)" end="(1078, 29)">
                    <IdentNode start="(1078, 14)" end="(1078, 29)" leading="" trailing=" " raw_val="idxOf_lt_length" val="idxOf_lt_length" full_name="List.idxOf_lt_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1065, 9)" def_end="(1065, 24)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1078, 30)" end="(1078, 53)">
                    <AtomNode start="(1078, 30)" end="(1078, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(1078, 31)" end="(1078, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1078, 37)" end="(1078, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1078, 40)" end="(1078, 52)" kind="str">
                      <AtomNode start="(1078, 40)" end="(1078, 52)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1078, 52)" end="(1078, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1078, 53)" end="(1078, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1079, 1)" end="(1079, 45)" name="indexOf_lt_length">
        <AtomNode start="(1079, 1)" end="(1079, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1079, 8)" end="(1079, 25)">
          <IdentNode start="(1079, 8)" end="(1079, 25)" leading="" trailing=" " raw_val="indexOf_lt_length" val="indexOf_lt_length"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1079, 26)" end="(1079, 45)">
          <AtomNode start="(1079, 26)" end="(1079, 28)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1079, 29)" end="(1079, 45)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1079, 29)" end="(1079, 30)" leading="" trailing="" val="@"/>
            <IdentNode start="(1079, 30)" end="(1079, 45)" leading="" trailing="&#10;&#10;" raw_val="idxOf_lt_length" val="idxOf_lt_length" full_name="List.idxOf_lt_length" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1065, 9)" def_end="(1065, 24)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(1081, 1)" end="(1085, 3)" comment="### finIdxOf?&#10;&#10;The verification API for `finIdxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findFinIdx?` (and proved using them).&#10;-/">
      <AtomNode start="(1081, 1)" end="(1081, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(1081, 5)" end="(1085, 3)" leading="" trailing="&#10;&#10;" val="### finIdxOf?&#10;&#10;The verification API for `finIdxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findFinIdx?` (and proved using them).&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(1087, 1)" end="(1089, 60)" name="idxOf?_eq_map_finIdxOf?_val" full_name="List.idxOf?_eq_map_finIdxOf?_val">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1087, 1)" end="(1089, 60)" name="idxOf?_eq_map_finIdxOf?_val" full_name="List.idxOf?_eq_map_finIdxOf?_val" _is_private_decl="False">
        <AtomNode start="(1087, 1)" end="(1087, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1087, 9)" end="(1087, 36)">
          <IdentNode start="(1087, 9)" end="(1087, 36)" leading="" trailing=" " raw_val="idxOf?_eq_map_finIdxOf?_val" val="idxOf?_eq_map_finIdxOf?_val"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1087, 37)" end="(1088, 47)">
          <NullNode start="(1087, 37)" end="(1087, 66)">
            <OtherNode start="(1087, 37)" end="(1087, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1087, 37)" end="(1087, 38)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1087, 38)" end="(1087, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1087, 38)" end="(1087, 41)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1087, 42)" end="(1087, 43)">
                  <IdentNode start="(1087, 42)" end="(1087, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1087, 43)" end="(1087, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1087, 45)" end="(1087, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1087, 45)" end="(1087, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(1087, 46)" end="(1087, 48)">
                <IdentNode start="(1087, 46)" end="(1087, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(1087, 49)" end="(1087, 57)">
                <AtomNode start="(1087, 49)" end="(1087, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1087, 51)" end="(1087, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1087, 51)" end="(1087, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1087, 56)" end="(1087, 57)">
                    <IdentNode start="(1087, 56)" end="(1087, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1087, 57)" end="(1087, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1087, 59)" end="(1087, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1087, 59)" end="(1087, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(1087, 60)" end="(1087, 61)">
                <IdentNode start="(1087, 60)" end="(1087, 61)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1087, 62)" end="(1087, 65)">
                <AtomNode start="(1087, 62)" end="(1087, 63)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1087, 64)" end="(1087, 65)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1087, 65)" end="(1087, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1087, 67)" end="(1088, 47)">
            <AtomNode start="(1087, 67)" end="(1087, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1088, 5)" end="(1088, 47)" kind="«term_=_»">
              <OtherNode start="(1088, 5)" end="(1088, 16)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1088, 5)" end="(1088, 14)" leading="" trailing=" " raw_val="xs.idxOf?" val="xs.idxOf?"/>
                <NullNode start="(1088, 15)" end="(1088, 16)">
                  <IdentNode start="(1088, 15)" end="(1088, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1088, 17)" end="(1088, 18)" leading="" trailing=" " val="="/>
              <OtherNode start="(1088, 19)" end="(1088, 47)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1088, 19)" end="(1088, 39)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1088, 19)" end="(1088, 35)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1088, 19)" end="(1088, 20)" leading="" trailing="" val="("/>
                    <OtherNode start="(1088, 20)" end="(1088, 34)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1088, 20)" end="(1088, 32)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                      <NullNode start="(1088, 33)" end="(1088, 34)">
                        <IdentNode start="(1088, 33)" end="(1088, 34)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1088, 34)" end="(1088, 35)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1088, 35)" end="(1088, 36)" leading="" trailing="" val="."/>
                  <IdentNode start="(1088, 36)" end="(1088, 39)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(1088, 40)" end="(1088, 47)">
                  <OtherNode start="(1088, 40)" end="(1088, 47)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1088, 40)" end="(1088, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(1088, 41)" end="(1088, 46)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(1088, 41)" end="(1088, 42)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(1088, 41)" end="(1088, 42)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(1088, 42)" end="(1088, 43)" leading="" trailing="" val="."/>
                      <IdentNode start="(1088, 43)" end="(1088, 46)" leading="" trailing="" raw_val="val" val="val" full_name="Fin.val" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(1088, 46)" end="(1088, 47)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1088, 48)" end="(1089, 60)">
          <AtomNode start="(1088, 48)" end="(1088, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1088, 51)" end="(1089, 60)">
            <AtomNode start="(1088, 51)" end="(1088, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1089, 3)" end="(1089, 60)">
              <TacticTacticseq1IndentedNode start="(1089, 3)" end="(1089, 60)">
                <NullNode start="(1089, 3)" end="(1089, 60)">
                  <OtherNode start="(1089, 3)" end="(1089, 60)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;xs : List α&#10;a : α&#10;⊢ idxOf? a xs = Option.map (fun x =&amp;gt; ↑x) (finIdxOf? a xs)" state_after="no goals" tactic="simp [idxOf?, finIdxOf?, findIdx?_eq_map_findFinIdx?_val]">
                    <AtomNode start="(1089, 3)" end="(1089, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1089, 8)" end="(1089, 60)">
                      <AtomNode start="(1089, 8)" end="(1089, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1089, 9)" end="(1089, 59)">
                        <OtherNode start="(1089, 9)" end="(1089, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1089, 9)" end="(1089, 15)" leading="" trailing="" raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1089, 15)" end="(1089, 16)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1089, 17)" end="(1089, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1089, 17)" end="(1089, 26)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1089, 26)" end="(1089, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1089, 28)" end="(1089, 59)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1089, 28)" end="(1089, 59)" leading="" trailing="" raw_val="findIdx?_eq_map_findFinIdx?_val" val="findIdx?_eq_map_findFinIdx?_val" full_name="List.findIdx?_eq_map_findFinIdx?_val" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(942, 9)" def_end="(942, 40)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1089, 59)" end="(1089, 60)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1091, 1)" end="(1091, 80)" name="finIdxOf?_nil" full_name="List.finIdxOf?_nil">
      <CommandDeclmodifiersNode start="(1091, 1)" end="(1091, 8)">
        <NullNode/>
        <NullNode start="(1091, 1)" end="(1091, 8)">
          <OtherNode start="(1091, 1)" end="(1091, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1091, 1)" end="(1091, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1091, 3)" end="(1091, 7)">
              <OtherNode start="(1091, 3)" end="(1091, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1091, 3)" end="(1091, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1091, 3)" end="(1091, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1091, 7)" end="(1091, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1091, 9)" end="(1091, 80)" name="finIdxOf?_nil" full_name="List.finIdxOf?_nil" _is_private_decl="False">
        <AtomNode start="(1091, 9)" end="(1091, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1091, 17)" end="(1091, 30)">
          <IdentNode start="(1091, 17)" end="(1091, 30)" leading="" trailing=" " raw_val="finIdxOf?_nil" val="finIdxOf?_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1091, 31)" end="(1091, 73)">
          <NullNode start="(1091, 31)" end="(1091, 38)">
            <OtherNode start="(1091, 31)" end="(1091, 38)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1091, 31)" end="(1091, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1091, 32)" end="(1091, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1091, 32)" end="(1091, 35)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1091, 36)" end="(1091, 37)">
                  <IdentNode start="(1091, 36)" end="(1091, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1091, 37)" end="(1091, 38)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1091, 39)" end="(1091, 73)">
            <AtomNode start="(1091, 39)" end="(1091, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1091, 41)" end="(1091, 73)" kind="«term_=_»">
              <OtherNode start="(1091, 41)" end="(1091, 66)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1091, 41)" end="(1091, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1091, 41)" end="(1091, 54)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(1091, 41)" end="(1091, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(1091, 42)" end="(1091, 44)" kind="«term[_]»">
                      <AtomNode start="(1091, 42)" end="(1091, 43)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(1091, 43)" end="(1091, 44)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(1091, 45)" end="(1091, 46)" leading="" trailing=" " val=":"/>
                    <NullNode start="(1091, 47)" end="(1091, 53)">
                      <OtherNode start="(1091, 47)" end="(1091, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(1091, 47)" end="(1091, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(1091, 52)" end="(1091, 53)">
                          <IdentNode start="(1091, 52)" end="(1091, 53)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(1091, 53)" end="(1091, 54)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1091, 54)" end="(1091, 55)" leading="" trailing="" val="."/>
                  <IdentNode start="(1091, 55)" end="(1091, 64)" leading="" trailing=" " raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1091, 65)" end="(1091, 66)">
                  <IdentNode start="(1091, 65)" end="(1091, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1091, 67)" end="(1091, 68)" leading="" trailing=" " val="="/>
              <IdentNode start="(1091, 69)" end="(1091, 73)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1091, 74)" end="(1091, 80)">
          <AtomNode start="(1091, 74)" end="(1091, 76)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1091, 77)" end="(1091, 80)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1093, 1)" end="(1096, 37)" name="finIdxOf?_cons" full_name="List.finIdxOf?_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1093, 1)" end="(1096, 37)" name="finIdxOf?_cons" full_name="List.finIdxOf?_cons" _is_private_decl="False">
        <AtomNode start="(1093, 1)" end="(1093, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1093, 9)" end="(1093, 23)">
          <IdentNode start="(1093, 9)" end="(1093, 23)" leading="" trailing=" " raw_val="finIdxOf?_cons" val="finIdxOf?_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1093, 24)" end="(1095, 74)">
          <NullNode start="(1093, 24)" end="(1093, 53)">
            <OtherNode start="(1093, 24)" end="(1093, 31)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1093, 24)" end="(1093, 25)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1093, 25)" end="(1093, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1093, 25)" end="(1093, 28)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1093, 29)" end="(1093, 30)">
                  <IdentNode start="(1093, 29)" end="(1093, 30)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1093, 30)" end="(1093, 31)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1093, 32)" end="(1093, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1093, 32)" end="(1093, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(1093, 33)" end="(1093, 34)">
                <IdentNode start="(1093, 33)" end="(1093, 34)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1093, 35)" end="(1093, 38)">
                <AtomNode start="(1093, 35)" end="(1093, 36)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1093, 37)" end="(1093, 38)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1093, 38)" end="(1093, 39)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1093, 40)" end="(1093, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1093, 40)" end="(1093, 41)" leading="" trailing="" val="{"/>
              <NullNode start="(1093, 41)" end="(1093, 43)">
                <IdentNode start="(1093, 41)" end="(1093, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(1093, 44)" end="(1093, 52)">
                <AtomNode start="(1093, 44)" end="(1093, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1093, 46)" end="(1093, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1093, 46)" end="(1093, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1093, 51)" end="(1093, 52)">
                    <IdentNode start="(1093, 51)" end="(1093, 52)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1093, 52)" end="(1093, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1093, 54)" end="(1095, 74)">
            <AtomNode start="(1093, 54)" end="(1093, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1094, 5)" end="(1095, 74)" kind="«term_=_»">
              <OtherNode start="(1094, 5)" end="(1094, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1094, 5)" end="(1094, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1094, 5)" end="(1094, 14)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1094, 5)" end="(1094, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1094, 6)" end="(1094, 13)" kind="«term_::_»">
                      <IdentNode start="(1094, 6)" end="(1094, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(1094, 8)" end="(1094, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(1094, 11)" end="(1094, 13)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(1094, 13)" end="(1094, 14)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1094, 14)" end="(1094, 15)" leading="" trailing="" val="."/>
                  <IdentNode start="(1094, 15)" end="(1094, 24)" leading="" trailing=" " raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1094, 25)" end="(1094, 26)">
                  <IdentNode start="(1094, 25)" end="(1094, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1094, 27)" end="(1094, 28)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(1095, 7)" end="(1095, 74)" kind="termIfThenElse">
                <AtomNode start="(1095, 7)" end="(1095, 9)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1095, 10)" end="(1095, 16)" kind="«term_==_»">
                  <IdentNode start="(1095, 10)" end="(1095, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1095, 12)" end="(1095, 14)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(1095, 15)" end="(1095, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(1095, 17)" end="(1095, 21)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1095, 22)" end="(1095, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1095, 22)" end="(1095, 26)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1095, 27)" end="(1095, 39)">
                    <OtherNode start="(1095, 27)" end="(1095, 39)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(1095, 27)" end="(1095, 28)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(1095, 28)" end="(1095, 38)">
                        <OtherNode start="(1095, 28)" end="(1095, 29)" kind="num">
                          <AtomNode start="(1095, 28)" end="(1095, 29)" leading="" trailing="" val="0"/>
                        </OtherNode>
                        <AtomNode start="(1095, 29)" end="(1095, 30)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(1095, 31)" end="(1095, 38)">
                          <AtomNode start="(1095, 31)" end="(1095, 33)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(1095, 34)" end="(1095, 38)">
                            <TacticTacticseq1IndentedNode start="(1095, 34)" end="(1095, 38)">
                              <NullNode start="(1095, 34)" end="(1095, 38)">
                                <OtherNode start="(1095, 34)" end="(1095, 38)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.257227&#10;b : α&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;⊢ 0 &amp;lt; xs.length + 1" state_after="no goals" tactic="simp">
                                  <AtomNode start="(1095, 34)" end="(1095, 38)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(1095, 38)" end="(1095, 39)" leading="" trailing=" " val="⟩"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1095, 40)" end="(1095, 44)" leading="" trailing=" " val="else"/>
                <OtherNode start="(1095, 45)" end="(1095, 74)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(1095, 45)" end="(1095, 65)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(1095, 45)" end="(1095, 61)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1095, 45)" end="(1095, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(1095, 46)" end="(1095, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(1095, 46)" end="(1095, 58)" leading="" trailing=" " raw_val="xs.finIdxOf?" val="xs.finIdxOf?"/>
                        <NullNode start="(1095, 59)" end="(1095, 60)">
                          <IdentNode start="(1095, 59)" end="(1095, 60)" leading="" trailing="" raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(1095, 60)" end="(1095, 61)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(1095, 61)" end="(1095, 62)" leading="" trailing="" val="."/>
                    <IdentNode start="(1095, 62)" end="(1095, 65)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <NullNode start="(1095, 66)" end="(1095, 74)">
                    <OtherNode start="(1095, 66)" end="(1095, 74)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1095, 66)" end="(1095, 67)" leading="" trailing="" val="("/>
                      <OtherNode start="(1095, 67)" end="(1095, 73)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(1095, 67)" end="(1095, 68)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(1095, 67)" end="(1095, 68)" leading="" trailing="" val="·"/>
                        </OtherNode>
                        <AtomNode start="(1095, 68)" end="(1095, 69)" leading="" trailing="" val="."/>
                        <IdentNode start="(1095, 69)" end="(1095, 73)" leading="" trailing="" raw_val="succ" val="succ" full_name="Fin.succ" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                      </OtherNode>
                      <AtomNode start="(1095, 73)" end="(1095, 74)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1095, 75)" end="(1096, 37)">
          <AtomNode start="(1095, 75)" end="(1095, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1095, 78)" end="(1096, 37)">
            <AtomNode start="(1095, 78)" end="(1095, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1096, 3)" end="(1096, 37)">
              <TacticTacticseq1IndentedNode start="(1096, 3)" end="(1096, 37)">
                <NullNode start="(1096, 3)" end="(1096, 37)">
                  <OtherNode start="(1096, 3)" end="(1096, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;b : α&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;⊢ finIdxOf? b (a :: xs) = if (a == b) = true then some ⟨0, ⋯⟩ else Option.map (fun x =&amp;gt; x.succ) (finIdxOf? b xs)" state_after="no goals" tactic="simp [finIdxOf?, findFinIdx?_cons]">
                    <AtomNode start="(1096, 3)" end="(1096, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1096, 8)" end="(1096, 37)">
                      <AtomNode start="(1096, 8)" end="(1096, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1096, 9)" end="(1096, 36)">
                        <OtherNode start="(1096, 9)" end="(1096, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1096, 9)" end="(1096, 18)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1096, 18)" end="(1096, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1096, 20)" end="(1096, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1096, 20)" end="(1096, 36)" leading="" trailing="" raw_val="findFinIdx?_cons" val="findFinIdx?_cons" full_name="List.findFinIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(954, 9)" def_end="(954, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1096, 36)" end="(1096, 37)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1098, 1)" end="(1105, 14)" name="finIdxOf?_eq_none_iff" full_name="List.finIdxOf?_eq_none_iff">
      <CommandDeclmodifiersNode start="(1098, 1)" end="(1098, 8)">
        <NullNode/>
        <NullNode start="(1098, 1)" end="(1098, 8)">
          <OtherNode start="(1098, 1)" end="(1098, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1098, 1)" end="(1098, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1098, 3)" end="(1098, 7)">
              <OtherNode start="(1098, 3)" end="(1098, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1098, 3)" end="(1098, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1098, 3)" end="(1098, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1098, 7)" end="(1098, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1098, 9)" end="(1105, 14)" name="finIdxOf?_eq_none_iff" full_name="List.finIdxOf?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(1098, 9)" end="(1098, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1098, 17)" end="(1098, 38)">
          <IdentNode start="(1098, 17)" end="(1098, 38)" leading="" trailing=" " raw_val="finIdxOf?_eq_none_iff" val="finIdxOf?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1098, 39)" end="(1099, 33)">
          <NullNode start="(1098, 39)" end="(1098, 81)">
            <OtherNode start="(1098, 39)" end="(1098, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1098, 39)" end="(1098, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1098, 40)" end="(1098, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1098, 40)" end="(1098, 43)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1098, 44)" end="(1098, 45)">
                  <IdentNode start="(1098, 44)" end="(1098, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1098, 45)" end="(1098, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1098, 47)" end="(1098, 60)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1098, 47)" end="(1098, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1098, 48)" end="(1098, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1098, 48)" end="(1098, 57)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1098, 58)" end="(1098, 59)">
                  <IdentNode start="(1098, 58)" end="(1098, 59)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1098, 59)" end="(1098, 60)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1098, 61)" end="(1098, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1098, 61)" end="(1098, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(1098, 62)" end="(1098, 63)">
                <IdentNode start="(1098, 62)" end="(1098, 63)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1098, 64)" end="(1098, 72)">
                <AtomNode start="(1098, 64)" end="(1098, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1098, 66)" end="(1098, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1098, 66)" end="(1098, 70)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1098, 71)" end="(1098, 72)">
                    <IdentNode start="(1098, 71)" end="(1098, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1098, 72)" end="(1098, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1098, 74)" end="(1098, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1098, 74)" end="(1098, 75)" leading="" trailing="" val="{"/>
              <NullNode start="(1098, 75)" end="(1098, 76)">
                <IdentNode start="(1098, 75)" end="(1098, 76)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1098, 77)" end="(1098, 80)">
                <AtomNode start="(1098, 77)" end="(1098, 78)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1098, 79)" end="(1098, 80)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1098, 80)" end="(1098, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1098, 82)" end="(1099, 33)">
            <AtomNode start="(1098, 82)" end="(1098, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1099, 5)" end="(1099, 33)" kind="«term_↔_»">
              <OtherNode start="(1099, 5)" end="(1099, 25)" kind="«term_=_»">
                <OtherNode start="(1099, 5)" end="(1099, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1099, 5)" end="(1099, 16)" leading="" trailing=" " raw_val="l.finIdxOf?" val="l.finIdxOf?"/>
                  <NullNode start="(1099, 17)" end="(1099, 18)">
                    <IdentNode start="(1099, 17)" end="(1099, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1099, 19)" end="(1099, 20)" leading="" trailing=" " val="="/>
                <IdentNode start="(1099, 21)" end="(1099, 25)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1099, 26)" end="(1099, 27)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1099, 28)" end="(1099, 33)" kind="«term_∉_»">
                <IdentNode start="(1099, 28)" end="(1099, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(1099, 30)" end="(1099, 31)" leading="" trailing=" " val="∉"/>
                <IdentNode start="(1099, 32)" end="(1099, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1099, 34)" end="(1105, 14)">
          <AtomNode start="(1099, 34)" end="(1099, 36)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1099, 37)" end="(1105, 14)">
            <AtomNode start="(1099, 37)" end="(1099, 39)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1100, 3)" end="(1105, 14)">
              <TacticTacticseq1IndentedNode start="(1100, 3)" end="(1105, 14)">
                <NullNode start="(1100, 3)" end="(1105, 14)">
                  <OtherNode start="(1100, 3)" end="(1100, 61)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ finIdxOf? a l = none ↔ ¬a ∈ l" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) ↔ ¬a ∈ l" tactic="simp only [finIdxOf?, findFinIdx?_eq_none_iff, beq_iff_eq]">
                    <AtomNode start="(1100, 3)" end="(1100, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1100, 8)" end="(1100, 12)">
                      <AtomNode start="(1100, 8)" end="(1100, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1100, 13)" end="(1100, 61)">
                      <AtomNode start="(1100, 13)" end="(1100, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1100, 14)" end="(1100, 60)">
                        <OtherNode start="(1100, 14)" end="(1100, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1100, 14)" end="(1100, 23)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1100, 23)" end="(1100, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1100, 25)" end="(1100, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1100, 25)" end="(1100, 48)" leading="" trailing="" raw_val="findFinIdx?_eq_none_iff" val="findFinIdx?_eq_none_iff" full_name="List.findFinIdx?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(977, 17)" def_end="(977, 40)"/>
                        </OtherNode>
                        <AtomNode start="(1100, 48)" end="(1100, 49)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1100, 50)" end="(1100, 60)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1100, 50)" end="(1100, 60)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1100, 60)" end="(1100, 61)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1101, 3)" end="(1101, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) ↔ ¬a ∈ l" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) → ¬a ∈ l&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" tactic="constructor">
                    <AtomNode start="(1101, 3)" end="(1101, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1102, 3)" end="(1103, 20)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) → ¬a ∈ l&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" state_after="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" tactic="· intro w m&#10;  exact w a m rfl">
                    <OtherNode start="(1102, 3)" end="(1102, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1102, 3)" end="(1102, 4)" kind="patternIgnore">
                        <OtherNode start="(1102, 3)" end="(1102, 4)" kind="token.«· »">
                          <AtomNode start="(1102, 3)" end="(1102, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1102, 5)" end="(1103, 20)">
                      <TacticTacticseq1IndentedNode start="(1102, 5)" end="(1103, 20)">
                        <NullNode start="(1102, 5)" end="(1103, 20)">
                          <OtherNode start="(1102, 5)" end="(1102, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) → ¬a ∈ l" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;w : ∀ (x : α), x ∈ l → ¬x = a&#10;m : a ∈ l&#10;⊢ False" tactic="intro w m">
                            <AtomNode start="(1102, 5)" end="(1102, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(1102, 11)" end="(1102, 14)">
                              <IdentNode start="(1102, 11)" end="(1102, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(1102, 13)" end="(1102, 14)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1103, 5)" end="(1103, 20)" kind="Lean.Parser.Tactic.exact" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;w : ∀ (x : α), x ∈ l → ¬x = a&#10;m : a ∈ l&#10;⊢ False" state_after="no goals" tactic="exact w a m rfl">
                            <AtomNode start="(1103, 5)" end="(1103, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(1103, 11)" end="(1103, 20)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(1103, 11)" end="(1103, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(1103, 13)" end="(1103, 20)">
                                <IdentNode start="(1103, 13)" end="(1103, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(1103, 15)" end="(1103, 16)" leading="" trailing=" " raw_val="m" val="m"/>
                                <IdentNode start="(1103, 17)" end="(1103, 20)" leading="" trailing="&#10;  " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1104, 3)" end="(1105, 14)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" state_after="no goals" tactic="· rintro h a m rfl&#10;  exact h m">
                    <OtherNode start="(1104, 3)" end="(1104, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1104, 3)" end="(1104, 4)" kind="patternIgnore">
                        <OtherNode start="(1104, 3)" end="(1104, 4)" kind="token.«· »">
                          <AtomNode start="(1104, 3)" end="(1104, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1104, 5)" end="(1105, 14)">
                      <TacticTacticseq1IndentedNode start="(1104, 5)" end="(1105, 14)">
                        <NullNode start="(1104, 5)" end="(1105, 14)">
                          <OtherNode start="(1104, 5)" end="(1104, 21)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" state_after="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;m : a ∈ l&#10;h : ¬a ∈ l&#10;⊢ False" tactic="rintro h a m rfl">
                            <AtomNode start="(1104, 5)" end="(1104, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(1104, 12)" end="(1104, 21)">
                              <OtherNode start="(1104, 12)" end="(1104, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1104, 12)" end="(1104, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1104, 12)" end="(1104, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(1104, 14)" end="(1104, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1104, 14)" end="(1104, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1104, 14)" end="(1104, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(1104, 16)" end="(1104, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1104, 16)" end="(1104, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1104, 16)" end="(1104, 17)" leading="" trailing=" " raw_val="m" val="m"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(1104, 18)" end="(1104, 21)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1104, 18)" end="(1104, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1104, 18)" end="(1104, 21)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1105, 5)" end="(1105, 14)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;m : a ∈ l&#10;h : ¬a ∈ l&#10;⊢ False" state_after="no goals" tactic="exact h m">
                            <AtomNode start="(1105, 5)" end="(1105, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(1105, 11)" end="(1105, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(1105, 11)" end="(1105, 12)" leading="" trailing=" " raw_val="h" val="h"/>
                              <NullNode start="(1105, 13)" end="(1105, 14)">
                                <IdentNode start="(1105, 13)" end="(1105, 14)" leading="" trailing="&#10;&#10;" raw_val="m" val="m"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1107, 1)" end="(1109, 61)" name="finIdxOf?_eq_some_iff" full_name="List.finIdxOf?_eq_some_iff">
      <CommandDeclmodifiersNode start="(1107, 1)" end="(1107, 8)">
        <NullNode/>
        <NullNode start="(1107, 1)" end="(1107, 8)">
          <OtherNode start="(1107, 1)" end="(1107, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1107, 1)" end="(1107, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1107, 3)" end="(1107, 7)">
              <OtherNode start="(1107, 3)" end="(1107, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1107, 3)" end="(1107, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1107, 3)" end="(1107, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1107, 7)" end="(1107, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1107, 9)" end="(1109, 61)" name="finIdxOf?_eq_some_iff" full_name="List.finIdxOf?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(1107, 9)" end="(1107, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1107, 17)" end="(1107, 38)">
          <IdentNode start="(1107, 17)" end="(1107, 38)" leading="" trailing=" " raw_val="finIdxOf?_eq_some_iff" val="finIdxOf?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1107, 39)" end="(1108, 67)">
          <NullNode start="(1107, 39)" end="(1107, 100)">
            <OtherNode start="(1107, 39)" end="(1107, 46)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1107, 39)" end="(1107, 40)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1107, 40)" end="(1107, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1107, 40)" end="(1107, 43)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1107, 44)" end="(1107, 45)">
                  <IdentNode start="(1107, 44)" end="(1107, 45)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1107, 45)" end="(1107, 46)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1107, 47)" end="(1107, 60)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1107, 47)" end="(1107, 48)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1107, 48)" end="(1107, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1107, 48)" end="(1107, 57)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1107, 58)" end="(1107, 59)">
                  <IdentNode start="(1107, 58)" end="(1107, 59)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1107, 59)" end="(1107, 60)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1107, 61)" end="(1107, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1107, 61)" end="(1107, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(1107, 62)" end="(1107, 63)">
                <IdentNode start="(1107, 62)" end="(1107, 63)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1107, 64)" end="(1107, 72)">
                <AtomNode start="(1107, 64)" end="(1107, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1107, 66)" end="(1107, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1107, 66)" end="(1107, 70)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1107, 71)" end="(1107, 72)">
                    <IdentNode start="(1107, 71)" end="(1107, 72)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1107, 72)" end="(1107, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1107, 74)" end="(1107, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1107, 74)" end="(1107, 75)" leading="" trailing="" val="{"/>
              <NullNode start="(1107, 75)" end="(1107, 76)">
                <IdentNode start="(1107, 75)" end="(1107, 76)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1107, 77)" end="(1107, 80)">
                <AtomNode start="(1107, 77)" end="(1107, 78)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1107, 79)" end="(1107, 80)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1107, 80)" end="(1107, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1107, 82)" end="(1107, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1107, 82)" end="(1107, 83)" leading="" trailing="" val="{"/>
              <NullNode start="(1107, 83)" end="(1107, 84)">
                <IdentNode start="(1107, 83)" end="(1107, 84)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(1107, 85)" end="(1107, 99)">
                <AtomNode start="(1107, 85)" end="(1107, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1107, 87)" end="(1107, 99)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1107, 87)" end="(1107, 90)" leading="" trailing=" " raw_val="Fin" val="Fin" full_name="Fin" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1107, 91)" end="(1107, 99)">
                    <IdentNode start="(1107, 91)" end="(1107, 99)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1107, 99)" end="(1107, 100)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1107, 101)" end="(1108, 67)">
            <AtomNode start="(1107, 101)" end="(1107, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1108, 5)" end="(1108, 67)" kind="«term_↔_»">
              <OtherNode start="(1108, 5)" end="(1108, 27)" kind="«term_=_»">
                <OtherNode start="(1108, 5)" end="(1108, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1108, 5)" end="(1108, 16)" leading="" trailing=" " raw_val="l.finIdxOf?" val="l.finIdxOf?"/>
                  <NullNode start="(1108, 17)" end="(1108, 18)">
                    <IdentNode start="(1108, 17)" end="(1108, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1108, 19)" end="(1108, 20)" leading="" trailing=" " val="="/>
                <OtherNode start="(1108, 21)" end="(1108, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1108, 21)" end="(1108, 25)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1108, 26)" end="(1108, 27)">
                    <IdentNode start="(1108, 26)" end="(1108, 27)" leading="" trailing=" " raw_val="i" val="i"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(1108, 28)" end="(1108, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1108, 30)" end="(1108, 67)" kind="«term_∧_»">
                <OtherNode start="(1108, 30)" end="(1108, 38)" kind="«term_=_»">
                  <OtherNode start="(1108, 30)" end="(1108, 34)" kind="«term__[_]»">
                    <IdentNode start="(1108, 30)" end="(1108, 31)" leading="" trailing="" raw_val="l" val="l"/>
                    <AtomNode start="(1108, 31)" end="(1108, 32)" leading="" trailing="" val="["/>
                    <IdentNode start="(1108, 32)" end="(1108, 33)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(1108, 33)" end="(1108, 34)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <AtomNode start="(1108, 35)" end="(1108, 36)" leading="" trailing=" " val="="/>
                  <IdentNode start="(1108, 37)" end="(1108, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
                <AtomNode start="(1108, 39)" end="(1108, 40)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(1108, 41)" end="(1108, 67)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(1108, 41)" end="(1108, 42)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(1108, 43)" end="(1108, 56)">
                    <IdentNode start="(1108, 43)" end="(1108, 44)" leading="" trailing=" " raw_val="j" val="j"/>
                    <TermExplicitbinderNode start="(1108, 45)" end="(1108, 56)">
                      <AtomNode start="(1108, 45)" end="(1108, 46)" leading="" trailing="" val="("/>
                      <NullNode start="(1108, 46)" end="(1108, 47)">
                        <TermHoleNode start="(1108, 46)" end="(1108, 47)">
                          <AtomNode start="(1108, 46)" end="(1108, 47)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </NullNode>
                      <NullNode start="(1108, 48)" end="(1108, 55)">
                        <AtomNode start="(1108, 48)" end="(1108, 49)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(1108, 50)" end="(1108, 55)" kind="«term_&amp;lt;_»">
                          <IdentNode start="(1108, 50)" end="(1108, 51)" leading="" trailing=" " raw_val="j" val="j"/>
                          <AtomNode start="(1108, 52)" end="(1108, 53)" leading="" trailing=" " val="&amp;lt;"/>
                          <IdentNode start="(1108, 54)" end="(1108, 55)" leading="" trailing="" raw_val="i" val="i"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(1108, 55)" end="(1108, 56)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(1108, 56)" end="(1108, 57)" leading="" trailing=" " val=","/>
                  <OtherNode start="(1108, 58)" end="(1108, 67)" kind="«term¬_»">
                    <AtomNode start="(1108, 58)" end="(1108, 59)" leading="" trailing="" val="¬"/>
                    <OtherNode start="(1108, 59)" end="(1108, 67)" kind="«term_=_»">
                      <OtherNode start="(1108, 59)" end="(1108, 63)" kind="«term__[_]»">
                        <IdentNode start="(1108, 59)" end="(1108, 60)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(1108, 60)" end="(1108, 61)" leading="" trailing="" val="["/>
                        <IdentNode start="(1108, 61)" end="(1108, 62)" leading="" trailing="" raw_val="j" val="j"/>
                        <AtomNode start="(1108, 62)" end="(1108, 63)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <AtomNode start="(1108, 64)" end="(1108, 65)" leading="" trailing=" " val="="/>
                      <IdentNode start="(1108, 66)" end="(1108, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1108, 68)" end="(1109, 61)">
          <AtomNode start="(1108, 68)" end="(1108, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1108, 71)" end="(1109, 61)">
            <AtomNode start="(1108, 71)" end="(1108, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1109, 3)" end="(1109, 61)">
              <TacticTacticseq1IndentedNode start="(1109, 3)" end="(1109, 61)">
                <NullNode start="(1109, 3)" end="(1109, 61)">
                  <OtherNode start="(1109, 3)" end="(1109, 61)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;i : Fin l.length&#10;⊢ finIdxOf? a l = some i ↔ l[i] = a ∧ ∀ (j : Fin l.length), j &amp;lt; i → ¬l[j] = a" state_after="no goals" tactic="simp only [finIdxOf?, findFinIdx?_eq_some_iff, beq_iff_eq]">
                    <AtomNode start="(1109, 3)" end="(1109, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1109, 8)" end="(1109, 12)">
                      <AtomNode start="(1109, 8)" end="(1109, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1109, 13)" end="(1109, 61)">
                      <AtomNode start="(1109, 13)" end="(1109, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1109, 14)" end="(1109, 60)">
                        <OtherNode start="(1109, 14)" end="(1109, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1109, 14)" end="(1109, 23)" leading="" trailing="" raw_val="finIdxOf?" val="finIdxOf?" full_name="List.finIdxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1109, 23)" end="(1109, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1109, 25)" end="(1109, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1109, 25)" end="(1109, 48)" leading="" trailing="" raw_val="findFinIdx?_eq_some_iff" val="findFinIdx?_eq_some_iff" full_name="List.findFinIdx?_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(982, 9)" def_end="(982, 32)"/>
                        </OtherNode>
                        <AtomNode start="(1109, 48)" end="(1109, 49)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1109, 50)" end="(1109, 60)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1109, 50)" end="(1109, 60)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1109, 60)" end="(1109, 61)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1111, 1)" end="(1118, 40)" name="isSome_finIdxOf?" full_name="List.isSome_finIdxOf?">
      <CommandDeclmodifiersNode start="(1111, 1)" end="(1111, 8)">
        <NullNode/>
        <NullNode start="(1111, 1)" end="(1111, 8)">
          <OtherNode start="(1111, 1)" end="(1111, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1111, 1)" end="(1111, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1111, 3)" end="(1111, 7)">
              <OtherNode start="(1111, 3)" end="(1111, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1111, 3)" end="(1111, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1111, 3)" end="(1111, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1111, 7)" end="(1111, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1112, 1)" end="(1118, 40)" name="isSome_finIdxOf?" full_name="List.isSome_finIdxOf?" _is_private_decl="False">
        <AtomNode start="(1112, 1)" end="(1112, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1112, 9)" end="(1112, 25)">
          <IdentNode start="(1112, 9)" end="(1112, 25)" leading="" trailing=" " raw_val="isSome_finIdxOf?" val="isSome_finIdxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1112, 26)" end="(1113, 35)">
          <NullNode start="(1112, 26)" end="(1112, 68)">
            <OtherNode start="(1112, 26)" end="(1112, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1112, 26)" end="(1112, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1112, 27)" end="(1112, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1112, 27)" end="(1112, 30)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1112, 31)" end="(1112, 32)">
                  <IdentNode start="(1112, 31)" end="(1112, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1112, 32)" end="(1112, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1112, 34)" end="(1112, 47)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1112, 34)" end="(1112, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1112, 35)" end="(1112, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1112, 35)" end="(1112, 44)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1112, 45)" end="(1112, 46)">
                  <IdentNode start="(1112, 45)" end="(1112, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1112, 46)" end="(1112, 47)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1112, 48)" end="(1112, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1112, 48)" end="(1112, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(1112, 49)" end="(1112, 50)">
                <IdentNode start="(1112, 49)" end="(1112, 50)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1112, 51)" end="(1112, 59)">
                <AtomNode start="(1112, 51)" end="(1112, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1112, 53)" end="(1112, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1112, 53)" end="(1112, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1112, 58)" end="(1112, 59)">
                    <IdentNode start="(1112, 58)" end="(1112, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1112, 59)" end="(1112, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1112, 61)" end="(1112, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1112, 61)" end="(1112, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(1112, 62)" end="(1112, 63)">
                <IdentNode start="(1112, 62)" end="(1112, 63)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1112, 64)" end="(1112, 67)">
                <AtomNode start="(1112, 64)" end="(1112, 65)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1112, 66)" end="(1112, 67)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1112, 67)" end="(1112, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1112, 69)" end="(1113, 35)">
            <AtomNode start="(1112, 69)" end="(1112, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1113, 5)" end="(1113, 35)" kind="«term_↔_»">
              <OtherNode start="(1113, 5)" end="(1113, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1113, 5)" end="(1113, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1113, 5)" end="(1113, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1113, 6)" end="(1113, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1113, 6)" end="(1113, 17)" leading="" trailing=" " raw_val="l.finIdxOf?" val="l.finIdxOf?"/>
                    <NullNode start="(1113, 18)" end="(1113, 19)">
                      <IdentNode start="(1113, 18)" end="(1113, 19)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1113, 19)" end="(1113, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1113, 20)" end="(1113, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(1113, 21)" end="(1113, 27)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1113, 28)" end="(1113, 29)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1113, 30)" end="(1113, 35)" kind="«term_∈_»">
                <IdentNode start="(1113, 30)" end="(1113, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(1113, 32)" end="(1113, 33)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(1113, 34)" end="(1113, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1113, 36)" end="(1118, 40)">
          <AtomNode start="(1113, 36)" end="(1113, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1113, 39)" end="(1118, 40)">
            <AtomNode start="(1113, 39)" end="(1113, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1114, 3)" end="(1118, 40)">
              <TacticTacticseq1IndentedNode start="(1114, 3)" end="(1118, 40)">
                <NullNode start="(1114, 3)" end="(1118, 40)">
                  <OtherNode start="(1114, 3)" end="(1118, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (finIdxOf? a l).isSome = true ↔ a ∈ l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [finIdxOf?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                    <AtomNode start="(1114, 3)" end="(1114, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1114, 13)" end="(1114, 14)">
                      <OtherNode start="(1114, 13)" end="(1114, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1114, 13)" end="(1114, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1114, 15)" end="(1118, 40)">
                      <OtherNode start="(1114, 15)" end="(1118, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1114, 15)" end="(1114, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1115, 3)" end="(1118, 40)">
                          <OtherNode start="(1115, 3)" end="(1115, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1115, 3)" end="(1115, 8)">
                              <OtherNode start="(1115, 3)" end="(1115, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1115, 3)" end="(1115, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1115, 5)" end="(1115, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1115, 5)" end="(1115, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1115, 9)" end="(1115, 16)">
                              <AtomNode start="(1115, 9)" end="(1115, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1115, 12)" end="(1115, 16)">
                                <TacticTacticseq1IndentedNode start="(1115, 12)" end="(1115, 16)">
                                  <NullNode start="(1115, 12)" end="(1115, 16)">
                                    <OtherNode start="(1115, 12)" end="(1115, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ (finIdxOf? a []).isSome = true ↔ a ∈ []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1115, 12)" end="(1115, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1116, 3)" end="(1118, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1116, 3)" end="(1116, 17)">
                              <OtherNode start="(1116, 3)" end="(1116, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1116, 3)" end="(1116, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1116, 5)" end="(1116, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1116, 5)" end="(1116, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1116, 10)" end="(1116, 17)">
                                  <IdentNode start="(1116, 10)" end="(1116, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1116, 12)" end="(1116, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1116, 15)" end="(1116, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1116, 18)" end="(1118, 40)">
                              <AtomNode start="(1116, 18)" end="(1116, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1117, 5)" end="(1118, 40)">
                                <TacticTacticseq1IndentedNode start="(1117, 5)" end="(1118, 40)">
                                  <NullNode start="(1117, 5)" end="(1118, 40)">
                                    <OtherNode start="(1117, 5)" end="(1117, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : (finIdxOf? a xs).isSome = true ↔ a ∈ xs&#10;⊢ (finIdxOf? a (x :: xs)).isSome = true ↔ a ∈ x :: xs" state_after="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : (finIdxOf? a xs).isSome = true ↔ a ∈ xs&#10;⊢ (if (x == a) = true then some ⟨0, ⋯⟩ else Option.map (fun x =&amp;gt; x.succ) (finIdxOf? a xs)).isSome = true ↔ a ∈ x :: xs" tactic="simp only [finIdxOf?_cons]">
                                      <AtomNode start="(1117, 5)" end="(1117, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1117, 10)" end="(1117, 14)">
                                        <AtomNode start="(1117, 10)" end="(1117, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1117, 15)" end="(1117, 31)">
                                        <AtomNode start="(1117, 15)" end="(1117, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1117, 16)" end="(1117, 30)">
                                          <OtherNode start="(1117, 16)" end="(1117, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1117, 16)" end="(1117, 30)" leading="" trailing="" raw_val="finIdxOf?_cons" val="finIdxOf?_cons" full_name="List.finIdxOf?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1093, 9)" def_end="(1093, 23)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1117, 30)" end="(1117, 31)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1118, 5)" end="(1118, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : (finIdxOf? a xs).isSome = true ↔ a ∈ xs&#10;⊢ (if (x == a) = true then some ⟨0, ⋯⟩ else Option.map (fun x =&amp;gt; x.succ) (finIdxOf? a xs)).isSome = true ↔ a ∈ x :: xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                                      <OtherNode start="(1118, 5)" end="(1118, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1118, 5)" end="(1118, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1118, 11)" end="(1118, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1118, 15)" end="(1118, 40)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1118, 15)" end="(1118, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(1118, 24)" end="(1118, 40)">
                                          <AtomNode start="(1118, 24)" end="(1118, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(1118, 25)" end="(1118, 39)">
                                            <OtherNode start="(1118, 25)" end="(1118, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(1118, 25)" end="(1118, 39)" kind="Lean.Parser.Term.app">
                                                <OtherNode start="(1118, 25)" end="(1118, 33)" kind="Lean.Parser.Term.explicit">
                                                  <AtomNode start="(1118, 25)" end="(1118, 26)" leading="" trailing="" val="@"/>
                                                  <IdentNode start="(1118, 26)" end="(1118, 33)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                </OtherNode>
                                                <NullNode start="(1118, 34)" end="(1118, 39)">
                                                  <TermHoleNode start="(1118, 34)" end="(1118, 35)">
                                                    <AtomNode start="(1118, 34)" end="(1118, 35)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <IdentNode start="(1118, 36)" end="(1118, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                                  <IdentNode start="(1118, 38)" end="(1118, 39)" leading="" trailing="" raw_val="a" val="a"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(1118, 39)" end="(1118, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1120, 1)" end="(1127, 40)" name="isNone_finIdxOf?" full_name="List.isNone_finIdxOf?">
      <CommandDeclmodifiersNode start="(1120, 1)" end="(1120, 8)">
        <NullNode/>
        <NullNode start="(1120, 1)" end="(1120, 8)">
          <OtherNode start="(1120, 1)" end="(1120, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1120, 1)" end="(1120, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1120, 3)" end="(1120, 7)">
              <OtherNode start="(1120, 3)" end="(1120, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1120, 3)" end="(1120, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1120, 3)" end="(1120, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1120, 7)" end="(1120, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1121, 1)" end="(1127, 40)" name="isNone_finIdxOf?" full_name="List.isNone_finIdxOf?" _is_private_decl="False">
        <AtomNode start="(1121, 1)" end="(1121, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1121, 9)" end="(1121, 25)">
          <IdentNode start="(1121, 9)" end="(1121, 25)" leading="" trailing=" " raw_val="isNone_finIdxOf?" val="isNone_finIdxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1121, 26)" end="(1122, 37)">
          <NullNode start="(1121, 26)" end="(1121, 68)">
            <OtherNode start="(1121, 26)" end="(1121, 33)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1121, 26)" end="(1121, 27)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1121, 27)" end="(1121, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1121, 27)" end="(1121, 30)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1121, 31)" end="(1121, 32)">
                  <IdentNode start="(1121, 31)" end="(1121, 32)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1121, 32)" end="(1121, 33)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1121, 34)" end="(1121, 47)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1121, 34)" end="(1121, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1121, 35)" end="(1121, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1121, 35)" end="(1121, 44)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1121, 45)" end="(1121, 46)">
                  <IdentNode start="(1121, 45)" end="(1121, 46)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1121, 46)" end="(1121, 47)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1121, 48)" end="(1121, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1121, 48)" end="(1121, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(1121, 49)" end="(1121, 50)">
                <IdentNode start="(1121, 49)" end="(1121, 50)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1121, 51)" end="(1121, 59)">
                <AtomNode start="(1121, 51)" end="(1121, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1121, 53)" end="(1121, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1121, 53)" end="(1121, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1121, 58)" end="(1121, 59)">
                    <IdentNode start="(1121, 58)" end="(1121, 59)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1121, 59)" end="(1121, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1121, 61)" end="(1121, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1121, 61)" end="(1121, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(1121, 62)" end="(1121, 63)">
                <IdentNode start="(1121, 62)" end="(1121, 63)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1121, 64)" end="(1121, 67)">
                <AtomNode start="(1121, 64)" end="(1121, 65)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1121, 66)" end="(1121, 67)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1121, 67)" end="(1121, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1121, 69)" end="(1122, 37)">
            <AtomNode start="(1121, 69)" end="(1121, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1122, 5)" end="(1122, 37)" kind="«term_=_»">
              <OtherNode start="(1122, 5)" end="(1122, 27)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1122, 5)" end="(1122, 20)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1122, 5)" end="(1122, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1122, 6)" end="(1122, 19)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1122, 6)" end="(1122, 17)" leading="" trailing=" " raw_val="l.finIdxOf?" val="l.finIdxOf?"/>
                    <NullNode start="(1122, 18)" end="(1122, 19)">
                      <IdentNode start="(1122, 18)" end="(1122, 19)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1122, 19)" end="(1122, 20)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1122, 20)" end="(1122, 21)" leading="" trailing="" val="."/>
                <IdentNode start="(1122, 21)" end="(1122, 27)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1122, 28)" end="(1122, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(1122, 30)" end="(1122, 37)" kind="«term¬_»">
                <AtomNode start="(1122, 30)" end="(1122, 31)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(1122, 32)" end="(1122, 37)" kind="«term_∈_»">
                  <IdentNode start="(1122, 32)" end="(1122, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1122, 34)" end="(1122, 35)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(1122, 36)" end="(1122, 37)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1122, 38)" end="(1127, 40)">
          <AtomNode start="(1122, 38)" end="(1122, 40)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1122, 41)" end="(1127, 40)">
            <AtomNode start="(1122, 41)" end="(1122, 43)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1123, 3)" end="(1127, 40)">
              <TacticTacticseq1IndentedNode start="(1123, 3)" end="(1127, 40)">
                <NullNode start="(1123, 3)" end="(1127, 40)">
                  <OtherNode start="(1123, 3)" end="(1127, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ((finIdxOf? a l).isNone = true) = ¬a ∈ l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [finIdxOf?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                    <AtomNode start="(1123, 3)" end="(1123, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1123, 13)" end="(1123, 14)">
                      <OtherNode start="(1123, 13)" end="(1123, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1123, 13)" end="(1123, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1123, 15)" end="(1127, 40)">
                      <OtherNode start="(1123, 15)" end="(1127, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1123, 15)" end="(1123, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1124, 3)" end="(1127, 40)">
                          <OtherNode start="(1124, 3)" end="(1124, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1124, 3)" end="(1124, 8)">
                              <OtherNode start="(1124, 3)" end="(1124, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1124, 3)" end="(1124, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1124, 5)" end="(1124, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1124, 5)" end="(1124, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1124, 9)" end="(1124, 16)">
                              <AtomNode start="(1124, 9)" end="(1124, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1124, 12)" end="(1124, 16)">
                                <TacticTacticseq1IndentedNode start="(1124, 12)" end="(1124, 16)">
                                  <NullNode start="(1124, 12)" end="(1124, 16)">
                                    <OtherNode start="(1124, 12)" end="(1124, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ ((finIdxOf? a []).isNone = true) = ¬a ∈ []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1124, 12)" end="(1124, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1125, 3)" end="(1127, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1125, 3)" end="(1125, 17)">
                              <OtherNode start="(1125, 3)" end="(1125, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1125, 3)" end="(1125, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1125, 5)" end="(1125, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1125, 5)" end="(1125, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1125, 10)" end="(1125, 17)">
                                  <IdentNode start="(1125, 10)" end="(1125, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1125, 12)" end="(1125, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1125, 15)" end="(1125, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1125, 18)" end="(1127, 40)">
                              <AtomNode start="(1125, 18)" end="(1125, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1126, 5)" end="(1127, 40)">
                                <TacticTacticseq1IndentedNode start="(1126, 5)" end="(1127, 40)">
                                  <NullNode start="(1126, 5)" end="(1127, 40)">
                                    <OtherNode start="(1126, 5)" end="(1126, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : ((finIdxOf? a xs).isNone = true) = ¬a ∈ xs&#10;⊢ ((finIdxOf? a (x :: xs)).isNone = true) = ¬a ∈ x :: xs" state_after="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : ((finIdxOf? a xs).isNone = true) = ¬a ∈ xs&#10;⊢ ((if (x == a) = true then some ⟨0, ⋯⟩ else Option.map (fun x =&amp;gt; x.succ) (finIdxOf? a xs)).isNone = true) =&#10;    ¬a ∈ x :: xs" tactic="simp only [finIdxOf?_cons]">
                                      <AtomNode start="(1126, 5)" end="(1126, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1126, 10)" end="(1126, 14)">
                                        <AtomNode start="(1126, 10)" end="(1126, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1126, 15)" end="(1126, 31)">
                                        <AtomNode start="(1126, 15)" end="(1126, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1126, 16)" end="(1126, 30)">
                                          <OtherNode start="(1126, 16)" end="(1126, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1126, 16)" end="(1126, 30)" leading="" trailing="" raw_val="finIdxOf?_cons" val="finIdxOf?_cons" full_name="List.finIdxOf?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1093, 9)" def_end="(1093, 23)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1126, 30)" end="(1126, 31)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1127, 5)" end="(1127, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : ((finIdxOf? a xs).isNone = true) = ¬a ∈ xs&#10;⊢ ((if (x == a) = true then some ⟨0, ⋯⟩ else Option.map (fun x =&amp;gt; x.succ) (finIdxOf? a xs)).isNone = true) =&#10;    ¬a ∈ x :: xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                                      <OtherNode start="(1127, 5)" end="(1127, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1127, 5)" end="(1127, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1127, 11)" end="(1127, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1127, 15)" end="(1127, 40)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1127, 15)" end="(1127, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(1127, 24)" end="(1127, 40)">
                                          <AtomNode start="(1127, 24)" end="(1127, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(1127, 25)" end="(1127, 39)">
                                            <OtherNode start="(1127, 25)" end="(1127, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(1127, 25)" end="(1127, 39)" kind="Lean.Parser.Term.app">
                                                <OtherNode start="(1127, 25)" end="(1127, 33)" kind="Lean.Parser.Term.explicit">
                                                  <AtomNode start="(1127, 25)" end="(1127, 26)" leading="" trailing="" val="@"/>
                                                  <IdentNode start="(1127, 26)" end="(1127, 33)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                </OtherNode>
                                                <NullNode start="(1127, 34)" end="(1127, 39)">
                                                  <TermHoleNode start="(1127, 34)" end="(1127, 35)">
                                                    <AtomNode start="(1127, 34)" end="(1127, 35)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <IdentNode start="(1127, 36)" end="(1127, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                                  <IdentNode start="(1127, 38)" end="(1127, 39)" leading="" trailing="" raw_val="a" val="a"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(1127, 39)" end="(1127, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(1129, 1)" end="(1133, 3)" comment="### idxOf?&#10;&#10;The verification API for `idxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx?` (and proved using them).&#10;-/">
      <AtomNode start="(1129, 1)" end="(1129, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(1129, 5)" end="(1133, 3)" leading="" trailing="&#10;&#10;" val="### idxOf?&#10;&#10;The verification API for `idxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx?` (and proved using them).&#10;-/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(1135, 1)" end="(1135, 74)" name="idxOf?_nil" full_name="List.idxOf?_nil">
      <CommandDeclmodifiersNode start="(1135, 1)" end="(1135, 8)">
        <NullNode/>
        <NullNode start="(1135, 1)" end="(1135, 8)">
          <OtherNode start="(1135, 1)" end="(1135, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1135, 1)" end="(1135, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1135, 3)" end="(1135, 7)">
              <OtherNode start="(1135, 3)" end="(1135, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1135, 3)" end="(1135, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1135, 3)" end="(1135, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1135, 7)" end="(1135, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1135, 9)" end="(1135, 74)" name="idxOf?_nil" full_name="List.idxOf?_nil" _is_private_decl="False">
        <AtomNode start="(1135, 9)" end="(1135, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1135, 17)" end="(1135, 27)">
          <IdentNode start="(1135, 17)" end="(1135, 27)" leading="" trailing=" " raw_val="idxOf?_nil" val="idxOf?_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1135, 28)" end="(1135, 67)">
          <NullNode start="(1135, 28)" end="(1135, 35)">
            <OtherNode start="(1135, 28)" end="(1135, 35)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1135, 28)" end="(1135, 29)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1135, 29)" end="(1135, 34)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1135, 29)" end="(1135, 32)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1135, 33)" end="(1135, 34)">
                  <IdentNode start="(1135, 33)" end="(1135, 34)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1135, 34)" end="(1135, 35)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1135, 36)" end="(1135, 67)">
            <AtomNode start="(1135, 36)" end="(1135, 37)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1135, 38)" end="(1135, 67)" kind="«term_=_»">
              <OtherNode start="(1135, 38)" end="(1135, 60)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1135, 38)" end="(1135, 58)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1135, 38)" end="(1135, 51)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(1135, 38)" end="(1135, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(1135, 39)" end="(1135, 41)" kind="«term[_]»">
                      <AtomNode start="(1135, 39)" end="(1135, 40)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(1135, 40)" end="(1135, 41)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(1135, 42)" end="(1135, 43)" leading="" trailing=" " val=":"/>
                    <NullNode start="(1135, 44)" end="(1135, 50)">
                      <OtherNode start="(1135, 44)" end="(1135, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(1135, 44)" end="(1135, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(1135, 49)" end="(1135, 50)">
                          <IdentNode start="(1135, 49)" end="(1135, 50)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(1135, 50)" end="(1135, 51)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1135, 51)" end="(1135, 52)" leading="" trailing="" val="."/>
                  <IdentNode start="(1135, 52)" end="(1135, 58)" leading="" trailing=" " raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1135, 59)" end="(1135, 60)">
                  <IdentNode start="(1135, 59)" end="(1135, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1135, 61)" end="(1135, 62)" leading="" trailing=" " val="="/>
              <IdentNode start="(1135, 63)" end="(1135, 67)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1135, 68)" end="(1135, 74)">
          <AtomNode start="(1135, 68)" end="(1135, 70)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1135, 71)" end="(1135, 74)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1137, 1)" end="(1139, 31)" name="idxOf?_cons" full_name="List.idxOf?_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1137, 1)" end="(1139, 31)" name="idxOf?_cons" full_name="List.idxOf?_cons" _is_private_decl="False">
        <AtomNode start="(1137, 1)" end="(1137, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1137, 9)" end="(1137, 20)">
          <IdentNode start="(1137, 9)" end="(1137, 20)" leading="" trailing=" " raw_val="idxOf?_cons" val="idxOf?_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1137, 21)" end="(1138, 78)">
          <NullNode start="(1137, 21)" end="(1137, 58)">
            <OtherNode start="(1137, 21)" end="(1137, 28)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1137, 21)" end="(1137, 22)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1137, 22)" end="(1137, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1137, 22)" end="(1137, 25)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1137, 26)" end="(1137, 27)">
                  <IdentNode start="(1137, 26)" end="(1137, 27)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1137, 27)" end="(1137, 28)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1137, 29)" end="(1137, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1137, 29)" end="(1137, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(1137, 30)" end="(1137, 31)">
                <IdentNode start="(1137, 30)" end="(1137, 31)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1137, 32)" end="(1137, 35)">
                <AtomNode start="(1137, 32)" end="(1137, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1137, 34)" end="(1137, 35)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1137, 35)" end="(1137, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1137, 37)" end="(1137, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1137, 37)" end="(1137, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(1137, 38)" end="(1137, 40)">
                <IdentNode start="(1137, 38)" end="(1137, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(1137, 41)" end="(1137, 49)">
                <AtomNode start="(1137, 41)" end="(1137, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1137, 43)" end="(1137, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1137, 43)" end="(1137, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1137, 48)" end="(1137, 49)">
                    <IdentNode start="(1137, 48)" end="(1137, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1137, 49)" end="(1137, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1137, 51)" end="(1137, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1137, 51)" end="(1137, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(1137, 52)" end="(1137, 53)">
                <IdentNode start="(1137, 52)" end="(1137, 53)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(1137, 54)" end="(1137, 57)">
                <AtomNode start="(1137, 54)" end="(1137, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1137, 56)" end="(1137, 57)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1137, 57)" end="(1137, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1137, 59)" end="(1138, 78)">
            <AtomNode start="(1137, 59)" end="(1137, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1138, 5)" end="(1138, 78)" kind="«term_=_»">
              <OtherNode start="(1138, 5)" end="(1138, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1138, 5)" end="(1138, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1138, 5)" end="(1138, 14)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1138, 5)" end="(1138, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1138, 6)" end="(1138, 13)" kind="«term_::_»">
                      <IdentNode start="(1138, 6)" end="(1138, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(1138, 8)" end="(1138, 10)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(1138, 11)" end="(1138, 13)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(1138, 13)" end="(1138, 14)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1138, 14)" end="(1138, 15)" leading="" trailing="" val="."/>
                  <IdentNode start="(1138, 15)" end="(1138, 21)" leading="" trailing=" " raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1138, 22)" end="(1138, 23)">
                  <IdentNode start="(1138, 22)" end="(1138, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1138, 24)" end="(1138, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(1138, 26)" end="(1138, 78)" kind="termIfThenElse">
                <AtomNode start="(1138, 26)" end="(1138, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1138, 29)" end="(1138, 35)" kind="«term_==_»">
                  <IdentNode start="(1138, 29)" end="(1138, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1138, 31)" end="(1138, 33)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(1138, 34)" end="(1138, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(1138, 36)" end="(1138, 40)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1138, 41)" end="(1138, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1138, 41)" end="(1138, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1138, 46)" end="(1138, 47)">
                    <OtherNode start="(1138, 46)" end="(1138, 47)" kind="num">
                      <AtomNode start="(1138, 46)" end="(1138, 47)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1138, 48)" end="(1138, 52)" leading="" trailing=" " val="else"/>
                <OtherNode start="(1138, 53)" end="(1138, 78)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(1138, 53)" end="(1138, 70)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(1138, 53)" end="(1138, 66)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1138, 53)" end="(1138, 54)" leading="" trailing="" val="("/>
                      <OtherNode start="(1138, 54)" end="(1138, 65)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(1138, 54)" end="(1138, 63)" leading="" trailing=" " raw_val="xs.idxOf?" val="xs.idxOf?"/>
                        <NullNode start="(1138, 64)" end="(1138, 65)">
                          <IdentNode start="(1138, 64)" end="(1138, 65)" leading="" trailing="" raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(1138, 65)" end="(1138, 66)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(1138, 66)" end="(1138, 67)" leading="" trailing="" val="."/>
                    <IdentNode start="(1138, 67)" end="(1138, 70)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                  <NullNode start="(1138, 71)" end="(1138, 78)">
                    <OtherNode start="(1138, 71)" end="(1138, 78)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1138, 71)" end="(1138, 72)" leading="" trailing="" val="("/>
                      <OtherNode start="(1138, 72)" end="(1138, 77)" kind="«term_+_»">
                        <OtherNode start="(1138, 72)" end="(1138, 73)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(1138, 72)" end="(1138, 73)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                        <AtomNode start="(1138, 74)" end="(1138, 75)" leading="" trailing=" " val="+"/>
                        <OtherNode start="(1138, 76)" end="(1138, 77)" kind="num">
                          <AtomNode start="(1138, 76)" end="(1138, 77)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(1138, 77)" end="(1138, 78)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1138, 79)" end="(1139, 31)">
          <AtomNode start="(1138, 79)" end="(1138, 81)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1138, 82)" end="(1139, 31)">
            <AtomNode start="(1138, 82)" end="(1138, 84)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1139, 3)" end="(1139, 31)">
              <TacticTacticseq1IndentedNode start="(1139, 3)" end="(1139, 31)">
                <NullNode start="(1139, 3)" end="(1139, 31)">
                  <OtherNode start="(1139, 3)" end="(1139, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a : α&#10;xs : List α&#10;b : α&#10;⊢ idxOf? b (a :: xs) = if (a == b) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? b xs)" state_after="no goals" tactic="simp [idxOf?, findIdx?_cons]">
                    <AtomNode start="(1139, 3)" end="(1139, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1139, 8)" end="(1139, 31)">
                      <AtomNode start="(1139, 8)" end="(1139, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1139, 9)" end="(1139, 30)">
                        <OtherNode start="(1139, 9)" end="(1139, 15)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1139, 9)" end="(1139, 15)" leading="" trailing="" raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1139, 15)" end="(1139, 16)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1139, 17)" end="(1139, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1139, 17)" end="(1139, 30)" leading="" trailing="" raw_val="findIdx?_cons" val="findIdx?_cons" full_name="List.findIdx?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(498, 9)" def_end="(498, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1139, 30)" end="(1139, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1141, 1)" end="(1142, 33)" name="idxOf?_singleton" full_name="List.idxOf?_singleton">
      <CommandDeclmodifiersNode start="(1141, 1)" end="(1141, 8)">
        <NullNode/>
        <NullNode start="(1141, 1)" end="(1141, 8)">
          <OtherNode start="(1141, 1)" end="(1141, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1141, 1)" end="(1141, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1141, 3)" end="(1141, 7)">
              <OtherNode start="(1141, 3)" end="(1141, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1141, 3)" end="(1141, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1141, 3)" end="(1141, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1141, 7)" end="(1141, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1141, 9)" end="(1142, 33)" name="idxOf?_singleton" full_name="List.idxOf?_singleton" _is_private_decl="False">
        <AtomNode start="(1141, 9)" end="(1141, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1141, 17)" end="(1141, 33)">
          <IdentNode start="(1141, 17)" end="(1141, 33)" leading="" trailing=" " raw_val="idxOf?_singleton" val="idxOf?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1141, 34)" end="(1141, 100)">
          <NullNode start="(1141, 34)" end="(1141, 51)">
            <OtherNode start="(1141, 34)" end="(1141, 41)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1141, 34)" end="(1141, 35)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1141, 35)" end="(1141, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1141, 35)" end="(1141, 38)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1141, 39)" end="(1141, 40)">
                  <IdentNode start="(1141, 39)" end="(1141, 40)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1141, 40)" end="(1141, 41)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1141, 42)" end="(1141, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1141, 42)" end="(1141, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(1141, 43)" end="(1141, 46)">
                <IdentNode start="(1141, 43)" end="(1141, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(1141, 45)" end="(1141, 46)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(1141, 47)" end="(1141, 50)">
                <AtomNode start="(1141, 47)" end="(1141, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1141, 49)" end="(1141, 50)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1141, 50)" end="(1141, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1141, 52)" end="(1141, 100)">
            <AtomNode start="(1141, 52)" end="(1141, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1141, 54)" end="(1141, 100)" kind="«term_=_»">
              <OtherNode start="(1141, 54)" end="(1141, 66)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1141, 54)" end="(1141, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1141, 54)" end="(1141, 57)" kind="«term[_]»">
                    <AtomNode start="(1141, 54)" end="(1141, 55)" leading="" trailing="" val="["/>
                    <NullNode start="(1141, 55)" end="(1141, 56)">
                      <IdentNode start="(1141, 55)" end="(1141, 56)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(1141, 56)" end="(1141, 57)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(1141, 57)" end="(1141, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(1141, 58)" end="(1141, 64)" leading="" trailing=" " raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1141, 65)" end="(1141, 66)">
                  <IdentNode start="(1141, 65)" end="(1141, 66)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1141, 67)" end="(1141, 68)" leading="" trailing=" " val="="/>
              <OtherNode start="(1141, 69)" end="(1141, 100)" kind="termIfThenElse">
                <AtomNode start="(1141, 69)" end="(1141, 71)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1141, 72)" end="(1141, 78)" kind="«term_==_»">
                  <IdentNode start="(1141, 72)" end="(1141, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1141, 74)" end="(1141, 76)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(1141, 77)" end="(1141, 78)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(1141, 79)" end="(1141, 83)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1141, 84)" end="(1141, 90)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1141, 84)" end="(1141, 88)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1141, 89)" end="(1141, 90)">
                    <OtherNode start="(1141, 89)" end="(1141, 90)" kind="num">
                      <AtomNode start="(1141, 89)" end="(1141, 90)" leading="" trailing=" " val="0"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1141, 91)" end="(1141, 95)" leading="" trailing=" " val="else"/>
                <IdentNode start="(1141, 96)" end="(1141, 100)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1141, 101)" end="(1142, 33)">
          <AtomNode start="(1141, 101)" end="(1141, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1141, 104)" end="(1142, 33)">
            <AtomNode start="(1141, 104)" end="(1141, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1142, 3)" end="(1142, 33)">
              <TacticTacticseq1IndentedNode start="(1142, 3)" end="(1142, 33)">
                <NullNode start="(1142, 3)" end="(1142, 33)">
                  <OtherNode start="(1142, 3)" end="(1142, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝ : BEq α&#10;a b : α&#10;⊢ idxOf? b [a] = if (a == b) = true then some 0 else none" state_after="no goals" tactic="simp [idxOf?_cons, idxOf?_nil]">
                    <AtomNode start="(1142, 3)" end="(1142, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1142, 8)" end="(1142, 33)">
                      <AtomNode start="(1142, 8)" end="(1142, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1142, 9)" end="(1142, 32)">
                        <OtherNode start="(1142, 9)" end="(1142, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1142, 9)" end="(1142, 20)" leading="" trailing="" raw_val="idxOf?_cons" val="idxOf?_cons" full_name="List.idxOf?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1137, 9)" def_end="(1137, 20)"/>
                        </OtherNode>
                        <AtomNode start="(1142, 20)" end="(1142, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1142, 22)" end="(1142, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1142, 22)" end="(1142, 32)" leading="" trailing="" raw_val="idxOf?_nil" val="idxOf?_nil" full_name="List.idxOf?_nil" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1135, 17)" def_end="(1135, 27)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1142, 32)" end="(1142, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1144, 1)" end="(1152, 18)" name="idxOf?_eq_none_iff" full_name="List.idxOf?_eq_none_iff">
      <CommandDeclmodifiersNode start="(1144, 1)" end="(1144, 8)">
        <NullNode/>
        <NullNode start="(1144, 1)" end="(1144, 8)">
          <OtherNode start="(1144, 1)" end="(1144, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1144, 1)" end="(1144, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1144, 3)" end="(1144, 7)">
              <OtherNode start="(1144, 3)" end="(1144, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1144, 3)" end="(1144, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1144, 3)" end="(1144, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1144, 7)" end="(1144, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1144, 9)" end="(1152, 18)" name="idxOf?_eq_none_iff" full_name="List.idxOf?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(1144, 9)" end="(1144, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1144, 17)" end="(1144, 35)">
          <IdentNode start="(1144, 17)" end="(1144, 35)" leading="" trailing=" " raw_val="idxOf?_eq_none_iff" val="idxOf?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1144, 36)" end="(1145, 30)">
          <NullNode start="(1144, 36)" end="(1144, 78)">
            <OtherNode start="(1144, 36)" end="(1144, 43)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1144, 36)" end="(1144, 37)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1144, 37)" end="(1144, 42)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1144, 37)" end="(1144, 40)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1144, 41)" end="(1144, 42)">
                  <IdentNode start="(1144, 41)" end="(1144, 42)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1144, 42)" end="(1144, 43)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1144, 44)" end="(1144, 57)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1144, 44)" end="(1144, 45)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1144, 45)" end="(1144, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1144, 45)" end="(1144, 54)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1144, 55)" end="(1144, 56)">
                  <IdentNode start="(1144, 55)" end="(1144, 56)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1144, 56)" end="(1144, 57)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1144, 58)" end="(1144, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1144, 58)" end="(1144, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(1144, 59)" end="(1144, 60)">
                <IdentNode start="(1144, 59)" end="(1144, 60)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1144, 61)" end="(1144, 69)">
                <AtomNode start="(1144, 61)" end="(1144, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1144, 63)" end="(1144, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1144, 63)" end="(1144, 67)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1144, 68)" end="(1144, 69)">
                    <IdentNode start="(1144, 68)" end="(1144, 69)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1144, 69)" end="(1144, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1144, 71)" end="(1144, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1144, 71)" end="(1144, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(1144, 72)" end="(1144, 73)">
                <IdentNode start="(1144, 72)" end="(1144, 73)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1144, 74)" end="(1144, 77)">
                <AtomNode start="(1144, 74)" end="(1144, 75)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1144, 76)" end="(1144, 77)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1144, 77)" end="(1144, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1144, 79)" end="(1145, 30)">
            <AtomNode start="(1144, 79)" end="(1144, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1145, 5)" end="(1145, 30)" kind="«term_↔_»">
              <OtherNode start="(1145, 5)" end="(1145, 22)" kind="«term_=_»">
                <OtherNode start="(1145, 5)" end="(1145, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1145, 5)" end="(1145, 13)" leading="" trailing=" " raw_val="l.idxOf?" val="l.idxOf?"/>
                  <NullNode start="(1145, 14)" end="(1145, 15)">
                    <IdentNode start="(1145, 14)" end="(1145, 15)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1145, 16)" end="(1145, 17)" leading="" trailing=" " val="="/>
                <IdentNode start="(1145, 18)" end="(1145, 22)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1145, 23)" end="(1145, 24)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1145, 25)" end="(1145, 30)" kind="«term_∉_»">
                <IdentNode start="(1145, 25)" end="(1145, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(1145, 27)" end="(1145, 28)" leading="" trailing=" " val="∉"/>
                <IdentNode start="(1145, 29)" end="(1145, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1145, 31)" end="(1152, 18)">
          <AtomNode start="(1145, 31)" end="(1145, 33)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1145, 34)" end="(1152, 18)">
            <AtomNode start="(1145, 34)" end="(1145, 36)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1146, 3)" end="(1152, 18)">
              <TacticTacticseq1IndentedNode start="(1146, 3)" end="(1152, 18)">
                <NullNode start="(1146, 3)" end="(1152, 18)">
                  <OtherNode start="(1146, 3)" end="(1146, 71)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ idxOf? a l = none ↔ ¬a ∈ l" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) ↔ ¬a ∈ l" tactic="simp only [idxOf?, findIdx?_eq_none_iff, beq_eq_false_iff_ne, ne_eq]">
                    <AtomNode start="(1146, 3)" end="(1146, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1146, 8)" end="(1146, 12)">
                      <AtomNode start="(1146, 8)" end="(1146, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1146, 13)" end="(1146, 71)">
                      <AtomNode start="(1146, 13)" end="(1146, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1146, 14)" end="(1146, 70)">
                        <OtherNode start="(1146, 14)" end="(1146, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1146, 14)" end="(1146, 20)" leading="" trailing="" raw_val="idxOf?" val="idxOf?" full_name="List.idxOf?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1146, 20)" end="(1146, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1146, 22)" end="(1146, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1146, 22)" end="(1146, 42)" leading="" trailing="" raw_val="findIdx?_eq_none_iff" val="findIdx?_eq_none_iff" full_name="List.findIdx?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(686, 9)" def_end="(686, 29)"/>
                        </OtherNode>
                        <AtomNode start="(1146, 42)" end="(1146, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1146, 44)" end="(1146, 63)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1146, 44)" end="(1146, 63)" leading="" trailing="" raw_val="beq_eq_false_iff_ne" val="beq_eq_false_iff_ne" full_name="beq_eq_false_iff_ne" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(1146, 63)" end="(1146, 64)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1146, 65)" end="(1146, 70)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1146, 65)" end="(1146, 70)" leading="" trailing="" raw_val="ne_eq" val="ne_eq" full_name="ne_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1146, 70)" end="(1146, 71)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1147, 3)" end="(1147, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) ↔ ¬a ∈ l" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) → ¬a ∈ l&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" tactic="constructor">
                    <AtomNode start="(1147, 3)" end="(1147, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1148, 3)" end="(1150, 14)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) → ¬a ∈ l&#10;&#10;case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" state_after="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" tactic="· intro w h&#10;  specialize w _ h&#10;  simp at w">
                    <OtherNode start="(1148, 3)" end="(1148, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1148, 3)" end="(1148, 4)" kind="patternIgnore">
                        <OtherNode start="(1148, 3)" end="(1148, 4)" kind="token.«· »">
                          <AtomNode start="(1148, 3)" end="(1148, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1148, 5)" end="(1150, 14)">
                      <TacticTacticseq1IndentedNode start="(1148, 5)" end="(1150, 14)">
                        <NullNode start="(1148, 5)" end="(1150, 14)">
                          <OtherNode start="(1148, 5)" end="(1148, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (∀ (x : α), x ∈ l → ¬x = a) → ¬a ∈ l" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;w : ∀ (x : α), x ∈ l → ¬x = a&#10;h : a ∈ l&#10;⊢ False" tactic="intro w h">
                            <AtomNode start="(1148, 5)" end="(1148, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(1148, 11)" end="(1148, 14)">
                              <IdentNode start="(1148, 11)" end="(1148, 12)" leading="" trailing=" " raw_val="w" val="w"/>
                              <IdentNode start="(1148, 13)" end="(1148, 14)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1149, 5)" end="(1149, 21)" kind="Lean.Parser.Tactic.specialize" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;w : ∀ (x : α), x ∈ l → ¬x = a&#10;h : a ∈ l&#10;⊢ False" state_after="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;w : ¬a = a&#10;⊢ False" tactic="specialize w _ h">
                            <AtomNode start="(1149, 5)" end="(1149, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(1149, 16)" end="(1149, 21)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(1149, 16)" end="(1149, 17)" leading="" trailing=" " raw_val="w" val="w"/>
                              <NullNode start="(1149, 18)" end="(1149, 21)">
                                <TermHoleNode start="(1149, 18)" end="(1149, 19)">
                                  <AtomNode start="(1149, 18)" end="(1149, 19)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <IdentNode start="(1149, 20)" end="(1149, 21)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1150, 5)" end="(1150, 14)" kind="Lean.Parser.Tactic.simp" state_before="case mp&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;h : a ∈ l&#10;w : ¬a = a&#10;⊢ False" state_after="no goals" tactic="simp at w">
                            <AtomNode start="(1150, 5)" end="(1150, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(1150, 10)" end="(1150, 14)">
                              <OtherNode start="(1150, 10)" end="(1150, 14)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(1150, 10)" end="(1150, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(1150, 13)" end="(1150, 14)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(1150, 13)" end="(1150, 14)">
                                    <IdentNode start="(1150, 13)" end="(1150, 14)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1151, 3)" end="(1152, 18)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" state_after="no goals" tactic="· rintro w x h rfl&#10;  contradiction">
                    <OtherNode start="(1151, 3)" end="(1151, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1151, 3)" end="(1151, 4)" kind="patternIgnore">
                        <OtherNode start="(1151, 3)" end="(1151, 4)" kind="token.«· »">
                          <AtomNode start="(1151, 3)" end="(1151, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1151, 5)" end="(1152, 18)">
                      <TacticTacticseq1IndentedNode start="(1151, 5)" end="(1152, 18)">
                        <NullNode start="(1151, 5)" end="(1152, 18)">
                          <OtherNode start="(1151, 5)" end="(1151, 21)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ¬a ∈ l → ∀ (x : α), x ∈ l → ¬x = a" state_after="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;x : α&#10;h : x ∈ l&#10;w : ¬x ∈ l&#10;⊢ False" tactic="rintro w x h rfl">
                            <AtomNode start="(1151, 5)" end="(1151, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(1151, 12)" end="(1151, 21)">
                              <OtherNode start="(1151, 12)" end="(1151, 13)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1151, 12)" end="(1151, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1151, 12)" end="(1151, 13)" leading="" trailing=" " raw_val="w" val="w"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(1151, 14)" end="(1151, 15)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1151, 14)" end="(1151, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1151, 14)" end="(1151, 15)" leading="" trailing=" " raw_val="x" val="x"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(1151, 16)" end="(1151, 17)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1151, 16)" end="(1151, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1151, 16)" end="(1151, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(1151, 18)" end="(1151, 21)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1151, 18)" end="(1151, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                  <IdentNode start="(1151, 18)" end="(1151, 21)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1152, 5)" end="(1152, 18)" kind="Lean.Parser.Tactic.contradiction" state_before="case mpr&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;x : α&#10;h : x ∈ l&#10;w : ¬x ∈ l&#10;⊢ False" state_after="no goals" tactic="contradiction">
                            <AtomNode start="(1152, 5)" end="(1152, 18)" leading="" trailing="&#10;&#10;" val="contradiction"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1154, 1)" end="(1155, 51)" name="indexOf?_eq_none_iff" full_name="List.indexOf?_eq_none_iff">
      <CommandDeclmodifiersNode start="(1154, 1)" end="(1154, 57)">
        <NullNode/>
        <NullNode start="(1154, 1)" end="(1154, 57)">
          <OtherNode start="(1154, 1)" end="(1154, 57)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1154, 1)" end="(1154, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1154, 3)" end="(1154, 56)">
              <OtherNode start="(1154, 3)" end="(1154, 56)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1154, 3)" end="(1154, 56)" kind="Lean.deprecated">
                  <AtomNode start="(1154, 3)" end="(1154, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1154, 14)" end="(1154, 32)">
                    <IdentNode start="(1154, 14)" end="(1154, 32)" leading="" trailing=" " raw_val="idxOf?_eq_none_iff" val="idxOf?_eq_none_iff" full_name="List.idxOf?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1144, 17)" def_end="(1144, 35)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1154, 33)" end="(1154, 56)">
                    <AtomNode start="(1154, 33)" end="(1154, 34)" leading="" trailing="" val="("/>
                    <AtomNode start="(1154, 34)" end="(1154, 39)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1154, 40)" end="(1154, 42)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1154, 43)" end="(1154, 55)" kind="str">
                      <AtomNode start="(1154, 43)" end="(1154, 55)" leading="" trailing="" val="&amp;quot;2025-01-29&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1154, 55)" end="(1154, 56)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1154, 56)" end="(1154, 57)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1155, 1)" end="(1155, 51)" name="indexOf?_eq_none_iff">
        <AtomNode start="(1155, 1)" end="(1155, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1155, 8)" end="(1155, 28)">
          <IdentNode start="(1155, 8)" end="(1155, 28)" leading="" trailing=" " raw_val="indexOf?_eq_none_iff" val="indexOf?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1155, 29)" end="(1155, 51)">
          <AtomNode start="(1155, 29)" end="(1155, 31)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1155, 32)" end="(1155, 51)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1155, 32)" end="(1155, 33)" leading="" trailing="" val="@"/>
            <IdentNode start="(1155, 33)" end="(1155, 51)" leading="" trailing="&#10;&#10;" raw_val="idxOf?_eq_none_iff" val="idxOf?_eq_none_iff" full_name="List.idxOf?_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1144, 17)" def_end="(1144, 35)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1157, 1)" end="(1164, 40)" name="isSome_idxOf?" full_name="List.isSome_idxOf?">
      <CommandDeclmodifiersNode start="(1157, 1)" end="(1157, 8)">
        <NullNode/>
        <NullNode start="(1157, 1)" end="(1157, 8)">
          <OtherNode start="(1157, 1)" end="(1157, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1157, 1)" end="(1157, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1157, 3)" end="(1157, 7)">
              <OtherNode start="(1157, 3)" end="(1157, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1157, 3)" end="(1157, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1157, 3)" end="(1157, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1157, 7)" end="(1157, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1158, 1)" end="(1164, 40)" name="isSome_idxOf?" full_name="List.isSome_idxOf?" _is_private_decl="False">
        <AtomNode start="(1158, 1)" end="(1158, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1158, 9)" end="(1158, 22)">
          <IdentNode start="(1158, 9)" end="(1158, 22)" leading="" trailing=" " raw_val="isSome_idxOf?" val="isSome_idxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1158, 23)" end="(1159, 32)">
          <NullNode start="(1158, 23)" end="(1158, 65)">
            <OtherNode start="(1158, 23)" end="(1158, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1158, 23)" end="(1158, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1158, 24)" end="(1158, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1158, 24)" end="(1158, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1158, 28)" end="(1158, 29)">
                  <IdentNode start="(1158, 28)" end="(1158, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1158, 29)" end="(1158, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1158, 31)" end="(1158, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1158, 31)" end="(1158, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1158, 32)" end="(1158, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1158, 32)" end="(1158, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1158, 42)" end="(1158, 43)">
                  <IdentNode start="(1158, 42)" end="(1158, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1158, 43)" end="(1158, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1158, 45)" end="(1158, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1158, 45)" end="(1158, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(1158, 46)" end="(1158, 47)">
                <IdentNode start="(1158, 46)" end="(1158, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1158, 48)" end="(1158, 56)">
                <AtomNode start="(1158, 48)" end="(1158, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1158, 50)" end="(1158, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1158, 50)" end="(1158, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1158, 55)" end="(1158, 56)">
                    <IdentNode start="(1158, 55)" end="(1158, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1158, 56)" end="(1158, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1158, 58)" end="(1158, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1158, 58)" end="(1158, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(1158, 59)" end="(1158, 60)">
                <IdentNode start="(1158, 59)" end="(1158, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1158, 61)" end="(1158, 64)">
                <AtomNode start="(1158, 61)" end="(1158, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1158, 63)" end="(1158, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1158, 64)" end="(1158, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1158, 66)" end="(1159, 32)">
            <AtomNode start="(1158, 66)" end="(1158, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1159, 5)" end="(1159, 32)" kind="«term_↔_»">
              <OtherNode start="(1159, 5)" end="(1159, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1159, 5)" end="(1159, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1159, 5)" end="(1159, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1159, 6)" end="(1159, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1159, 6)" end="(1159, 14)" leading="" trailing=" " raw_val="l.idxOf?" val="l.idxOf?"/>
                    <NullNode start="(1159, 15)" end="(1159, 16)">
                      <IdentNode start="(1159, 15)" end="(1159, 16)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1159, 16)" end="(1159, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1159, 17)" end="(1159, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(1159, 18)" end="(1159, 24)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1159, 25)" end="(1159, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1159, 27)" end="(1159, 32)" kind="«term_∈_»">
                <IdentNode start="(1159, 27)" end="(1159, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(1159, 29)" end="(1159, 30)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(1159, 31)" end="(1159, 32)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1159, 33)" end="(1164, 40)">
          <AtomNode start="(1159, 33)" end="(1159, 35)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1159, 36)" end="(1164, 40)">
            <AtomNode start="(1159, 36)" end="(1159, 38)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1160, 3)" end="(1164, 40)">
              <TacticTacticseq1IndentedNode start="(1160, 3)" end="(1164, 40)">
                <NullNode start="(1160, 3)" end="(1164, 40)">
                  <OtherNode start="(1160, 3)" end="(1164, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ (idxOf? a l).isSome = true ↔ a ∈ l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [idxOf?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                    <AtomNode start="(1160, 3)" end="(1160, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1160, 13)" end="(1160, 14)">
                      <OtherNode start="(1160, 13)" end="(1160, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1160, 13)" end="(1160, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1160, 15)" end="(1164, 40)">
                      <OtherNode start="(1160, 15)" end="(1164, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1160, 15)" end="(1160, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1161, 3)" end="(1164, 40)">
                          <OtherNode start="(1161, 3)" end="(1161, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1161, 3)" end="(1161, 8)">
                              <OtherNode start="(1161, 3)" end="(1161, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1161, 3)" end="(1161, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1161, 5)" end="(1161, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1161, 5)" end="(1161, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1161, 9)" end="(1161, 16)">
                              <AtomNode start="(1161, 9)" end="(1161, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1161, 12)" end="(1161, 16)">
                                <TacticTacticseq1IndentedNode start="(1161, 12)" end="(1161, 16)">
                                  <NullNode start="(1161, 12)" end="(1161, 16)">
                                    <OtherNode start="(1161, 12)" end="(1161, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ (idxOf? a []).isSome = true ↔ a ∈ []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1161, 12)" end="(1161, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1162, 3)" end="(1164, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1162, 3)" end="(1162, 17)">
                              <OtherNode start="(1162, 3)" end="(1162, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1162, 3)" end="(1162, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1162, 5)" end="(1162, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1162, 5)" end="(1162, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1162, 10)" end="(1162, 17)">
                                  <IdentNode start="(1162, 10)" end="(1162, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1162, 12)" end="(1162, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1162, 15)" end="(1162, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1162, 18)" end="(1164, 40)">
                              <AtomNode start="(1162, 18)" end="(1162, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1163, 5)" end="(1164, 40)">
                                <TacticTacticseq1IndentedNode start="(1163, 5)" end="(1164, 40)">
                                  <NullNode start="(1163, 5)" end="(1164, 40)">
                                    <OtherNode start="(1163, 5)" end="(1163, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : (idxOf? a xs).isSome = true ↔ a ∈ xs&#10;⊢ (idxOf? a (x :: xs)).isSome = true ↔ a ∈ x :: xs" state_after="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : (idxOf? a xs).isSome = true ↔ a ∈ xs&#10;⊢ (if (x == a) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs)).isSome = true ↔ a ∈ x :: xs" tactic="simp only [idxOf?_cons]">
                                      <AtomNode start="(1163, 5)" end="(1163, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1163, 10)" end="(1163, 14)">
                                        <AtomNode start="(1163, 10)" end="(1163, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1163, 15)" end="(1163, 28)">
                                        <AtomNode start="(1163, 15)" end="(1163, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1163, 16)" end="(1163, 27)">
                                          <OtherNode start="(1163, 16)" end="(1163, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1163, 16)" end="(1163, 27)" leading="" trailing="" raw_val="idxOf?_cons" val="idxOf?_cons" full_name="List.idxOf?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1137, 9)" def_end="(1137, 20)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1163, 27)" end="(1163, 28)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1164, 5)" end="(1164, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : (idxOf? a xs).isSome = true ↔ a ∈ xs&#10;⊢ (if (x == a) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs)).isSome = true ↔ a ∈ x :: xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                                      <OtherNode start="(1164, 5)" end="(1164, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1164, 5)" end="(1164, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1164, 11)" end="(1164, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1164, 15)" end="(1164, 40)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1164, 15)" end="(1164, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(1164, 24)" end="(1164, 40)">
                                          <AtomNode start="(1164, 24)" end="(1164, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(1164, 25)" end="(1164, 39)">
                                            <OtherNode start="(1164, 25)" end="(1164, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(1164, 25)" end="(1164, 39)" kind="Lean.Parser.Term.app">
                                                <OtherNode start="(1164, 25)" end="(1164, 33)" kind="Lean.Parser.Term.explicit">
                                                  <AtomNode start="(1164, 25)" end="(1164, 26)" leading="" trailing="" val="@"/>
                                                  <IdentNode start="(1164, 26)" end="(1164, 33)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                </OtherNode>
                                                <NullNode start="(1164, 34)" end="(1164, 39)">
                                                  <TermHoleNode start="(1164, 34)" end="(1164, 35)">
                                                    <AtomNode start="(1164, 34)" end="(1164, 35)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <IdentNode start="(1164, 36)" end="(1164, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                                  <IdentNode start="(1164, 38)" end="(1164, 39)" leading="" trailing="" raw_val="a" val="a"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(1164, 39)" end="(1164, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1166, 1)" end="(1173, 40)" name="isNone_idxOf?" full_name="List.isNone_idxOf?">
      <CommandDeclmodifiersNode start="(1166, 1)" end="(1166, 8)">
        <NullNode/>
        <NullNode start="(1166, 1)" end="(1166, 8)">
          <OtherNode start="(1166, 1)" end="(1166, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1166, 1)" end="(1166, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1166, 3)" end="(1166, 7)">
              <OtherNode start="(1166, 3)" end="(1166, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1166, 3)" end="(1166, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1166, 3)" end="(1166, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1166, 7)" end="(1166, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1167, 1)" end="(1173, 40)" name="isNone_idxOf?" full_name="List.isNone_idxOf?" _is_private_decl="False">
        <AtomNode start="(1167, 1)" end="(1167, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1167, 9)" end="(1167, 22)">
          <IdentNode start="(1167, 9)" end="(1167, 22)" leading="" trailing=" " raw_val="isNone_idxOf?" val="isNone_idxOf?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1167, 23)" end="(1168, 34)">
          <NullNode start="(1167, 23)" end="(1167, 65)">
            <OtherNode start="(1167, 23)" end="(1167, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1167, 23)" end="(1167, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1167, 24)" end="(1167, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1167, 24)" end="(1167, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1167, 28)" end="(1167, 29)">
                  <IdentNode start="(1167, 28)" end="(1167, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1167, 29)" end="(1167, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1167, 31)" end="(1167, 44)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(1167, 31)" end="(1167, 32)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(1167, 32)" end="(1167, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1167, 32)" end="(1167, 41)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                <NullNode start="(1167, 42)" end="(1167, 43)">
                  <IdentNode start="(1167, 42)" end="(1167, 43)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1167, 43)" end="(1167, 44)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <OtherNode start="(1167, 45)" end="(1167, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1167, 45)" end="(1167, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(1167, 46)" end="(1167, 47)">
                <IdentNode start="(1167, 46)" end="(1167, 47)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1167, 48)" end="(1167, 56)">
                <AtomNode start="(1167, 48)" end="(1167, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1167, 50)" end="(1167, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1167, 50)" end="(1167, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1167, 55)" end="(1167, 56)">
                    <IdentNode start="(1167, 55)" end="(1167, 56)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1167, 56)" end="(1167, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1167, 58)" end="(1167, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1167, 58)" end="(1167, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(1167, 59)" end="(1167, 60)">
                <IdentNode start="(1167, 59)" end="(1167, 60)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1167, 61)" end="(1167, 64)">
                <AtomNode start="(1167, 61)" end="(1167, 62)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1167, 63)" end="(1167, 64)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1167, 64)" end="(1167, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1167, 66)" end="(1168, 34)">
            <AtomNode start="(1167, 66)" end="(1167, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1168, 5)" end="(1168, 34)" kind="«term_=_»">
              <OtherNode start="(1168, 5)" end="(1168, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1168, 5)" end="(1168, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1168, 5)" end="(1168, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1168, 6)" end="(1168, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1168, 6)" end="(1168, 14)" leading="" trailing=" " raw_val="l.idxOf?" val="l.idxOf?"/>
                    <NullNode start="(1168, 15)" end="(1168, 16)">
                      <IdentNode start="(1168, 15)" end="(1168, 16)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1168, 16)" end="(1168, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1168, 17)" end="(1168, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(1168, 18)" end="(1168, 24)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1168, 25)" end="(1168, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(1168, 27)" end="(1168, 34)" kind="«term¬_»">
                <AtomNode start="(1168, 27)" end="(1168, 28)" leading="" trailing=" " val="¬"/>
                <OtherNode start="(1168, 29)" end="(1168, 34)" kind="«term_∈_»">
                  <IdentNode start="(1168, 29)" end="(1168, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(1168, 31)" end="(1168, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(1168, 33)" end="(1168, 34)" leading="" trailing=" " raw_val="l" val="l"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1168, 35)" end="(1173, 40)">
          <AtomNode start="(1168, 35)" end="(1168, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1168, 38)" end="(1173, 40)">
            <AtomNode start="(1168, 38)" end="(1168, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1169, 3)" end="(1173, 40)">
              <TacticTacticseq1IndentedNode start="(1169, 3)" end="(1173, 40)">
                <NullNode start="(1169, 3)" end="(1173, 40)">
                  <OtherNode start="(1169, 3)" end="(1173, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;l : List α&#10;a : α&#10;⊢ ((idxOf? a l).isNone = true) = ¬a ∈ l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp&#10;| cons x xs ih =&amp;gt;&#10;  simp only [idxOf?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                    <AtomNode start="(1169, 3)" end="(1169, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1169, 13)" end="(1169, 14)">
                      <OtherNode start="(1169, 13)" end="(1169, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1169, 13)" end="(1169, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1169, 15)" end="(1173, 40)">
                      <OtherNode start="(1169, 15)" end="(1173, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1169, 15)" end="(1169, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1170, 3)" end="(1173, 40)">
                          <OtherNode start="(1170, 3)" end="(1170, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1170, 3)" end="(1170, 8)">
                              <OtherNode start="(1170, 3)" end="(1170, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1170, 3)" end="(1170, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1170, 5)" end="(1170, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1170, 5)" end="(1170, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1170, 9)" end="(1170, 16)">
                              <AtomNode start="(1170, 9)" end="(1170, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1170, 12)" end="(1170, 16)">
                                <TacticTacticseq1IndentedNode start="(1170, 12)" end="(1170, 16)">
                                  <NullNode start="(1170, 12)" end="(1170, 16)">
                                    <OtherNode start="(1170, 12)" end="(1170, 16)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;⊢ ((idxOf? a []).isNone = true) = ¬a ∈ []" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1170, 12)" end="(1170, 16)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1171, 3)" end="(1173, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1171, 3)" end="(1171, 17)">
                              <OtherNode start="(1171, 3)" end="(1171, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1171, 3)" end="(1171, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1171, 5)" end="(1171, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1171, 5)" end="(1171, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1171, 10)" end="(1171, 17)">
                                  <IdentNode start="(1171, 10)" end="(1171, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(1171, 12)" end="(1171, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(1171, 15)" end="(1171, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1171, 18)" end="(1173, 40)">
                              <AtomNode start="(1171, 18)" end="(1171, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1172, 5)" end="(1173, 40)">
                                <TacticTacticseq1IndentedNode start="(1172, 5)" end="(1173, 40)">
                                  <NullNode start="(1172, 5)" end="(1173, 40)">
                                    <OtherNode start="(1172, 5)" end="(1172, 28)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : ((idxOf? a xs).isNone = true) = ¬a ∈ xs&#10;⊢ ((idxOf? a (x :: xs)).isNone = true) = ¬a ∈ x :: xs" state_after="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : ((idxOf? a xs).isNone = true) = ¬a ∈ xs&#10;⊢ ((if (x == a) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs)).isNone = true) = ¬a ∈ x :: xs" tactic="simp only [idxOf?_cons]">
                                      <AtomNode start="(1172, 5)" end="(1172, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1172, 10)" end="(1172, 14)">
                                        <AtomNode start="(1172, 10)" end="(1172, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1172, 15)" end="(1172, 28)">
                                        <AtomNode start="(1172, 15)" end="(1172, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1172, 16)" end="(1172, 27)">
                                          <OtherNode start="(1172, 16)" end="(1172, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1172, 16)" end="(1172, 27)" leading="" trailing="" raw_val="idxOf?_cons" val="idxOf?_cons" full_name="List.idxOf?_cons" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1137, 9)" def_end="(1137, 20)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1172, 27)" end="(1172, 28)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1173, 5)" end="(1173, 40)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a x : α&#10;xs : List α&#10;ih : ((idxOf? a xs).isNone = true) = ¬a ∈ xs&#10;⊢ ((if (x == a) = true then some 0 else Option.map (fun x =&amp;gt; x + 1) (idxOf? a xs)).isNone = true) = ¬a ∈ x :: xs" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all [@eq_comm _ x a]">
                                      <OtherNode start="(1173, 5)" end="(1173, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1173, 5)" end="(1173, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1173, 11)" end="(1173, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1173, 15)" end="(1173, 40)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1173, 15)" end="(1173, 23)" leading="" trailing=" " val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(1173, 24)" end="(1173, 40)">
                                          <AtomNode start="(1173, 24)" end="(1173, 25)" leading="" trailing="" val="["/>
                                          <NullNode start="(1173, 25)" end="(1173, 39)">
                                            <OtherNode start="(1173, 25)" end="(1173, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <OtherNode start="(1173, 25)" end="(1173, 39)" kind="Lean.Parser.Term.app">
                                                <OtherNode start="(1173, 25)" end="(1173, 33)" kind="Lean.Parser.Term.explicit">
                                                  <AtomNode start="(1173, 25)" end="(1173, 26)" leading="" trailing="" val="@"/>
                                                  <IdentNode start="(1173, 26)" end="(1173, 33)" leading="" trailing=" " raw_val="eq_comm" val="eq_comm" full_name="eq_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                </OtherNode>
                                                <NullNode start="(1173, 34)" end="(1173, 39)">
                                                  <TermHoleNode start="(1173, 34)" end="(1173, 35)">
                                                    <AtomNode start="(1173, 34)" end="(1173, 35)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <IdentNode start="(1173, 36)" end="(1173, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                                  <IdentNode start="(1173, 38)" end="(1173, 39)" leading="" trailing="" raw_val="a" val="a"/>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(1173, 39)" end="(1173, 40)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(1176, 1)" end="(1176, 18)" comment="### lookup -/">
      <AtomNode start="(1176, 1)" end="(1176, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(1176, 5)" end="(1176, 18)" leading="" trailing="&#10;&#10;" val="### lookup -/"/>
    </CommandModuledocNode>
    <CommandSectionNode start="(1178, 1)" end="(1178, 15)" name="lookup">
      <AtomNode start="(1178, 1)" end="(1178, 8)" leading="" trailing=" " val="section"/>
      <NullNode start="(1178, 9)" end="(1178, 15)">
        <IdentNode start="(1178, 9)" end="(1178, 15)" leading="" trailing="&#10;" raw_val="lookup" val="lookup"/>
      </NullNode>
    </CommandSectionNode>
    <OtherNode start="(1179, 1)" end="(1179, 31)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(1179, 1)" end="(1179, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(1179, 10)" end="(1179, 31)">
        <OtherNode start="(1179, 10)" end="(1179, 17)" kind="Lean.Parser.Term.instBinder">
          <AtomNode start="(1179, 10)" end="(1179, 11)" leading="" trailing="" val="["/>
          <NullNode/>
          <OtherNode start="(1179, 11)" end="(1179, 16)" kind="Lean.Parser.Term.app">
            <IdentNode start="(1179, 11)" end="(1179, 14)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(1179, 15)" end="(1179, 16)">
              <IdentNode start="(1179, 15)" end="(1179, 16)" leading="" trailing="" raw_val="α" val="α"/>
            </NullNode>
          </OtherNode>
          <AtomNode start="(1179, 16)" end="(1179, 17)" leading="" trailing=" " val="]"/>
        </OtherNode>
        <OtherNode start="(1179, 18)" end="(1179, 31)" kind="Lean.Parser.Term.instBinder">
          <AtomNode start="(1179, 18)" end="(1179, 19)" leading="" trailing="" val="["/>
          <NullNode/>
          <OtherNode start="(1179, 19)" end="(1179, 30)" kind="Lean.Parser.Term.app">
            <IdentNode start="(1179, 19)" end="(1179, 28)" leading="" trailing=" " raw_val="LawfulBEq" val="LawfulBEq" full_name="LawfulBEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
            <NullNode start="(1179, 29)" end="(1179, 30)">
              <IdentNode start="(1179, 29)" end="(1179, 30)" leading="" trailing="" raw_val="α" val="α"/>
            </NullNode>
          </OtherNode>
          <AtomNode start="(1179, 30)" end="(1179, 31)" leading="" trailing="&#10;&#10;" val="]"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(1181, 1)" end="(1182, 21)" name="lookup_cons_self" full_name="List.lookup_cons_self">
      <CommandDeclmodifiersNode start="(1181, 1)" end="(1181, 8)">
        <NullNode/>
        <NullNode start="(1181, 1)" end="(1181, 8)">
          <OtherNode start="(1181, 1)" end="(1181, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1181, 1)" end="(1181, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1181, 3)" end="(1181, 7)">
              <OtherNode start="(1181, 3)" end="(1181, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1181, 3)" end="(1181, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1181, 3)" end="(1181, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1181, 7)" end="(1181, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1181, 9)" end="(1182, 21)" name="lookup_cons_self" full_name="List.lookup_cons_self" _is_private_decl="False">
        <AtomNode start="(1181, 9)" end="(1181, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1181, 17)" end="(1181, 33)">
          <IdentNode start="(1181, 17)" end="(1181, 33)" leading="" trailing="  " raw_val="lookup_cons_self" val="lookup_cons_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1181, 35)" end="(1181, 76)">
          <NullNode start="(1181, 35)" end="(1181, 42)">
            <OtherNode start="(1181, 35)" end="(1181, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1181, 35)" end="(1181, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(1181, 36)" end="(1181, 37)">
                <IdentNode start="(1181, 36)" end="(1181, 37)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1181, 38)" end="(1181, 41)">
                <AtomNode start="(1181, 38)" end="(1181, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1181, 40)" end="(1181, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1181, 41)" end="(1181, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1181, 43)" end="(1181, 76)">
            <AtomNode start="(1181, 43)" end="(1181, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1181, 45)" end="(1181, 76)" kind="«term_=_»">
              <OtherNode start="(1181, 45)" end="(1181, 67)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1181, 45)" end="(1181, 65)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1181, 45)" end="(1181, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1181, 45)" end="(1181, 46)" leading="" trailing="" val="("/>
                    <OtherNode start="(1181, 46)" end="(1181, 57)" kind="«term_::_»">
                      <OtherNode start="(1181, 46)" end="(1181, 51)" kind="Lean.Parser.Term.tuple">
                        <AtomNode start="(1181, 46)" end="(1181, 47)" leading="" trailing="" val="("/>
                        <NullNode start="(1181, 47)" end="(1181, 50)">
                          <IdentNode start="(1181, 47)" end="(1181, 48)" leading="" trailing="" raw_val="k" val="k"/>
                          <AtomNode start="(1181, 48)" end="(1181, 49)" leading="" trailing="" val=","/>
                          <NullNode start="(1181, 49)" end="(1181, 50)">
                            <IdentNode start="(1181, 49)" end="(1181, 50)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(1181, 50)" end="(1181, 51)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <AtomNode start="(1181, 52)" end="(1181, 54)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(1181, 55)" end="(1181, 57)" leading="" trailing="" raw_val="es" val="es"/>
                    </OtherNode>
                    <AtomNode start="(1181, 57)" end="(1181, 58)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1181, 58)" end="(1181, 59)" leading="" trailing="" val="."/>
                  <IdentNode start="(1181, 59)" end="(1181, 65)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1181, 66)" end="(1181, 67)">
                  <IdentNode start="(1181, 66)" end="(1181, 67)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1181, 68)" end="(1181, 69)" leading="" trailing=" " val="="/>
              <OtherNode start="(1181, 70)" end="(1181, 76)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1181, 70)" end="(1181, 74)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1181, 75)" end="(1181, 76)">
                  <IdentNode start="(1181, 75)" end="(1181, 76)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1181, 77)" end="(1182, 21)">
          <AtomNode start="(1181, 77)" end="(1181, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1181, 80)" end="(1182, 21)">
            <AtomNode start="(1181, 80)" end="(1181, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1182, 3)" end="(1182, 21)">
              <TacticTacticseq1IndentedNode start="(1182, 3)" end="(1182, 21)">
                <NullNode start="(1182, 3)" end="(1182, 21)">
                  <OtherNode start="(1182, 3)" end="(1182, 21)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β✝ : Type u_1&#10;b : β✝&#10;es : List (α × β✝)&#10;k : α&#10;⊢ lookup k ((k, b) :: es) = some b" state_after="no goals" tactic="simp [lookup_cons]">
                    <AtomNode start="(1182, 3)" end="(1182, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1182, 8)" end="(1182, 21)">
                      <AtomNode start="(1182, 8)" end="(1182, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1182, 9)" end="(1182, 20)">
                        <OtherNode start="(1182, 9)" end="(1182, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1182, 9)" end="(1182, 20)" leading="" trailing="" raw_val="lookup_cons" val="lookup_cons" full_name="List.lookup_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1182, 20)" end="(1182, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1184, 1)" end="(1186, 21)" name="lookup_singleton" full_name="List.lookup_singleton">
      <CommandDeclmodifiersNode start="(1184, 1)" end="(1184, 8)">
        <NullNode/>
        <NullNode start="(1184, 1)" end="(1184, 8)">
          <OtherNode start="(1184, 1)" end="(1184, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1184, 1)" end="(1184, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1184, 3)" end="(1184, 7)">
              <OtherNode start="(1184, 3)" end="(1184, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1184, 3)" end="(1184, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1184, 3)" end="(1184, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1184, 7)" end="(1184, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1184, 9)" end="(1186, 21)" name="lookup_singleton" full_name="List.lookup_singleton" _is_private_decl="False">
        <AtomNode start="(1184, 9)" end="(1184, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1184, 17)" end="(1184, 33)">
          <IdentNode start="(1184, 17)" end="(1184, 33)" leading="" trailing=" " raw_val="lookup_singleton" val="lookup_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1184, 34)" end="(1184, 96)">
          <NullNode start="(1184, 34)" end="(1184, 43)">
            <OtherNode start="(1184, 34)" end="(1184, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1184, 34)" end="(1184, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(1184, 35)" end="(1184, 38)">
                <IdentNode start="(1184, 35)" end="(1184, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(1184, 37)" end="(1184, 38)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(1184, 39)" end="(1184, 42)">
                <AtomNode start="(1184, 39)" end="(1184, 40)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1184, 41)" end="(1184, 42)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1184, 42)" end="(1184, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1184, 44)" end="(1184, 96)">
            <AtomNode start="(1184, 44)" end="(1184, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(1184, 46)" end="(1184, 96)" kind="«term_=_»">
              <OtherNode start="(1184, 46)" end="(1184, 62)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1184, 46)" end="(1184, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1184, 46)" end="(1184, 53)" kind="«term[_]»">
                    <AtomNode start="(1184, 46)" end="(1184, 47)" leading="" trailing="" val="["/>
                    <NullNode start="(1184, 47)" end="(1184, 52)">
                      <OtherNode start="(1184, 47)" end="(1184, 52)" kind="Lean.Parser.Term.tuple">
                        <AtomNode start="(1184, 47)" end="(1184, 48)" leading="" trailing="" val="("/>
                        <NullNode start="(1184, 48)" end="(1184, 51)">
                          <IdentNode start="(1184, 48)" end="(1184, 49)" leading="" trailing="" raw_val="a" val="a"/>
                          <AtomNode start="(1184, 49)" end="(1184, 50)" leading="" trailing="" val=","/>
                          <NullNode start="(1184, 50)" end="(1184, 51)">
                            <IdentNode start="(1184, 50)" end="(1184, 51)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(1184, 51)" end="(1184, 52)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(1184, 52)" end="(1184, 53)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(1184, 53)" end="(1184, 54)" leading="" trailing="" val="."/>
                  <IdentNode start="(1184, 54)" end="(1184, 60)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1184, 61)" end="(1184, 62)">
                  <IdentNode start="(1184, 61)" end="(1184, 62)" leading="" trailing=" " raw_val="c" val="c"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1184, 63)" end="(1184, 64)" leading="" trailing=" " val="="/>
              <OtherNode start="(1184, 65)" end="(1184, 96)" kind="termIfThenElse">
                <AtomNode start="(1184, 65)" end="(1184, 67)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1184, 68)" end="(1184, 74)" kind="«term_==_»">
                  <IdentNode start="(1184, 68)" end="(1184, 69)" leading="" trailing=" " raw_val="c" val="c"/>
                  <AtomNode start="(1184, 70)" end="(1184, 72)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(1184, 73)" end="(1184, 74)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
                <AtomNode start="(1184, 75)" end="(1184, 79)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1184, 80)" end="(1184, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1184, 80)" end="(1184, 84)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1184, 85)" end="(1184, 86)">
                    <IdentNode start="(1184, 85)" end="(1184, 86)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1184, 87)" end="(1184, 91)" leading="" trailing=" " val="else"/>
                <IdentNode start="(1184, 92)" end="(1184, 96)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1184, 97)" end="(1186, 21)">
          <AtomNode start="(1184, 97)" end="(1184, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1184, 100)" end="(1186, 21)">
            <AtomNode start="(1184, 100)" end="(1184, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1185, 3)" end="(1186, 21)">
              <TacticTacticseq1IndentedNode start="(1185, 3)" end="(1186, 21)">
                <NullNode start="(1185, 3)" end="(1186, 21)">
                  <OtherNode start="(1185, 3)" end="(1185, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;c a b : α&#10;⊢ lookup c [(a, b)] = if (c == a) = true then some b else none" state_after="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;c a b : α&#10;⊢ (match c == a with&#10;    | true =&amp;gt; some b&#10;    | false =&amp;gt; none) =&#10;    if (c == a) = true then some b else none" tactic="simp [lookup_cons, lookup_nil]">
                    <AtomNode start="(1185, 3)" end="(1185, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1185, 8)" end="(1185, 33)">
                      <AtomNode start="(1185, 8)" end="(1185, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1185, 9)" end="(1185, 32)">
                        <OtherNode start="(1185, 9)" end="(1185, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1185, 9)" end="(1185, 20)" leading="" trailing="" raw_val="lookup_cons" val="lookup_cons" full_name="List.lookup_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(1185, 20)" end="(1185, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1185, 22)" end="(1185, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1185, 22)" end="(1185, 32)" leading="" trailing="" raw_val="lookup_nil" val="lookup_nil" full_name="List.lookup_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1185, 32)" end="(1185, 33)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1186, 3)" end="(1186, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;c a b : α&#10;⊢ (match c == a with&#10;    | true =&amp;gt; some b&#10;    | false =&amp;gt; none) =&#10;    if (c == a) = true then some b else none" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(1186, 3)" end="(1186, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(1186, 3)" end="(1186, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(1186, 9)" end="(1186, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(1186, 13)" end="(1186, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(1186, 13)" end="(1186, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1188, 1)" end="(1196, 25)" name="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1188, 1)" end="(1196, 25)" name="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" _is_private_decl="False">
        <AtomNode start="(1188, 1)" end="(1188, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1188, 9)" end="(1188, 28)">
          <IdentNode start="(1188, 9)" end="(1188, 28)" leading="" trailing=" " raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1188, 29)" end="(1189, 74)">
          <NullNode start="(1188, 29)" end="(1188, 55)">
            <OtherNode start="(1188, 29)" end="(1188, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1188, 29)" end="(1188, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(1188, 30)" end="(1188, 31)">
                <IdentNode start="(1188, 30)" end="(1188, 31)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1188, 32)" end="(1188, 46)">
                <AtomNode start="(1188, 32)" end="(1188, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1188, 34)" end="(1188, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1188, 34)" end="(1188, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1188, 39)" end="(1188, 46)">
                    <OtherNode start="(1188, 39)" end="(1188, 46)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1188, 39)" end="(1188, 40)" leading="" trailing="" val="("/>
                      <OtherNode start="(1188, 40)" end="(1188, 45)" kind="«term_×_»">
                        <IdentNode start="(1188, 40)" end="(1188, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1188, 42)" end="(1188, 43)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1188, 44)" end="(1188, 45)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1188, 45)" end="(1188, 46)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1188, 46)" end="(1188, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1188, 48)" end="(1188, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1188, 48)" end="(1188, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(1188, 49)" end="(1188, 50)">
                <IdentNode start="(1188, 49)" end="(1188, 50)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1188, 51)" end="(1188, 54)">
                <AtomNode start="(1188, 51)" end="(1188, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1188, 53)" end="(1188, 54)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1188, 54)" end="(1188, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1188, 56)" end="(1189, 74)">
            <AtomNode start="(1188, 56)" end="(1188, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1189, 5)" end="(1189, 74)" kind="«term_=_»">
              <OtherNode start="(1189, 5)" end="(1189, 15)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1189, 5)" end="(1189, 13)" leading="" trailing=" " raw_val="l.lookup" val="l.lookup"/>
                <NullNode start="(1189, 14)" end="(1189, 15)">
                  <IdentNode start="(1189, 14)" end="(1189, 15)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1189, 16)" end="(1189, 17)" leading="" trailing=" " val="="/>
              <OtherNode start="(1189, 18)" end="(1189, 74)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1189, 18)" end="(1189, 29)" leading="" trailing=" " raw_val="l.findSome?" val="l.findSome?"/>
                <NullNode start="(1189, 30)" end="(1189, 74)">
                  <OtherNode start="(1189, 30)" end="(1189, 74)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(1189, 30)" end="(1189, 33)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(1189, 34)" end="(1189, 74)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(1189, 34)" end="(1189, 35)">
                        <IdentNode start="(1189, 34)" end="(1189, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(1189, 36)" end="(1189, 38)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(1189, 39)" end="(1189, 74)" kind="termIfThenElse">
                        <AtomNode start="(1189, 39)" end="(1189, 41)" leading="" trailing=" " val="if"/>
                        <OtherNode start="(1189, 42)" end="(1189, 50)" kind="«term_==_»">
                          <IdentNode start="(1189, 42)" end="(1189, 43)" leading="" trailing=" " raw_val="k" val="k"/>
                          <AtomNode start="(1189, 44)" end="(1189, 46)" leading="" trailing=" " val="=="/>
                          <OtherNode start="(1189, 47)" end="(1189, 50)" kind="Lean.Parser.Term.proj">
                            <IdentNode start="(1189, 47)" end="(1189, 48)" leading="" trailing="" raw_val="p" val="p"/>
                            <AtomNode start="(1189, 48)" end="(1189, 49)" leading="" trailing="" val="."/>
                            <OtherNode start="(1189, 49)" end="(1189, 50)" kind="fieldIdx">
                              <AtomNode start="(1189, 49)" end="(1189, 50)" leading="" trailing=" " val="1"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(1189, 51)" end="(1189, 55)" leading="" trailing=" " val="then"/>
                        <OtherNode start="(1189, 56)" end="(1189, 64)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(1189, 56)" end="(1189, 60)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(1189, 61)" end="(1189, 64)">
                            <OtherNode start="(1189, 61)" end="(1189, 64)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(1189, 61)" end="(1189, 62)" leading="" trailing="" raw_val="p" val="p"/>
                              <AtomNode start="(1189, 62)" end="(1189, 63)" leading="" trailing="" val="."/>
                              <OtherNode start="(1189, 63)" end="(1189, 64)" kind="fieldIdx">
                                <AtomNode start="(1189, 63)" end="(1189, 64)" leading="" trailing=" " val="2"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(1189, 65)" end="(1189, 69)" leading="" trailing=" " val="else"/>
                        <IdentNode start="(1189, 70)" end="(1189, 74)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1189, 75)" end="(1196, 25)">
          <AtomNode start="(1189, 75)" end="(1189, 77)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1189, 78)" end="(1196, 25)">
            <AtomNode start="(1189, 78)" end="(1189, 80)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1190, 3)" end="(1196, 25)">
              <TacticTacticseq1IndentedNode start="(1190, 3)" end="(1196, 25)">
                <NullNode start="(1190, 3)" end="(1196, 25)">
                  <OtherNode start="(1190, 3)" end="(1196, 25)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;⊢ lookup k l = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; rfl&#10;| cons p l ih =&amp;gt;&#10;  match p with&#10;  | (k', v) =&amp;gt;&#10;    simp only [lookup_cons, findSome?_cons]&#10;    split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(1190, 3)" end="(1190, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1190, 13)" end="(1190, 14)">
                      <OtherNode start="(1190, 13)" end="(1190, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1190, 13)" end="(1190, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1190, 15)" end="(1196, 25)">
                      <OtherNode start="(1190, 15)" end="(1196, 25)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1190, 15)" end="(1190, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1191, 3)" end="(1196, 25)">
                          <OtherNode start="(1191, 3)" end="(1191, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1191, 3)" end="(1191, 8)">
                              <OtherNode start="(1191, 3)" end="(1191, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1191, 3)" end="(1191, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1191, 5)" end="(1191, 8)">
                                  <NullNode/>
                                  <IdentNode start="(1191, 5)" end="(1191, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1191, 9)" end="(1191, 15)">
                              <AtomNode start="(1191, 9)" end="(1191, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1191, 12)" end="(1191, 15)">
                                <TacticTacticseq1IndentedNode start="(1191, 12)" end="(1191, 15)">
                                  <NullNode start="(1191, 12)" end="(1191, 15)">
                                    <OtherNode start="(1191, 12)" end="(1191, 15)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case nil&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;⊢ lookup k [] = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) []" state_after="no goals" tactic="rfl">
                                      <AtomNode start="(1191, 12)" end="(1191, 15)" leading="" trailing="&#10;  " val="rfl"/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1192, 3)" end="(1196, 25)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1192, 3)" end="(1192, 16)">
                              <OtherNode start="(1192, 3)" end="(1192, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1192, 3)" end="(1192, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1192, 5)" end="(1192, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1192, 5)" end="(1192, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(1192, 10)" end="(1192, 16)">
                                  <IdentNode start="(1192, 10)" end="(1192, 11)" leading="" trailing=" " raw_val="p" val="p"/>
                                  <IdentNode start="(1192, 12)" end="(1192, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(1192, 14)" end="(1192, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1192, 17)" end="(1196, 25)">
                              <AtomNode start="(1192, 17)" end="(1192, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1193, 5)" end="(1196, 25)">
                                <TacticTacticseq1IndentedNode start="(1193, 5)" end="(1196, 25)">
                                  <NullNode start="(1193, 5)" end="(1196, 25)">
                                    <OtherNode start="(1193, 5)" end="(1196, 25)" kind="Lean.Parser.Tactic.match" state_before="case cons&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;p : α × β&#10;l : List (α × β)&#10;ih : lookup k l = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l&#10;⊢ lookup k (p :: l) = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) (p :: l)" state_after="no goals" tactic="match p with&#10;| (k', v) =&amp;gt;&#10;  simp only [lookup_cons, findSome?_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                                      <AtomNode start="(1193, 5)" end="(1193, 10)" leading="" trailing=" " val="match"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(1193, 11)" end="(1193, 12)">
                                        <OtherNode start="(1193, 11)" end="(1193, 12)" kind="Lean.Parser.Term.matchDiscr">
                                          <NullNode/>
                                          <IdentNode start="(1193, 11)" end="(1193, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(1193, 13)" end="(1193, 17)" leading="" trailing="&#10;    " val="with"/>
                                      <OtherNode start="(1194, 5)" end="(1196, 25)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(1194, 5)" end="(1196, 25)">
                                          <OtherNode start="(1194, 5)" end="(1196, 25)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(1194, 5)" end="(1194, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(1194, 7)" end="(1194, 14)">
                                              <NullNode start="(1194, 7)" end="(1194, 14)">
                                                <OtherNode start="(1194, 7)" end="(1194, 14)" kind="Lean.Parser.Term.tuple">
                                                  <AtomNode start="(1194, 7)" end="(1194, 8)" leading="" trailing="" val="("/>
                                                  <NullNode start="(1194, 8)" end="(1194, 13)">
                                                    <IdentNode start="(1194, 8)" end="(1194, 10)" leading="" trailing="" raw_val="k'" val="k'"/>
                                                    <AtomNode start="(1194, 10)" end="(1194, 11)" leading="" trailing=" " val=","/>
                                                    <NullNode start="(1194, 12)" end="(1194, 13)">
                                                      <IdentNode start="(1194, 12)" end="(1194, 13)" leading="" trailing="" raw_val="v" val="v"/>
                                                    </NullNode>
                                                  </NullNode>
                                                  <AtomNode start="(1194, 13)" end="(1194, 14)" leading="" trailing=" " val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(1194, 15)" end="(1194, 17)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(1195, 7)" end="(1196, 25)">
                                              <TacticTacticseq1IndentedNode start="(1195, 7)" end="(1196, 25)">
                                                <NullNode start="(1195, 7)" end="(1196, 25)">
                                                  <OtherNode start="(1195, 7)" end="(1195, 46)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;p : α × β&#10;l : List (α × β)&#10;ih : lookup k l = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l&#10;k' : α&#10;v : β&#10;⊢ lookup k ((k', v) :: l) = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) ((k', v) :: l)" state_after="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;p : α × β&#10;l : List (α × β)&#10;ih : lookup k l = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l&#10;k' : α&#10;v : β&#10;⊢ (match k == k' with&#10;    | true =&amp;gt; some v&#10;    | false =&amp;gt; lookup k l) =&#10;    match if (k == k') = true then some v else none with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l" tactic="simp only [lookup_cons, findSome?_cons]">
                                                    <AtomNode start="(1195, 7)" end="(1195, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode start="(1195, 12)" end="(1195, 16)">
                                                      <AtomNode start="(1195, 12)" end="(1195, 16)" leading="" trailing=" " val="only"/>
                                                    </NullNode>
                                                    <NullNode start="(1195, 17)" end="(1195, 46)">
                                                      <AtomNode start="(1195, 17)" end="(1195, 18)" leading="" trailing="" val="["/>
                                                      <NullNode start="(1195, 18)" end="(1195, 45)">
                                                        <OtherNode start="(1195, 18)" end="(1195, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(1195, 18)" end="(1195, 29)" leading="" trailing="" raw_val="lookup_cons" val="lookup_cons" full_name="List.lookup_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                        </OtherNode>
                                                        <AtomNode start="(1195, 29)" end="(1195, 30)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(1195, 31)" end="(1195, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(1195, 31)" end="(1195, 45)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(1195, 45)" end="(1195, 46)" leading="" trailing="&#10;      " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(1196, 7)" end="(1196, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;p : α × β&#10;l : List (α × β)&#10;ih : lookup k l = findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l&#10;k' : α&#10;v : β&#10;⊢ (match k == k' with&#10;    | true =&amp;gt; some v&#10;    | false =&amp;gt; lookup k l) =&#10;    match if (k == k') = true then some v else none with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                                    <OtherNode start="(1196, 7)" end="(1196, 12)" kind="Lean.Parser.Tactic.split">
                                                      <AtomNode start="(1196, 7)" end="(1196, 12)" leading="" trailing=" " val="split"/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <AtomNode start="(1196, 13)" end="(1196, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                    <OtherNode start="(1196, 17)" end="(1196, 25)" kind="Lean.Parser.Tactic.simpAll">
                                                      <AtomNode start="(1196, 17)" end="(1196, 25)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1198, 1)" end="(1200, 29)" name="lookup_eq_none_iff" full_name="List.lookup_eq_none_iff">
      <CommandDeclmodifiersNode start="(1198, 1)" end="(1198, 8)">
        <NullNode/>
        <NullNode start="(1198, 1)" end="(1198, 8)">
          <OtherNode start="(1198, 1)" end="(1198, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1198, 1)" end="(1198, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1198, 3)" end="(1198, 7)">
              <OtherNode start="(1198, 3)" end="(1198, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1198, 3)" end="(1198, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1198, 3)" end="(1198, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1198, 7)" end="(1198, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1198, 9)" end="(1200, 29)" name="lookup_eq_none_iff" full_name="List.lookup_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(1198, 9)" end="(1198, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1198, 17)" end="(1198, 35)">
          <IdentNode start="(1198, 17)" end="(1198, 35)" leading="" trailing=" " raw_val="lookup_eq_none_iff" val="lookup_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1198, 36)" end="(1199, 42)">
          <NullNode start="(1198, 36)" end="(1198, 62)">
            <OtherNode start="(1198, 36)" end="(1198, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1198, 36)" end="(1198, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(1198, 37)" end="(1198, 38)">
                <IdentNode start="(1198, 37)" end="(1198, 38)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1198, 39)" end="(1198, 53)">
                <AtomNode start="(1198, 39)" end="(1198, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1198, 41)" end="(1198, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1198, 41)" end="(1198, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1198, 46)" end="(1198, 53)">
                    <OtherNode start="(1198, 46)" end="(1198, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1198, 46)" end="(1198, 47)" leading="" trailing="" val="("/>
                      <OtherNode start="(1198, 47)" end="(1198, 52)" kind="«term_×_»">
                        <IdentNode start="(1198, 47)" end="(1198, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1198, 49)" end="(1198, 50)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1198, 51)" end="(1198, 52)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1198, 52)" end="(1198, 53)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1198, 53)" end="(1198, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1198, 55)" end="(1198, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1198, 55)" end="(1198, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(1198, 56)" end="(1198, 57)">
                <IdentNode start="(1198, 56)" end="(1198, 57)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1198, 58)" end="(1198, 61)">
                <AtomNode start="(1198, 58)" end="(1198, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1198, 60)" end="(1198, 61)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1198, 61)" end="(1198, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1198, 63)" end="(1199, 42)">
            <AtomNode start="(1198, 63)" end="(1198, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1199, 5)" end="(1199, 42)" kind="«term_↔_»">
              <OtherNode start="(1199, 5)" end="(1199, 22)" kind="«term_=_»">
                <OtherNode start="(1199, 5)" end="(1199, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1199, 5)" end="(1199, 13)" leading="" trailing=" " raw_val="l.lookup" val="l.lookup"/>
                  <NullNode start="(1199, 14)" end="(1199, 15)">
                    <IdentNode start="(1199, 14)" end="(1199, 15)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1199, 16)" end="(1199, 17)" leading="" trailing=" " val="="/>
                <IdentNode start="(1199, 18)" end="(1199, 22)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1199, 23)" end="(1199, 24)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1199, 25)" end="(1199, 42)" kind="Lean.«term∀__,_»">
                <AtomNode start="(1199, 25)" end="(1199, 26)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(1199, 27)" end="(1199, 28)">
                  <IdentNode start="(1199, 27)" end="(1199, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                </LeanBinderidentNode>
                <OtherNode start="(1199, 29)" end="(1199, 32)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(1199, 29)" end="(1199, 30)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(1199, 31)" end="(1199, 32)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(1199, 32)" end="(1199, 33)" leading="" trailing=" " val=","/>
                <OtherNode start="(1199, 34)" end="(1199, 42)" kind="«term_!=_»">
                  <IdentNode start="(1199, 34)" end="(1199, 35)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(1199, 36)" end="(1199, 38)" leading="" trailing=" " val="!="/>
                  <OtherNode start="(1199, 39)" end="(1199, 42)" kind="Lean.Parser.Term.proj">
                    <IdentNode start="(1199, 39)" end="(1199, 40)" leading="" trailing="" raw_val="p" val="p"/>
                    <AtomNode start="(1199, 40)" end="(1199, 41)" leading="" trailing="" val="."/>
                    <OtherNode start="(1199, 41)" end="(1199, 42)" kind="fieldIdx">
                      <AtomNode start="(1199, 41)" end="(1199, 42)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1199, 43)" end="(1200, 29)">
          <AtomNode start="(1199, 43)" end="(1199, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1199, 46)" end="(1200, 29)">
            <AtomNode start="(1199, 46)" end="(1199, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1200, 3)" end="(1200, 29)">
              <TacticTacticseq1IndentedNode start="(1200, 3)" end="(1200, 29)">
                <NullNode start="(1200, 3)" end="(1200, 29)">
                  <OtherNode start="(1200, 3)" end="(1200, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;⊢ lookup k l = none ↔ ∀ (p : α × β), p ∈ l → (k != p.fst) = true" state_after="no goals" tactic="simp [lookup_eq_findSome?]">
                    <AtomNode start="(1200, 3)" end="(1200, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1200, 8)" end="(1200, 29)">
                      <AtomNode start="(1200, 8)" end="(1200, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1200, 9)" end="(1200, 28)">
                        <OtherNode start="(1200, 9)" end="(1200, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1200, 9)" end="(1200, 28)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1200, 28)" end="(1200, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1202, 1)" end="(1204, 29)" name="lookup_isSome_iff" full_name="List.lookup_isSome_iff">
      <CommandDeclmodifiersNode start="(1202, 1)" end="(1202, 8)">
        <NullNode/>
        <NullNode start="(1202, 1)" end="(1202, 8)">
          <OtherNode start="(1202, 1)" end="(1202, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1202, 1)" end="(1202, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1202, 3)" end="(1202, 7)">
              <OtherNode start="(1202, 3)" end="(1202, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1202, 3)" end="(1202, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1202, 3)" end="(1202, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1202, 7)" end="(1202, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1202, 9)" end="(1204, 29)" name="lookup_isSome_iff" full_name="List.lookup_isSome_iff" _is_private_decl="False">
        <AtomNode start="(1202, 9)" end="(1202, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1202, 17)" end="(1202, 34)">
          <IdentNode start="(1202, 17)" end="(1202, 34)" leading="" trailing=" " raw_val="lookup_isSome_iff" val="lookup_isSome_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1202, 35)" end="(1203, 44)">
          <NullNode start="(1202, 35)" end="(1202, 61)">
            <OtherNode start="(1202, 35)" end="(1202, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1202, 35)" end="(1202, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(1202, 36)" end="(1202, 37)">
                <IdentNode start="(1202, 36)" end="(1202, 37)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1202, 38)" end="(1202, 52)">
                <AtomNode start="(1202, 38)" end="(1202, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1202, 40)" end="(1202, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1202, 40)" end="(1202, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1202, 45)" end="(1202, 52)">
                    <OtherNode start="(1202, 45)" end="(1202, 52)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1202, 45)" end="(1202, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(1202, 46)" end="(1202, 51)" kind="«term_×_»">
                        <IdentNode start="(1202, 46)" end="(1202, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1202, 48)" end="(1202, 49)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1202, 50)" end="(1202, 51)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1202, 51)" end="(1202, 52)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1202, 52)" end="(1202, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1202, 54)" end="(1202, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1202, 54)" end="(1202, 55)" leading="" trailing="" val="{"/>
              <NullNode start="(1202, 55)" end="(1202, 56)">
                <IdentNode start="(1202, 55)" end="(1202, 56)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1202, 57)" end="(1202, 60)">
                <AtomNode start="(1202, 57)" end="(1202, 58)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1202, 59)" end="(1202, 60)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1202, 60)" end="(1202, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1202, 62)" end="(1203, 44)">
            <AtomNode start="(1202, 62)" end="(1202, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1203, 5)" end="(1203, 44)" kind="«term_↔_»">
              <OtherNode start="(1203, 5)" end="(1203, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1203, 5)" end="(1203, 17)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1203, 5)" end="(1203, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1203, 6)" end="(1203, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1203, 6)" end="(1203, 14)" leading="" trailing=" " raw_val="l.lookup" val="l.lookup"/>
                    <NullNode start="(1203, 15)" end="(1203, 16)">
                      <IdentNode start="(1203, 15)" end="(1203, 16)" leading="" trailing="" raw_val="k" val="k"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1203, 16)" end="(1203, 17)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1203, 17)" end="(1203, 18)" leading="" trailing="" val="."/>
                <IdentNode start="(1203, 18)" end="(1203, 24)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1203, 25)" end="(1203, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1203, 27)" end="(1203, 44)" kind="Lean.«term∃__,_»">
                <AtomNode start="(1203, 27)" end="(1203, 28)" leading="" trailing=" " val="∃"/>
                <LeanBinderidentNode start="(1203, 29)" end="(1203, 30)">
                  <IdentNode start="(1203, 29)" end="(1203, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                </LeanBinderidentNode>
                <OtherNode start="(1203, 31)" end="(1203, 34)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(1203, 31)" end="(1203, 32)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(1203, 33)" end="(1203, 34)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(1203, 34)" end="(1203, 35)" leading="" trailing=" " val=","/>
                <OtherNode start="(1203, 36)" end="(1203, 44)" kind="«term_==_»">
                  <IdentNode start="(1203, 36)" end="(1203, 37)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(1203, 38)" end="(1203, 40)" leading="" trailing=" " val="=="/>
                  <OtherNode start="(1203, 41)" end="(1203, 44)" kind="Lean.Parser.Term.proj">
                    <IdentNode start="(1203, 41)" end="(1203, 42)" leading="" trailing="" raw_val="p" val="p"/>
                    <AtomNode start="(1203, 42)" end="(1203, 43)" leading="" trailing="" val="."/>
                    <OtherNode start="(1203, 43)" end="(1203, 44)" kind="fieldIdx">
                      <AtomNode start="(1203, 43)" end="(1203, 44)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1203, 45)" end="(1204, 29)">
          <AtomNode start="(1203, 45)" end="(1203, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1203, 48)" end="(1204, 29)">
            <AtomNode start="(1203, 48)" end="(1203, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1204, 3)" end="(1204, 29)">
              <TacticTacticseq1IndentedNode start="(1204, 3)" end="(1204, 29)">
                <NullNode start="(1204, 3)" end="(1204, 29)">
                  <OtherNode start="(1204, 3)" end="(1204, 29)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;⊢ (lookup k l).isSome = true ↔ ∃ p, p ∈ l ∧ (k == p.fst) = true" state_after="no goals" tactic="simp [lookup_eq_findSome?]">
                    <AtomNode start="(1204, 3)" end="(1204, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1204, 8)" end="(1204, 29)">
                      <AtomNode start="(1204, 8)" end="(1204, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1204, 9)" end="(1204, 28)">
                        <OtherNode start="(1204, 9)" end="(1204, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1204, 9)" end="(1204, 28)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1204, 28)" end="(1204, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1206, 1)" end="(1216, 59)" name="lookup_eq_some_iff" full_name="List.lookup_eq_some_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1206, 1)" end="(1216, 59)" name="lookup_eq_some_iff" full_name="List.lookup_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(1206, 1)" end="(1206, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1206, 9)" end="(1206, 27)">
          <IdentNode start="(1206, 9)" end="(1206, 27)" leading="" trailing=" " raw_val="lookup_eq_some_iff" val="lookup_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1206, 28)" end="(1207, 79)">
          <NullNode start="(1206, 28)" end="(1206, 62)">
            <OtherNode start="(1206, 28)" end="(1206, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1206, 28)" end="(1206, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(1206, 29)" end="(1206, 30)">
                <IdentNode start="(1206, 29)" end="(1206, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(1206, 31)" end="(1206, 45)">
                <AtomNode start="(1206, 31)" end="(1206, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1206, 33)" end="(1206, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1206, 33)" end="(1206, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1206, 38)" end="(1206, 45)">
                    <OtherNode start="(1206, 38)" end="(1206, 45)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1206, 38)" end="(1206, 39)" leading="" trailing="" val="("/>
                      <OtherNode start="(1206, 39)" end="(1206, 44)" kind="«term_×_»">
                        <IdentNode start="(1206, 39)" end="(1206, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1206, 41)" end="(1206, 42)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1206, 43)" end="(1206, 44)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1206, 44)" end="(1206, 45)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1206, 45)" end="(1206, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1206, 47)" end="(1206, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1206, 47)" end="(1206, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(1206, 48)" end="(1206, 49)">
                <IdentNode start="(1206, 48)" end="(1206, 49)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1206, 50)" end="(1206, 53)">
                <AtomNode start="(1206, 50)" end="(1206, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1206, 52)" end="(1206, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1206, 53)" end="(1206, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1206, 55)" end="(1206, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1206, 55)" end="(1206, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(1206, 56)" end="(1206, 57)">
                <IdentNode start="(1206, 56)" end="(1206, 57)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(1206, 58)" end="(1206, 61)">
                <AtomNode start="(1206, 58)" end="(1206, 59)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1206, 60)" end="(1206, 61)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(1206, 61)" end="(1206, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1206, 63)" end="(1207, 79)">
            <AtomNode start="(1206, 63)" end="(1206, 64)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1207, 5)" end="(1207, 79)" kind="«term_↔_»">
              <OtherNode start="(1207, 5)" end="(1207, 24)" kind="«term_=_»">
                <OtherNode start="(1207, 5)" end="(1207, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1207, 5)" end="(1207, 13)" leading="" trailing=" " raw_val="l.lookup" val="l.lookup"/>
                  <NullNode start="(1207, 14)" end="(1207, 15)">
                    <IdentNode start="(1207, 14)" end="(1207, 15)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1207, 16)" end="(1207, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(1207, 18)" end="(1207, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1207, 18)" end="(1207, 22)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1207, 23)" end="(1207, 24)">
                    <IdentNode start="(1207, 23)" end="(1207, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(1207, 25)" end="(1207, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(1207, 27)" end="(1207, 79)" kind="«term∃_,_»">
                <AtomNode start="(1207, 27)" end="(1207, 28)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(1207, 29)" end="(1207, 34)" kind="Lean.explicitBinders">
                  <OtherNode start="(1207, 29)" end="(1207, 34)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(1207, 29)" end="(1207, 34)">
                      <LeanBinderidentNode start="(1207, 29)" end="(1207, 31)">
                        <IdentNode start="(1207, 29)" end="(1207, 31)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(1207, 32)" end="(1207, 34)">
                        <IdentNode start="(1207, 32)" end="(1207, 34)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1207, 34)" end="(1207, 35)" leading="" trailing=" " val=","/>
                <OtherNode start="(1207, 36)" end="(1207, 79)" kind="«term_∧_»">
                  <OtherNode start="(1207, 36)" end="(1207, 58)" kind="«term_=_»">
                    <IdentNode start="(1207, 36)" end="(1207, 37)" leading="" trailing=" " raw_val="l" val="l"/>
                    <AtomNode start="(1207, 38)" end="(1207, 39)" leading="" trailing=" " val="="/>
                    <OtherNode start="(1207, 40)" end="(1207, 58)" kind="«term_++_»">
                      <IdentNode start="(1207, 40)" end="(1207, 42)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(1207, 43)" end="(1207, 45)" leading="" trailing=" " val="++"/>
                      <OtherNode start="(1207, 46)" end="(1207, 58)" kind="«term_::_»">
                        <OtherNode start="(1207, 46)" end="(1207, 52)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(1207, 46)" end="(1207, 47)" leading="" trailing="" val="("/>
                          <NullNode start="(1207, 47)" end="(1207, 51)">
                            <IdentNode start="(1207, 47)" end="(1207, 48)" leading="" trailing="" raw_val="k" val="k"/>
                            <AtomNode start="(1207, 48)" end="(1207, 49)" leading="" trailing=" " val=","/>
                            <NullNode start="(1207, 50)" end="(1207, 51)">
                              <IdentNode start="(1207, 50)" end="(1207, 51)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(1207, 51)" end="(1207, 52)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(1207, 53)" end="(1207, 55)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(1207, 56)" end="(1207, 58)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(1207, 59)" end="(1207, 60)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(1207, 61)" end="(1207, 79)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(1207, 61)" end="(1207, 62)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(1207, 63)" end="(1207, 64)">
                      <IdentNode start="(1207, 63)" end="(1207, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(1207, 65)" end="(1207, 69)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(1207, 65)" end="(1207, 66)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(1207, 67)" end="(1207, 69)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                    </OtherNode>
                    <AtomNode start="(1207, 69)" end="(1207, 70)" leading="" trailing=" " val=","/>
                    <OtherNode start="(1207, 71)" end="(1207, 79)" kind="«term_!=_»">
                      <IdentNode start="(1207, 71)" end="(1207, 72)" leading="" trailing=" " raw_val="k" val="k"/>
                      <AtomNode start="(1207, 73)" end="(1207, 75)" leading="" trailing=" " val="!="/>
                      <OtherNode start="(1207, 76)" end="(1207, 79)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(1207, 76)" end="(1207, 77)" leading="" trailing="" raw_val="p" val="p"/>
                        <AtomNode start="(1207, 77)" end="(1207, 78)" leading="" trailing="" val="."/>
                        <OtherNode start="(1207, 78)" end="(1207, 79)" kind="fieldIdx">
                          <AtomNode start="(1207, 78)" end="(1207, 79)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1207, 80)" end="(1216, 59)">
          <AtomNode start="(1207, 80)" end="(1207, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1207, 83)" end="(1216, 59)">
            <AtomNode start="(1207, 83)" end="(1207, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1208, 3)" end="(1216, 59)">
              <TacticTacticseq1IndentedNode start="(1208, 3)" end="(1216, 59)">
                <NullNode start="(1208, 3)" end="(1216, 59)">
                  <OtherNode start="(1208, 3)" end="(1208, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ lookup k l = some b ↔ ∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true" state_after="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none) ↔&#10;    ∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true" tactic="simp only [lookup_eq_findSome?, findSome?_eq_some_iff]">
                    <AtomNode start="(1208, 3)" end="(1208, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1208, 8)" end="(1208, 12)">
                      <AtomNode start="(1208, 8)" end="(1208, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1208, 13)" end="(1208, 57)">
                      <AtomNode start="(1208, 13)" end="(1208, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1208, 14)" end="(1208, 56)">
                        <OtherNode start="(1208, 14)" end="(1208, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1208, 14)" end="(1208, 33)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                        <AtomNode start="(1208, 33)" end="(1208, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1208, 35)" end="(1208, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1208, 35)" end="(1208, 56)" leading="" trailing="" raw_val="findSome?_eq_some_iff" val="findSome?_eq_some_iff" full_name="List.findSome?_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(60, 9)" def_end="(60, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1208, 56)" end="(1208, 57)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1209, 3)" end="(1209, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none) ↔&#10;    ∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true" state_after="case mp&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none) →&#10;    ∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true&#10;&#10;case mpr&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true) →&#10;    ∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none" tactic="constructor">
                    <AtomNode start="(1209, 3)" end="(1209, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1210, 3)" end="(1214, 43)" kind="Lean.cdot" state_before="case mp&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none) →&#10;    ∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true&#10;&#10;case mpr&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true) →&#10;    ∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none" state_after="case mpr&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true) →&#10;    ∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none" tactic="· rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩&#10;  simp only [beq_iff_eq, Option.ite_none_right_eq_some, Option.some.injEq] at h₁&#10;  obtain ⟨rfl, rfl⟩ := h₁&#10;  simp at h₂&#10;  exact ⟨l₁, l₂, rfl, by simpa using h₂⟩">
                    <OtherNode start="(1210, 3)" end="(1210, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1210, 3)" end="(1210, 4)" kind="patternIgnore">
                        <OtherNode start="(1210, 3)" end="(1210, 4)" kind="token.«· »">
                          <AtomNode start="(1210, 3)" end="(1210, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1210, 5)" end="(1214, 43)">
                      <TacticTacticseq1IndentedNode start="(1210, 5)" end="(1214, 43)">
                        <NullNode start="(1210, 5)" end="(1214, 43)">
                          <OtherNode start="(1210, 5)" end="(1210, 36)" kind="Lean.Parser.Tactic.rintro" state_before="case mp&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none) →&#10;    ∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true" state_after="case mp.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₁ : (if (k == a.fst) = true then some a.snd else none) = some b&#10;h₂ : ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (k, b) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (k != p.fst) = true" tactic="rintro ⟨l₁, a, l₂, rfl, h₁, h₂⟩">
                            <AtomNode start="(1210, 5)" end="(1210, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(1210, 12)" end="(1210, 36)">
                              <OtherNode start="(1210, 12)" end="(1210, 36)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1210, 12)" end="(1210, 36)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(1210, 12)" end="(1210, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(1210, 13)" end="(1210, 35)">
                                    <OtherNode start="(1210, 13)" end="(1210, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1210, 13)" end="(1210, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1210, 13)" end="(1210, 15)">
                                          <OtherNode start="(1210, 13)" end="(1210, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1210, 13)" end="(1210, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1210, 15)" end="(1210, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1210, 17)" end="(1210, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1210, 17)" end="(1210, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1210, 17)" end="(1210, 18)">
                                          <OtherNode start="(1210, 17)" end="(1210, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1210, 17)" end="(1210, 18)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1210, 18)" end="(1210, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1210, 20)" end="(1210, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1210, 20)" end="(1210, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1210, 20)" end="(1210, 22)">
                                          <OtherNode start="(1210, 20)" end="(1210, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1210, 20)" end="(1210, 22)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1210, 22)" end="(1210, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1210, 24)" end="(1210, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1210, 24)" end="(1210, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1210, 24)" end="(1210, 27)">
                                          <OtherNode start="(1210, 24)" end="(1210, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1210, 24)" end="(1210, 27)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1210, 27)" end="(1210, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1210, 29)" end="(1210, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1210, 29)" end="(1210, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1210, 29)" end="(1210, 31)">
                                          <OtherNode start="(1210, 29)" end="(1210, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1210, 29)" end="(1210, 31)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1210, 31)" end="(1210, 32)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1210, 33)" end="(1210, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1210, 33)" end="(1210, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1210, 33)" end="(1210, 35)">
                                          <OtherNode start="(1210, 33)" end="(1210, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1210, 33)" end="(1210, 35)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(1210, 35)" end="(1210, 36)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1211, 5)" end="(1211, 83)" kind="Lean.Parser.Tactic.simp" state_before="case mp.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₁ : (if (k == a.fst) = true then some a.snd else none) = some b&#10;h₂ : ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (k, b) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (k != p.fst) = true" state_after="case mp.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none&#10;h₁ : k = a.fst ∧ a.snd = b&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (k, b) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (k != p.fst) = true" tactic="simp only [beq_iff_eq, Option.ite_none_right_eq_some, Option.some.injEq] at h₁">
                            <AtomNode start="(1211, 5)" end="(1211, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(1211, 10)" end="(1211, 14)">
                              <AtomNode start="(1211, 10)" end="(1211, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(1211, 15)" end="(1211, 77)">
                              <AtomNode start="(1211, 15)" end="(1211, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(1211, 16)" end="(1211, 76)">
                                <OtherNode start="(1211, 16)" end="(1211, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(1211, 16)" end="(1211, 26)" leading="" trailing="" raw_val="beq_iff_eq" val="beq_iff_eq" full_name="beq_iff_eq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(1211, 26)" end="(1211, 27)" leading="" trailing=" " val=","/>
                                <OtherNode start="(1211, 28)" end="(1211, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(1211, 28)" end="(1211, 57)" leading="" trailing="" raw_val="Option.ite_none_right_eq_some" val="Option.ite_none_right_eq_some" full_name="Option.ite_none_right_eq_some" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(1211, 57)" end="(1211, 58)" leading="" trailing=" " val=","/>
                                <OtherNode start="(1211, 59)" end="(1211, 76)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(1211, 59)" end="(1211, 76)" leading="" trailing="" raw_val="Option.some.injEq" val="Option.some.injEq" full_name="Option.some.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(1211, 76)" end="(1211, 77)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(1211, 78)" end="(1211, 83)">
                              <OtherNode start="(1211, 78)" end="(1211, 83)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(1211, 78)" end="(1211, 80)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(1211, 81)" end="(1211, 83)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(1211, 81)" end="(1211, 83)">
                                    <IdentNode start="(1211, 81)" end="(1211, 83)" leading="" trailing="&#10;    " raw_val="h₁" val="h₁"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1212, 5)" end="(1212, 28)" kind="Lean.Parser.Tactic.obtain" state_before="case mp.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none&#10;h₁ : k = a.fst ∧ a.snd = b&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (k, b) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (k != p.fst) = true" state_after="case mp.intro.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (x : α × β), x ∈ l₁ → (if (a.fst == x.fst) = true then some x.snd else none) = none&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (a.fst, a.snd) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (a.fst != p.fst) = true" tactic="obtain ⟨rfl, rfl⟩ := h₁">
                            <AtomNode start="(1212, 5)" end="(1212, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(1212, 12)" end="(1212, 22)">
                              <OtherNode start="(1212, 12)" end="(1212, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(1212, 12)" end="(1212, 22)">
                                  <OtherNode start="(1212, 12)" end="(1212, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(1212, 12)" end="(1212, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(1212, 13)" end="(1212, 21)">
                                      <OtherNode start="(1212, 13)" end="(1212, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(1212, 13)" end="(1212, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(1212, 13)" end="(1212, 16)">
                                            <OtherNode start="(1212, 13)" end="(1212, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(1212, 13)" end="(1212, 16)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1212, 16)" end="(1212, 17)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(1212, 18)" end="(1212, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(1212, 18)" end="(1212, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(1212, 18)" end="(1212, 21)">
                                            <OtherNode start="(1212, 18)" end="(1212, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(1212, 18)" end="(1212, 21)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(1212, 21)" end="(1212, 22)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(1212, 23)" end="(1212, 28)">
                              <AtomNode start="(1212, 23)" end="(1212, 25)" leading="" trailing=" " val=":="/>
                              <NullNode start="(1212, 26)" end="(1212, 28)">
                                <IdentNode start="(1212, 26)" end="(1212, 28)" leading="" trailing="&#10;    " raw_val="h₁" val="h₁"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1213, 5)" end="(1213, 15)" kind="Lean.Parser.Tactic.simp" state_before="case mp.intro.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (x : α × β), x ∈ l₁ → (if (a.fst == x.fst) = true then some x.snd else none) = none&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (a.fst, a.snd) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (a.fst != p.fst) = true" state_after="case mp.intro.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (a_1 : α) (b : β), (a_1, b) ∈ l₁ → ¬a.fst = a_1&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (a.fst, a.snd) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (a.fst != p.fst) = true" tactic="simp at h₂">
                            <AtomNode start="(1213, 5)" end="(1213, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(1213, 10)" end="(1213, 15)">
                              <OtherNode start="(1213, 10)" end="(1213, 15)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(1213, 10)" end="(1213, 12)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(1213, 13)" end="(1213, 15)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(1213, 13)" end="(1213, 15)">
                                    <IdentNode start="(1213, 13)" end="(1213, 15)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1214, 5)" end="(1214, 43)" kind="Lean.Parser.Tactic.exact" state_before="case mp.intro.intro.intro.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (a_1 : α) (b : β), (a_1, b) ∈ l₁ → ¬a.fst = a_1&#10;⊢ ∃ l₁_1 l₂_1, l₁ ++ a :: l₂ = l₁_1 ++ (a.fst, a.snd) :: l₂_1 ∧ ∀ (p : α × β), p ∈ l₁_1 → (a.fst != p.fst) = true" state_after="no goals" tactic="exact ⟨l₁, l₂, rfl, by simpa using h₂⟩">
                            <AtomNode start="(1214, 5)" end="(1214, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(1214, 11)" end="(1214, 43)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(1214, 11)" end="(1214, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(1214, 12)" end="(1214, 42)">
                                <IdentNode start="(1214, 12)" end="(1214, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(1214, 14)" end="(1214, 15)" leading="" trailing=" " val=","/>
                                <IdentNode start="(1214, 16)" end="(1214, 18)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(1214, 18)" end="(1214, 19)" leading="" trailing=" " val=","/>
                                <IdentNode start="(1214, 20)" end="(1214, 23)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <AtomNode start="(1214, 23)" end="(1214, 24)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(1214, 25)" end="(1214, 42)">
                                  <AtomNode start="(1214, 25)" end="(1214, 27)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(1214, 28)" end="(1214, 42)">
                                    <TacticTacticseq1IndentedNode start="(1214, 28)" end="(1214, 42)">
                                      <NullNode start="(1214, 28)" end="(1214, 42)">
                                        <OtherNode start="(1214, 28)" end="(1214, 42)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l₁ : List (α × β)&#10;a : α × β&#10;l₂ : List (α × β)&#10;h₂ : ∀ (a_1 : α) (b : β), (a_1, b) ∈ l₁ → ¬a.fst = a_1&#10;⊢ ∀ (p : α × β), p ∈ l₁ → (a.fst != p.fst) = true" state_after="no goals" tactic="simpa using h₂">
                                          <AtomNode start="(1214, 28)" end="(1214, 33)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(1214, 34)" end="(1214, 42)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(1214, 34)" end="(1214, 42)">
                                              <AtomNode start="(1214, 34)" end="(1214, 39)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(1214, 40)" end="(1214, 42)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(1214, 42)" end="(1214, 43)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1215, 3)" end="(1216, 59)" kind="Lean.cdot" state_before="case mpr&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true) →&#10;    ∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none" state_after="no goals" tactic="· rintro ⟨l₁, l₂, rfl, h⟩&#10;  exact ⟨l₁, (k, b), l₂, rfl, by simp, by simpa using h⟩">
                    <OtherNode start="(1215, 3)" end="(1215, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(1215, 3)" end="(1215, 4)" kind="patternIgnore">
                        <OtherNode start="(1215, 3)" end="(1215, 4)" kind="token.«· »">
                          <AtomNode start="(1215, 3)" end="(1215, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(1215, 5)" end="(1216, 59)">
                      <TacticTacticseq1IndentedNode start="(1215, 5)" end="(1216, 59)">
                        <NullNode start="(1215, 5)" end="(1216, 59)">
                          <OtherNode start="(1215, 5)" end="(1215, 28)" kind="Lean.Parser.Tactic.rintro" state_before="case mpr&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l : List (α × β)&#10;k : α&#10;b : β&#10;⊢ (∃ l₁ l₂, l = l₁ ++ (k, b) :: l₂ ∧ ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true) →&#10;    ∃ l₁ a l₂,&#10;      l = l₁ ++ a :: l₂ ∧&#10;        (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;          ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none" state_after="case mpr.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true&#10;⊢ ∃ l₁_1 a l₂_1,&#10;    l₁ ++ (k, b) :: l₂ = l₁_1 ++ a :: l₂_1 ∧&#10;      (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;        ∀ (x : α × β), x ∈ l₁_1 → (if (k == x.fst) = true then some x.snd else none) = none" tactic="rintro ⟨l₁, l₂, rfl, h⟩">
                            <AtomNode start="(1215, 5)" end="(1215, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(1215, 12)" end="(1215, 28)">
                              <OtherNode start="(1215, 12)" end="(1215, 28)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(1215, 12)" end="(1215, 28)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(1215, 12)" end="(1215, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(1215, 13)" end="(1215, 27)">
                                    <OtherNode start="(1215, 13)" end="(1215, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1215, 13)" end="(1215, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1215, 13)" end="(1215, 15)">
                                          <OtherNode start="(1215, 13)" end="(1215, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1215, 13)" end="(1215, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1215, 15)" end="(1215, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1215, 17)" end="(1215, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1215, 17)" end="(1215, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1215, 17)" end="(1215, 19)">
                                          <OtherNode start="(1215, 17)" end="(1215, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1215, 17)" end="(1215, 19)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1215, 19)" end="(1215, 20)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1215, 21)" end="(1215, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1215, 21)" end="(1215, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1215, 21)" end="(1215, 24)">
                                          <OtherNode start="(1215, 21)" end="(1215, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1215, 21)" end="(1215, 24)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(1215, 24)" end="(1215, 25)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(1215, 26)" end="(1215, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(1215, 26)" end="(1215, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(1215, 26)" end="(1215, 27)">
                                          <OtherNode start="(1215, 26)" end="(1215, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(1215, 26)" end="(1215, 27)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(1215, 27)" end="(1215, 28)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(1216, 5)" end="(1216, 59)" kind="Lean.Parser.Tactic.exact" state_before="case mpr.intro.intro.intro&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true&#10;⊢ ∃ l₁_1 a l₂_1,&#10;    l₁ ++ (k, b) :: l₂ = l₁_1 ++ a :: l₂_1 ∧&#10;      (if (k == a.fst) = true then some a.snd else none) = some b ∧&#10;        ∀ (x : α × β), x ∈ l₁_1 → (if (k == x.fst) = true then some x.snd else none) = none" state_after="no goals" tactic="exact ⟨l₁, (k, b), l₂, rfl, by simp, by simpa using h⟩">
                            <AtomNode start="(1216, 5)" end="(1216, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(1216, 11)" end="(1216, 59)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(1216, 11)" end="(1216, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(1216, 12)" end="(1216, 58)">
                                <IdentNode start="(1216, 12)" end="(1216, 14)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(1216, 14)" end="(1216, 15)" leading="" trailing=" " val=","/>
                                <OtherNode start="(1216, 16)" end="(1216, 22)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(1216, 16)" end="(1216, 17)" leading="" trailing="" val="("/>
                                  <NullNode start="(1216, 17)" end="(1216, 21)">
                                    <IdentNode start="(1216, 17)" end="(1216, 18)" leading="" trailing="" raw_val="k" val="k"/>
                                    <AtomNode start="(1216, 18)" end="(1216, 19)" leading="" trailing=" " val=","/>
                                    <NullNode start="(1216, 20)" end="(1216, 21)">
                                      <IdentNode start="(1216, 20)" end="(1216, 21)" leading="" trailing="" raw_val="b" val="b"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(1216, 21)" end="(1216, 22)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(1216, 22)" end="(1216, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(1216, 24)" end="(1216, 26)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(1216, 26)" end="(1216, 27)" leading="" trailing=" " val=","/>
                                <IdentNode start="(1216, 28)" end="(1216, 31)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <AtomNode start="(1216, 31)" end="(1216, 32)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(1216, 33)" end="(1216, 40)">
                                  <AtomNode start="(1216, 33)" end="(1216, 35)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(1216, 36)" end="(1216, 40)">
                                    <TacticTacticseq1IndentedNode start="(1216, 36)" end="(1216, 40)">
                                      <NullNode start="(1216, 36)" end="(1216, 40)">
                                        <OtherNode start="(1216, 36)" end="(1216, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true&#10;⊢ (if (k == (k, b).fst) = true then some (k, b).snd else none) = some b" state_after="no goals" tactic="simp">
                                          <AtomNode start="(1216, 36)" end="(1216, 40)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(1216, 40)" end="(1216, 41)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(1216, 42)" end="(1216, 58)">
                                  <AtomNode start="(1216, 42)" end="(1216, 44)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(1216, 45)" end="(1216, 58)">
                                    <TacticTacticseq1IndentedNode start="(1216, 45)" end="(1216, 58)">
                                      <NullNode start="(1216, 45)" end="(1216, 58)">
                                        <OtherNode start="(1216, 45)" end="(1216, 58)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : ∀ (p : α × β), p ∈ l₁ → (k != p.fst) = true&#10;⊢ ∀ (x : α × β), x ∈ l₁ → (if (k == x.fst) = true then some x.snd else none) = none" state_after="no goals" tactic="simpa using h">
                                          <AtomNode start="(1216, 45)" end="(1216, 50)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(1216, 51)" end="(1216, 58)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(1216, 51)" end="(1216, 58)">
                                              <AtomNode start="(1216, 51)" end="(1216, 56)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(1216, 57)" end="(1216, 58)" leading="" trailing="" raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(1216, 58)" end="(1216, 59)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1218, 1)" end="(1220, 47)" name="lookup_append" full_name="List.lookup_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1218, 1)" end="(1220, 47)" name="lookup_append" full_name="List.lookup_append" _is_private_decl="False">
        <AtomNode start="(1218, 1)" end="(1218, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1218, 9)" end="(1218, 22)">
          <IdentNode start="(1218, 9)" end="(1218, 22)" leading="" trailing=" " raw_val="lookup_append" val="lookup_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1218, 23)" end="(1219, 57)">
          <NullNode start="(1218, 23)" end="(1218, 53)">
            <OtherNode start="(1218, 23)" end="(1218, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1218, 23)" end="(1218, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(1218, 24)" end="(1218, 29)">
                <IdentNode start="(1218, 24)" end="(1218, 26)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1218, 27)" end="(1218, 29)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1218, 30)" end="(1218, 44)">
                <AtomNode start="(1218, 30)" end="(1218, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1218, 32)" end="(1218, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1218, 32)" end="(1218, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1218, 37)" end="(1218, 44)">
                    <OtherNode start="(1218, 37)" end="(1218, 44)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1218, 37)" end="(1218, 38)" leading="" trailing="" val="("/>
                      <OtherNode start="(1218, 38)" end="(1218, 43)" kind="«term_×_»">
                        <IdentNode start="(1218, 38)" end="(1218, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1218, 40)" end="(1218, 41)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1218, 42)" end="(1218, 43)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1218, 43)" end="(1218, 44)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1218, 44)" end="(1218, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(1218, 46)" end="(1218, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1218, 46)" end="(1218, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(1218, 47)" end="(1218, 48)">
                <IdentNode start="(1218, 47)" end="(1218, 48)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1218, 49)" end="(1218, 52)">
                <AtomNode start="(1218, 49)" end="(1218, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1218, 51)" end="(1218, 52)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1218, 52)" end="(1218, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1218, 54)" end="(1219, 57)">
            <AtomNode start="(1218, 54)" end="(1218, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1219, 5)" end="(1219, 57)" kind="«term_=_»">
              <OtherNode start="(1219, 5)" end="(1219, 24)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1219, 5)" end="(1219, 22)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1219, 5)" end="(1219, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1219, 5)" end="(1219, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1219, 6)" end="(1219, 14)" kind="«term_++_»">
                      <IdentNode start="(1219, 6)" end="(1219, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(1219, 9)" end="(1219, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(1219, 12)" end="(1219, 14)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </OtherNode>
                    <AtomNode start="(1219, 14)" end="(1219, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1219, 15)" end="(1219, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(1219, 16)" end="(1219, 22)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1219, 23)" end="(1219, 24)">
                  <IdentNode start="(1219, 23)" end="(1219, 24)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1219, 25)" end="(1219, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(1219, 27)" end="(1219, 57)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1219, 27)" end="(1219, 43)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1219, 27)" end="(1219, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1219, 27)" end="(1219, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(1219, 28)" end="(1219, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1219, 28)" end="(1219, 37)" leading="" trailing=" " raw_val="l₁.lookup" val="l₁.lookup"/>
                      <NullNode start="(1219, 38)" end="(1219, 39)">
                        <IdentNode start="(1219, 38)" end="(1219, 39)" leading="" trailing="" raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1219, 39)" end="(1219, 40)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1219, 40)" end="(1219, 41)" leading="" trailing="" val="."/>
                  <IdentNode start="(1219, 41)" end="(1219, 43)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1219, 44)" end="(1219, 57)">
                  <OtherNode start="(1219, 44)" end="(1219, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1219, 44)" end="(1219, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(1219, 45)" end="(1219, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1219, 45)" end="(1219, 54)" leading="" trailing=" " raw_val="l₂.lookup" val="l₂.lookup"/>
                      <NullNode start="(1219, 55)" end="(1219, 56)">
                        <IdentNode start="(1219, 55)" end="(1219, 56)" leading="" trailing="" raw_val="k" val="k"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1219, 56)" end="(1219, 57)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1219, 58)" end="(1220, 47)">
          <AtomNode start="(1219, 58)" end="(1219, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1219, 61)" end="(1220, 47)">
            <AtomNode start="(1219, 61)" end="(1219, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1220, 3)" end="(1220, 47)">
              <TacticTacticseq1IndentedNode start="(1220, 3)" end="(1220, 47)">
                <NullNode start="(1220, 3)" end="(1220, 47)">
                  <OtherNode start="(1220, 3)" end="(1220, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;l₁ l₂ : List (α × β)&#10;k : α&#10;⊢ lookup k (l₁ ++ l₂) = (lookup k l₁).or (lookup k l₂)" state_after="no goals" tactic="simp [lookup_eq_findSome?, findSome?_append]">
                    <AtomNode start="(1220, 3)" end="(1220, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1220, 8)" end="(1220, 47)">
                      <AtomNode start="(1220, 8)" end="(1220, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1220, 9)" end="(1220, 46)">
                        <OtherNode start="(1220, 9)" end="(1220, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1220, 9)" end="(1220, 28)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                        <AtomNode start="(1220, 28)" end="(1220, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1220, 30)" end="(1220, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1220, 30)" end="(1220, 46)" leading="" trailing="" raw_val="findSome?_append" val="findSome?_append" full_name="List.findSome?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1220, 46)" end="(1220, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1222, 1)" end="(1228, 23)" name="lookup_replicate" full_name="List.lookup_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1222, 1)" end="(1228, 23)" name="lookup_replicate" full_name="List.lookup_replicate" _is_private_decl="False">
        <AtomNode start="(1222, 1)" end="(1222, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1222, 9)" end="(1222, 25)">
          <IdentNode start="(1222, 9)" end="(1222, 25)" leading="" trailing=" " raw_val="lookup_replicate" val="lookup_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1222, 26)" end="(1223, 91)">
          <NullNode start="(1222, 26)" end="(1222, 33)">
            <OtherNode start="(1222, 26)" end="(1222, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1222, 26)" end="(1222, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(1222, 27)" end="(1222, 28)">
                <IdentNode start="(1222, 27)" end="(1222, 28)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1222, 29)" end="(1222, 32)">
                <AtomNode start="(1222, 29)" end="(1222, 30)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1222, 31)" end="(1222, 32)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1222, 32)" end="(1222, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1222, 34)" end="(1223, 91)">
            <AtomNode start="(1222, 34)" end="(1222, 35)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1223, 5)" end="(1223, 91)" kind="«term_=_»">
              <OtherNode start="(1223, 5)" end="(1223, 33)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1223, 5)" end="(1223, 31)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1223, 5)" end="(1223, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1223, 5)" end="(1223, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1223, 6)" end="(1223, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1223, 6)" end="(1223, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(1223, 16)" end="(1223, 23)">
                        <IdentNode start="(1223, 16)" end="(1223, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(1223, 18)" end="(1223, 23)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(1223, 18)" end="(1223, 19)" leading="" trailing="" val="("/>
                          <NullNode start="(1223, 19)" end="(1223, 22)">
                            <IdentNode start="(1223, 19)" end="(1223, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(1223, 20)" end="(1223, 21)" leading="" trailing="" val=","/>
                            <NullNode start="(1223, 21)" end="(1223, 22)">
                              <IdentNode start="(1223, 21)" end="(1223, 22)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(1223, 22)" end="(1223, 23)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1223, 23)" end="(1223, 24)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1223, 24)" end="(1223, 25)" leading="" trailing="" val="."/>
                  <IdentNode start="(1223, 25)" end="(1223, 31)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1223, 32)" end="(1223, 33)">
                  <IdentNode start="(1223, 32)" end="(1223, 33)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1223, 34)" end="(1223, 35)" leading="" trailing=" " val="="/>
              <OtherNode start="(1223, 36)" end="(1223, 91)" kind="termIfThenElse">
                <AtomNode start="(1223, 36)" end="(1223, 38)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1223, 39)" end="(1223, 44)" kind="«term_=_»">
                  <IdentNode start="(1223, 39)" end="(1223, 40)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(1223, 41)" end="(1223, 42)" leading="" trailing=" " val="="/>
                  <OtherNode start="(1223, 43)" end="(1223, 44)" kind="num">
                    <AtomNode start="(1223, 43)" end="(1223, 44)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1223, 45)" end="(1223, 49)" leading="" trailing=" " val="then"/>
                <IdentNode start="(1223, 50)" end="(1223, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(1223, 55)" end="(1223, 59)" leading="" trailing=" " val="else"/>
                <OtherNode start="(1223, 60)" end="(1223, 91)" kind="termIfThenElse">
                  <AtomNode start="(1223, 60)" end="(1223, 62)" leading="" trailing=" " val="if"/>
                  <OtherNode start="(1223, 63)" end="(1223, 69)" kind="«term_==_»">
                    <IdentNode start="(1223, 63)" end="(1223, 64)" leading="" trailing=" " raw_val="k" val="k"/>
                    <AtomNode start="(1223, 65)" end="(1223, 67)" leading="" trailing=" " val="=="/>
                    <IdentNode start="(1223, 68)" end="(1223, 69)" leading="" trailing=" " raw_val="a" val="a"/>
                  </OtherNode>
                  <AtomNode start="(1223, 70)" end="(1223, 74)" leading="" trailing=" " val="then"/>
                  <OtherNode start="(1223, 75)" end="(1223, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1223, 75)" end="(1223, 79)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(1223, 80)" end="(1223, 81)">
                      <IdentNode start="(1223, 80)" end="(1223, 81)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1223, 82)" end="(1223, 86)" leading="" trailing=" " val="else"/>
                  <IdentNode start="(1223, 87)" end="(1223, 91)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1223, 92)" end="(1228, 23)">
          <AtomNode start="(1223, 92)" end="(1223, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1223, 95)" end="(1228, 23)">
            <AtomNode start="(1223, 95)" end="(1223, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1224, 3)" end="(1228, 23)">
              <TacticTacticseq1IndentedNode start="(1224, 3)" end="(1228, 23)">
                <NullNode start="(1224, 3)" end="(1228, 23)">
                  <OtherNode start="(1224, 3)" end="(1228, 23)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a : α&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;⊢ lookup k (replicate n (a, b)) = if n = 0 then none else if (k == a) = true then some b else none" state_after="no goals" tactic="induction n with&#10;| zero =&amp;gt; simp&#10;| succ n ih =&amp;gt;&#10;  simp only [replicate_succ, lookup_cons]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(1224, 3)" end="(1224, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(1224, 13)" end="(1224, 14)">
                      <OtherNode start="(1224, 13)" end="(1224, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(1224, 13)" end="(1224, 14)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1224, 15)" end="(1228, 23)">
                      <OtherNode start="(1224, 15)" end="(1228, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(1224, 15)" end="(1224, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(1225, 3)" end="(1228, 23)">
                          <OtherNode start="(1225, 3)" end="(1225, 17)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1225, 3)" end="(1225, 9)">
                              <OtherNode start="(1225, 3)" end="(1225, 9)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1225, 3)" end="(1225, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1225, 5)" end="(1225, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1225, 5)" end="(1225, 9)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1225, 10)" end="(1225, 17)">
                              <AtomNode start="(1225, 10)" end="(1225, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1225, 13)" end="(1225, 17)">
                                <TacticTacticseq1IndentedNode start="(1225, 13)" end="(1225, 17)">
                                  <NullNode start="(1225, 13)" end="(1225, 17)">
                                    <OtherNode start="(1225, 13)" end="(1225, 17)" kind="Lean.Parser.Tactic.simp" state_before="case zero&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;⊢ lookup k (replicate 0 (a, b)) = if 0 = 0 then none else if (k == a) = true then some b else none" state_after="no goals" tactic="simp">
                                      <AtomNode start="(1225, 13)" end="(1225, 17)" leading="" trailing="&#10;  " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(1226, 3)" end="(1228, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(1226, 3)" end="(1226, 14)">
                              <OtherNode start="(1226, 3)" end="(1226, 14)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(1226, 3)" end="(1226, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(1226, 5)" end="(1226, 9)">
                                  <NullNode/>
                                  <IdentNode start="(1226, 5)" end="(1226, 9)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                </GroupNode>
                                <NullNode start="(1226, 10)" end="(1226, 14)">
                                  <IdentNode start="(1226, 10)" end="(1226, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                                  <IdentNode start="(1226, 12)" end="(1226, 14)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(1226, 15)" end="(1228, 23)">
                              <AtomNode start="(1226, 15)" end="(1226, 17)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(1227, 5)" end="(1228, 23)">
                                <TacticTacticseq1IndentedNode start="(1227, 5)" end="(1228, 23)">
                                  <NullNode start="(1227, 5)" end="(1228, 23)">
                                    <OtherNode start="(1227, 5)" end="(1227, 44)" kind="Lean.Parser.Tactic.simp" state_before="case succ&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;n : Nat&#10;ih : lookup k (replicate n (a, b)) = if n = 0 then none else if (k == a) = true then some b else none&#10;⊢ lookup k (replicate (n + 1) (a, b)) = if n + 1 = 0 then none else if (k == a) = true then some b else none" state_after="case succ&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;n : Nat&#10;ih : lookup k (replicate n (a, b)) = if n = 0 then none else if (k == a) = true then some b else none&#10;⊢ (match k == a with&#10;    | true =&amp;gt; some b&#10;    | false =&amp;gt; lookup k (replicate n (a, b))) =&#10;    if n + 1 = 0 then none else if (k == a) = true then some b else none" tactic="simp only [replicate_succ, lookup_cons]">
                                      <AtomNode start="(1227, 5)" end="(1227, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(1227, 10)" end="(1227, 14)">
                                        <AtomNode start="(1227, 10)" end="(1227, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(1227, 15)" end="(1227, 44)">
                                        <AtomNode start="(1227, 15)" end="(1227, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(1227, 16)" end="(1227, 43)">
                                          <OtherNode start="(1227, 16)" end="(1227, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1227, 16)" end="(1227, 30)" leading="" trailing="" raw_val="replicate_succ" val="replicate_succ" full_name="List.replicate_succ" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(1227, 30)" end="(1227, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(1227, 32)" end="(1227, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(1227, 32)" end="(1227, 43)" leading="" trailing="" raw_val="lookup_cons" val="lookup_cons" full_name="List.lookup_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(1227, 43)" end="(1227, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(1228, 5)" end="(1228, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case succ&#10;α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;n : Nat&#10;ih : lookup k (replicate n (a, b)) = if n = 0 then none else if (k == a) = true then some b else none&#10;⊢ (match k == a with&#10;    | true =&amp;gt; some b&#10;    | false =&amp;gt; lookup k (replicate n (a, b))) =&#10;    if n + 1 = 0 then none else if (k == a) = true then some b else none" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(1228, 5)" end="(1228, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(1228, 5)" end="(1228, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(1228, 11)" end="(1228, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(1228, 15)" end="(1228, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(1228, 15)" end="(1228, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1230, 1)" end="(1232, 42)" name="lookup_replicate_of_pos" full_name="List.lookup_replicate_of_pos">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1230, 1)" end="(1232, 42)" name="lookup_replicate_of_pos" full_name="List.lookup_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(1230, 1)" end="(1230, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1230, 9)" end="(1230, 32)">
          <IdentNode start="(1230, 9)" end="(1230, 32)" leading="" trailing=" " raw_val="lookup_replicate_of_pos" val="lookup_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1230, 33)" end="(1231, 68)">
          <NullNode start="(1230, 33)" end="(1230, 52)">
            <OtherNode start="(1230, 33)" end="(1230, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1230, 33)" end="(1230, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(1230, 34)" end="(1230, 35)">
                <IdentNode start="(1230, 34)" end="(1230, 35)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1230, 36)" end="(1230, 39)">
                <AtomNode start="(1230, 36)" end="(1230, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1230, 38)" end="(1230, 39)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1230, 39)" end="(1230, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1230, 41)" end="(1230, 52)">
              <AtomNode start="(1230, 41)" end="(1230, 42)" leading="" trailing="" val="("/>
              <NullNode start="(1230, 42)" end="(1230, 43)">
                <IdentNode start="(1230, 42)" end="(1230, 43)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1230, 44)" end="(1230, 51)">
                <AtomNode start="(1230, 44)" end="(1230, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1230, 46)" end="(1230, 51)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(1230, 46)" end="(1230, 47)" kind="num">
                    <AtomNode start="(1230, 46)" end="(1230, 47)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(1230, 48)" end="(1230, 49)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(1230, 50)" end="(1230, 51)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1230, 51)" end="(1230, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1230, 53)" end="(1231, 68)">
            <AtomNode start="(1230, 53)" end="(1230, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1231, 5)" end="(1231, 68)" kind="«term_=_»">
              <OtherNode start="(1231, 5)" end="(1231, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1231, 5)" end="(1231, 32)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1231, 5)" end="(1231, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1231, 5)" end="(1231, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1231, 6)" end="(1231, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1231, 6)" end="(1231, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(1231, 16)" end="(1231, 24)">
                        <IdentNode start="(1231, 16)" end="(1231, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(1231, 18)" end="(1231, 24)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(1231, 18)" end="(1231, 19)" leading="" trailing="" val="("/>
                          <NullNode start="(1231, 19)" end="(1231, 23)">
                            <IdentNode start="(1231, 19)" end="(1231, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(1231, 20)" end="(1231, 21)" leading="" trailing=" " val=","/>
                            <NullNode start="(1231, 22)" end="(1231, 23)">
                              <IdentNode start="(1231, 22)" end="(1231, 23)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(1231, 23)" end="(1231, 24)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1231, 24)" end="(1231, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1231, 25)" end="(1231, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(1231, 26)" end="(1231, 32)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1231, 33)" end="(1231, 34)">
                  <IdentNode start="(1231, 33)" end="(1231, 34)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1231, 35)" end="(1231, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(1231, 37)" end="(1231, 68)" kind="termIfThenElse">
                <AtomNode start="(1231, 37)" end="(1231, 39)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1231, 40)" end="(1231, 46)" kind="«term_==_»">
                  <IdentNode start="(1231, 40)" end="(1231, 41)" leading="" trailing=" " raw_val="k" val="k"/>
                  <AtomNode start="(1231, 42)" end="(1231, 44)" leading="" trailing=" " val="=="/>
                  <IdentNode start="(1231, 45)" end="(1231, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                </OtherNode>
                <AtomNode start="(1231, 47)" end="(1231, 51)" leading="" trailing=" " val="then"/>
                <OtherNode start="(1231, 52)" end="(1231, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1231, 52)" end="(1231, 56)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1231, 57)" end="(1231, 58)">
                    <IdentNode start="(1231, 57)" end="(1231, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1231, 59)" end="(1231, 63)" leading="" trailing=" " val="else"/>
                <IdentNode start="(1231, 64)" end="(1231, 68)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1231, 69)" end="(1232, 42)">
          <AtomNode start="(1231, 69)" end="(1231, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1231, 72)" end="(1232, 42)">
            <AtomNode start="(1231, 72)" end="(1231, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1232, 3)" end="(1232, 42)">
              <TacticTacticseq1IndentedNode start="(1232, 3)" end="(1232, 42)">
                <NullNode start="(1232, 3)" end="(1232, 42)">
                  <OtherNode start="(1232, 3)" end="(1232, 42)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;a : α&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;h : 0 &amp;lt; n&#10;⊢ lookup k (replicate n (a, b)) = if (k == a) = true then some b else none" state_after="no goals" tactic="simp [lookup_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(1232, 3)" end="(1232, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1232, 8)" end="(1232, 42)">
                      <AtomNode start="(1232, 8)" end="(1232, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1232, 9)" end="(1232, 41)">
                        <OtherNode start="(1232, 9)" end="(1232, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1232, 9)" end="(1232, 25)" leading="" trailing="" raw_val="lookup_replicate" val="lookup_replicate" full_name="List.lookup_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1222, 9)" def_end="(1222, 25)"/>
                        </OtherNode>
                        <AtomNode start="(1232, 25)" end="(1232, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1232, 27)" end="(1232, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(1232, 27)" end="(1232, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(1232, 27)" end="(1232, 39)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(1232, 40)" end="(1232, 41)">
                              <IdentNode start="(1232, 40)" end="(1232, 41)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1232, 41)" end="(1232, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1234, 1)" end="(1236, 26)" name="lookup_replicate_self" full_name="List.lookup_replicate_self">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1234, 1)" end="(1236, 26)" name="lookup_replicate_self" full_name="List.lookup_replicate_self" _is_private_decl="False">
        <AtomNode start="(1234, 1)" end="(1234, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1234, 9)" end="(1234, 30)">
          <IdentNode start="(1234, 9)" end="(1234, 30)" leading="" trailing=" " raw_val="lookup_replicate_self" val="lookup_replicate_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1234, 31)" end="(1235, 67)">
          <NullNode start="(1234, 31)" end="(1234, 38)">
            <OtherNode start="(1234, 31)" end="(1234, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1234, 31)" end="(1234, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(1234, 32)" end="(1234, 33)">
                <IdentNode start="(1234, 32)" end="(1234, 33)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1234, 34)" end="(1234, 37)">
                <AtomNode start="(1234, 34)" end="(1234, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1234, 36)" end="(1234, 37)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1234, 37)" end="(1234, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(1234, 39)" end="(1235, 67)">
            <AtomNode start="(1234, 39)" end="(1234, 40)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1235, 5)" end="(1235, 67)" kind="«term_=_»">
              <OtherNode start="(1235, 5)" end="(1235, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1235, 5)" end="(1235, 32)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1235, 5)" end="(1235, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1235, 5)" end="(1235, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1235, 6)" end="(1235, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1235, 6)" end="(1235, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(1235, 16)" end="(1235, 24)">
                        <IdentNode start="(1235, 16)" end="(1235, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(1235, 18)" end="(1235, 24)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(1235, 18)" end="(1235, 19)" leading="" trailing="" val="("/>
                          <NullNode start="(1235, 19)" end="(1235, 23)">
                            <IdentNode start="(1235, 19)" end="(1235, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(1235, 20)" end="(1235, 21)" leading="" trailing=" " val=","/>
                            <NullNode start="(1235, 22)" end="(1235, 23)">
                              <IdentNode start="(1235, 22)" end="(1235, 23)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(1235, 23)" end="(1235, 24)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1235, 24)" end="(1235, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1235, 25)" end="(1235, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(1235, 26)" end="(1235, 32)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1235, 33)" end="(1235, 34)">
                  <IdentNode start="(1235, 33)" end="(1235, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1235, 35)" end="(1235, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(1235, 37)" end="(1235, 67)" kind="termIfThenElse">
                <AtomNode start="(1235, 37)" end="(1235, 39)" leading="" trailing=" " val="if"/>
                <OtherNode start="(1235, 40)" end="(1235, 45)" kind="«term_=_»">
                  <IdentNode start="(1235, 40)" end="(1235, 41)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(1235, 42)" end="(1235, 43)" leading="" trailing=" " val="="/>
                  <OtherNode start="(1235, 44)" end="(1235, 45)" kind="num">
                    <AtomNode start="(1235, 44)" end="(1235, 45)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1235, 46)" end="(1235, 50)" leading="" trailing=" " val="then"/>
                <IdentNode start="(1235, 51)" end="(1235, 55)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(1235, 56)" end="(1235, 60)" leading="" trailing=" " val="else"/>
                <OtherNode start="(1235, 61)" end="(1235, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1235, 61)" end="(1235, 65)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1235, 66)" end="(1235, 67)">
                    <IdentNode start="(1235, 66)" end="(1235, 67)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1235, 68)" end="(1236, 26)">
          <AtomNode start="(1235, 68)" end="(1235, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1235, 71)" end="(1236, 26)">
            <AtomNode start="(1235, 71)" end="(1235, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1236, 3)" end="(1236, 26)">
              <TacticTacticseq1IndentedNode start="(1236, 3)" end="(1236, 26)">
                <NullNode start="(1236, 3)" end="(1236, 26)">
                  <OtherNode start="(1236, 3)" end="(1236, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;α✝ : Type u_1&#10;b : α✝&#10;a : α&#10;⊢ lookup a (replicate n (a, b)) = if n = 0 then none else some b" state_after="no goals" tactic="simp [lookup_replicate]">
                    <AtomNode start="(1236, 3)" end="(1236, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1236, 8)" end="(1236, 26)">
                      <AtomNode start="(1236, 8)" end="(1236, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1236, 9)" end="(1236, 25)">
                        <OtherNode start="(1236, 9)" end="(1236, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1236, 9)" end="(1236, 25)" leading="" trailing="" raw_val="lookup_replicate" val="lookup_replicate" full_name="List.lookup_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1222, 9)" def_end="(1222, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1236, 25)" end="(1236, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1238, 1)" end="(1240, 47)" name="lookup_replicate_self_of_pos" full_name="List.lookup_replicate_self_of_pos">
      <CommandDeclmodifiersNode start="(1238, 1)" end="(1238, 8)">
        <NullNode/>
        <NullNode start="(1238, 1)" end="(1238, 8)">
          <OtherNode start="(1238, 1)" end="(1238, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1238, 1)" end="(1238, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1238, 3)" end="(1238, 7)">
              <OtherNode start="(1238, 3)" end="(1238, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1238, 3)" end="(1238, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1238, 3)" end="(1238, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1238, 7)" end="(1238, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1238, 9)" end="(1240, 47)" name="lookup_replicate_self_of_pos" full_name="List.lookup_replicate_self_of_pos" _is_private_decl="False">
        <AtomNode start="(1238, 9)" end="(1238, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1238, 17)" end="(1238, 45)">
          <IdentNode start="(1238, 17)" end="(1238, 45)" leading="" trailing=" " raw_val="lookup_replicate_self_of_pos" val="lookup_replicate_self_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1238, 46)" end="(1239, 43)">
          <NullNode start="(1238, 46)" end="(1238, 65)">
            <OtherNode start="(1238, 46)" end="(1238, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1238, 46)" end="(1238, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(1238, 47)" end="(1238, 48)">
                <IdentNode start="(1238, 47)" end="(1238, 48)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(1238, 49)" end="(1238, 52)">
                <AtomNode start="(1238, 49)" end="(1238, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1238, 51)" end="(1238, 52)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1238, 52)" end="(1238, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1238, 54)" end="(1238, 65)">
              <AtomNode start="(1238, 54)" end="(1238, 55)" leading="" trailing="" val="("/>
              <NullNode start="(1238, 55)" end="(1238, 56)">
                <IdentNode start="(1238, 55)" end="(1238, 56)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1238, 57)" end="(1238, 64)">
                <AtomNode start="(1238, 57)" end="(1238, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1238, 59)" end="(1238, 64)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(1238, 59)" end="(1238, 60)" kind="num">
                    <AtomNode start="(1238, 59)" end="(1238, 60)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(1238, 61)" end="(1238, 62)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(1238, 63)" end="(1238, 64)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1238, 64)" end="(1238, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1238, 66)" end="(1239, 43)">
            <AtomNode start="(1238, 66)" end="(1238, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1239, 5)" end="(1239, 43)" kind="«term_=_»">
              <OtherNode start="(1239, 5)" end="(1239, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1239, 5)" end="(1239, 32)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1239, 5)" end="(1239, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1239, 5)" end="(1239, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1239, 6)" end="(1239, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1239, 6)" end="(1239, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(1239, 16)" end="(1239, 24)">
                        <IdentNode start="(1239, 16)" end="(1239, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(1239, 18)" end="(1239, 24)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(1239, 18)" end="(1239, 19)" leading="" trailing="" val="("/>
                          <NullNode start="(1239, 19)" end="(1239, 23)">
                            <IdentNode start="(1239, 19)" end="(1239, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(1239, 20)" end="(1239, 21)" leading="" trailing=" " val=","/>
                            <NullNode start="(1239, 22)" end="(1239, 23)">
                              <IdentNode start="(1239, 22)" end="(1239, 23)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(1239, 23)" end="(1239, 24)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1239, 24)" end="(1239, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1239, 25)" end="(1239, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(1239, 26)" end="(1239, 32)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1239, 33)" end="(1239, 34)">
                  <IdentNode start="(1239, 33)" end="(1239, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1239, 35)" end="(1239, 36)" leading="" trailing=" " val="="/>
              <OtherNode start="(1239, 37)" end="(1239, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(1239, 37)" end="(1239, 41)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(1239, 42)" end="(1239, 43)">
                  <IdentNode start="(1239, 42)" end="(1239, 43)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1239, 44)" end="(1240, 47)">
          <AtomNode start="(1239, 44)" end="(1239, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1239, 47)" end="(1240, 47)">
            <AtomNode start="(1239, 47)" end="(1239, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1240, 3)" end="(1240, 47)">
              <TacticTacticseq1IndentedNode start="(1240, 3)" end="(1240, 47)">
                <NullNode start="(1240, 3)" end="(1240, 47)">
                  <OtherNode start="(1240, 3)" end="(1240, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;n : Nat&#10;α✝ : Type u_1&#10;b : α✝&#10;a : α&#10;h : 0 &amp;lt; n&#10;⊢ lookup a (replicate n (a, b)) = some b" state_after="no goals" tactic="simp [lookup_replicate_self, Nat.ne_of_gt h]">
                    <AtomNode start="(1240, 3)" end="(1240, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1240, 8)" end="(1240, 47)">
                      <AtomNode start="(1240, 8)" end="(1240, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(1240, 9)" end="(1240, 46)">
                        <OtherNode start="(1240, 9)" end="(1240, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1240, 9)" end="(1240, 30)" leading="" trailing="" raw_val="lookup_replicate_self" val="lookup_replicate_self" full_name="List.lookup_replicate_self" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1234, 9)" def_end="(1234, 30)"/>
                        </OtherNode>
                        <AtomNode start="(1240, 30)" end="(1240, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(1240, 32)" end="(1240, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(1240, 32)" end="(1240, 46)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(1240, 32)" end="(1240, 44)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(1240, 45)" end="(1240, 46)">
                              <IdentNode start="(1240, 45)" end="(1240, 46)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1240, 46)" end="(1240, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1242, 1)" end="(1244, 30)" name="lookup_replicate_ne" full_name="List.lookup_replicate_ne">
      <CommandDeclmodifiersNode start="(1242, 1)" end="(1242, 8)">
        <NullNode/>
        <NullNode start="(1242, 1)" end="(1242, 8)">
          <OtherNode start="(1242, 1)" end="(1242, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1242, 1)" end="(1242, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1242, 3)" end="(1242, 7)">
              <OtherNode start="(1242, 3)" end="(1242, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1242, 3)" end="(1242, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(1242, 3)" end="(1242, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1242, 7)" end="(1242, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1242, 9)" end="(1244, 30)" name="lookup_replicate_ne" full_name="List.lookup_replicate_ne" _is_private_decl="False">
        <AtomNode start="(1242, 9)" end="(1242, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1242, 17)" end="(1242, 36)">
          <IdentNode start="(1242, 17)" end="(1242, 36)" leading="" trailing=" " raw_val="lookup_replicate_ne" val="lookup_replicate_ne"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1242, 37)" end="(1243, 41)">
          <NullNode start="(1242, 37)" end="(1242, 58)">
            <OtherNode start="(1242, 37)" end="(1242, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1242, 37)" end="(1242, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(1242, 38)" end="(1242, 39)">
                <IdentNode start="(1242, 38)" end="(1242, 39)" leading="" trailing=" " raw_val="k" val="k"/>
              </NullNode>
              <NullNode start="(1242, 40)" end="(1242, 43)">
                <AtomNode start="(1242, 40)" end="(1242, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(1242, 42)" end="(1242, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(1242, 43)" end="(1242, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1242, 45)" end="(1242, 58)">
              <AtomNode start="(1242, 45)" end="(1242, 46)" leading="" trailing="" val="("/>
              <NullNode start="(1242, 46)" end="(1242, 47)">
                <IdentNode start="(1242, 46)" end="(1242, 47)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1242, 48)" end="(1242, 57)">
                <AtomNode start="(1242, 48)" end="(1242, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1242, 50)" end="(1242, 57)" kind="term!_">
                  <AtomNode start="(1242, 50)" end="(1242, 51)" leading="" trailing="" val="!"/>
                  <OtherNode start="(1242, 51)" end="(1242, 57)" kind="«term_==_»">
                    <IdentNode start="(1242, 51)" end="(1242, 52)" leading="" trailing=" " raw_val="k" val="k"/>
                    <AtomNode start="(1242, 53)" end="(1242, 55)" leading="" trailing=" " val="=="/>
                    <IdentNode start="(1242, 56)" end="(1242, 57)" leading="" trailing="" raw_val="a" val="a"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1242, 57)" end="(1242, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1242, 59)" end="(1243, 41)">
            <AtomNode start="(1242, 59)" end="(1242, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1243, 5)" end="(1243, 41)" kind="«term_=_»">
              <OtherNode start="(1243, 5)" end="(1243, 34)" kind="Lean.Parser.Term.app">
                <OtherNode start="(1243, 5)" end="(1243, 32)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(1243, 5)" end="(1243, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(1243, 5)" end="(1243, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(1243, 6)" end="(1243, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(1243, 6)" end="(1243, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="List.replicate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(1243, 16)" end="(1243, 24)">
                        <IdentNode start="(1243, 16)" end="(1243, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(1243, 18)" end="(1243, 24)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(1243, 18)" end="(1243, 19)" leading="" trailing="" val="("/>
                          <NullNode start="(1243, 19)" end="(1243, 23)">
                            <IdentNode start="(1243, 19)" end="(1243, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(1243, 20)" end="(1243, 21)" leading="" trailing=" " val=","/>
                            <NullNode start="(1243, 22)" end="(1243, 23)">
                              <IdentNode start="(1243, 22)" end="(1243, 23)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(1243, 23)" end="(1243, 24)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(1243, 24)" end="(1243, 25)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(1243, 25)" end="(1243, 26)" leading="" trailing="" val="."/>
                  <IdentNode start="(1243, 26)" end="(1243, 32)" leading="" trailing=" " raw_val="lookup" val="lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(1243, 33)" end="(1243, 34)">
                  <IdentNode start="(1243, 33)" end="(1243, 34)" leading="" trailing=" " raw_val="k" val="k"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1243, 35)" end="(1243, 36)" leading="" trailing=" " val="="/>
              <IdentNode start="(1243, 37)" end="(1243, 41)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1243, 42)" end="(1244, 30)">
          <AtomNode start="(1243, 42)" end="(1243, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1243, 45)" end="(1244, 30)">
            <AtomNode start="(1243, 45)" end="(1243, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1244, 3)" end="(1244, 30)">
              <TacticTacticseq1IndentedNode start="(1244, 3)" end="(1244, 30)">
                <NullNode start="(1244, 3)" end="(1244, 30)">
                  <OtherNode start="(1244, 3)" end="(1244, 30)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;a : α&#10;n : Nat&#10;α✝ : Type u_1&#10;b : α✝&#10;k : α&#10;h : (!k == a) = true&#10;⊢ lookup k (replicate n (a, b)) = none" state_after="no goals" tactic="simp_all [lookup_replicate]">
                    <AtomNode start="(1244, 3)" end="(1244, 11)" leading="" trailing=" " val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(1244, 12)" end="(1244, 30)">
                      <AtomNode start="(1244, 12)" end="(1244, 13)" leading="" trailing="" val="["/>
                      <NullNode start="(1244, 13)" end="(1244, 29)">
                        <OtherNode start="(1244, 13)" end="(1244, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1244, 13)" end="(1244, 29)" leading="" trailing="" raw_val="lookup_replicate" val="lookup_replicate" full_name="List.lookup_replicate" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1222, 9)" def_end="(1222, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1244, 29)" end="(1244, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1246, 1)" end="(1249, 27)" name="Sublist.lookup_isSome" full_name="List.Sublist.lookup_isSome">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1246, 1)" end="(1249, 27)" name="Sublist.lookup_isSome" full_name="List.Sublist.lookup_isSome" _is_private_decl="False">
        <AtomNode start="(1246, 1)" end="(1246, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1246, 9)" end="(1246, 30)">
          <IdentNode start="(1246, 9)" end="(1246, 30)" leading="" trailing=" " raw_val="Sublist.lookup_isSome" val="Sublist.lookup_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1246, 31)" end="(1247, 48)">
          <NullNode start="(1246, 31)" end="(1246, 68)">
            <OtherNode start="(1246, 31)" end="(1246, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1246, 31)" end="(1246, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(1246, 32)" end="(1246, 37)">
                <IdentNode start="(1246, 32)" end="(1246, 34)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1246, 35)" end="(1246, 37)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1246, 38)" end="(1246, 52)">
                <AtomNode start="(1246, 38)" end="(1246, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1246, 40)" end="(1246, 52)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1246, 40)" end="(1246, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1246, 45)" end="(1246, 52)">
                    <OtherNode start="(1246, 45)" end="(1246, 52)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1246, 45)" end="(1246, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(1246, 46)" end="(1246, 51)" kind="«term_×_»">
                        <IdentNode start="(1246, 46)" end="(1246, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1246, 48)" end="(1246, 49)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1246, 50)" end="(1246, 51)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1246, 51)" end="(1246, 52)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1246, 52)" end="(1246, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1246, 54)" end="(1246, 68)">
              <AtomNode start="(1246, 54)" end="(1246, 55)" leading="" trailing="" val="("/>
              <NullNode start="(1246, 55)" end="(1246, 56)">
                <IdentNode start="(1246, 55)" end="(1246, 56)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1246, 57)" end="(1246, 67)">
                <AtomNode start="(1246, 57)" end="(1246, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1246, 59)" end="(1246, 67)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(1246, 59)" end="(1246, 61)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(1246, 62)" end="(1246, 64)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(1246, 65)" end="(1246, 67)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1246, 67)" end="(1246, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1246, 69)" end="(1247, 48)">
            <AtomNode start="(1246, 69)" end="(1246, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1247, 5)" end="(1247, 48)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(1247, 5)" end="(1247, 25)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1247, 5)" end="(1247, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1247, 5)" end="(1247, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(1247, 6)" end="(1247, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1247, 6)" end="(1247, 15)" leading="" trailing=" " raw_val="l₁.lookup" val="l₁.lookup"/>
                    <NullNode start="(1247, 16)" end="(1247, 17)">
                      <IdentNode start="(1247, 16)" end="(1247, 17)" leading="" trailing="" raw_val="k" val="k"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1247, 17)" end="(1247, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1247, 18)" end="(1247, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(1247, 19)" end="(1247, 25)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(1247, 26)" end="(1247, 27)" leading="" trailing=" " val="→"/>
              <OtherNode start="(1247, 28)" end="(1247, 48)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(1247, 28)" end="(1247, 41)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(1247, 28)" end="(1247, 29)" leading="" trailing="" val="("/>
                  <OtherNode start="(1247, 29)" end="(1247, 40)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(1247, 29)" end="(1247, 38)" leading="" trailing=" " raw_val="l₂.lookup" val="l₂.lookup"/>
                    <NullNode start="(1247, 39)" end="(1247, 40)">
                      <IdentNode start="(1247, 39)" end="(1247, 40)" leading="" trailing="" raw_val="k" val="k"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(1247, 40)" end="(1247, 41)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1247, 41)" end="(1247, 42)" leading="" trailing="" val="."/>
                <IdentNode start="(1247, 42)" end="(1247, 48)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1247, 49)" end="(1249, 27)">
          <AtomNode start="(1247, 49)" end="(1247, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1247, 52)" end="(1249, 27)">
            <AtomNode start="(1247, 52)" end="(1247, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1248, 3)" end="(1249, 27)">
              <TacticTacticseq1IndentedNode start="(1248, 3)" end="(1249, 27)">
                <NullNode start="(1248, 3)" end="(1249, 27)">
                  <OtherNode start="(1248, 3)" end="(1248, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (lookup k l₁).isSome = true → (lookup k l₂).isSome = true" state_after="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₁).isSome = true →&#10;    (findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₂).isSome = true" tactic="simp only [lookup_eq_findSome?]">
                    <AtomNode start="(1248, 3)" end="(1248, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1248, 8)" end="(1248, 12)">
                      <AtomNode start="(1248, 8)" end="(1248, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1248, 13)" end="(1248, 34)">
                      <AtomNode start="(1248, 13)" end="(1248, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1248, 14)" end="(1248, 33)">
                        <OtherNode start="(1248, 14)" end="(1248, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1248, 14)" end="(1248, 33)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1248, 33)" end="(1248, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1249, 3)" end="(1249, 27)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ (findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₁).isSome = true →&#10;    (findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₂).isSome = true" state_after="no goals" tactic="exact h.findSome?_isSome">
                    <AtomNode start="(1249, 3)" end="(1249, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(1249, 9)" end="(1249, 27)" leading="" trailing="&#10;&#10;" raw_val="h.findSome?_isSome" val="h.findSome?_isSome"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1251, 1)" end="(1254, 28)" name="Sublist.lookup_eq_none" full_name="List.Sublist.lookup_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1251, 1)" end="(1254, 28)" name="Sublist.lookup_eq_none" full_name="List.Sublist.lookup_eq_none" _is_private_decl="False">
        <AtomNode start="(1251, 1)" end="(1251, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1251, 9)" end="(1251, 31)">
          <IdentNode start="(1251, 9)" end="(1251, 31)" leading="" trailing=" " raw_val="Sublist.lookup_eq_none" val="Sublist.lookup_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1251, 32)" end="(1252, 44)">
          <NullNode start="(1251, 32)" end="(1251, 69)">
            <OtherNode start="(1251, 32)" end="(1251, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1251, 32)" end="(1251, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(1251, 33)" end="(1251, 38)">
                <IdentNode start="(1251, 33)" end="(1251, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1251, 36)" end="(1251, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1251, 39)" end="(1251, 53)">
                <AtomNode start="(1251, 39)" end="(1251, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1251, 41)" end="(1251, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1251, 41)" end="(1251, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1251, 46)" end="(1251, 53)">
                    <OtherNode start="(1251, 46)" end="(1251, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1251, 46)" end="(1251, 47)" leading="" trailing="" val="("/>
                      <OtherNode start="(1251, 47)" end="(1251, 52)" kind="«term_×_»">
                        <IdentNode start="(1251, 47)" end="(1251, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1251, 49)" end="(1251, 50)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1251, 51)" end="(1251, 52)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1251, 52)" end="(1251, 53)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1251, 53)" end="(1251, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1251, 55)" end="(1251, 69)">
              <AtomNode start="(1251, 55)" end="(1251, 56)" leading="" trailing="" val="("/>
              <NullNode start="(1251, 56)" end="(1251, 57)">
                <IdentNode start="(1251, 56)" end="(1251, 57)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1251, 58)" end="(1251, 68)">
                <AtomNode start="(1251, 58)" end="(1251, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1251, 60)" end="(1251, 68)" kind="List.«term_&amp;lt;+_»">
                  <IdentNode start="(1251, 60)" end="(1251, 62)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(1251, 63)" end="(1251, 65)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(1251, 66)" end="(1251, 68)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1251, 68)" end="(1251, 69)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1251, 70)" end="(1252, 44)">
            <AtomNode start="(1251, 70)" end="(1251, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1252, 5)" end="(1252, 44)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(1252, 5)" end="(1252, 23)" kind="«term_=_»">
                <OtherNode start="(1252, 5)" end="(1252, 16)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1252, 5)" end="(1252, 14)" leading="" trailing=" " raw_val="l₂.lookup" val="l₂.lookup"/>
                  <NullNode start="(1252, 15)" end="(1252, 16)">
                    <IdentNode start="(1252, 15)" end="(1252, 16)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1252, 17)" end="(1252, 18)" leading="" trailing=" " val="="/>
                <IdentNode start="(1252, 19)" end="(1252, 23)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1252, 24)" end="(1252, 25)" leading="" trailing=" " val="→"/>
              <OtherNode start="(1252, 26)" end="(1252, 44)" kind="«term_=_»">
                <OtherNode start="(1252, 26)" end="(1252, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1252, 26)" end="(1252, 35)" leading="" trailing=" " raw_val="l₁.lookup" val="l₁.lookup"/>
                  <NullNode start="(1252, 36)" end="(1252, 37)">
                    <IdentNode start="(1252, 36)" end="(1252, 37)" leading="" trailing=" " raw_val="k" val="k"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1252, 38)" end="(1252, 39)" leading="" trailing=" " val="="/>
                <IdentNode start="(1252, 40)" end="(1252, 44)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1252, 45)" end="(1254, 28)">
          <AtomNode start="(1252, 45)" end="(1252, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1252, 48)" end="(1254, 28)">
            <AtomNode start="(1252, 48)" end="(1252, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1253, 3)" end="(1254, 28)">
              <TacticTacticseq1IndentedNode start="(1253, 3)" end="(1254, 28)">
                <NullNode start="(1253, 3)" end="(1254, 28)">
                  <OtherNode start="(1253, 3)" end="(1253, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ lookup k l₂ = none → lookup k l₁ = none" state_after="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₂ = none →&#10;    findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₁ = none" tactic="simp only [lookup_eq_findSome?]">
                    <AtomNode start="(1253, 3)" end="(1253, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1253, 8)" end="(1253, 12)">
                      <AtomNode start="(1253, 8)" end="(1253, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1253, 13)" end="(1253, 34)">
                      <AtomNode start="(1253, 13)" end="(1253, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1253, 14)" end="(1253, 33)">
                        <OtherNode start="(1253, 14)" end="(1253, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1253, 14)" end="(1253, 33)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1253, 33)" end="(1253, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1254, 3)" end="(1254, 28)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₂ = none →&#10;    findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₁ = none" state_after="no goals" tactic="exact h.findSome?_eq_none">
                    <AtomNode start="(1254, 3)" end="(1254, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(1254, 9)" end="(1254, 28)" leading="" trailing="&#10;&#10;" raw_val="h.findSome?_eq_none" val="h.findSome?_eq_none"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1256, 1)" end="(1259, 28)" name="IsPrefix.lookup_eq_some" full_name="List.IsPrefix.lookup_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1256, 1)" end="(1259, 28)" name="IsPrefix.lookup_eq_some" full_name="List.IsPrefix.lookup_eq_some" _is_private_decl="False">
        <AtomNode start="(1256, 1)" end="(1256, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1256, 9)" end="(1256, 32)">
          <IdentNode start="(1256, 9)" end="(1256, 32)" leading="" trailing=" " raw_val="IsPrefix.lookup_eq_some" val="IsPrefix.lookup_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1256, 33)" end="(1257, 58)">
          <NullNode start="(1256, 33)" end="(1256, 71)">
            <OtherNode start="(1256, 33)" end="(1256, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1256, 33)" end="(1256, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(1256, 34)" end="(1256, 39)">
                <IdentNode start="(1256, 34)" end="(1256, 36)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1256, 37)" end="(1256, 39)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1256, 40)" end="(1256, 54)">
                <AtomNode start="(1256, 40)" end="(1256, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1256, 42)" end="(1256, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1256, 42)" end="(1256, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1256, 47)" end="(1256, 54)">
                    <OtherNode start="(1256, 47)" end="(1256, 54)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1256, 47)" end="(1256, 48)" leading="" trailing="" val="("/>
                      <OtherNode start="(1256, 48)" end="(1256, 53)" kind="«term_×_»">
                        <IdentNode start="(1256, 48)" end="(1256, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1256, 50)" end="(1256, 51)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1256, 52)" end="(1256, 53)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1256, 53)" end="(1256, 54)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1256, 54)" end="(1256, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1256, 56)" end="(1256, 71)">
              <AtomNode start="(1256, 56)" end="(1256, 57)" leading="" trailing="" val="("/>
              <NullNode start="(1256, 57)" end="(1256, 58)">
                <IdentNode start="(1256, 57)" end="(1256, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1256, 59)" end="(1256, 70)">
                <AtomNode start="(1256, 59)" end="(1256, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1256, 61)" end="(1256, 70)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(1256, 61)" end="(1256, 63)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(1256, 64)" end="(1256, 67)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(1256, 68)" end="(1256, 70)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1256, 70)" end="(1256, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1256, 72)" end="(1257, 58)">
            <AtomNode start="(1256, 72)" end="(1256, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1257, 5)" end="(1257, 58)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(1257, 5)" end="(1257, 30)" kind="«term_=_»">
                <OtherNode start="(1257, 5)" end="(1257, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1257, 5)" end="(1257, 16)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1257, 17)" end="(1257, 21)">
                    <IdentNode start="(1257, 17)" end="(1257, 18)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1257, 19)" end="(1257, 21)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1257, 22)" end="(1257, 23)" leading="" trailing=" " val="="/>
                <OtherNode start="(1257, 24)" end="(1257, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1257, 24)" end="(1257, 28)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1257, 29)" end="(1257, 30)">
                    <IdentNode start="(1257, 29)" end="(1257, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(1257, 31)" end="(1257, 32)" leading="" trailing=" " val="→"/>
              <OtherNode start="(1257, 33)" end="(1257, 58)" kind="«term_=_»">
                <OtherNode start="(1257, 33)" end="(1257, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1257, 33)" end="(1257, 44)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1257, 45)" end="(1257, 49)">
                    <IdentNode start="(1257, 45)" end="(1257, 46)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1257, 47)" end="(1257, 49)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1257, 50)" end="(1257, 51)" leading="" trailing=" " val="="/>
                <OtherNode start="(1257, 52)" end="(1257, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1257, 52)" end="(1257, 56)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1257, 57)" end="(1257, 58)">
                    <IdentNode start="(1257, 57)" end="(1257, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1257, 59)" end="(1259, 28)">
          <AtomNode start="(1257, 59)" end="(1257, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(1257, 62)" end="(1259, 28)">
            <AtomNode start="(1257, 62)" end="(1257, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(1258, 3)" end="(1259, 28)">
              <TacticTacticseq1IndentedNode start="(1258, 3)" end="(1259, 28)">
                <NullNode start="(1258, 3)" end="(1259, 28)">
                  <OtherNode start="(1258, 3)" end="(1258, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ lookup k l₁ = some b → lookup k l₂ = some b" state_after="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₁ = some b →&#10;    findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₂ = some b" tactic="simp only [lookup_eq_findSome?]">
                    <AtomNode start="(1258, 3)" end="(1258, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(1258, 8)" end="(1258, 12)">
                      <AtomNode start="(1258, 8)" end="(1258, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(1258, 13)" end="(1258, 34)">
                      <AtomNode start="(1258, 13)" end="(1258, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(1258, 14)" end="(1258, 33)">
                        <OtherNode start="(1258, 14)" end="(1258, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(1258, 14)" end="(1258, 33)" leading="" trailing="" raw_val="lookup_eq_findSome?" val="lookup_eq_findSome?" full_name="List.lookup_eq_findSome?" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(1188, 9)" def_end="(1188, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(1258, 33)" end="(1258, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(1259, 3)" end="(1259, 28)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_2&#10;inst✝¹ : BEq α&#10;inst✝ : LawfulBEq α&#10;β : Type u_1&#10;k : α&#10;b : β&#10;l₁ l₂ : List (α × β)&#10;h : l₁ &amp;lt;+: l₂&#10;⊢ findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₁ = some b →&#10;    findSome? (fun p =&amp;gt; if (k == p.fst) = true then some p.snd else none) l₂ = some b" state_after="no goals" tactic="exact h.findSome?_eq_some">
                    <AtomNode start="(1259, 3)" end="(1259, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(1259, 9)" end="(1259, 28)" leading="" trailing="&#10;&#10;" raw_val="h.findSome?_eq_some" val="h.findSome?_eq_some"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1261, 1)" end="(1263, 27)" name="IsPrefix.lookup_eq_none" full_name="List.IsPrefix.lookup_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1261, 1)" end="(1263, 27)" name="IsPrefix.lookup_eq_none" full_name="List.IsPrefix.lookup_eq_none" _is_private_decl="False">
        <AtomNode start="(1261, 1)" end="(1261, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1261, 9)" end="(1261, 32)">
          <IdentNode start="(1261, 9)" end="(1261, 32)" leading="" trailing=" " raw_val="IsPrefix.lookup_eq_none" val="IsPrefix.lookup_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1261, 33)" end="(1262, 54)">
          <NullNode start="(1261, 33)" end="(1261, 71)">
            <OtherNode start="(1261, 33)" end="(1261, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1261, 33)" end="(1261, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(1261, 34)" end="(1261, 39)">
                <IdentNode start="(1261, 34)" end="(1261, 36)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1261, 37)" end="(1261, 39)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1261, 40)" end="(1261, 54)">
                <AtomNode start="(1261, 40)" end="(1261, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1261, 42)" end="(1261, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1261, 42)" end="(1261, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1261, 47)" end="(1261, 54)">
                    <OtherNode start="(1261, 47)" end="(1261, 54)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1261, 47)" end="(1261, 48)" leading="" trailing="" val="("/>
                      <OtherNode start="(1261, 48)" end="(1261, 53)" kind="«term_×_»">
                        <IdentNode start="(1261, 48)" end="(1261, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1261, 50)" end="(1261, 51)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1261, 52)" end="(1261, 53)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1261, 53)" end="(1261, 54)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1261, 54)" end="(1261, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1261, 56)" end="(1261, 71)">
              <AtomNode start="(1261, 56)" end="(1261, 57)" leading="" trailing="" val="("/>
              <NullNode start="(1261, 57)" end="(1261, 58)">
                <IdentNode start="(1261, 57)" end="(1261, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1261, 59)" end="(1261, 70)">
                <AtomNode start="(1261, 59)" end="(1261, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1261, 61)" end="(1261, 70)" kind="List.«term_&amp;lt;+:_»">
                  <IdentNode start="(1261, 61)" end="(1261, 63)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(1261, 64)" end="(1261, 67)" leading="" trailing=" " val="&amp;lt;+:"/>
                  <IdentNode start="(1261, 68)" end="(1261, 70)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1261, 70)" end="(1261, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1261, 72)" end="(1262, 54)">
            <AtomNode start="(1261, 72)" end="(1261, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1262, 5)" end="(1262, 54)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(1262, 5)" end="(1262, 28)" kind="«term_=_»">
                <OtherNode start="(1262, 5)" end="(1262, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1262, 5)" end="(1262, 16)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1262, 17)" end="(1262, 21)">
                    <IdentNode start="(1262, 17)" end="(1262, 18)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1262, 19)" end="(1262, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1262, 22)" end="(1262, 23)" leading="" trailing=" " val="="/>
                <IdentNode start="(1262, 24)" end="(1262, 28)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1262, 29)" end="(1262, 30)" leading="" trailing=" " val="→"/>
              <OtherNode start="(1262, 31)" end="(1262, 54)" kind="«term_=_»">
                <OtherNode start="(1262, 31)" end="(1262, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1262, 31)" end="(1262, 42)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1262, 43)" end="(1262, 47)">
                    <IdentNode start="(1262, 43)" end="(1262, 44)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1262, 45)" end="(1262, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1262, 48)" end="(1262, 49)" leading="" trailing=" " val="="/>
                <IdentNode start="(1262, 50)" end="(1262, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1262, 55)" end="(1263, 27)">
          <AtomNode start="(1262, 55)" end="(1262, 57)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(1263, 3)" end="(1263, 27)" leading="" trailing="&#10;" raw_val="h.sublist.lookup_eq_none" val="h.sublist.lookup_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1264, 1)" end="(1266, 27)" name="IsSuffix.lookup_eq_none" full_name="List.IsSuffix.lookup_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1264, 1)" end="(1266, 27)" name="IsSuffix.lookup_eq_none" full_name="List.IsSuffix.lookup_eq_none" _is_private_decl="False">
        <AtomNode start="(1264, 1)" end="(1264, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1264, 9)" end="(1264, 32)">
          <IdentNode start="(1264, 9)" end="(1264, 32)" leading="" trailing=" " raw_val="IsSuffix.lookup_eq_none" val="IsSuffix.lookup_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1264, 33)" end="(1265, 54)">
          <NullNode start="(1264, 33)" end="(1264, 71)">
            <OtherNode start="(1264, 33)" end="(1264, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1264, 33)" end="(1264, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(1264, 34)" end="(1264, 39)">
                <IdentNode start="(1264, 34)" end="(1264, 36)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1264, 37)" end="(1264, 39)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1264, 40)" end="(1264, 54)">
                <AtomNode start="(1264, 40)" end="(1264, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1264, 42)" end="(1264, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1264, 42)" end="(1264, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1264, 47)" end="(1264, 54)">
                    <OtherNode start="(1264, 47)" end="(1264, 54)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1264, 47)" end="(1264, 48)" leading="" trailing="" val="("/>
                      <OtherNode start="(1264, 48)" end="(1264, 53)" kind="«term_×_»">
                        <IdentNode start="(1264, 48)" end="(1264, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1264, 50)" end="(1264, 51)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1264, 52)" end="(1264, 53)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1264, 53)" end="(1264, 54)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1264, 54)" end="(1264, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1264, 56)" end="(1264, 71)">
              <AtomNode start="(1264, 56)" end="(1264, 57)" leading="" trailing="" val="("/>
              <NullNode start="(1264, 57)" end="(1264, 58)">
                <IdentNode start="(1264, 57)" end="(1264, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1264, 59)" end="(1264, 70)">
                <AtomNode start="(1264, 59)" end="(1264, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1264, 61)" end="(1264, 70)" kind="List.«term_&amp;lt;:+_»">
                  <IdentNode start="(1264, 61)" end="(1264, 63)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(1264, 64)" end="(1264, 67)" leading="" trailing=" " val="&amp;lt;:+"/>
                  <IdentNode start="(1264, 68)" end="(1264, 70)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1264, 70)" end="(1264, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1264, 72)" end="(1265, 54)">
            <AtomNode start="(1264, 72)" end="(1264, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1265, 5)" end="(1265, 54)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(1265, 5)" end="(1265, 28)" kind="«term_=_»">
                <OtherNode start="(1265, 5)" end="(1265, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1265, 5)" end="(1265, 16)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1265, 17)" end="(1265, 21)">
                    <IdentNode start="(1265, 17)" end="(1265, 18)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1265, 19)" end="(1265, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1265, 22)" end="(1265, 23)" leading="" trailing=" " val="="/>
                <IdentNode start="(1265, 24)" end="(1265, 28)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1265, 29)" end="(1265, 30)" leading="" trailing=" " val="→"/>
              <OtherNode start="(1265, 31)" end="(1265, 54)" kind="«term_=_»">
                <OtherNode start="(1265, 31)" end="(1265, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1265, 31)" end="(1265, 42)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1265, 43)" end="(1265, 47)">
                    <IdentNode start="(1265, 43)" end="(1265, 44)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1265, 45)" end="(1265, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1265, 48)" end="(1265, 49)" leading="" trailing=" " val="="/>
                <IdentNode start="(1265, 50)" end="(1265, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1265, 55)" end="(1266, 27)">
          <AtomNode start="(1265, 55)" end="(1265, 57)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(1266, 3)" end="(1266, 27)" leading="" trailing="&#10;" raw_val="h.sublist.lookup_eq_none" val="h.sublist.lookup_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1267, 1)" end="(1269, 27)" name="IsInfix.lookup_eq_none" full_name="List.IsInfix.lookup_eq_none">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(1267, 1)" end="(1269, 27)" name="IsInfix.lookup_eq_none" full_name="List.IsInfix.lookup_eq_none" _is_private_decl="False">
        <AtomNode start="(1267, 1)" end="(1267, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(1267, 9)" end="(1267, 31)">
          <IdentNode start="(1267, 9)" end="(1267, 31)" leading="" trailing=" " raw_val="IsInfix.lookup_eq_none" val="IsInfix.lookup_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(1267, 32)" end="(1268, 54)">
          <NullNode start="(1267, 32)" end="(1267, 71)">
            <OtherNode start="(1267, 32)" end="(1267, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(1267, 32)" end="(1267, 33)" leading="" trailing="" val="{"/>
              <NullNode start="(1267, 33)" end="(1267, 38)">
                <IdentNode start="(1267, 33)" end="(1267, 35)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(1267, 36)" end="(1267, 38)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(1267, 39)" end="(1267, 53)">
                <AtomNode start="(1267, 39)" end="(1267, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1267, 41)" end="(1267, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1267, 41)" end="(1267, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(1267, 46)" end="(1267, 53)">
                    <OtherNode start="(1267, 46)" end="(1267, 53)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(1267, 46)" end="(1267, 47)" leading="" trailing="" val="("/>
                      <OtherNode start="(1267, 47)" end="(1267, 52)" kind="«term_×_»">
                        <IdentNode start="(1267, 47)" end="(1267, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(1267, 49)" end="(1267, 50)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(1267, 51)" end="(1267, 52)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(1267, 52)" end="(1267, 53)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1267, 53)" end="(1267, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(1267, 55)" end="(1267, 71)">
              <AtomNode start="(1267, 55)" end="(1267, 56)" leading="" trailing="" val="("/>
              <NullNode start="(1267, 56)" end="(1267, 57)">
                <IdentNode start="(1267, 56)" end="(1267, 57)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(1267, 58)" end="(1267, 70)">
                <AtomNode start="(1267, 58)" end="(1267, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1267, 60)" end="(1267, 70)" kind="List.«term_&amp;lt;:+:_»">
                  <IdentNode start="(1267, 60)" end="(1267, 62)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(1267, 63)" end="(1267, 67)" leading="" trailing=" " val="&amp;lt;:+:"/>
                  <IdentNode start="(1267, 68)" end="(1267, 70)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(1267, 70)" end="(1267, 71)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(1267, 72)" end="(1268, 54)">
            <AtomNode start="(1267, 72)" end="(1267, 73)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(1268, 5)" end="(1268, 54)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(1268, 5)" end="(1268, 28)" kind="«term_=_»">
                <OtherNode start="(1268, 5)" end="(1268, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1268, 5)" end="(1268, 16)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1268, 17)" end="(1268, 21)">
                    <IdentNode start="(1268, 17)" end="(1268, 18)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1268, 19)" end="(1268, 21)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1268, 22)" end="(1268, 23)" leading="" trailing=" " val="="/>
                <IdentNode start="(1268, 24)" end="(1268, 28)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(1268, 29)" end="(1268, 30)" leading="" trailing=" " val="→"/>
              <OtherNode start="(1268, 31)" end="(1268, 54)" kind="«term_=_»">
                <OtherNode start="(1268, 31)" end="(1268, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(1268, 31)" end="(1268, 42)" leading="" trailing=" " raw_val="List.lookup" val="List.lookup" full_name="List.lookup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(1268, 43)" end="(1268, 47)">
                    <IdentNode start="(1268, 43)" end="(1268, 44)" leading="" trailing=" " raw_val="k" val="k"/>
                    <IdentNode start="(1268, 45)" end="(1268, 47)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(1268, 48)" end="(1268, 49)" leading="" trailing=" " val="="/>
                <IdentNode start="(1268, 50)" end="(1268, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(1268, 55)" end="(1269, 27)">
          <AtomNode start="(1268, 55)" end="(1268, 57)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(1269, 3)" end="(1269, 27)" leading="" trailing="&#10;&#10;" raw_val="h.sublist.lookup_eq_none" val="h.sublist.lookup_eq_none"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(1271, 1)" end="(1271, 11)" name="lookup">
      <AtomNode start="(1271, 1)" end="(1271, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1271, 5)" end="(1271, 11)">
        <IdentNode start="(1271, 5)" end="(1271, 11)" leading="" trailing="&#10;&#10;" raw_val="lookup" val="lookup"/>
      </NullNode>
    </CommandEndNode>
    <CommandModuledocNode start="(1273, 1)" end="(1273, 24)" comment="### Deprecations -/">
      <AtomNode start="(1273, 1)" end="(1273, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(1273, 5)" end="(1273, 24)" leading="" trailing="&#10;&#10;" val="### Deprecations -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(1275, 1)" end="(1275, 85)" name="head_join" full_name="List.head_join">
      <CommandDeclmodifiersNode start="(1275, 1)" end="(1275, 51)">
        <NullNode/>
        <NullNode start="(1275, 1)" end="(1275, 51)">
          <OtherNode start="(1275, 1)" end="(1275, 51)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1275, 1)" end="(1275, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1275, 3)" end="(1275, 50)">
              <OtherNode start="(1275, 3)" end="(1275, 50)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1275, 3)" end="(1275, 50)" kind="Lean.deprecated">
                  <AtomNode start="(1275, 3)" end="(1275, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1275, 14)" end="(1275, 26)">
                    <IdentNode start="(1275, 14)" end="(1275, 26)" leading="" trailing=" " raw_val="head_flatten" val="head_flatten" full_name="List.head_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(140, 9)" def_end="(140, 21)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1275, 27)" end="(1275, 50)">
                    <AtomNode start="(1275, 27)" end="(1275, 28)" leading="" trailing="" val="("/>
                    <AtomNode start="(1275, 28)" end="(1275, 33)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1275, 34)" end="(1275, 36)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1275, 37)" end="(1275, 49)" kind="str">
                      <AtomNode start="(1275, 37)" end="(1275, 49)" leading="" trailing="" val="&amp;quot;2024-10-14&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1275, 49)" end="(1275, 50)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1275, 50)" end="(1275, 51)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1275, 52)" end="(1275, 85)" name="head_join">
        <AtomNode start="(1275, 52)" end="(1275, 58)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1275, 59)" end="(1275, 68)">
          <IdentNode start="(1275, 59)" end="(1275, 68)" leading="" trailing=" " raw_val="head_join" val="head_join"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1275, 69)" end="(1275, 85)">
          <AtomNode start="(1275, 69)" end="(1275, 71)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1275, 72)" end="(1275, 85)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1275, 72)" end="(1275, 73)" leading="" trailing="" val="@"/>
            <IdentNode start="(1275, 73)" end="(1275, 85)" leading="" trailing="&#10;" raw_val="head_flatten" val="head_flatten" full_name="List.head_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(140, 9)" def_end="(140, 21)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1276, 1)" end="(1276, 94)" name="getLast_join" full_name="List.getLast_join">
      <CommandDeclmodifiersNode start="(1276, 1)" end="(1276, 54)">
        <NullNode/>
        <NullNode start="(1276, 1)" end="(1276, 54)">
          <OtherNode start="(1276, 1)" end="(1276, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1276, 1)" end="(1276, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1276, 3)" end="(1276, 53)">
              <OtherNode start="(1276, 3)" end="(1276, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1276, 3)" end="(1276, 53)" kind="Lean.deprecated">
                  <AtomNode start="(1276, 3)" end="(1276, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1276, 14)" end="(1276, 29)">
                    <IdentNode start="(1276, 14)" end="(1276, 29)" leading="" trailing=" " raw_val="getLast_flatten" val="getLast_flatten" full_name="List.getLast_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(144, 9)" def_end="(144, 24)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1276, 30)" end="(1276, 53)">
                    <AtomNode start="(1276, 30)" end="(1276, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(1276, 31)" end="(1276, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1276, 37)" end="(1276, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1276, 40)" end="(1276, 52)" kind="str">
                      <AtomNode start="(1276, 40)" end="(1276, 52)" leading="" trailing="" val="&amp;quot;2024-10-14&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1276, 52)" end="(1276, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1276, 53)" end="(1276, 54)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1276, 55)" end="(1276, 94)" name="getLast_join">
        <AtomNode start="(1276, 55)" end="(1276, 61)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1276, 62)" end="(1276, 74)">
          <IdentNode start="(1276, 62)" end="(1276, 74)" leading="" trailing=" " raw_val="getLast_join" val="getLast_join"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1276, 75)" end="(1276, 94)">
          <AtomNode start="(1276, 75)" end="(1276, 77)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1276, 78)" end="(1276, 94)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1276, 78)" end="(1276, 79)" leading="" trailing="" val="@"/>
            <IdentNode start="(1276, 79)" end="(1276, 94)" leading="" trailing="&#10;" raw_val="getLast_flatten" val="getLast_flatten" full_name="List.getLast_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(144, 9)" def_end="(144, 24)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1277, 1)" end="(1277, 88)" name="find?_join" full_name="List.find?_join">
      <CommandDeclmodifiersNode start="(1277, 1)" end="(1277, 52)">
        <NullNode/>
        <NullNode start="(1277, 1)" end="(1277, 52)">
          <OtherNode start="(1277, 1)" end="(1277, 52)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1277, 1)" end="(1277, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1277, 3)" end="(1277, 51)">
              <OtherNode start="(1277, 3)" end="(1277, 51)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1277, 3)" end="(1277, 51)" kind="Lean.deprecated">
                  <AtomNode start="(1277, 3)" end="(1277, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1277, 14)" end="(1277, 27)">
                    <IdentNode start="(1277, 14)" end="(1277, 27)" leading="" trailing=" " raw_val="find?_flatten" val="find?_flatten" full_name="List.find?_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(327, 17)" def_end="(327, 30)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1277, 28)" end="(1277, 51)">
                    <AtomNode start="(1277, 28)" end="(1277, 29)" leading="" trailing="" val="("/>
                    <AtomNode start="(1277, 29)" end="(1277, 34)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1277, 35)" end="(1277, 37)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1277, 38)" end="(1277, 50)" kind="str">
                      <AtomNode start="(1277, 38)" end="(1277, 50)" leading="" trailing="" val="&amp;quot;2024-10-14&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1277, 50)" end="(1277, 51)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1277, 51)" end="(1277, 52)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1277, 53)" end="(1277, 88)" name="find?_join">
        <AtomNode start="(1277, 53)" end="(1277, 59)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1277, 60)" end="(1277, 70)">
          <IdentNode start="(1277, 60)" end="(1277, 70)" leading="" trailing=" " raw_val="find?_join" val="find?_join"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1277, 71)" end="(1277, 88)">
          <AtomNode start="(1277, 71)" end="(1277, 73)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1277, 74)" end="(1277, 88)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1277, 74)" end="(1277, 75)" leading="" trailing="" val="@"/>
            <IdentNode start="(1277, 75)" end="(1277, 88)" leading="" trailing="&#10;" raw_val="find?_flatten" val="find?_flatten" full_name="List.find?_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(327, 17)" def_end="(327, 30)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1278, 1)" end="(1278, 116)" name="find?_join_eq_none" full_name="List.find?_join_eq_none">
      <CommandDeclmodifiersNode start="(1278, 1)" end="(1278, 60)">
        <NullNode/>
        <NullNode start="(1278, 1)" end="(1278, 60)">
          <OtherNode start="(1278, 1)" end="(1278, 60)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1278, 1)" end="(1278, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1278, 3)" end="(1278, 59)">
              <OtherNode start="(1278, 3)" end="(1278, 59)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1278, 3)" end="(1278, 59)" kind="Lean.deprecated">
                  <AtomNode start="(1278, 3)" end="(1278, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1278, 14)" end="(1278, 35)">
                    <IdentNode start="(1278, 14)" end="(1278, 35)" leading="" trailing=" " raw_val="find?_flatten_eq_none" val="find?_flatten_eq_none" full_name="List.find?_flatten_eq_none" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(340, 8)" def_end="(340, 29)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1278, 36)" end="(1278, 59)">
                    <AtomNode start="(1278, 36)" end="(1278, 37)" leading="" trailing="" val="("/>
                    <AtomNode start="(1278, 37)" end="(1278, 42)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1278, 43)" end="(1278, 45)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1278, 46)" end="(1278, 58)" kind="str">
                      <AtomNode start="(1278, 46)" end="(1278, 58)" leading="" trailing="" val="&amp;quot;2024-10-14&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1278, 58)" end="(1278, 59)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1278, 59)" end="(1278, 60)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1278, 61)" end="(1278, 116)" name="find?_join_eq_none">
        <AtomNode start="(1278, 61)" end="(1278, 67)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1278, 68)" end="(1278, 86)">
          <IdentNode start="(1278, 68)" end="(1278, 86)" leading="" trailing=" " raw_val="find?_join_eq_none" val="find?_join_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1278, 87)" end="(1278, 116)">
          <AtomNode start="(1278, 87)" end="(1278, 89)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1278, 90)" end="(1278, 116)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1278, 90)" end="(1278, 91)" leading="" trailing="" val="@"/>
            <IdentNode start="(1278, 91)" end="(1278, 116)" leading="" trailing="&#10;" raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff" full_name="List.find?_flatten_eq_none_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(335, 9)" def_end="(335, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1279, 1)" end="(1279, 116)" name="find?_join_eq_some" full_name="List.find?_join_eq_some">
      <CommandDeclmodifiersNode start="(1279, 1)" end="(1279, 60)">
        <NullNode/>
        <NullNode start="(1279, 1)" end="(1279, 60)">
          <OtherNode start="(1279, 1)" end="(1279, 60)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1279, 1)" end="(1279, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1279, 3)" end="(1279, 59)">
              <OtherNode start="(1279, 3)" end="(1279, 59)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1279, 3)" end="(1279, 59)" kind="Lean.deprecated">
                  <AtomNode start="(1279, 3)" end="(1279, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1279, 14)" end="(1279, 35)">
                    <IdentNode start="(1279, 14)" end="(1279, 35)" leading="" trailing=" " raw_val="find?_flatten_eq_some" val="find?_flatten_eq_some" full_name="List.find?_flatten_eq_some" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(383, 8)" def_end="(383, 29)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1279, 36)" end="(1279, 59)">
                    <AtomNode start="(1279, 36)" end="(1279, 37)" leading="" trailing="" val="("/>
                    <AtomNode start="(1279, 37)" end="(1279, 42)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1279, 43)" end="(1279, 45)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1279, 46)" end="(1279, 58)" kind="str">
                      <AtomNode start="(1279, 46)" end="(1279, 58)" leading="" trailing="" val="&amp;quot;2024-10-14&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1279, 58)" end="(1279, 59)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1279, 59)" end="(1279, 60)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1279, 61)" end="(1279, 116)" name="find?_join_eq_some">
        <AtomNode start="(1279, 61)" end="(1279, 67)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1279, 68)" end="(1279, 86)">
          <IdentNode start="(1279, 68)" end="(1279, 86)" leading="" trailing=" " raw_val="find?_join_eq_some" val="find?_join_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1279, 87)" end="(1279, 116)">
          <AtomNode start="(1279, 87)" end="(1279, 89)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1279, 90)" end="(1279, 116)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1279, 90)" end="(1279, 91)" leading="" trailing="" val="@"/>
            <IdentNode start="(1279, 91)" end="(1279, 116)" leading="" trailing="&#10;" raw_val="find?_flatten_eq_some_iff" val="find?_flatten_eq_some_iff" full_name="List.find?_flatten_eq_some_iff" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(347, 9)" def_end="(347, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(1280, 1)" end="(1280, 97)" name="findIdx?_join" full_name="List.findIdx?_join">
      <CommandDeclmodifiersNode start="(1280, 1)" end="(1280, 55)">
        <NullNode/>
        <NullNode start="(1280, 1)" end="(1280, 55)">
          <OtherNode start="(1280, 1)" end="(1280, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(1280, 1)" end="(1280, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(1280, 3)" end="(1280, 54)">
              <OtherNode start="(1280, 3)" end="(1280, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(1280, 3)" end="(1280, 54)" kind="Lean.deprecated">
                  <AtomNode start="(1280, 3)" end="(1280, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(1280, 14)" end="(1280, 30)">
                    <IdentNode start="(1280, 14)" end="(1280, 30)" leading="" trailing=" " raw_val="findIdx?_flatten" val="findIdx?_flatten" full_name="List.findIdx?_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(822, 9)" def_end="(822, 25)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(1280, 31)" end="(1280, 54)">
                    <AtomNode start="(1280, 31)" end="(1280, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(1280, 32)" end="(1280, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(1280, 38)" end="(1280, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(1280, 41)" end="(1280, 53)" kind="str">
                      <AtomNode start="(1280, 41)" end="(1280, 53)" leading="" trailing="" val="&amp;quot;2024-10-14&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(1280, 53)" end="(1280, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1280, 54)" end="(1280, 55)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(1280, 56)" end="(1280, 97)" name="findIdx?_join">
        <AtomNode start="(1280, 56)" end="(1280, 62)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(1280, 63)" end="(1280, 76)">
          <IdentNode start="(1280, 63)" end="(1280, 76)" leading="" trailing=" " raw_val="findIdx?_join" val="findIdx?_join"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(1280, 77)" end="(1280, 97)">
          <AtomNode start="(1280, 77)" end="(1280, 79)" leading="" trailing=" " val=":="/>
          <OtherNode start="(1280, 80)" end="(1280, 97)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(1280, 80)" end="(1280, 81)" leading="" trailing="" val="@"/>
            <IdentNode start="(1280, 81)" end="(1280, 97)" leading="" trailing="&#10;&#10;" raw_val="findIdx?_flatten" val="findIdx?_flatten" full_name="List.findIdx?_flatten" mod_name="Init.Data.List.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Find.lean" def_start="(822, 9)" def_end="(822, 25)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(1282, 1)" end="(1282, 9)" name="List">
      <AtomNode start="(1282, 1)" end="(1282, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1282, 5)" end="(1282, 9)">
        <IdentNode start="(1282, 5)" end="(1282, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(16, 1)" end="(19, 3)" text="Lemmas about `List.findSome?`, `List.find?`, `List.findIdx`, `List.findIdx?`, `List.idxOf`,&#10;and `List.lookup`.&#10;-/"/>
    <Comment start="(21, 38)" end="(22, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(22, 39)" end="(25, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;&#10;"/>
    <Comment start="(29, 1)" end="(29, 21)" text="### findSome? -/"/>
    <Comment start="(159, 1)" end="(160, 1)" text="-- Argument is unused, but used to decide whether `simp` should unfold.&#10;"/>
    <Comment start="(199, 1)" end="(199, 17)" text="### find? -/"/>
    <Comment start="(342, 1)" end="(346, 3)" text="If `find? p` returns `some a` from `xs.flatten`, then `p a` holds, and&#10;some list in `xs` contains `a`, and no earlier element of that list satisfies `p`.&#10;Moreover, no earlier list in `xs` has an element satisfying `p`.&#10;-/"/>
    <Comment start="(414, 1)" end="(415, 1)" text="-- This isn't a `@[simp]` lemma since there is already a lemma for `l.find? p = none` for any `l`.&#10;"/>
    <Comment start="(470, 1)" end="(470, 41)" text="### findIdx? (preliminary lemmas) -/"/>
    <Comment start="(505, 1)" end="(505, 19)" text="### findIdx -/"/>
    <Comment start="(581, 1)" end="(581, 77)" text="`p` does not hold for elements with indices less than `xs.findIdx p`. -/"/>
    <Comment start="(605, 1)" end="(605, 64)" text="If `¬ p xs[j]` for all `j &lt; i`, then `i ≤ xs.findIdx p`. -/"/>
    <Comment start="(613, 1)" end="(613, 64)" text="If `¬ p xs[j]` for all `j ≤ i`, then `i &lt; xs.findIdx p`. -/"/>
    <Comment start="(621, 1)" end="(621, 74)" text="`xs.findIdx p = i` iff `p xs[i]` and `¬ p xs [j]` for all `j &lt; i`. -/"/>
    <Comment start="(683, 1)" end="(683, 20)" text="### findIdx? -/"/>
    <Comment start="(869, 1)" end="(870, 1)" text="-- See also `findIdx_le_findIdx`.&#10;"/>
    <Comment start="(926, 1)" end="(926, 23)" text="### findFinIdx? -/"/>
    <Comment start="(1022, 1)" end="(1026, 3)" text="### idxOf&#10;&#10;The verification API for `idxOf` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx` (and proved using them).&#10;-/"/>
    <Comment start="(1081, 1)" end="(1085, 3)" text="### finIdxOf?&#10;&#10;The verification API for `finIdxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findFinIdx?` (and proved using them).&#10;-/"/>
    <Comment start="(1129, 1)" end="(1133, 3)" text="### idxOf?&#10;&#10;The verification API for `idxOf?` is still incomplete.&#10;The lemmas below should be made consistent with those for `findIdx?` (and proved using them).&#10;-/"/>
    <Comment start="(1176, 1)" end="(1176, 18)" text="### lookup -/"/>
    <Comment start="(1273, 1)" end="(1273, 24)" text="### Deprecations -/"/>
  </Comments>
</TracedFile>
