<TracedFile path="src/lean/Init/Data/List/Sort/Lemmas.lean" md5="21c45ca5c0ae1016f309e0b60d943cfc">
  <FileNode start="(1, 1)" end="(499, 26)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 22)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 22)">
        <ModuleImportNode start="(9, 1)" end="(9, 27)" module="Init.Data.List.Perm" path="src/lean/Init/Data/List/Perm.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 27)" leading="" trailing="&#10;" raw_val="Init.Data.List.Perm" val="Init.Data.List.Perm"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 33)" module="Init.Data.List.Sort.Basic" path="src/lean/Init/Data/List/Sort/Basic.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 33)" leading="" trailing="&#10;" raw_val="Init.Data.List.Sort.Basic" val="Init.Data.List.Sort.Basic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 32)" module="Init.Data.List.Nat.Range" path="src/lean/Init/Data/List/Nat/Range.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 32)" leading="" trailing="&#10;" raw_val="Init.Data.List.Nat.Range" val="Init.Data.List.Nat.Range"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 22)" module="Init.Data.Bool" path="src/lean/Init/Data/Bool.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 22)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Bool" val="Init.Data.Bool"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(14, 1)" end="(24, 3)" comment="# Basic properties of `mergeSort`.&#10;&#10;* `sorted_mergeSort`: `mergeSort` produces a sorted list.&#10;* `mergeSort_perm`: `mergeSort` is a permutation of the input list.&#10;* `mergeSort_of_sorted`: `mergeSort` does not change a sorted list.&#10;* `mergeSort_cons`: proves `mergeSort le (x :: xs) = l₁ ++ x :: l₂` for some `l₁, l₂`&#10;  so that `mergeSort le xs = l₁ ++ l₂`, and no `a ∈ l₁` satisfies `le a x`.&#10;* `sublist_mergeSort`: if `c` is a sorted sublist of `l`, then `c` is still a sublist of `mergeSort le l`.&#10;&#10;-/">
      <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(15, 1)" end="(24, 3)" leading="" trailing="&#10;&#10;" val="# Basic properties of `mergeSort`.&#10;&#10;* `sorted_mergeSort`: `mergeSort` produces a sorted list.&#10;* `mergeSort_perm`: `mergeSort` is a permutation of the input list.&#10;* `mergeSort_of_sorted`: `mergeSort` does not change a sorted list.&#10;* `mergeSort_cons`: proves `mergeSort le (x :: xs) = l₁ ++ x :: l₂` for some `l₁, l₂`&#10;  so that `mergeSort le xs = l₁ ++ l₂`, and no `a ∈ l₁` satisfies `le a x`.&#10;* `sublist_mergeSort`: if `c` is a sorted sublist of `l`, then `c` is still a sublist of `mergeSort le l`.&#10;&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(26, 1)" end="(26, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(26, 1)" end="(26, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(26, 12)" end="(26, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(26, 33)" end="(26, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(27, 1)" end="(27, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(27, 1)" end="(27, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(27, 12)" end="(27, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(27, 34)" end="(27, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(29, 1)" end="(29, 15)" name="List">
      <AtomNode start="(29, 1)" end="(29, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(29, 11)" end="(29, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(31, 1)" end="(31, 22)" comment="### splitInTwo -/">
      <AtomNode start="(31, 1)" end="(31, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(31, 5)" end="(31, 22)" leading="" trailing="&#10;&#10;" val="### splitInTwo -/"/>
    </CommandModuledocNode>
    <CommandNamespaceNode start="(33, 1)" end="(33, 29)" name="MergeSort.Internal">
      <AtomNode start="(33, 1)" end="(33, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(33, 11)" end="(33, 29)" leading="" trailing="&#10;&#10;" raw_val="MergeSort.Internal" val="MergeSort.Internal"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(35, 1)" end="(37, 32)" name="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst">
      <CommandDeclmodifiersNode start="(35, 1)" end="(35, 8)">
        <NullNode/>
        <NullNode start="(35, 1)" end="(35, 8)">
          <OtherNode start="(35, 1)" end="(35, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(35, 1)" end="(35, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(35, 3)" end="(35, 7)">
              <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(35, 3)" end="(35, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(35, 7)" end="(35, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(35, 9)" end="(37, 32)" name="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" _is_private_decl="False">
        <AtomNode start="(35, 9)" end="(35, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(35, 17)" end="(35, 31)">
          <IdentNode start="(35, 17)" end="(35, 31)" leading="" trailing=" " raw_val="splitInTwo_fst" val="splitInTwo_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(35, 32)" end="(36, 90)">
          <NullNode start="(35, 32)" end="(35, 68)">
            <TermExplicitbinderNode start="(35, 32)" end="(35, 68)">
              <AtomNode start="(35, 32)" end="(35, 33)" leading="" trailing="" val="("/>
              <NullNode start="(35, 33)" end="(35, 34)">
                <IdentNode start="(35, 33)" end="(35, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(35, 35)" end="(35, 67)">
                <AtomNode start="(35, 35)" end="(35, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(35, 37)" end="(35, 67)" kind="«term{_:_//_}»">
                  <AtomNode start="(35, 37)" end="(35, 38)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(35, 39)" end="(35, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(35, 41)" end="(35, 49)">
                    <AtomNode start="(35, 41)" end="(35, 42)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(35, 43)" end="(35, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(35, 43)" end="(35, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(35, 48)" end="(35, 49)">
                        <IdentNode start="(35, 48)" end="(35, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(35, 50)" end="(35, 52)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(35, 53)" end="(35, 65)" kind="«term_=_»">
                    <IdentNode start="(35, 53)" end="(35, 61)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(35, 62)" end="(35, 63)" leading="" trailing=" " val="="/>
                    <IdentNode start="(35, 64)" end="(35, 65)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(35, 66)" end="(35, 67)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(35, 67)" end="(35, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(35, 69)" end="(36, 90)">
            <AtomNode start="(35, 69)" end="(35, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(36, 5)" end="(36, 90)" kind="«term_=_»">
              <OtherNode start="(36, 5)" end="(36, 21)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(36, 5)" end="(36, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(36, 5)" end="(36, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(36, 6)" end="(36, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(36, 6)" end="(36, 16)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(36, 17)" end="(36, 18)">
                      <IdentNode start="(36, 17)" end="(36, 18)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(36, 18)" end="(36, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(36, 19)" end="(36, 20)" leading="" trailing="" val="."/>
                <OtherNode start="(36, 20)" end="(36, 21)" kind="fieldIdx">
                  <AtomNode start="(36, 20)" end="(36, 21)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(36, 22)" end="(36, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(36, 24)" end="(36, 90)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(36, 24)" end="(36, 25)" leading="" trailing="" val="⟨"/>
                <NullNode start="(36, 25)" end="(36, 89)">
                  <OtherNode start="(36, 25)" end="(36, 43)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(36, 25)" end="(36, 33)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(36, 25)" end="(36, 28)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(36, 25)" end="(36, 26)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(36, 26)" end="(36, 27)" leading="" trailing="" val="."/>
                        <OtherNode start="(36, 27)" end="(36, 28)" kind="fieldIdx">
                          <AtomNode start="(36, 27)" end="(36, 28)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(36, 28)" end="(36, 29)" leading="" trailing="" val="."/>
                      <IdentNode start="(36, 29)" end="(36, 33)" leading="" trailing=" " raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </OtherNode>
                    <NullNode start="(36, 34)" end="(36, 43)">
                      <OtherNode start="(36, 34)" end="(36, 43)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(36, 34)" end="(36, 35)" leading="" trailing="" val="("/>
                        <OtherNode start="(36, 35)" end="(36, 42)" kind="«term_/_»">
                          <OtherNode start="(36, 35)" end="(36, 40)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(36, 35)" end="(36, 36)" leading="" trailing="" val="("/>
                            <OtherNode start="(36, 36)" end="(36, 39)" kind="«term_+_»">
                              <IdentNode start="(36, 36)" end="(36, 37)" leading="" trailing="" raw_val="n" val="n"/>
                              <AtomNode start="(36, 37)" end="(36, 38)" leading="" trailing="" val="+"/>
                              <OtherNode start="(36, 38)" end="(36, 39)" kind="num">
                                <AtomNode start="(36, 38)" end="(36, 39)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(36, 39)" end="(36, 40)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(36, 40)" end="(36, 41)" leading="" trailing="" val="/"/>
                          <OtherNode start="(36, 41)" end="(36, 42)" kind="num">
                            <AtomNode start="(36, 41)" end="(36, 42)" leading="" trailing="" val="2"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(36, 42)" end="(36, 43)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(36, 43)" end="(36, 44)" leading="" trailing=" " val=","/>
                  <TermBytacticNode start="(36, 45)" end="(36, 89)">
                    <AtomNode start="(36, 45)" end="(36, 47)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(36, 48)" end="(36, 89)">
                      <TacticTacticseq1IndentedNode start="(36, 48)" end="(36, 89)">
                        <NullNode start="(36, 48)" end="(36, 89)">
                          <OtherNode start="(36, 48)" end="(36, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.28&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (take ((n + 1) / 2) l.val).length = (n + 1) / 2" state_after="α : Type ?u.28&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ min ((n + 1) / 2) n = (n + 1) / 2" tactic="simp [splitInTwo, splitAt_eq, l.2]">
                            <AtomNode start="(36, 48)" end="(36, 52)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(36, 53)" end="(36, 82)">
                              <AtomNode start="(36, 53)" end="(36, 54)" leading="" trailing="" val="["/>
                              <NullNode start="(36, 54)" end="(36, 81)">
                                <OtherNode start="(36, 54)" end="(36, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(36, 54)" end="(36, 64)" leading="" trailing="" raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(36, 64)" end="(36, 65)" leading="" trailing=" " val=","/>
                                <OtherNode start="(36, 66)" end="(36, 76)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(36, 66)" end="(36, 76)" leading="" trailing="" raw_val="splitAt_eq" val="splitAt_eq" full_name="List.splitAt_eq" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                </OtherNode>
                                <AtomNode start="(36, 76)" end="(36, 77)" leading="" trailing=" " val=","/>
                                <OtherNode start="(36, 78)" end="(36, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(36, 78)" end="(36, 81)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(36, 78)" end="(36, 79)" leading="" trailing="" raw_val="l" val="l"/>
                                    <AtomNode start="(36, 79)" end="(36, 80)" leading="" trailing="" val="."/>
                                    <OtherNode start="(36, 80)" end="(36, 81)" kind="fieldIdx">
                                      <AtomNode start="(36, 80)" end="(36, 81)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(36, 81)" end="(36, 82)" leading="" trailing="" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(36, 82)" end="(36, 83)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(36, 84)" end="(36, 89)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.28&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ min ((n + 1) / 2) n = (n + 1) / 2" state_after="no goals" tactic="omega">
                            <AtomNode start="(36, 84)" end="(36, 89)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </NullNode>
                <AtomNode start="(36, 89)" end="(36, 90)" leading="" trailing=" " val="⟩"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(36, 91)" end="(37, 32)">
          <AtomNode start="(36, 91)" end="(36, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(36, 94)" end="(37, 32)">
            <AtomNode start="(36, 94)" end="(36, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(37, 3)" end="(37, 32)">
              <TacticTacticseq1IndentedNode start="(37, 3)" end="(37, 32)">
                <NullNode start="(37, 3)" end="(37, 32)">
                  <OtherNode start="(37, 3)" end="(37, 32)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo l).fst = ⟨take ((n + 1) / 2) l.val, ⋯⟩" state_after="no goals" tactic="simp [splitInTwo, splitAt_eq]">
                    <AtomNode start="(37, 3)" end="(37, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(37, 8)" end="(37, 32)">
                      <AtomNode start="(37, 8)" end="(37, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(37, 9)" end="(37, 31)">
                        <OtherNode start="(37, 9)" end="(37, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(37, 9)" end="(37, 19)" leading="" trailing="" raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(37, 19)" end="(37, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(37, 21)" end="(37, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(37, 21)" end="(37, 31)" leading="" trailing="" raw_val="splitAt_eq" val="splitAt_eq" full_name="List.splitAt_eq" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(37, 31)" end="(37, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(39, 1)" end="(41, 32)" name="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd">
      <CommandDeclmodifiersNode start="(39, 1)" end="(39, 8)">
        <NullNode/>
        <NullNode start="(39, 1)" end="(39, 8)">
          <OtherNode start="(39, 1)" end="(39, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(39, 1)" end="(39, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(39, 3)" end="(39, 7)">
              <OtherNode start="(39, 3)" end="(39, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(39, 3)" end="(39, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(39, 3)" end="(39, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(39, 7)" end="(39, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(39, 9)" end="(41, 32)" name="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" _is_private_decl="False">
        <AtomNode start="(39, 9)" end="(39, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(39, 17)" end="(39, 31)">
          <IdentNode start="(39, 17)" end="(39, 31)" leading="" trailing=" " raw_val="splitInTwo_snd" val="splitInTwo_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(39, 32)" end="(40, 90)">
          <NullNode start="(39, 32)" end="(39, 68)">
            <TermExplicitbinderNode start="(39, 32)" end="(39, 68)">
              <AtomNode start="(39, 32)" end="(39, 33)" leading="" trailing="" val="("/>
              <NullNode start="(39, 33)" end="(39, 34)">
                <IdentNode start="(39, 33)" end="(39, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(39, 35)" end="(39, 67)">
                <AtomNode start="(39, 35)" end="(39, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 37)" end="(39, 67)" kind="«term{_:_//_}»">
                  <AtomNode start="(39, 37)" end="(39, 38)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(39, 39)" end="(39, 40)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(39, 41)" end="(39, 49)">
                    <AtomNode start="(39, 41)" end="(39, 42)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(39, 43)" end="(39, 49)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(39, 43)" end="(39, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(39, 48)" end="(39, 49)">
                        <IdentNode start="(39, 48)" end="(39, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(39, 50)" end="(39, 52)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(39, 53)" end="(39, 65)" kind="«term_=_»">
                    <IdentNode start="(39, 53)" end="(39, 61)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(39, 62)" end="(39, 63)" leading="" trailing=" " val="="/>
                    <IdentNode start="(39, 64)" end="(39, 65)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(39, 66)" end="(39, 67)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(39, 67)" end="(39, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(39, 69)" end="(40, 90)">
            <AtomNode start="(39, 69)" end="(39, 70)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(40, 5)" end="(40, 90)" kind="«term_=_»">
              <OtherNode start="(40, 5)" end="(40, 21)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(40, 5)" end="(40, 19)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(40, 5)" end="(40, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(40, 6)" end="(40, 18)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(40, 6)" end="(40, 16)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(40, 17)" end="(40, 18)">
                      <IdentNode start="(40, 17)" end="(40, 18)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(40, 18)" end="(40, 19)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(40, 19)" end="(40, 20)" leading="" trailing="" val="."/>
                <OtherNode start="(40, 20)" end="(40, 21)" kind="fieldIdx">
                  <AtomNode start="(40, 20)" end="(40, 21)" leading="" trailing=" " val="2"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(40, 22)" end="(40, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(40, 24)" end="(40, 90)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(40, 24)" end="(40, 25)" leading="" trailing="" val="⟨"/>
                <NullNode start="(40, 25)" end="(40, 89)">
                  <OtherNode start="(40, 25)" end="(40, 43)" kind="Lean.Parser.Term.app">
                    <OtherNode start="(40, 25)" end="(40, 33)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(40, 25)" end="(40, 28)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(40, 25)" end="(40, 26)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(40, 26)" end="(40, 27)" leading="" trailing="" val="."/>
                        <OtherNode start="(40, 27)" end="(40, 28)" kind="fieldIdx">
                          <AtomNode start="(40, 27)" end="(40, 28)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(40, 28)" end="(40, 29)" leading="" trailing="" val="."/>
                      <IdentNode start="(40, 29)" end="(40, 33)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </OtherNode>
                    <NullNode start="(40, 34)" end="(40, 43)">
                      <OtherNode start="(40, 34)" end="(40, 43)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(40, 34)" end="(40, 35)" leading="" trailing="" val="("/>
                        <OtherNode start="(40, 35)" end="(40, 42)" kind="«term_/_»">
                          <OtherNode start="(40, 35)" end="(40, 40)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(40, 35)" end="(40, 36)" leading="" trailing="" val="("/>
                            <OtherNode start="(40, 36)" end="(40, 39)" kind="«term_+_»">
                              <IdentNode start="(40, 36)" end="(40, 37)" leading="" trailing="" raw_val="n" val="n"/>
                              <AtomNode start="(40, 37)" end="(40, 38)" leading="" trailing="" val="+"/>
                              <OtherNode start="(40, 38)" end="(40, 39)" kind="num">
                                <AtomNode start="(40, 38)" end="(40, 39)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(40, 39)" end="(40, 40)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(40, 40)" end="(40, 41)" leading="" trailing="" val="/"/>
                          <OtherNode start="(40, 41)" end="(40, 42)" kind="num">
                            <AtomNode start="(40, 41)" end="(40, 42)" leading="" trailing="" val="2"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(40, 42)" end="(40, 43)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(40, 43)" end="(40, 44)" leading="" trailing=" " val=","/>
                  <TermBytacticNode start="(40, 45)" end="(40, 89)">
                    <AtomNode start="(40, 45)" end="(40, 47)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(40, 48)" end="(40, 89)">
                      <TacticTacticseq1IndentedNode start="(40, 48)" end="(40, 89)">
                        <NullNode start="(40, 48)" end="(40, 89)">
                          <OtherNode start="(40, 48)" end="(40, 82)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.1327&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (drop ((n + 1) / 2) l.val).length = n / 2" state_after="α : Type ?u.1327&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ n - (n + 1) / 2 = n / 2" tactic="simp [splitInTwo, splitAt_eq, l.2]">
                            <AtomNode start="(40, 48)" end="(40, 52)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(40, 53)" end="(40, 82)">
                              <AtomNode start="(40, 53)" end="(40, 54)" leading="" trailing="" val="["/>
                              <NullNode start="(40, 54)" end="(40, 81)">
                                <OtherNode start="(40, 54)" end="(40, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(40, 54)" end="(40, 64)" leading="" trailing="" raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(40, 64)" end="(40, 65)" leading="" trailing=" " val=","/>
                                <OtherNode start="(40, 66)" end="(40, 76)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(40, 66)" end="(40, 76)" leading="" trailing="" raw_val="splitAt_eq" val="splitAt_eq" full_name="List.splitAt_eq" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                </OtherNode>
                                <AtomNode start="(40, 76)" end="(40, 77)" leading="" trailing=" " val=","/>
                                <OtherNode start="(40, 78)" end="(40, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(40, 78)" end="(40, 81)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(40, 78)" end="(40, 79)" leading="" trailing="" raw_val="l" val="l"/>
                                    <AtomNode start="(40, 79)" end="(40, 80)" leading="" trailing="" val="."/>
                                    <OtherNode start="(40, 80)" end="(40, 81)" kind="fieldIdx">
                                      <AtomNode start="(40, 80)" end="(40, 81)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(40, 81)" end="(40, 82)" leading="" trailing="" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(40, 82)" end="(40, 83)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(40, 84)" end="(40, 89)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.1327&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ n - (n + 1) / 2 = n / 2" state_after="no goals" tactic="omega">
                            <AtomNode start="(40, 84)" end="(40, 89)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </NullNode>
                <AtomNode start="(40, 89)" end="(40, 90)" leading="" trailing=" " val="⟩"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(40, 91)" end="(41, 32)">
          <AtomNode start="(40, 91)" end="(40, 93)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(40, 94)" end="(41, 32)">
            <AtomNode start="(40, 94)" end="(40, 96)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(41, 3)" end="(41, 32)">
              <TacticTacticseq1IndentedNode start="(41, 3)" end="(41, 32)">
                <NullNode start="(41, 3)" end="(41, 32)">
                  <OtherNode start="(41, 3)" end="(41, 32)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo l).snd = ⟨drop ((n + 1) / 2) l.val, ⋯⟩" state_after="no goals" tactic="simp [splitInTwo, splitAt_eq]">
                    <AtomNode start="(41, 3)" end="(41, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(41, 8)" end="(41, 32)">
                      <AtomNode start="(41, 8)" end="(41, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(41, 9)" end="(41, 31)">
                        <OtherNode start="(41, 9)" end="(41, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(41, 9)" end="(41, 19)" leading="" trailing="" raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(41, 19)" end="(41, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(41, 21)" end="(41, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(41, 21)" end="(41, 31)" leading="" trailing="" raw_val="splitAt_eq" val="splitAt_eq" full_name="List.splitAt_eq" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(41, 31)" end="(41, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(43, 1)" end="(44, 7)" name="splitInTwo_fst_append_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_append_splitInTwo_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(43, 1)" end="(44, 7)" name="splitInTwo_fst_append_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_append_splitInTwo_snd" _is_private_decl="False">
        <AtomNode start="(43, 1)" end="(43, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(43, 9)" end="(43, 45)">
          <IdentNode start="(43, 9)" end="(43, 45)" leading="" trailing=" " raw_val="splitInTwo_fst_append_splitInTwo_snd" val="splitInTwo_fst_append_splitInTwo_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(43, 46)" end="(43, 131)">
          <NullNode start="(43, 46)" end="(43, 82)">
            <TermExplicitbinderNode start="(43, 46)" end="(43, 82)">
              <AtomNode start="(43, 46)" end="(43, 47)" leading="" trailing="" val="("/>
              <NullNode start="(43, 47)" end="(43, 48)">
                <IdentNode start="(43, 47)" end="(43, 48)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(43, 49)" end="(43, 81)">
                <AtomNode start="(43, 49)" end="(43, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(43, 51)" end="(43, 81)" kind="«term{_:_//_}»">
                  <AtomNode start="(43, 51)" end="(43, 52)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(43, 53)" end="(43, 54)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(43, 55)" end="(43, 63)">
                    <AtomNode start="(43, 55)" end="(43, 56)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(43, 57)" end="(43, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(43, 57)" end="(43, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(43, 62)" end="(43, 63)">
                        <IdentNode start="(43, 62)" end="(43, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(43, 64)" end="(43, 66)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(43, 67)" end="(43, 79)" kind="«term_=_»">
                    <IdentNode start="(43, 67)" end="(43, 75)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(43, 76)" end="(43, 77)" leading="" trailing=" " val="="/>
                    <IdentNode start="(43, 78)" end="(43, 79)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(43, 80)" end="(43, 81)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(43, 81)" end="(43, 82)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(43, 83)" end="(43, 131)">
            <AtomNode start="(43, 83)" end="(43, 84)" leading="" trailing=" " val=":"/>
            <OtherNode start="(43, 85)" end="(43, 131)" kind="«term_=_»">
              <OtherNode start="(43, 85)" end="(43, 125)" kind="«term_++_»">
                <OtherNode start="(43, 85)" end="(43, 103)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(43, 85)" end="(43, 101)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(43, 85)" end="(43, 99)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(43, 85)" end="(43, 86)" leading="" trailing="" val="("/>
                      <OtherNode start="(43, 86)" end="(43, 98)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(43, 86)" end="(43, 96)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        <NullNode start="(43, 97)" end="(43, 98)">
                          <IdentNode start="(43, 97)" end="(43, 98)" leading="" trailing="" raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(43, 98)" end="(43, 99)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(43, 99)" end="(43, 100)" leading="" trailing="" val="."/>
                    <OtherNode start="(43, 100)" end="(43, 101)" kind="fieldIdx">
                      <AtomNode start="(43, 100)" end="(43, 101)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(43, 101)" end="(43, 102)" leading="" trailing="" val="."/>
                  <OtherNode start="(43, 102)" end="(43, 103)" kind="fieldIdx">
                    <AtomNode start="(43, 102)" end="(43, 103)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(43, 104)" end="(43, 106)" leading="" trailing=" " val="++"/>
                <OtherNode start="(43, 107)" end="(43, 125)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(43, 107)" end="(43, 123)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(43, 107)" end="(43, 121)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(43, 107)" end="(43, 108)" leading="" trailing="" val="("/>
                      <OtherNode start="(43, 108)" end="(43, 120)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(43, 108)" end="(43, 118)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        <NullNode start="(43, 119)" end="(43, 120)">
                          <IdentNode start="(43, 119)" end="(43, 120)" leading="" trailing="" raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(43, 120)" end="(43, 121)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(43, 121)" end="(43, 122)" leading="" trailing="" val="."/>
                    <OtherNode start="(43, 122)" end="(43, 123)" kind="fieldIdx">
                      <AtomNode start="(43, 122)" end="(43, 123)" leading="" trailing="" val="2"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(43, 123)" end="(43, 124)" leading="" trailing="" val="."/>
                  <OtherNode start="(43, 124)" end="(43, 125)" kind="fieldIdx">
                    <AtomNode start="(43, 124)" end="(43, 125)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(43, 126)" end="(43, 127)" leading="" trailing=" " val="="/>
              <OtherNode start="(43, 128)" end="(43, 131)" kind="Lean.Parser.Term.proj">
                <IdentNode start="(43, 128)" end="(43, 129)" leading="" trailing="" raw_val="l" val="l"/>
                <AtomNode start="(43, 129)" end="(43, 130)" leading="" trailing="" val="."/>
                <OtherNode start="(43, 130)" end="(43, 131)" kind="fieldIdx">
                  <AtomNode start="(43, 130)" end="(43, 131)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(43, 132)" end="(44, 7)">
          <AtomNode start="(43, 132)" end="(43, 134)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(43, 135)" end="(44, 7)">
            <AtomNode start="(43, 135)" end="(43, 137)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(44, 3)" end="(44, 7)">
              <TacticTacticseq1IndentedNode start="(44, 3)" end="(44, 7)">
                <NullNode start="(44, 3)" end="(44, 7)">
                  <OtherNode start="(44, 3)" end="(44, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo l).fst.val ++ (splitInTwo l).snd.val = l.val" state_after="no goals" tactic="simp">
                    <AtomNode start="(44, 3)" end="(44, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(46, 1)" end="(61, 9)" name="splitInTwo_cons_cons_zipIdx_fst" full_name="List.MergeSort.Internal.splitInTwo_cons_cons_zipIdx_fst">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(46, 1)" end="(61, 9)" name="splitInTwo_cons_cons_zipIdx_fst" full_name="List.MergeSort.Internal.splitInTwo_cons_cons_zipIdx_fst" _is_private_decl="False">
        <AtomNode start="(46, 1)" end="(46, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(46, 9)" end="(46, 40)">
          <IdentNode start="(46, 9)" end="(46, 40)" leading="" trailing=" " raw_val="splitInTwo_cons_cons_zipIdx_fst" val="splitInTwo_cons_cons_zipIdx_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(46, 41)" end="(48, 51)">
          <NullNode start="(46, 41)" end="(46, 63)">
            <TermExplicitbinderNode start="(46, 41)" end="(46, 50)">
              <AtomNode start="(46, 41)" end="(46, 42)" leading="" trailing="" val="("/>
              <NullNode start="(46, 42)" end="(46, 43)">
                <IdentNode start="(46, 42)" end="(46, 43)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(46, 44)" end="(46, 49)">
                <AtomNode start="(46, 44)" end="(46, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(46, 46)" end="(46, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(46, 49)" end="(46, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(46, 51)" end="(46, 63)">
              <AtomNode start="(46, 51)" end="(46, 52)" leading="" trailing="" val="("/>
              <NullNode start="(46, 52)" end="(46, 53)">
                <IdentNode start="(46, 52)" end="(46, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(46, 54)" end="(46, 62)">
                <AtomNode start="(46, 54)" end="(46, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(46, 56)" end="(46, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(46, 56)" end="(46, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(46, 61)" end="(46, 62)">
                    <IdentNode start="(46, 61)" end="(46, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(46, 62)" end="(46, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(46, 64)" end="(48, 51)">
            <AtomNode start="(46, 64)" end="(46, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(47, 5)" end="(48, 51)" kind="«term_=_»">
              <OtherNode start="(47, 5)" end="(47, 65)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(47, 5)" end="(47, 63)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(47, 5)" end="(47, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(47, 5)" end="(47, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(47, 6)" end="(47, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(47, 6)" end="(47, 16)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                      <NullNode start="(47, 17)" end="(47, 60)">
                        <OtherNode start="(47, 17)" end="(47, 60)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(47, 17)" end="(47, 18)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(47, 18)" end="(47, 59)">
                            <OtherNode start="(47, 18)" end="(47, 54)" kind="«term_::_»">
                              <OtherNode start="(47, 18)" end="(47, 24)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(47, 18)" end="(47, 19)" leading="" trailing="" val="("/>
                                <NullNode start="(47, 19)" end="(47, 23)">
                                  <IdentNode start="(47, 19)" end="(47, 20)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(47, 20)" end="(47, 21)" leading="" trailing=" " val=","/>
                                  <NullNode start="(47, 22)" end="(47, 23)">
                                    <IdentNode start="(47, 22)" end="(47, 23)" leading="" trailing="" raw_val="i" val="i"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(47, 23)" end="(47, 24)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <AtomNode start="(47, 25)" end="(47, 27)" leading="" trailing=" " val="::"/>
                              <OtherNode start="(47, 28)" end="(47, 54)" kind="«term_::_»">
                                <OtherNode start="(47, 28)" end="(47, 36)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(47, 28)" end="(47, 29)" leading="" trailing="" val="("/>
                                  <NullNode start="(47, 29)" end="(47, 35)">
                                    <IdentNode start="(47, 29)" end="(47, 30)" leading="" trailing="" raw_val="b" val="b"/>
                                    <AtomNode start="(47, 30)" end="(47, 31)" leading="" trailing=" " val=","/>
                                    <NullNode start="(47, 32)" end="(47, 35)">
                                      <OtherNode start="(47, 32)" end="(47, 35)" kind="«term_+_»">
                                        <IdentNode start="(47, 32)" end="(47, 33)" leading="" trailing="" raw_val="i" val="i"/>
                                        <AtomNode start="(47, 33)" end="(47, 34)" leading="" trailing="" val="+"/>
                                        <OtherNode start="(47, 34)" end="(47, 35)" kind="num">
                                          <AtomNode start="(47, 34)" end="(47, 35)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(47, 35)" end="(47, 36)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(47, 37)" end="(47, 39)" leading="" trailing=" " val="::"/>
                                <OtherNode start="(47, 40)" end="(47, 54)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(47, 40)" end="(47, 48)" leading="" trailing=" " raw_val="l.zipIdx" val="l.zipIdx"/>
                                  <NullNode start="(47, 49)" end="(47, 54)">
                                    <OtherNode start="(47, 49)" end="(47, 54)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(47, 49)" end="(47, 50)" leading="" trailing="" val="("/>
                                      <OtherNode start="(47, 50)" end="(47, 53)" kind="«term_+_»">
                                        <IdentNode start="(47, 50)" end="(47, 51)" leading="" trailing="" raw_val="i" val="i"/>
                                        <AtomNode start="(47, 51)" end="(47, 52)" leading="" trailing="" val="+"/>
                                        <OtherNode start="(47, 52)" end="(47, 53)" kind="num">
                                          <AtomNode start="(47, 52)" end="(47, 53)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(47, 53)" end="(47, 54)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(47, 54)" end="(47, 55)" leading="" trailing=" " val=","/>
                            <IdentNode start="(47, 56)" end="(47, 59)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </NullNode>
                          <AtomNode start="(47, 59)" end="(47, 60)" leading="" trailing="" val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(47, 60)" end="(47, 61)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(47, 61)" end="(47, 62)" leading="" trailing="" val="."/>
                  <OtherNode start="(47, 62)" end="(47, 63)" kind="fieldIdx">
                    <AtomNode start="(47, 62)" end="(47, 63)" leading="" trailing="" val="1"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(47, 63)" end="(47, 64)" leading="" trailing="" val="."/>
                <OtherNode start="(47, 64)" end="(47, 65)" kind="fieldIdx">
                  <AtomNode start="(47, 64)" end="(47, 65)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(47, 66)" end="(47, 67)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(48, 7)" end="(48, 51)" kind="Lean.Parser.Term.app">
                <OtherNode start="(48, 7)" end="(48, 49)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(48, 7)" end="(48, 42)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(48, 7)" end="(48, 40)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(48, 7)" end="(48, 38)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(48, 7)" end="(48, 8)" leading="" trailing="" val="("/>
                        <OtherNode start="(48, 8)" end="(48, 37)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(48, 8)" end="(48, 18)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                          <NullNode start="(48, 19)" end="(48, 37)">
                            <OtherNode start="(48, 19)" end="(48, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(48, 19)" end="(48, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(48, 20)" end="(48, 36)">
                                <OtherNode start="(48, 20)" end="(48, 31)" kind="«term_::_»">
                                  <IdentNode start="(48, 20)" end="(48, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(48, 22)" end="(48, 24)" leading="" trailing=" " val="::"/>
                                  <OtherNode start="(48, 25)" end="(48, 31)" kind="«term_::_»">
                                    <IdentNode start="(48, 25)" end="(48, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <AtomNode start="(48, 27)" end="(48, 29)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(48, 30)" end="(48, 31)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(48, 31)" end="(48, 32)" leading="" trailing=" " val=","/>
                                <IdentNode start="(48, 33)" end="(48, 36)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(48, 36)" end="(48, 37)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(48, 37)" end="(48, 38)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(48, 38)" end="(48, 39)" leading="" trailing="" val="."/>
                      <OtherNode start="(48, 39)" end="(48, 40)" kind="fieldIdx">
                        <AtomNode start="(48, 39)" end="(48, 40)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(48, 40)" end="(48, 41)" leading="" trailing="" val="."/>
                    <OtherNode start="(48, 41)" end="(48, 42)" kind="fieldIdx">
                      <AtomNode start="(48, 41)" end="(48, 42)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(48, 42)" end="(48, 43)" leading="" trailing="" val="."/>
                  <IdentNode start="(48, 43)" end="(48, 49)" leading="" trailing=" " raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(48, 50)" end="(48, 51)">
                  <IdentNode start="(48, 50)" end="(48, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(48, 52)" end="(61, 9)">
          <AtomNode start="(48, 52)" end="(48, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(48, 55)" end="(61, 9)">
            <AtomNode start="(48, 55)" end="(48, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(49, 3)" end="(61, 9)">
              <TacticTacticseq1IndentedNode start="(49, 3)" end="(61, 9)">
                <NullNode start="(49, 3)" end="(61, 9)">
                  <OtherNode start="(49, 3)" end="(49, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;⊢ (splitInTwo ⟨(a, i) :: (b, i + 1) :: l.zipIdx (i + 2), ⋯⟩).fst.val = (splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.zipIdx i" state_after="α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;⊢ take ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)) =&#10;    (take ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx i" tactic="simp only [length_cons, splitInTwo_fst, length_zipIdx]">
                    <AtomNode start="(49, 3)" end="(49, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(49, 8)" end="(49, 12)">
                      <AtomNode start="(49, 8)" end="(49, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(49, 13)" end="(49, 57)">
                      <AtomNode start="(49, 13)" end="(49, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(49, 14)" end="(49, 56)">
                        <OtherNode start="(49, 14)" end="(49, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(49, 14)" end="(49, 25)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(49, 25)" end="(49, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(49, 27)" end="(49, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(49, 27)" end="(49, 41)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                        </OtherNode>
                        <AtomNode start="(49, 41)" end="(49, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(49, 43)" end="(49, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(49, 43)" end="(49, 56)" leading="" trailing="" raw_val="length_zipIdx" val="length_zipIdx" full_name="List.length_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(49, 56)" end="(49, 57)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(50, 3)" end="(50, 9)" kind="Lean.Elab.Tactic.Ext.tacticExt1___" state_before="α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;⊢ take ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)) =&#10;    (take ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx i" state_after="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (take ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)))[j]? =&#10;    ((take ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx i)[j]?" tactic="ext1 j">
                    <AtomNode start="(50, 3)" end="(50, 7)" leading="" trailing=" " val="ext1"/>
                    <NullNode start="(50, 8)" end="(50, 9)">
                      <OtherNode start="(50, 8)" end="(50, 9)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(50, 8)" end="(50, 9)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(50, 8)" end="(50, 9)" leading="" trailing="&#10;  " raw_val="j" val="j"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(51, 3)" end="(51, 53)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (take ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)))[j]? =&#10;    ((take ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx i)[j]?" state_after="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (if j &amp;lt; (l.length + 1 + 1 + 1) / 2 then ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[j]? else none) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j &amp;lt; (l.length + 1 + 1 + 1) / 2 then (a :: b :: l)[j]? else none)" tactic="rw [getElem?_take, getElem?_zipIdx, getElem?_take]">
                    <AtomNode start="(51, 3)" end="(51, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(51, 6)" end="(51, 53)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(51, 6)" end="(51, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(51, 7)" end="(51, 52)">
                        <OtherNode start="(51, 7)" end="(51, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(51, 7)" end="(51, 20)" leading="" trailing="" raw_val="getElem?_take" val="getElem?_take" full_name="List.getElem?_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(51, 20)" end="(51, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(51, 22)" end="(51, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(51, 22)" end="(51, 37)" leading="" trailing="" raw_val="getElem?_zipIdx" val="getElem?_zipIdx" full_name="List.getElem?_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                        <AtomNode start="(51, 37)" end="(51, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(51, 39)" end="(51, 52)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(51, 39)" end="(51, 52)" leading="" trailing="" raw_val="getElem?_take" val="getElem?_take" full_name="List.getElem?_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(51, 52)" end="(51, 53)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(52, 3)" end="(52, 8)" kind="Lean.Parser.Tactic.split" state_before="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (if j &amp;lt; (l.length + 1 + 1 + 1) / 2 then ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[j]? else none) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j &amp;lt; (l.length + 1 + 1 + 1) / 2 then (a :: b :: l)[j]? else none)" state_after="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[j]? = Option.map (fun a =&amp;gt; (a, i + j)) (a :: b :: l)[j]?&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ none = Option.map (fun a =&amp;gt; (a, i + j)) none" tactic="split">
                    <AtomNode start="(52, 3)" end="(52, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(53, 3)" end="(60, 28)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[j]? = Option.map (fun a =&amp;gt; (a, i + j)) (a :: b :: l)[j]?&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ none = Option.map (fun a =&amp;gt; (a, i + j)) none" state_after="case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ none = Option.map (fun a =&amp;gt; (a, i + j)) none" tactic="· rw [getElem?_cons, getElem?_cons, getElem?_cons, getElem?_cons]&#10;  split&#10;  · simp; omega&#10;  · split&#10;    · simp; omega&#10;    · simp only [getElem?_zipIdx]&#10;      congr&#10;      ext &amp;lt;;&amp;gt; simp; omega">
                    <OtherNode start="(53, 3)" end="(53, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(53, 3)" end="(53, 4)" kind="patternIgnore">
                        <OtherNode start="(53, 3)" end="(53, 4)" kind="token.«· »">
                          <AtomNode start="(53, 3)" end="(53, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(53, 5)" end="(60, 28)">
                      <TacticTacticseq1IndentedNode start="(53, 5)" end="(60, 28)">
                        <NullNode start="(53, 5)" end="(60, 28)">
                          <OtherNode start="(53, 5)" end="(53, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[j]? = Option.map (fun a =&amp;gt; (a, i + j)) (a :: b :: l)[j]?" state_after="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ (if j = 0 then some (a, i) else if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j = 0 then some a else if j - 1 = 0 then some b else l[j - 1 - 1]?)" tactic="rw [getElem?_cons, getElem?_cons, getElem?_cons, getElem?_cons]">
                            <AtomNode start="(53, 5)" end="(53, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(53, 8)" end="(53, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(53, 8)" end="(53, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(53, 9)" end="(53, 67)">
                                <OtherNode start="(53, 9)" end="(53, 22)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(53, 9)" end="(53, 22)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(53, 22)" end="(53, 23)" leading="" trailing=" " val=","/>
                                <OtherNode start="(53, 24)" end="(53, 37)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(53, 24)" end="(53, 37)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(53, 37)" end="(53, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(53, 39)" end="(53, 52)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(53, 39)" end="(53, 52)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(53, 52)" end="(53, 53)" leading="" trailing=" " val=","/>
                                <OtherNode start="(53, 54)" end="(53, 67)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(53, 54)" end="(53, 67)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(53, 67)" end="(53, 68)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(54, 5)" end="(54, 10)" kind="Lean.Parser.Tactic.split" state_before="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ (if j = 0 then some (a, i) else if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j = 0 then some a else if j - 1 = 0 then some b else l[j - 1 - 1]?)" state_after="case h.isTrue.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : j = 0&#10;⊢ some (a, i) = Option.map (fun a =&amp;gt; (a, i + j)) (some a)&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : ¬j = 0&#10;⊢ (if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j - 1 = 0 then some b else l[j - 1 - 1]?)" tactic="split">
                            <AtomNode start="(54, 5)" end="(54, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(55, 5)" end="(55, 18)" kind="Lean.cdot" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : j = 0&#10;⊢ some (a, i) = Option.map (fun a =&amp;gt; (a, i + j)) (some a)&#10;&#10;case h.isTrue.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : ¬j = 0&#10;⊢ (if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j - 1 = 0 then some b else l[j - 1 - 1]?)" state_after="case h.isTrue.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : ¬j = 0&#10;⊢ (if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j - 1 = 0 then some b else l[j - 1 - 1]?)" tactic="· simp; omega">
                            <OtherNode start="(55, 5)" end="(55, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(55, 5)" end="(55, 6)" kind="patternIgnore">
                                <OtherNode start="(55, 5)" end="(55, 6)" kind="token.«· »">
                                  <AtomNode start="(55, 5)" end="(55, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(55, 7)" end="(55, 18)">
                              <TacticTacticseq1IndentedNode start="(55, 7)" end="(55, 18)">
                                <NullNode start="(55, 7)" end="(55, 18)">
                                  <OtherNode start="(55, 7)" end="(55, 11)" kind="Lean.Parser.Tactic.simp" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : j = 0&#10;⊢ some (a, i) = Option.map (fun a =&amp;gt; (a, i + j)) (some a)" state_after="case h.isTrue.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : j = 0&#10;⊢ j = 0" tactic="simp">
                                    <AtomNode start="(55, 7)" end="(55, 11)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(55, 11)" end="(55, 12)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(55, 13)" end="(55, 18)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : j = 0&#10;⊢ j = 0" state_after="no goals" tactic="omega">
                                    <AtomNode start="(55, 13)" end="(55, 18)" leading="" trailing="&#10;    " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(56, 5)" end="(60, 28)" kind="Lean.cdot" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : ¬j = 0&#10;⊢ (if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j - 1 = 0 then some b else l[j - 1 - 1]?)" state_after="no goals" tactic="· split&#10;  · simp; omega&#10;  · simp only [getElem?_zipIdx]&#10;    congr&#10;    ext &amp;lt;;&amp;gt; simp; omega">
                            <OtherNode start="(56, 5)" end="(56, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(56, 5)" end="(56, 6)" kind="patternIgnore">
                                <OtherNode start="(56, 5)" end="(56, 6)" kind="token.«· »">
                                  <AtomNode start="(56, 5)" end="(56, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(56, 7)" end="(60, 28)">
                              <TacticTacticseq1IndentedNode start="(56, 7)" end="(60, 28)">
                                <NullNode start="(56, 7)" end="(60, 28)">
                                  <OtherNode start="(56, 7)" end="(56, 12)" kind="Lean.Parser.Tactic.split" state_before="case h.isTrue.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝ : ¬j = 0&#10;⊢ (if j - 1 = 0 then some (b, i + 1) else (l.zipIdx (i + 2))[j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + j)) (if j - 1 = 0 then some b else l[j - 1 - 1]?)" state_after="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : j - 1 = 0&#10;⊢ some (b, i + 1) = Option.map (fun a =&amp;gt; (a, i + j)) (some b)&#10;&#10;case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" tactic="split">
                                    <AtomNode start="(56, 7)" end="(56, 12)" leading="" trailing="&#10;      " val="split"/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(57, 7)" end="(57, 20)" kind="Lean.cdot" state_before="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : j - 1 = 0&#10;⊢ some (b, i + 1) = Option.map (fun a =&amp;gt; (a, i + j)) (some b)&#10;&#10;case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" state_after="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" tactic="· simp; omega">
                                    <OtherNode start="(57, 7)" end="(57, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(57, 7)" end="(57, 8)" kind="patternIgnore">
                                        <OtherNode start="(57, 7)" end="(57, 8)" kind="token.«· »">
                                          <AtomNode start="(57, 7)" end="(57, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(57, 9)" end="(57, 20)">
                                      <TacticTacticseq1IndentedNode start="(57, 9)" end="(57, 20)">
                                        <NullNode start="(57, 9)" end="(57, 20)">
                                          <OtherNode start="(57, 9)" end="(57, 13)" kind="Lean.Parser.Tactic.simp" state_before="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : j - 1 = 0&#10;⊢ some (b, i + 1) = Option.map (fun a =&amp;gt; (a, i + j)) (some b)" state_after="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : j - 1 = 0&#10;⊢ 1 = j" tactic="simp">
                                            <AtomNode start="(57, 9)" end="(57, 13)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                          <AtomNode start="(57, 13)" end="(57, 14)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(57, 15)" end="(57, 20)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : j - 1 = 0&#10;⊢ 1 = j" state_after="no goals" tactic="omega">
                                            <AtomNode start="(57, 15)" end="(57, 20)" leading="" trailing="&#10;      " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(58, 7)" end="(60, 28)" kind="Lean.cdot" state_before="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" state_after="no goals" tactic="· simp only [getElem?_zipIdx]&#10;  congr&#10;  ext &amp;lt;;&amp;gt; simp; omega">
                                    <OtherNode start="(58, 7)" end="(58, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(58, 7)" end="(58, 8)" kind="patternIgnore">
                                        <OtherNode start="(58, 7)" end="(58, 8)" kind="token.«· »">
                                          <AtomNode start="(58, 7)" end="(58, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(58, 9)" end="(60, 28)">
                                      <TacticTacticseq1IndentedNode start="(58, 9)" end="(60, 28)">
                                        <NullNode start="(58, 9)" end="(60, 28)">
                                          <OtherNode start="(58, 9)" end="(58, 36)" kind="Lean.Parser.Tactic.simp" state_before="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" state_after="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ Option.map (fun a =&amp;gt; (a, i + 2 + (j - 1 - 1))) l[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" tactic="simp only [getElem?_zipIdx]">
                                            <AtomNode start="(58, 9)" end="(58, 13)" leading="" trailing=" " val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode start="(58, 14)" end="(58, 18)">
                                              <AtomNode start="(58, 14)" end="(58, 18)" leading="" trailing=" " val="only"/>
                                            </NullNode>
                                            <NullNode start="(58, 19)" end="(58, 36)">
                                              <AtomNode start="(58, 19)" end="(58, 20)" leading="" trailing="" val="["/>
                                              <NullNode start="(58, 20)" end="(58, 35)">
                                                <OtherNode start="(58, 20)" end="(58, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <IdentNode start="(58, 20)" end="(58, 35)" leading="" trailing="" raw_val="getElem?_zipIdx" val="getElem?_zipIdx" full_name="List.getElem?_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                                </OtherNode>
                                              </NullNode>
                                              <AtomNode start="(58, 35)" end="(58, 36)" leading="" trailing="&#10;        " val="]"/>
                                            </NullNode>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(59, 9)" end="(59, 14)" kind="Lean.Parser.Tactic.congr" state_before="case h.isTrue.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ Option.map (fun a =&amp;gt; (a, i + 2 + (j - 1 - 1))) l[j - 1 - 1]? = Option.map (fun a =&amp;gt; (a, i + j)) l[j - 1 - 1]?" state_after="case h.isTrue.isFalse.isFalse.e_f&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (fun a =&amp;gt; (a, i + 2 + (j - 1 - 1))) = fun a =&amp;gt; (a, i + j)" tactic="congr">
                                            <AtomNode start="(59, 9)" end="(59, 14)" leading="" trailing="&#10;        " val="congr"/>
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(60, 9)" end="(60, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.isTrue.isFalse.isFalse.e_f&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;⊢ (fun a =&amp;gt; (a, i + 2 + (j - 1 - 1))) = fun a =&amp;gt; (a, i + j)" state_after="case h.isTrue.isFalse.isFalse.e_f.h.snd&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;x✝ : α&#10;⊢ i + 2 + (j - 1 - 1) = i + j" tactic="ext &amp;lt;;&amp;gt; simp">
                                            <OtherNode start="(60, 9)" end="(60, 12)" kind="Lean.Elab.Tactic.Ext.ext">
                                              <AtomNode start="(60, 9)" end="(60, 12)" leading="" trailing=" " val="ext"/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(60, 13)" end="(60, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                            <OtherNode start="(60, 17)" end="(60, 21)" kind="Lean.Parser.Tactic.simp">
                                              <AtomNode start="(60, 17)" end="(60, 21)" leading="" trailing="" val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(60, 21)" end="(60, 22)" leading="" trailing=" " val=";"/>
                                          <OtherNode start="(60, 23)" end="(60, 28)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue.isFalse.isFalse.e_f.h.snd&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝² : j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;h✝¹ : ¬j = 0&#10;h✝ : ¬j - 1 = 0&#10;x✝ : α&#10;⊢ i + 2 + (j - 1 - 1) = i + j" state_after="no goals" tactic="omega">
                                            <AtomNode start="(60, 23)" end="(60, 28)" leading="" trailing="&#10;  " val="omega"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(61, 3)" end="(61, 9)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ none = Option.map (fun a =&amp;gt; (a, i + j)) none" state_after="no goals" tactic="· simp">
                    <OtherNode start="(61, 3)" end="(61, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(61, 3)" end="(61, 4)" kind="patternIgnore">
                        <OtherNode start="(61, 3)" end="(61, 4)" kind="token.«· »">
                          <AtomNode start="(61, 3)" end="(61, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(61, 5)" end="(61, 9)">
                      <TacticTacticseq1IndentedNode start="(61, 5)" end="(61, 9)">
                        <NullNode start="(61, 5)" end="(61, 9)">
                          <OtherNode start="(61, 5)" end="(61, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬j &amp;lt; (l.length + 1 + 1 + 1) / 2&#10;⊢ none = Option.map (fun a =&amp;gt; (a, i + j)) none" state_after="no goals" tactic="simp">
                            <AtomNode start="(61, 5)" end="(61, 9)" leading="" trailing="&#10;&#10;" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(63, 1)" end="(76, 26)" name="splitInTwo_cons_cons_zipIdx_snd" full_name="List.MergeSort.Internal.splitInTwo_cons_cons_zipIdx_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(63, 1)" end="(76, 26)" name="splitInTwo_cons_cons_zipIdx_snd" full_name="List.MergeSort.Internal.splitInTwo_cons_cons_zipIdx_snd" _is_private_decl="False">
        <AtomNode start="(63, 1)" end="(63, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(63, 9)" end="(63, 40)">
          <IdentNode start="(63, 9)" end="(63, 40)" leading="" trailing=" " raw_val="splitInTwo_cons_cons_zipIdx_snd" val="splitInTwo_cons_cons_zipIdx_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(63, 41)" end="(65, 68)">
          <NullNode start="(63, 41)" end="(63, 63)">
            <TermExplicitbinderNode start="(63, 41)" end="(63, 50)">
              <AtomNode start="(63, 41)" end="(63, 42)" leading="" trailing="" val="("/>
              <NullNode start="(63, 42)" end="(63, 43)">
                <IdentNode start="(63, 42)" end="(63, 43)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(63, 44)" end="(63, 49)">
                <AtomNode start="(63, 44)" end="(63, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(63, 46)" end="(63, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(63, 49)" end="(63, 50)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(63, 51)" end="(63, 63)">
              <AtomNode start="(63, 51)" end="(63, 52)" leading="" trailing="" val="("/>
              <NullNode start="(63, 52)" end="(63, 53)">
                <IdentNode start="(63, 52)" end="(63, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(63, 54)" end="(63, 62)">
                <AtomNode start="(63, 54)" end="(63, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(63, 56)" end="(63, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(63, 56)" end="(63, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(63, 61)" end="(63, 62)">
                    <IdentNode start="(63, 61)" end="(63, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(63, 62)" end="(63, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(63, 64)" end="(65, 68)">
            <AtomNode start="(63, 64)" end="(63, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(64, 5)" end="(65, 68)" kind="«term_=_»">
              <OtherNode start="(64, 5)" end="(64, 65)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(64, 5)" end="(64, 63)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(64, 5)" end="(64, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(64, 5)" end="(64, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(64, 6)" end="(64, 60)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(64, 6)" end="(64, 16)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                      <NullNode start="(64, 17)" end="(64, 60)">
                        <OtherNode start="(64, 17)" end="(64, 60)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(64, 17)" end="(64, 18)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(64, 18)" end="(64, 59)">
                            <OtherNode start="(64, 18)" end="(64, 54)" kind="«term_::_»">
                              <OtherNode start="(64, 18)" end="(64, 24)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(64, 18)" end="(64, 19)" leading="" trailing="" val="("/>
                                <NullNode start="(64, 19)" end="(64, 23)">
                                  <IdentNode start="(64, 19)" end="(64, 20)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(64, 20)" end="(64, 21)" leading="" trailing=" " val=","/>
                                  <NullNode start="(64, 22)" end="(64, 23)">
                                    <IdentNode start="(64, 22)" end="(64, 23)" leading="" trailing="" raw_val="i" val="i"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(64, 23)" end="(64, 24)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <AtomNode start="(64, 25)" end="(64, 27)" leading="" trailing=" " val="::"/>
                              <OtherNode start="(64, 28)" end="(64, 54)" kind="«term_::_»">
                                <OtherNode start="(64, 28)" end="(64, 36)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(64, 28)" end="(64, 29)" leading="" trailing="" val="("/>
                                  <NullNode start="(64, 29)" end="(64, 35)">
                                    <IdentNode start="(64, 29)" end="(64, 30)" leading="" trailing="" raw_val="b" val="b"/>
                                    <AtomNode start="(64, 30)" end="(64, 31)" leading="" trailing=" " val=","/>
                                    <NullNode start="(64, 32)" end="(64, 35)">
                                      <OtherNode start="(64, 32)" end="(64, 35)" kind="«term_+_»">
                                        <IdentNode start="(64, 32)" end="(64, 33)" leading="" trailing="" raw_val="i" val="i"/>
                                        <AtomNode start="(64, 33)" end="(64, 34)" leading="" trailing="" val="+"/>
                                        <OtherNode start="(64, 34)" end="(64, 35)" kind="num">
                                          <AtomNode start="(64, 34)" end="(64, 35)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(64, 35)" end="(64, 36)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <AtomNode start="(64, 37)" end="(64, 39)" leading="" trailing=" " val="::"/>
                                <OtherNode start="(64, 40)" end="(64, 54)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(64, 40)" end="(64, 48)" leading="" trailing=" " raw_val="l.zipIdx" val="l.zipIdx"/>
                                  <NullNode start="(64, 49)" end="(64, 54)">
                                    <OtherNode start="(64, 49)" end="(64, 54)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(64, 49)" end="(64, 50)" leading="" trailing="" val="("/>
                                      <OtherNode start="(64, 50)" end="(64, 53)" kind="«term_+_»">
                                        <IdentNode start="(64, 50)" end="(64, 51)" leading="" trailing="" raw_val="i" val="i"/>
                                        <AtomNode start="(64, 51)" end="(64, 52)" leading="" trailing="" val="+"/>
                                        <OtherNode start="(64, 52)" end="(64, 53)" kind="num">
                                          <AtomNode start="(64, 52)" end="(64, 53)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(64, 53)" end="(64, 54)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(64, 54)" end="(64, 55)" leading="" trailing=" " val=","/>
                            <IdentNode start="(64, 56)" end="(64, 59)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </NullNode>
                          <AtomNode start="(64, 59)" end="(64, 60)" leading="" trailing="" val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(64, 60)" end="(64, 61)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(64, 61)" end="(64, 62)" leading="" trailing="" val="."/>
                  <OtherNode start="(64, 62)" end="(64, 63)" kind="fieldIdx">
                    <AtomNode start="(64, 62)" end="(64, 63)" leading="" trailing="" val="2"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(64, 63)" end="(64, 64)" leading="" trailing="" val="."/>
                <OtherNode start="(64, 64)" end="(64, 65)" kind="fieldIdx">
                  <AtomNode start="(64, 64)" end="(64, 65)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(64, 66)" end="(64, 67)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(65, 7)" end="(65, 68)" kind="Lean.Parser.Term.app">
                <OtherNode start="(65, 7)" end="(65, 49)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(65, 7)" end="(65, 42)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(65, 7)" end="(65, 40)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(65, 7)" end="(65, 38)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(65, 7)" end="(65, 8)" leading="" trailing="" val="("/>
                        <OtherNode start="(65, 8)" end="(65, 37)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(65, 8)" end="(65, 18)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                          <NullNode start="(65, 19)" end="(65, 37)">
                            <OtherNode start="(65, 19)" end="(65, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(65, 19)" end="(65, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(65, 20)" end="(65, 36)">
                                <OtherNode start="(65, 20)" end="(65, 31)" kind="«term_::_»">
                                  <IdentNode start="(65, 20)" end="(65, 21)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(65, 22)" end="(65, 24)" leading="" trailing=" " val="::"/>
                                  <OtherNode start="(65, 25)" end="(65, 31)" kind="«term_::_»">
                                    <IdentNode start="(65, 25)" end="(65, 26)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <AtomNode start="(65, 27)" end="(65, 29)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(65, 30)" end="(65, 31)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(65, 31)" end="(65, 32)" leading="" trailing=" " val=","/>
                                <IdentNode start="(65, 33)" end="(65, 36)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(65, 36)" end="(65, 37)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(65, 37)" end="(65, 38)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(65, 38)" end="(65, 39)" leading="" trailing="" val="."/>
                      <OtherNode start="(65, 39)" end="(65, 40)" kind="fieldIdx">
                        <AtomNode start="(65, 39)" end="(65, 40)" leading="" trailing="" val="2"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(65, 40)" end="(65, 41)" leading="" trailing="" val="."/>
                    <OtherNode start="(65, 41)" end="(65, 42)" kind="fieldIdx">
                      <AtomNode start="(65, 41)" end="(65, 42)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(65, 42)" end="(65, 43)" leading="" trailing="" val="."/>
                  <IdentNode start="(65, 43)" end="(65, 49)" leading="" trailing=" " raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(65, 50)" end="(65, 68)">
                  <OtherNode start="(65, 50)" end="(65, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(65, 50)" end="(65, 51)" leading="" trailing="" val="("/>
                    <OtherNode start="(65, 51)" end="(65, 67)" kind="«term_+_»">
                      <IdentNode start="(65, 51)" end="(65, 52)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(65, 52)" end="(65, 53)" leading="" trailing="" val="+"/>
                      <OtherNode start="(65, 53)" end="(65, 67)" kind="«term_/_»">
                        <OtherNode start="(65, 53)" end="(65, 65)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(65, 53)" end="(65, 54)" leading="" trailing="" val="("/>
                          <OtherNode start="(65, 54)" end="(65, 64)" kind="«term_+_»">
                            <IdentNode start="(65, 54)" end="(65, 62)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                            <AtomNode start="(65, 62)" end="(65, 63)" leading="" trailing="" val="+"/>
                            <OtherNode start="(65, 63)" end="(65, 64)" kind="num">
                              <AtomNode start="(65, 63)" end="(65, 64)" leading="" trailing="" val="3"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(65, 64)" end="(65, 65)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(65, 65)" end="(65, 66)" leading="" trailing="" val="/"/>
                        <OtherNode start="(65, 66)" end="(65, 67)" kind="num">
                          <AtomNode start="(65, 66)" end="(65, 67)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(65, 67)" end="(65, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(65, 69)" end="(76, 26)">
          <AtomNode start="(65, 69)" end="(65, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(65, 72)" end="(76, 26)">
            <AtomNode start="(65, 72)" end="(65, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(66, 3)" end="(76, 26)">
              <TacticTacticseq1IndentedNode start="(66, 3)" end="(76, 26)">
                <NullNode start="(66, 3)" end="(76, 26)">
                  <OtherNode start="(66, 3)" end="(66, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;⊢ (splitInTwo ⟨(a, i) :: (b, i + 1) :: l.zipIdx (i + 2), ⋯⟩).snd.val =&#10;    (splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.zipIdx (i + (l.length + 3) / 2)" state_after="α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;⊢ drop ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)) =&#10;    (drop ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx (i + (l.length + 3) / 2)" tactic="simp only [length_cons, splitInTwo_snd, length_zipIdx]">
                    <AtomNode start="(66, 3)" end="(66, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(66, 8)" end="(66, 12)">
                      <AtomNode start="(66, 8)" end="(66, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(66, 13)" end="(66, 57)">
                      <AtomNode start="(66, 13)" end="(66, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(66, 14)" end="(66, 56)">
                        <OtherNode start="(66, 14)" end="(66, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(66, 14)" end="(66, 25)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(66, 25)" end="(66, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(66, 27)" end="(66, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(66, 27)" end="(66, 41)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                        </OtherNode>
                        <AtomNode start="(66, 41)" end="(66, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(66, 43)" end="(66, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(66, 43)" end="(66, 56)" leading="" trailing="" raw_val="length_zipIdx" val="length_zipIdx" full_name="List.length_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(66, 56)" end="(66, 57)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(67, 3)" end="(67, 9)" kind="Lean.Elab.Tactic.Ext.tacticExt1___" state_before="α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;⊢ drop ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)) =&#10;    (drop ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx (i + (l.length + 3) / 2)" state_after="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (drop ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)))[j]? =&#10;    ((drop ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx (i + (l.length + 3) / 2))[j]?" tactic="ext1 j">
                    <AtomNode start="(67, 3)" end="(67, 7)" leading="" trailing=" " val="ext1"/>
                    <NullNode start="(67, 8)" end="(67, 9)">
                      <OtherNode start="(67, 8)" end="(67, 9)" kind="Lean.Parser.Tactic.rintroPat.one">
                        <OtherNode start="(67, 8)" end="(67, 9)" kind="Lean.Parser.Tactic.rcasesPat.one">
                          <IdentNode start="(67, 8)" end="(67, 9)" leading="" trailing="&#10;  " raw_val="j" val="j"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(68, 3)" end="(68, 53)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (drop ((l.length + 1 + 1 + 1) / 2) ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2)))[j]? =&#10;    ((drop ((l.length + 1 + 1 + 1) / 2) (a :: b :: l)).zipIdx (i + (l.length + 3) / 2))[j]?" state_after="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (a :: b :: l)[(l.length + 1 + 1 + 1) / 2 + j]?" tactic="rw [getElem?_drop, getElem?_zipIdx, getElem?_drop]">
                    <AtomNode start="(68, 3)" end="(68, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(68, 6)" end="(68, 53)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(68, 6)" end="(68, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(68, 7)" end="(68, 52)">
                        <OtherNode start="(68, 7)" end="(68, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(68, 7)" end="(68, 20)" leading="" trailing="" raw_val="getElem?_drop" val="getElem?_drop" full_name="List.getElem?_drop" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(68, 20)" end="(68, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(68, 22)" end="(68, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(68, 22)" end="(68, 37)" leading="" trailing="" raw_val="getElem?_zipIdx" val="getElem?_zipIdx" full_name="List.getElem?_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                        </OtherNode>
                        <AtomNode start="(68, 37)" end="(68, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(68, 39)" end="(68, 52)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(68, 39)" end="(68, 52)" leading="" trailing="" raw_val="getElem?_drop" val="getElem?_drop" full_name="List.getElem?_drop" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(68, 52)" end="(68, 53)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(69, 3)" end="(69, 66)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ ((a, i) :: (b, i + 1) :: l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (a :: b :: l)[(l.length + 1 + 1 + 1) / 2 + j]?" state_after="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j = 0 then some (a, i)&#10;    else&#10;      if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;      else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j = 0 then some a&#10;      else if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" tactic="rw [getElem?_cons, getElem?_cons, getElem?_cons, getElem?_cons]">
                    <AtomNode start="(69, 3)" end="(69, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(69, 6)" end="(69, 66)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(69, 6)" end="(69, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(69, 7)" end="(69, 65)">
                        <OtherNode start="(69, 7)" end="(69, 20)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(69, 7)" end="(69, 20)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(69, 20)" end="(69, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(69, 22)" end="(69, 35)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(69, 22)" end="(69, 35)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(69, 35)" end="(69, 36)" leading="" trailing=" " val=","/>
                        <OtherNode start="(69, 37)" end="(69, 50)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(69, 37)" end="(69, 50)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(69, 50)" end="(69, 51)" leading="" trailing=" " val=","/>
                        <OtherNode start="(69, 52)" end="(69, 65)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(69, 52)" end="(69, 65)" leading="" trailing="" raw_val="getElem?_cons" val="getElem?_cons" full_name="List.getElem?_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(69, 65)" end="(69, 66)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(70, 3)" end="(70, 8)" kind="Lean.Parser.Tactic.split" state_before="case h&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j = 0 then some (a, i)&#10;    else&#10;      if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;      else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j = 0 then some a&#10;      else if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" state_after="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ some (a, i) = Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (some a)&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;    else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" tactic="split">
                    <AtomNode start="(70, 3)" end="(70, 8)" leading="" trailing="&#10;  " val="split"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(71, 3)" end="(71, 16)" kind="Lean.cdot" state_before="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ some (a, i) = Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (some a)&#10;&#10;case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;    else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" state_after="case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;    else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" tactic="· simp; omega">
                    <OtherNode start="(71, 3)" end="(71, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(71, 3)" end="(71, 4)" kind="patternIgnore">
                        <OtherNode start="(71, 3)" end="(71, 4)" kind="token.«· »">
                          <AtomNode start="(71, 3)" end="(71, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(71, 5)" end="(71, 16)">
                      <TacticTacticseq1IndentedNode start="(71, 5)" end="(71, 16)">
                        <NullNode start="(71, 5)" end="(71, 16)">
                          <OtherNode start="(71, 5)" end="(71, 9)" kind="Lean.Parser.Tactic.simp" state_before="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ some (a, i) = Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (some a)" state_after="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ i = i + (l.length + 3) / 2 + j" tactic="simp">
                            <AtomNode start="(71, 5)" end="(71, 9)" leading="" trailing="" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(71, 9)" end="(71, 10)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(71, 11)" end="(71, 16)" kind="Lean.Parser.Tactic.omega" state_before="case h.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ i = i + (l.length + 3) / 2 + j" state_after="no goals" tactic="omega">
                            <AtomNode start="(71, 11)" end="(71, 16)" leading="" trailing="&#10;  " val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(72, 3)" end="(76, 26)" kind="Lean.cdot" state_before="case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;    else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" state_after="no goals" tactic="· split&#10;  · simp; omega&#10;  · simp only [getElem?_zipIdx]&#10;    congr&#10;    ext &amp;lt;;&amp;gt; simp; omega">
                    <OtherNode start="(72, 3)" end="(72, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(72, 3)" end="(72, 4)" kind="patternIgnore">
                        <OtherNode start="(72, 3)" end="(72, 4)" kind="token.«· »">
                          <AtomNode start="(72, 3)" end="(72, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(72, 5)" end="(76, 26)">
                      <TacticTacticseq1IndentedNode start="(72, 5)" end="(76, 26)">
                        <NullNode start="(72, 5)" end="(76, 26)">
                          <OtherNode start="(72, 5)" end="(72, 10)" kind="Lean.Parser.Tactic.split" state_before="case h.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;⊢ (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some (b, i + 1)&#10;    else (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?) =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j))&#10;      (if (l.length + 1 + 1 + 1) / 2 + j - 1 = 0 then some b else l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?)" state_after="case h.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ some (b, i + 1) = Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (some b)&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" tactic="split">
                            <AtomNode start="(72, 5)" end="(72, 10)" leading="" trailing="&#10;    " val="split"/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(73, 5)" end="(73, 18)" kind="Lean.cdot" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ some (b, i + 1) = Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (some b)&#10;&#10;case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" tactic="· simp; omega">
                            <OtherNode start="(73, 5)" end="(73, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(73, 5)" end="(73, 6)" kind="patternIgnore">
                                <OtherNode start="(73, 5)" end="(73, 6)" kind="token.«· »">
                                  <AtomNode start="(73, 5)" end="(73, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(73, 7)" end="(73, 18)">
                              <TacticTacticseq1IndentedNode start="(73, 7)" end="(73, 18)">
                                <NullNode start="(73, 7)" end="(73, 18)">
                                  <OtherNode start="(73, 7)" end="(73, 11)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ some (b, i + 1) = Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) (some b)" state_after="case h.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ i + 1 = i + (l.length + 3) / 2 + j" tactic="simp">
                                    <AtomNode start="(73, 7)" end="(73, 11)" leading="" trailing="" val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(73, 11)" end="(73, 12)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(73, 13)" end="(73, 18)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.isTrue&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : (l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ i + 1 = i + (l.length + 3) / 2 + j" state_after="no goals" tactic="omega">
                                    <AtomNode start="(73, 13)" end="(73, 18)" leading="" trailing="&#10;    " val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(74, 5)" end="(76, 26)" kind="Lean.cdot" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" state_after="no goals" tactic="· simp only [getElem?_zipIdx]&#10;  congr&#10;  ext &amp;lt;;&amp;gt; simp; omega">
                            <OtherNode start="(74, 5)" end="(74, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(74, 5)" end="(74, 6)" kind="patternIgnore">
                                <OtherNode start="(74, 5)" end="(74, 6)" kind="token.«· »">
                                  <AtomNode start="(74, 5)" end="(74, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(74, 7)" end="(76, 26)">
                              <TacticTacticseq1IndentedNode start="(74, 7)" end="(76, 26)">
                                <NullNode start="(74, 7)" end="(76, 26)">
                                  <OtherNode start="(74, 7)" end="(74, 34)" kind="Lean.Parser.Tactic.simp" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (l.zipIdx (i + 2))[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" state_after="case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ Option.map (fun a =&amp;gt; (a, i + 2 + ((l.length + 1 + 1 + 1) / 2 + j - 1 - 1)))&#10;      l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" tactic="simp only [getElem?_zipIdx]">
                                    <AtomNode start="(74, 7)" end="(74, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(74, 12)" end="(74, 16)">
                                      <AtomNode start="(74, 12)" end="(74, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(74, 17)" end="(74, 34)">
                                      <AtomNode start="(74, 17)" end="(74, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(74, 18)" end="(74, 33)">
                                        <OtherNode start="(74, 18)" end="(74, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(74, 18)" end="(74, 33)" leading="" trailing="" raw_val="getElem?_zipIdx" val="getElem?_zipIdx" full_name="List.getElem?_zipIdx" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(74, 33)" end="(74, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(75, 7)" end="(75, 12)" kind="Lean.Parser.Tactic.congr" state_before="case h.isFalse.isFalse&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ Option.map (fun a =&amp;gt; (a, i + 2 + ((l.length + 1 + 1 + 1) / 2 + j - 1 - 1)))&#10;      l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]? =&#10;    Option.map (fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)) l[(l.length + 1 + 1 + 1) / 2 + j - 1 - 1]?" state_after="case h.isFalse.isFalse.e_f&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (fun a =&amp;gt; (a, i + 2 + ((l.length + 1 + 1 + 1) / 2 + j - 1 - 1))) = fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)" tactic="congr">
                                    <AtomNode start="(75, 7)" end="(75, 12)" leading="" trailing="&#10;      " val="congr"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(76, 7)" end="(76, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.isFalse.isFalse.e_f&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;⊢ (fun a =&amp;gt; (a, i + 2 + ((l.length + 1 + 1 + 1) / 2 + j - 1 - 1))) = fun a =&amp;gt; (a, i + (l.length + 3) / 2 + j)" state_after="case h.isFalse.isFalse.e_f.h.snd&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;x✝ : α&#10;⊢ i + 2 + ((l.length + 1 + 1 + 1) / 2 + j - 1 - 1) = i + (l.length + 3) / 2 + j" tactic="ext &amp;lt;;&amp;gt; simp">
                                    <OtherNode start="(76, 7)" end="(76, 10)" kind="Lean.Elab.Tactic.Ext.ext">
                                      <AtomNode start="(76, 7)" end="(76, 10)" leading="" trailing=" " val="ext"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(76, 11)" end="(76, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                    <OtherNode start="(76, 15)" end="(76, 19)" kind="Lean.Parser.Tactic.simp">
                                      <AtomNode start="(76, 15)" end="(76, 19)" leading="" trailing="" val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(76, 19)" end="(76, 20)" leading="" trailing=" " val=";"/>
                                  <OtherNode start="(76, 21)" end="(76, 26)" kind="Lean.Parser.Tactic.omega" state_before="case h.isFalse.isFalse.e_f.h.snd&#10;α : Type u_1&#10;a b : α&#10;i : Nat&#10;l : List α&#10;j : Nat&#10;h✝¹ : ¬(l.length + 1 + 1 + 1) / 2 + j = 0&#10;h✝ : ¬(l.length + 1 + 1 + 1) / 2 + j - 1 = 0&#10;x✝ : α&#10;⊢ i + 2 + ((l.length + 1 + 1 + 1) / 2 + j - 1 - 1) = i + (l.length + 3) / 2 + j" state_after="no goals" tactic="omega">
                                    <AtomNode start="(76, 21)" end="(76, 26)" leading="" trailing="&#10;&#10;" val="omega"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(78, 1)" end="(80, 15)" name="splitInTwo_fst_sorted" full_name="List.MergeSort.Internal.splitInTwo_fst_sorted">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(78, 1)" end="(80, 15)" name="splitInTwo_fst_sorted" full_name="List.MergeSort.Internal.splitInTwo_fst_sorted" _is_private_decl="False">
        <AtomNode start="(78, 1)" end="(78, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(78, 9)" end="(78, 30)">
          <IdentNode start="(78, 9)" end="(78, 30)" leading="" trailing=" " raw_val="splitInTwo_fst_sorted" val="splitInTwo_fst_sorted"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(78, 31)" end="(78, 122)">
          <NullNode start="(78, 31)" end="(78, 89)">
            <TermExplicitbinderNode start="(78, 31)" end="(78, 67)">
              <AtomNode start="(78, 31)" end="(78, 32)" leading="" trailing="" val="("/>
              <NullNode start="(78, 32)" end="(78, 33)">
                <IdentNode start="(78, 32)" end="(78, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(78, 34)" end="(78, 66)">
                <AtomNode start="(78, 34)" end="(78, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 36)" end="(78, 66)" kind="«term{_:_//_}»">
                  <AtomNode start="(78, 36)" end="(78, 37)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(78, 38)" end="(78, 39)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(78, 40)" end="(78, 48)">
                    <AtomNode start="(78, 40)" end="(78, 41)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(78, 42)" end="(78, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(78, 42)" end="(78, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(78, 47)" end="(78, 48)">
                        <IdentNode start="(78, 47)" end="(78, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(78, 49)" end="(78, 51)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(78, 52)" end="(78, 64)" kind="«term_=_»">
                    <IdentNode start="(78, 52)" end="(78, 60)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(78, 61)" end="(78, 62)" leading="" trailing=" " val="="/>
                    <IdentNode start="(78, 63)" end="(78, 64)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(78, 65)" end="(78, 66)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 66)" end="(78, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(78, 68)" end="(78, 89)">
              <AtomNode start="(78, 68)" end="(78, 69)" leading="" trailing="" val="("/>
              <NullNode start="(78, 69)" end="(78, 70)">
                <IdentNode start="(78, 69)" end="(78, 70)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(78, 71)" end="(78, 88)">
                <AtomNode start="(78, 71)" end="(78, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 73)" end="(78, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 73)" end="(78, 81)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(78, 82)" end="(78, 88)">
                    <IdentNode start="(78, 82)" end="(78, 84)" leading="" trailing=" " raw_val="le" val="le"/>
                    <OtherNode start="(78, 85)" end="(78, 88)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(78, 85)" end="(78, 86)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(78, 86)" end="(78, 87)" leading="" trailing="" val="."/>
                      <OtherNode start="(78, 87)" end="(78, 88)" kind="fieldIdx">
                        <AtomNode start="(78, 87)" end="(78, 88)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 88)" end="(78, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(78, 90)" end="(78, 122)">
            <AtomNode start="(78, 90)" end="(78, 91)" leading="" trailing=" " val=":"/>
            <OtherNode start="(78, 92)" end="(78, 122)" kind="Lean.Parser.Term.app">
              <IdentNode start="(78, 92)" end="(78, 100)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              <NullNode start="(78, 101)" end="(78, 122)">
                <IdentNode start="(78, 101)" end="(78, 103)" leading="" trailing=" " raw_val="le" val="le"/>
                <OtherNode start="(78, 104)" end="(78, 122)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(78, 104)" end="(78, 120)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(78, 104)" end="(78, 118)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(78, 104)" end="(78, 105)" leading="" trailing="" val="("/>
                      <OtherNode start="(78, 105)" end="(78, 117)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(78, 105)" end="(78, 115)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        <NullNode start="(78, 116)" end="(78, 117)">
                          <IdentNode start="(78, 116)" end="(78, 117)" leading="" trailing="" raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(78, 117)" end="(78, 118)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(78, 118)" end="(78, 119)" leading="" trailing="" val="."/>
                    <OtherNode start="(78, 119)" end="(78, 120)" kind="fieldIdx">
                      <AtomNode start="(78, 119)" end="(78, 120)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(78, 120)" end="(78, 121)" leading="" trailing="" val="."/>
                  <OtherNode start="(78, 121)" end="(78, 122)" kind="fieldIdx">
                    <AtomNode start="(78, 121)" end="(78, 122)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(78, 123)" end="(80, 15)">
          <AtomNode start="(78, 123)" end="(78, 125)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(78, 126)" end="(80, 15)">
            <AtomNode start="(78, 126)" end="(78, 128)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(79, 3)" end="(80, 15)">
              <TacticTacticseq1IndentedNode start="(79, 3)" end="(80, 15)">
                <NullNode start="(79, 3)" end="(80, 15)">
                  <OtherNode start="(79, 3)" end="(79, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ Pairwise le (splitInTwo l).fst.val" state_after="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ Pairwise le ⟨take ((n + 1) / 2) l.val, ⋯⟩.val" tactic="rw [splitInTwo_fst]">
                    <AtomNode start="(79, 3)" end="(79, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(79, 6)" end="(79, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(79, 6)" end="(79, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(79, 7)" end="(79, 21)">
                        <OtherNode start="(79, 7)" end="(79, 21)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(79, 7)" end="(79, 21)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(79, 21)" end="(79, 22)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(80, 3)" end="(80, 15)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ Pairwise le ⟨take ((n + 1) / 2) l.val, ⋯⟩.val" state_after="no goals" tactic="exact h.take">
                    <AtomNode start="(80, 3)" end="(80, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(80, 9)" end="(80, 15)" leading="" trailing="&#10;&#10;" raw_val="h.take" val="h.take"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(82, 1)" end="(84, 15)" name="splitInTwo_snd_sorted" full_name="List.MergeSort.Internal.splitInTwo_snd_sorted">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(82, 1)" end="(84, 15)" name="splitInTwo_snd_sorted" full_name="List.MergeSort.Internal.splitInTwo_snd_sorted" _is_private_decl="False">
        <AtomNode start="(82, 1)" end="(82, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(82, 9)" end="(82, 30)">
          <IdentNode start="(82, 9)" end="(82, 30)" leading="" trailing=" " raw_val="splitInTwo_snd_sorted" val="splitInTwo_snd_sorted"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(82, 31)" end="(82, 122)">
          <NullNode start="(82, 31)" end="(82, 89)">
            <TermExplicitbinderNode start="(82, 31)" end="(82, 67)">
              <AtomNode start="(82, 31)" end="(82, 32)" leading="" trailing="" val="("/>
              <NullNode start="(82, 32)" end="(82, 33)">
                <IdentNode start="(82, 32)" end="(82, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(82, 34)" end="(82, 66)">
                <AtomNode start="(82, 34)" end="(82, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(82, 36)" end="(82, 66)" kind="«term{_:_//_}»">
                  <AtomNode start="(82, 36)" end="(82, 37)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(82, 38)" end="(82, 39)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(82, 40)" end="(82, 48)">
                    <AtomNode start="(82, 40)" end="(82, 41)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(82, 42)" end="(82, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(82, 42)" end="(82, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(82, 47)" end="(82, 48)">
                        <IdentNode start="(82, 47)" end="(82, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(82, 49)" end="(82, 51)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(82, 52)" end="(82, 64)" kind="«term_=_»">
                    <IdentNode start="(82, 52)" end="(82, 60)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(82, 61)" end="(82, 62)" leading="" trailing=" " val="="/>
                    <IdentNode start="(82, 63)" end="(82, 64)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(82, 65)" end="(82, 66)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(82, 66)" end="(82, 67)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(82, 68)" end="(82, 89)">
              <AtomNode start="(82, 68)" end="(82, 69)" leading="" trailing="" val="("/>
              <NullNode start="(82, 69)" end="(82, 70)">
                <IdentNode start="(82, 69)" end="(82, 70)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(82, 71)" end="(82, 88)">
                <AtomNode start="(82, 71)" end="(82, 72)" leading="" trailing=" " val=":"/>
                <OtherNode start="(82, 73)" end="(82, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(82, 73)" end="(82, 81)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(82, 82)" end="(82, 88)">
                    <IdentNode start="(82, 82)" end="(82, 84)" leading="" trailing=" " raw_val="le" val="le"/>
                    <OtherNode start="(82, 85)" end="(82, 88)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(82, 85)" end="(82, 86)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(82, 86)" end="(82, 87)" leading="" trailing="" val="."/>
                      <OtherNode start="(82, 87)" end="(82, 88)" kind="fieldIdx">
                        <AtomNode start="(82, 87)" end="(82, 88)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(82, 88)" end="(82, 89)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(82, 90)" end="(82, 122)">
            <AtomNode start="(82, 90)" end="(82, 91)" leading="" trailing=" " val=":"/>
            <OtherNode start="(82, 92)" end="(82, 122)" kind="Lean.Parser.Term.app">
              <IdentNode start="(82, 92)" end="(82, 100)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              <NullNode start="(82, 101)" end="(82, 122)">
                <IdentNode start="(82, 101)" end="(82, 103)" leading="" trailing=" " raw_val="le" val="le"/>
                <OtherNode start="(82, 104)" end="(82, 122)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(82, 104)" end="(82, 120)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(82, 104)" end="(82, 118)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(82, 104)" end="(82, 105)" leading="" trailing="" val="("/>
                      <OtherNode start="(82, 105)" end="(82, 117)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(82, 105)" end="(82, 115)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        <NullNode start="(82, 116)" end="(82, 117)">
                          <IdentNode start="(82, 116)" end="(82, 117)" leading="" trailing="" raw_val="l" val="l"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(82, 117)" end="(82, 118)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(82, 118)" end="(82, 119)" leading="" trailing="" val="."/>
                    <OtherNode start="(82, 119)" end="(82, 120)" kind="fieldIdx">
                      <AtomNode start="(82, 119)" end="(82, 120)" leading="" trailing="" val="2"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(82, 120)" end="(82, 121)" leading="" trailing="" val="."/>
                  <OtherNode start="(82, 121)" end="(82, 122)" kind="fieldIdx">
                    <AtomNode start="(82, 121)" end="(82, 122)" leading="" trailing=" " val="1"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(82, 123)" end="(84, 15)">
          <AtomNode start="(82, 123)" end="(82, 125)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(82, 126)" end="(84, 15)">
            <AtomNode start="(82, 126)" end="(82, 128)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(83, 3)" end="(84, 15)">
              <TacticTacticseq1IndentedNode start="(83, 3)" end="(84, 15)">
                <NullNode start="(83, 3)" end="(84, 15)">
                  <OtherNode start="(83, 3)" end="(83, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ Pairwise le (splitInTwo l).snd.val" state_after="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ Pairwise le ⟨drop ((n + 1) / 2) l.val, ⋯⟩.val" tactic="rw [splitInTwo_snd]">
                    <AtomNode start="(83, 3)" end="(83, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(83, 6)" end="(83, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(83, 6)" end="(83, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(83, 7)" end="(83, 21)">
                        <OtherNode start="(83, 7)" end="(83, 21)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(83, 7)" end="(83, 21)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(83, 21)" end="(83, 22)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(84, 3)" end="(84, 15)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ Pairwise le ⟨drop ((n + 1) / 2) l.val, ⋯⟩.val" state_after="no goals" tactic="exact h.drop">
                    <AtomNode start="(84, 3)" end="(84, 8)" leading="" trailing=" " val="exact"/>
                    <IdentNode start="(84, 9)" end="(84, 15)" leading="" trailing="&#10;&#10;" raw_val="h.drop" val="h.drop"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(86, 1)" end="(90, 44)" name="splitInTwo_fst_le_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_le_splitInTwo_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(86, 1)" end="(90, 44)" name="splitInTwo_fst_le_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_le_splitInTwo_snd" _is_private_decl="False">
        <AtomNode start="(86, 1)" end="(86, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(86, 9)" end="(86, 41)">
          <IdentNode start="(86, 9)" end="(86, 41)" leading="" trailing=" " raw_val="splitInTwo_fst_le_splitInTwo_snd" val="splitInTwo_fst_le_splitInTwo_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(86, 42)" end="(87, 68)">
          <NullNode start="(86, 42)" end="(86, 100)">
            <OtherNode start="(86, 42)" end="(86, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(86, 42)" end="(86, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(86, 43)" end="(86, 44)">
                <IdentNode start="(86, 43)" end="(86, 44)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(86, 45)" end="(86, 77)">
                <AtomNode start="(86, 45)" end="(86, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(86, 47)" end="(86, 77)" kind="«term{_:_//_}»">
                  <AtomNode start="(86, 47)" end="(86, 48)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(86, 49)" end="(86, 50)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(86, 51)" end="(86, 59)">
                    <AtomNode start="(86, 51)" end="(86, 52)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(86, 53)" end="(86, 59)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(86, 53)" end="(86, 57)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(86, 58)" end="(86, 59)">
                        <IdentNode start="(86, 58)" end="(86, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(86, 60)" end="(86, 62)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(86, 63)" end="(86, 75)" kind="«term_=_»">
                    <IdentNode start="(86, 63)" end="(86, 71)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(86, 72)" end="(86, 73)" leading="" trailing=" " val="="/>
                    <IdentNode start="(86, 74)" end="(86, 75)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(86, 76)" end="(86, 77)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(86, 77)" end="(86, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(86, 79)" end="(86, 100)">
              <AtomNode start="(86, 79)" end="(86, 80)" leading="" trailing="" val="("/>
              <NullNode start="(86, 80)" end="(86, 81)">
                <IdentNode start="(86, 80)" end="(86, 81)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(86, 82)" end="(86, 99)">
                <AtomNode start="(86, 82)" end="(86, 83)" leading="" trailing=" " val=":"/>
                <OtherNode start="(86, 84)" end="(86, 99)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(86, 84)" end="(86, 92)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  <NullNode start="(86, 93)" end="(86, 99)">
                    <IdentNode start="(86, 93)" end="(86, 95)" leading="" trailing=" " raw_val="le" val="le"/>
                    <OtherNode start="(86, 96)" end="(86, 99)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(86, 96)" end="(86, 97)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(86, 97)" end="(86, 98)" leading="" trailing="" val="."/>
                      <OtherNode start="(86, 98)" end="(86, 99)" kind="fieldIdx">
                        <AtomNode start="(86, 98)" end="(86, 99)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(86, 99)" end="(86, 100)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(86, 101)" end="(87, 68)">
            <AtomNode start="(86, 101)" end="(86, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(87, 5)" end="(87, 68)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(87, 5)" end="(87, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(87, 7)" end="(87, 10)">
                <IdentNode start="(87, 7)" end="(87, 8)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(87, 9)" end="(87, 10)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(87, 10)" end="(87, 11)" leading="" trailing=" " val=","/>
              <OtherNode start="(87, 12)" end="(87, 68)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(87, 12)" end="(87, 34)" kind="«term_∈_»">
                  <IdentNode start="(87, 12)" end="(87, 13)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(87, 14)" end="(87, 15)" leading="" trailing=" " val="∈"/>
                  <OtherNode start="(87, 16)" end="(87, 34)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(87, 16)" end="(87, 32)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(87, 16)" end="(87, 30)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(87, 16)" end="(87, 17)" leading="" trailing="" val="("/>
                        <OtherNode start="(87, 17)" end="(87, 29)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(87, 17)" end="(87, 27)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                          <NullNode start="(87, 28)" end="(87, 29)">
                            <IdentNode start="(87, 28)" end="(87, 29)" leading="" trailing="" raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(87, 29)" end="(87, 30)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(87, 30)" end="(87, 31)" leading="" trailing="" val="."/>
                      <OtherNode start="(87, 31)" end="(87, 32)" kind="fieldIdx">
                        <AtomNode start="(87, 31)" end="(87, 32)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(87, 32)" end="(87, 33)" leading="" trailing="" val="."/>
                    <OtherNode start="(87, 33)" end="(87, 34)" kind="fieldIdx">
                      <AtomNode start="(87, 33)" end="(87, 34)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(87, 35)" end="(87, 36)" leading="" trailing=" " val="→"/>
                <OtherNode start="(87, 37)" end="(87, 68)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(87, 37)" end="(87, 59)" kind="«term_∈_»">
                    <IdentNode start="(87, 37)" end="(87, 38)" leading="" trailing=" " raw_val="b" val="b"/>
                    <AtomNode start="(87, 39)" end="(87, 40)" leading="" trailing=" " val="∈"/>
                    <OtherNode start="(87, 41)" end="(87, 59)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(87, 41)" end="(87, 57)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(87, 41)" end="(87, 55)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(87, 41)" end="(87, 42)" leading="" trailing="" val="("/>
                          <OtherNode start="(87, 42)" end="(87, 54)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(87, 42)" end="(87, 52)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                            <NullNode start="(87, 53)" end="(87, 54)">
                              <IdentNode start="(87, 53)" end="(87, 54)" leading="" trailing="" raw_val="l" val="l"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(87, 54)" end="(87, 55)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(87, 55)" end="(87, 56)" leading="" trailing="" val="."/>
                        <OtherNode start="(87, 56)" end="(87, 57)" kind="fieldIdx">
                          <AtomNode start="(87, 56)" end="(87, 57)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(87, 57)" end="(87, 58)" leading="" trailing="" val="."/>
                      <OtherNode start="(87, 58)" end="(87, 59)" kind="fieldIdx">
                        <AtomNode start="(87, 58)" end="(87, 59)" leading="" trailing=" " val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(87, 60)" end="(87, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(87, 62)" end="(87, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(87, 62)" end="(87, 64)" leading="" trailing=" " raw_val="le" val="le"/>
                    <NullNode start="(87, 65)" end="(87, 68)">
                      <IdentNode start="(87, 65)" end="(87, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(87, 67)" end="(87, 68)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(87, 69)" end="(90, 44)">
          <AtomNode start="(87, 69)" end="(87, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(87, 72)" end="(90, 44)">
            <AtomNode start="(87, 72)" end="(87, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(88, 3)" end="(90, 44)">
              <TacticTacticseq1IndentedNode start="(88, 3)" end="(90, 44)">
                <NullNode start="(88, 3)" end="(90, 44)">
                  <OtherNode start="(88, 3)" end="(88, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ ∀ (a b : α), a ∈ (splitInTwo l).fst.val → b ∈ (splitInTwo l).snd.val → le a b" state_after="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ ∀ (a b : α), a ∈ ⟨take ((n + 1) / 2) l.val, ⋯⟩.val → b ∈ ⟨drop ((n + 1) / 2) l.val, ⋯⟩.val → le a b" tactic="rw [splitInTwo_fst, splitInTwo_snd]">
                    <AtomNode start="(88, 3)" end="(88, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(88, 6)" end="(88, 38)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(88, 6)" end="(88, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(88, 7)" end="(88, 37)">
                        <OtherNode start="(88, 7)" end="(88, 21)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(88, 7)" end="(88, 21)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                        </OtherNode>
                        <AtomNode start="(88, 21)" end="(88, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(88, 23)" end="(88, 37)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(88, 23)" end="(88, 37)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(88, 37)" end="(88, 38)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(89, 3)" end="(89, 18)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;⊢ ∀ (a b : α), a ∈ ⟨take ((n + 1) / 2) l.val, ⋯⟩.val → b ∈ ⟨drop ((n + 1) / 2) l.val, ⋯⟩.val → le a b" state_after="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;a b : α&#10;ma : a ∈ ⟨take ((n + 1) / 2) l.val, ⋯⟩.val&#10;mb : b ∈ ⟨drop ((n + 1) / 2) l.val, ⋯⟩.val&#10;⊢ le a b" tactic="intro a b ma mb">
                    <AtomNode start="(89, 3)" end="(89, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(89, 9)" end="(89, 18)">
                      <IdentNode start="(89, 9)" end="(89, 10)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(89, 11)" end="(89, 12)" leading="" trailing=" " raw_val="b" val="b"/>
                      <IdentNode start="(89, 13)" end="(89, 15)" leading="" trailing=" " raw_val="ma" val="ma"/>
                      <IdentNode start="(89, 16)" end="(89, 18)" leading="" trailing="&#10;  " raw_val="mb" val="mb"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(90, 3)" end="(90, 44)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;n : Nat&#10;le : α → α → Prop&#10;l : { l // l.length = n }&#10;h : Pairwise le l.val&#10;a b : α&#10;ma : a ∈ ⟨take ((n + 1) / 2) l.val, ⋯⟩.val&#10;mb : b ∈ ⟨drop ((n + 1) / 2) l.val, ⋯⟩.val&#10;⊢ le a b" state_after="no goals" tactic="exact h.rel_of_mem_take_of_mem_drop ma mb">
                    <AtomNode start="(90, 3)" end="(90, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(90, 9)" end="(90, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(90, 9)" end="(90, 38)" leading="" trailing=" " raw_val="h.rel_of_mem_take_of_mem_drop" val="h.rel_of_mem_take_of_mem_drop"/>
                      <NullNode start="(90, 39)" end="(90, 44)">
                        <IdentNode start="(90, 39)" end="(90, 41)" leading="" trailing=" " raw_val="ma" val="ma"/>
                        <IdentNode start="(90, 42)" end="(90, 44)" leading="" trailing="&#10;&#10;" raw_val="mb" val="mb"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(92, 1)" end="(92, 23)" name="MergeSort.Internal">
      <AtomNode start="(92, 1)" end="(92, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(92, 5)" end="(92, 23)">
        <IdentNode start="(92, 5)" end="(92, 23)" leading="" trailing="&#10;&#10;" raw_val="MergeSort.Internal" val="MergeSort.Internal"/>
      </NullNode>
    </CommandEndNode>
    <CommandOpenNode start="(94, 1)" end="(94, 24)">
      <AtomNode start="(94, 1)" end="(94, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(94, 6)" end="(94, 24)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(94, 6)" end="(94, 24)">
          <IdentNode start="(94, 6)" end="(94, 24)" leading="" trailing="&#10;&#10;" raw_val="MergeSort.Internal" val="MergeSort.Internal"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(96, 1)" end="(96, 20)" comment="### zipIdxLE -/">
      <AtomNode start="(96, 1)" end="(96, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(96, 5)" end="(96, 20)" leading="" trailing="&#10;&#10;" val="### zipIdxLE -/"/>
    </CommandModuledocNode>
    <OtherNode start="(98, 1)" end="(98, 29)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(98, 1)" end="(98, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(98, 10)" end="(98, 29)">
        <OtherNode start="(98, 10)" end="(98, 29)" kind="Lean.Parser.Term.implicitBinder">
          <AtomNode start="(98, 10)" end="(98, 11)" leading="" trailing="" val="{"/>
          <NullNode start="(98, 11)" end="(98, 13)">
            <IdentNode start="(98, 11)" end="(98, 13)" leading="" trailing=" " raw_val="le" val="le"/>
          </NullNode>
          <NullNode start="(98, 14)" end="(98, 28)">
            <AtomNode start="(98, 14)" end="(98, 15)" leading="" trailing=" " val=":"/>
            <OtherNode start="(98, 16)" end="(98, 28)" kind="Lean.Parser.Term.arrow">
              <IdentNode start="(98, 16)" end="(98, 17)" leading="" trailing=" " raw_val="α" val="α"/>
              <AtomNode start="(98, 18)" end="(98, 19)" leading="" trailing=" " val="→"/>
              <OtherNode start="(98, 20)" end="(98, 28)" kind="Lean.Parser.Term.arrow">
                <IdentNode start="(98, 20)" end="(98, 21)" leading="" trailing=" " raw_val="α" val="α"/>
                <AtomNode start="(98, 22)" end="(98, 23)" leading="" trailing=" " val="→"/>
                <IdentNode start="(98, 24)" end="(98, 28)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(98, 28)" end="(98, 29)" leading="" trailing="&#10;&#10;" val="}"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(100, 1)" end="(126, 13)" name="zipIdxLE_trans" full_name="List.zipIdxLE_trans">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(100, 1)" end="(126, 13)" name="zipIdxLE_trans" full_name="List.zipIdxLE_trans" _is_private_decl="False">
        <AtomNode start="(100, 1)" end="(100, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(100, 9)" end="(100, 23)">
          <IdentNode start="(100, 9)" end="(100, 23)" leading="" trailing=" " raw_val="zipIdxLE_trans" val="zipIdxLE_trans"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(100, 24)" end="(101, 76)">
          <NullNode start="(100, 24)" end="(101, 22)">
            <TermExplicitbinderNode start="(100, 24)" end="(100, 67)">
              <AtomNode start="(100, 24)" end="(100, 25)" leading="" trailing="" val="("/>
              <NullNode start="(100, 25)" end="(100, 30)">
                <IdentNode start="(100, 25)" end="(100, 30)" leading="" trailing=" " raw_val="trans" val="trans"/>
              </NullNode>
              <NullNode start="(100, 31)" end="(100, 66)">
                <AtomNode start="(100, 31)" end="(100, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(100, 33)" end="(100, 66)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(100, 33)" end="(100, 34)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(100, 35)" end="(100, 40)">
                    <IdentNode start="(100, 35)" end="(100, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(100, 37)" end="(100, 38)" leading="" trailing=" " raw_val="b" val="b"/>
                    <IdentNode start="(100, 39)" end="(100, 40)" leading="" trailing="" raw_val="c" val="c"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(100, 40)" end="(100, 41)" leading="" trailing=" " val=","/>
                  <OtherNode start="(100, 42)" end="(100, 66)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(100, 42)" end="(100, 48)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(100, 42)" end="(100, 44)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(100, 45)" end="(100, 48)">
                        <IdentNode start="(100, 45)" end="(100, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(100, 47)" end="(100, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(100, 49)" end="(100, 50)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(100, 51)" end="(100, 66)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(100, 51)" end="(100, 57)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(100, 51)" end="(100, 53)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(100, 54)" end="(100, 57)">
                          <IdentNode start="(100, 54)" end="(100, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(100, 56)" end="(100, 57)" leading="" trailing=" " raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(100, 58)" end="(100, 59)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(100, 60)" end="(100, 66)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(100, 60)" end="(100, 62)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(100, 63)" end="(100, 66)">
                          <IdentNode start="(100, 63)" end="(100, 64)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(100, 65)" end="(100, 66)" leading="" trailing="" raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(100, 66)" end="(100, 67)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(101, 5)" end="(101, 22)">
              <AtomNode start="(101, 5)" end="(101, 6)" leading="" trailing="" val="("/>
              <NullNode start="(101, 6)" end="(101, 11)">
                <IdentNode start="(101, 6)" end="(101, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(101, 8)" end="(101, 9)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(101, 10)" end="(101, 11)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(101, 12)" end="(101, 21)">
                <AtomNode start="(101, 12)" end="(101, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(101, 14)" end="(101, 21)" kind="«term_×_»">
                  <IdentNode start="(101, 14)" end="(101, 15)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(101, 16)" end="(101, 17)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(101, 18)" end="(101, 21)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(101, 21)" end="(101, 22)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(101, 23)" end="(101, 76)">
            <AtomNode start="(101, 23)" end="(101, 24)" leading="" trailing=" " val=":"/>
            <OtherNode start="(101, 25)" end="(101, 76)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(101, 25)" end="(101, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(101, 25)" end="(101, 33)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(101, 34)" end="(101, 40)">
                  <IdentNode start="(101, 34)" end="(101, 36)" leading="" trailing=" " raw_val="le" val="le"/>
                  <IdentNode start="(101, 37)" end="(101, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(101, 39)" end="(101, 40)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(101, 41)" end="(101, 42)" leading="" trailing=" " val="→"/>
              <OtherNode start="(101, 43)" end="(101, 76)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(101, 43)" end="(101, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(101, 43)" end="(101, 51)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(101, 52)" end="(101, 58)">
                    <IdentNode start="(101, 52)" end="(101, 54)" leading="" trailing=" " raw_val="le" val="le"/>
                    <IdentNode start="(101, 55)" end="(101, 56)" leading="" trailing=" " raw_val="b" val="b"/>
                    <IdentNode start="(101, 57)" end="(101, 58)" leading="" trailing=" " raw_val="c" val="c"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(101, 59)" end="(101, 60)" leading="" trailing=" " val="→"/>
                <OtherNode start="(101, 61)" end="(101, 76)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(101, 61)" end="(101, 69)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(101, 70)" end="(101, 76)">
                    <IdentNode start="(101, 70)" end="(101, 72)" leading="" trailing=" " raw_val="le" val="le"/>
                    <IdentNode start="(101, 73)" end="(101, 74)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(101, 75)" end="(101, 76)" leading="" trailing=" " raw_val="c" val="c"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(101, 77)" end="(126, 13)">
          <AtomNode start="(101, 77)" end="(101, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(101, 80)" end="(126, 13)">
            <AtomNode start="(101, 80)" end="(101, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(102, 3)" end="(126, 13)">
              <TacticTacticseq1IndentedNode start="(102, 3)" end="(126, 13)">
                <NullNode start="(102, 3)" end="(126, 13)">
                  <OtherNode start="(102, 3)" end="(102, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;⊢ zipIdxLE le a b = true → zipIdxLE le b c = true → zipIdxLE le a c = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;⊢ (if le a.fst b.fst = true then if le b.fst a.fst = true then decide (a.snd ≤ b.snd) else true else false) = true →&#10;    (if le b.fst c.fst = true then if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true else false) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" tactic="simp only [zipIdxLE]">
                    <AtomNode start="(102, 3)" end="(102, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(102, 8)" end="(102, 12)">
                      <AtomNode start="(102, 8)" end="(102, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(102, 13)" end="(102, 23)">
                      <AtomNode start="(102, 13)" end="(102, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(102, 14)" end="(102, 22)">
                        <OtherNode start="(102, 14)" end="(102, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(102, 14)" end="(102, 22)" leading="" trailing="" raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(102, 22)" end="(102, 23)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(103, 3)" end="(103, 53)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;⊢ (if le a.fst b.fst = true then if le b.fst a.fst = true then decide (a.snd ≤ b.snd) else true else false) = true →&#10;    (if le b.fst c.fst = true then if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true else false) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="split &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; split &amp;lt;;&amp;gt; rename_i ab₂ ba₂ bc₂">
                    <OtherNode start="(103, 3)" end="(103, 28)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                      <OtherNode start="(103, 3)" end="(103, 18)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                        <OtherNode start="(103, 3)" end="(103, 8)" kind="Lean.Parser.Tactic.split">
                          <AtomNode start="(103, 3)" end="(103, 8)" leading="" trailing=" " val="split"/>
                          <NullNode/>
                          <NullNode/>
                        </OtherNode>
                        <AtomNode start="(103, 9)" end="(103, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                        <OtherNode start="(103, 13)" end="(103, 18)" kind="Lean.Parser.Tactic.split">
                          <AtomNode start="(103, 13)" end="(103, 18)" leading="" trailing=" " val="split"/>
                          <NullNode/>
                          <NullNode/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(103, 19)" end="(103, 22)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                      <OtherNode start="(103, 23)" end="(103, 28)" kind="Lean.Parser.Tactic.split">
                        <AtomNode start="(103, 23)" end="(103, 28)" leading="" trailing=" " val="split"/>
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(103, 29)" end="(103, 32)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(103, 33)" end="(103, 53)" kind="Lean.Parser.Tactic.renameI">
                      <AtomNode start="(103, 33)" end="(103, 41)" leading="" trailing=" " val="rename_i"/>
                      <NullNode start="(103, 42)" end="(103, 53)">
                        <LeanBinderidentNode start="(103, 42)" end="(103, 45)">
                          <IdentNode start="(103, 42)" end="(103, 45)" leading="" trailing=" " raw_val="ab₂" val="ab₂"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(103, 46)" end="(103, 49)">
                          <IdentNode start="(103, 46)" end="(103, 49)" leading="" trailing=" " raw_val="ba₂" val="ba₂"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(103, 50)" end="(103, 53)">
                          <IdentNode start="(103, 50)" end="(103, 53)" leading="" trailing="&#10;  " raw_val="bc₂" val="bc₂"/>
                        </LeanBinderidentNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(104, 3)" end="(111, 42)" kind="Lean.cdot" state_before="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isTrue.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all&#10;  intro ab₁&#10;  intro h&#10;  refine ⟨trans _ _ _ ab₂ bc₂, ?_⟩&#10;  rcases h with (cd₂ | bc₁)&#10;  · exact Or.inl (Decidable.byContradiction&#10;      (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ (by simpa using ca₂) ab₂]))&#10;  · exact Or.inr (Nat.le_trans ab₁ bc₁)">
                    <OtherNode start="(104, 3)" end="(104, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(104, 3)" end="(104, 4)" kind="patternIgnore">
                        <OtherNode start="(104, 3)" end="(104, 4)" kind="token.«· »">
                          <AtomNode start="(104, 3)" end="(104, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(104, 5)" end="(111, 42)">
                      <TacticTacticseq1IndentedNode start="(104, 5)" end="(111, 42)">
                        <NullNode start="(104, 5)" end="(111, 42)">
                          <OtherNode start="(104, 5)" end="(104, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ a.snd ≤ b.snd →&#10;    le c.fst b.fst = false ∨ b.snd ≤ c.snd → le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" tactic="simp_all">
                            <AtomNode start="(104, 5)" end="(104, 13)" leading="" trailing="&#10;    " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(105, 5)" end="(105, 14)" kind="Lean.Parser.Tactic.intro" state_before="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ a.snd ≤ b.snd →&#10;    le c.fst b.fst = false ∨ b.snd ≤ c.snd → le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" state_after="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;⊢ le c.fst b.fst = false ∨ b.snd ≤ c.snd → le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" tactic="intro ab₁">
                            <AtomNode start="(105, 5)" end="(105, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(105, 11)" end="(105, 14)">
                              <IdentNode start="(105, 11)" end="(105, 14)" leading="" trailing="&#10;    " raw_val="ab₁" val="ab₁"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(106, 5)" end="(106, 12)" kind="Lean.Parser.Tactic.intro" state_before="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;⊢ le c.fst b.fst = false ∨ b.snd ≤ c.snd → le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" state_after="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" tactic="intro h">
                            <AtomNode start="(106, 5)" end="(106, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(106, 11)" end="(106, 12)">
                              <IdentNode start="(106, 11)" end="(106, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(107, 5)" end="(107, 37)" kind="Lean.Parser.Tactic.refine" state_before="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" state_after="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" tactic="refine ⟨trans _ _ _ ab₂ bc₂, ?_⟩">
                            <AtomNode start="(107, 5)" end="(107, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(107, 12)" end="(107, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(107, 12)" end="(107, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(107, 13)" end="(107, 36)">
                                <OtherNode start="(107, 13)" end="(107, 32)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(107, 13)" end="(107, 18)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                  <NullNode start="(107, 19)" end="(107, 32)">
                                    <TermHoleNode start="(107, 19)" end="(107, 20)">
                                      <AtomNode start="(107, 19)" end="(107, 20)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <TermHoleNode start="(107, 21)" end="(107, 22)">
                                      <AtomNode start="(107, 21)" end="(107, 22)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <TermHoleNode start="(107, 23)" end="(107, 24)">
                                      <AtomNode start="(107, 23)" end="(107, 24)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <IdentNode start="(107, 25)" end="(107, 28)" leading="" trailing=" " raw_val="ab₂" val="ab₂"/>
                                    <IdentNode start="(107, 29)" end="(107, 32)" leading="" trailing="" raw_val="bc₂" val="bc₂"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(107, 32)" end="(107, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(107, 34)" end="(107, 36)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(107, 34)" end="(107, 35)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(107, 35)" end="(107, 36)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(107, 36)" end="(107, 37)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(108, 5)" end="(108, 30)" kind="Lean.Parser.Tactic.rcases" state_before="case isTrue.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" state_after="case isTrue.isTrue.isTrue.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;cd₂ : le c.fst b.fst = false&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd&#10;&#10;case isTrue.isTrue.isTrue.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;bc₁ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" tactic="rcases h with (cd₂ | bc₁)">
                            <AtomNode start="(108, 5)" end="(108, 11)" leading="" trailing=" " val="rcases"/>
                            <NullNode start="(108, 12)" end="(108, 13)">
                              <OtherNode start="(108, 12)" end="(108, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(108, 12)" end="(108, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(108, 14)" end="(108, 30)">
                              <AtomNode start="(108, 14)" end="(108, 18)" leading="" trailing=" " val="with"/>
                              <OtherNode start="(108, 19)" end="(108, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(108, 19)" end="(108, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(108, 19)" end="(108, 30)">
                                    <OtherNode start="(108, 19)" end="(108, 30)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                      <AtomNode start="(108, 19)" end="(108, 20)" leading="" trailing="" val="("/>
                                      <OtherNode start="(108, 20)" end="(108, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(108, 20)" end="(108, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(108, 20)" end="(108, 29)">
                                            <OtherNode start="(108, 20)" end="(108, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(108, 20)" end="(108, 23)" leading="" trailing=" " raw_val="cd₂" val="cd₂"/>
                                            </OtherNode>
                                            <AtomNode start="(108, 24)" end="(108, 25)" leading="" trailing=" " val="|"/>
                                            <OtherNode start="(108, 26)" end="(108, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(108, 26)" end="(108, 29)" leading="" trailing="" raw_val="bc₁" val="bc₁"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(108, 29)" end="(108, 30)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(109, 5)" end="(110, 73)" kind="Lean.cdot" state_before="case isTrue.isTrue.isTrue.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;cd₂ : le c.fst b.fst = false&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd&#10;&#10;case isTrue.isTrue.isTrue.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;bc₁ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" state_after="case isTrue.isTrue.isTrue.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;bc₁ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" tactic="· exact Or.inl (Decidable.byContradiction&#10;    (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ (by simpa using ca₂) ab₂]))">
                            <OtherNode start="(109, 5)" end="(109, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(109, 5)" end="(109, 6)" kind="patternIgnore">
                                <OtherNode start="(109, 5)" end="(109, 6)" kind="token.«· »">
                                  <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(109, 7)" end="(110, 73)">
                              <TacticTacticseq1IndentedNode start="(109, 7)" end="(110, 73)">
                                <NullNode start="(109, 7)" end="(110, 73)">
                                  <OtherNode start="(109, 7)" end="(110, 73)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue.isTrue.isTrue.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;cd₂ : le c.fst b.fst = false&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" state_after="no goals" tactic="exact Or.inl (Decidable.byContradiction&#10;  (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ (by simpa using ca₂) ab₂]))">
                                    <AtomNode start="(109, 7)" end="(109, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(109, 13)" end="(110, 73)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(109, 13)" end="(109, 19)" leading="" trailing=" " raw_val="Or.inl" val="Or.inl" full_name="Or.inl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(109, 20)" end="(110, 73)">
                                        <OtherNode start="(109, 20)" end="(110, 73)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(109, 20)" end="(109, 21)" leading="" trailing="" val="("/>
                                          <OtherNode start="(109, 21)" end="(110, 72)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(109, 21)" end="(109, 46)" leading="" trailing="&#10;        " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(110, 9)" end="(110, 72)">
                                              <OtherNode start="(110, 9)" end="(110, 72)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(110, 9)" end="(110, 10)" leading="" trailing="" val="("/>
                                                <OtherNode start="(110, 10)" end="(110, 71)" kind="Lean.Parser.Term.fun">
                                                  <AtomNode start="(110, 10)" end="(110, 13)" leading="" trailing=" " val="fun"/>
                                                  <OtherNode start="(110, 14)" end="(110, 71)" kind="Lean.Parser.Term.basicFun">
                                                    <NullNode start="(110, 14)" end="(110, 17)">
                                                      <IdentNode start="(110, 14)" end="(110, 17)" leading="" trailing=" " raw_val="ca₂" val="ca₂"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <AtomNode start="(110, 18)" end="(110, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                                                    <TermBytacticNode start="(110, 21)" end="(110, 71)">
                                                      <AtomNode start="(110, 21)" end="(110, 23)" leading="" trailing=" " val="by"/>
                                                      <TacticTacticseqNode start="(110, 24)" end="(110, 71)">
                                                        <TacticTacticseq1IndentedNode start="(110, 24)" end="(110, 71)">
                                                          <NullNode start="(110, 24)" end="(110, 71)">
                                                            <OtherNode start="(110, 24)" end="(110, 71)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;cd₂ : le c.fst b.fst = false&#10;ca₂ : ¬le c.fst a.fst = false&#10;⊢ False" state_after="no goals" tactic="simp_all [trans _ _ _ (by simpa using ca₂) ab₂]">
                                                            <AtomNode start="(110, 24)" end="(110, 32)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(110, 33)" end="(110, 71)">
                                                            <AtomNode start="(110, 33)" end="(110, 34)" leading="" trailing="" val="["/>
                                                            <NullNode start="(110, 34)" end="(110, 70)">
                                                            <OtherNode start="(110, 34)" end="(110, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(110, 34)" end="(110, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(110, 34)" end="(110, 39)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                                            <NullNode start="(110, 40)" end="(110, 70)">
                                                            <TermHoleNode start="(110, 40)" end="(110, 41)">
                                                            <AtomNode start="(110, 40)" end="(110, 41)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(110, 42)" end="(110, 43)">
                                                            <AtomNode start="(110, 42)" end="(110, 43)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(110, 44)" end="(110, 45)">
                                                            <AtomNode start="(110, 44)" end="(110, 45)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(110, 46)" end="(110, 66)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(110, 46)" end="(110, 47)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(110, 47)" end="(110, 65)">
                                                            <AtomNode start="(110, 47)" end="(110, 49)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(110, 50)" end="(110, 65)">
                                                            <TacticTacticseq1IndentedNode start="(110, 50)" end="(110, 65)">
                                                            <NullNode start="(110, 50)" end="(110, 65)">
                                                            <OtherNode start="(110, 50)" end="(110, 65)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;cd₂ : le c.fst b.fst = false&#10;ca₂ : ¬le c.fst a.fst = false&#10;⊢ le ?m.29277 a.fst = true" state_after="no goals" tactic="simpa using ca₂">
                                                            <AtomNode start="(110, 50)" end="(110, 55)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(110, 56)" end="(110, 65)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(110, 56)" end="(110, 65)">
                                                            <AtomNode start="(110, 56)" end="(110, 61)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(110, 62)" end="(110, 65)" leading="" trailing="" raw_val="ca₂" val="ca₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(110, 65)" end="(110, 66)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(110, 67)" end="(110, 70)" leading="" trailing="" raw_val="ab₂" val="ab₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(110, 70)" end="(110, 71)" leading="" trailing="" val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </TermBytacticNode>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(110, 71)" end="(110, 72)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(110, 72)" end="(110, 73)" leading="" trailing="&#10;    " val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(111, 5)" end="(111, 42)" kind="Lean.cdot" state_before="case isTrue.isTrue.isTrue.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;bc₁ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" state_after="no goals" tactic="· exact Or.inr (Nat.le_trans ab₁ bc₁)">
                            <OtherNode start="(111, 5)" end="(111, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(111, 5)" end="(111, 6)" kind="patternIgnore">
                                <OtherNode start="(111, 5)" end="(111, 6)" kind="token.«· »">
                                  <AtomNode start="(111, 5)" end="(111, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(111, 7)" end="(111, 42)">
                              <TacticTacticseq1IndentedNode start="(111, 7)" end="(111, 42)">
                                <NullNode start="(111, 7)" end="(111, 42)">
                                  <OtherNode start="(111, 7)" end="(111, 42)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue.isTrue.isTrue.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;ab₁ : a.snd ≤ b.snd&#10;bc₁ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" state_after="no goals" tactic="exact Or.inr (Nat.le_trans ab₁ bc₁)">
                                    <AtomNode start="(111, 7)" end="(111, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(111, 13)" end="(111, 42)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(111, 13)" end="(111, 19)" leading="" trailing=" " raw_val="Or.inr" val="Or.inr" full_name="Or.inr" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(111, 20)" end="(111, 42)">
                                        <OtherNode start="(111, 20)" end="(111, 42)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(111, 20)" end="(111, 21)" leading="" trailing="" val="("/>
                                          <OtherNode start="(111, 21)" end="(111, 41)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(111, 21)" end="(111, 33)" leading="" trailing=" " raw_val="Nat.le_trans" val="Nat.le_trans" full_name="Nat.le_trans" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                            <NullNode start="(111, 34)" end="(111, 41)">
                                              <IdentNode start="(111, 34)" end="(111, 37)" leading="" trailing=" " raw_val="ab₁" val="ab₁"/>
                                              <IdentNode start="(111, 38)" end="(111, 41)" leading="" trailing="" raw_val="bc₁" val="bc₁"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(111, 41)" end="(111, 42)" leading="" trailing="&#10;  " val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(112, 3)" end="(112, 13)" kind="Lean.cdot" state_before="case isTrue.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all">
                    <OtherNode start="(112, 3)" end="(112, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(112, 3)" end="(112, 4)" kind="patternIgnore">
                        <OtherNode start="(112, 3)" end="(112, 4)" kind="token.«· »">
                          <AtomNode start="(112, 3)" end="(112, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(112, 5)" end="(112, 13)">
                      <TacticTacticseq1IndentedNode start="(112, 5)" end="(112, 13)">
                        <NullNode start="(112, 5)" end="(112, 13)">
                          <OtherNode start="(112, 5)" end="(112, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ decide (a.snd ≤ b.snd) = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(112, 5)" end="(112, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(113, 3)" end="(121, 73)" kind="Lean.cdot" state_before="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all&#10;  intro h&#10;  refine ⟨trans _ _ _ ab₂ bc₂, ?_⟩&#10;  left&#10;  rcases h with (cb₂ | _)&#10;  · exact (Decidable.byContradiction&#10;      (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ (by simpa using ca₂) ab₂]))&#10;  · exact (Decidable.byContradiction&#10;      (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ bc₂ (by simpa using ca₂)]))">
                    <OtherNode start="(113, 3)" end="(113, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(113, 3)" end="(113, 4)" kind="patternIgnore">
                        <OtherNode start="(113, 3)" end="(113, 4)" kind="token.«· »">
                          <AtomNode start="(113, 3)" end="(113, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(113, 5)" end="(121, 73)">
                      <TacticTacticseq1IndentedNode start="(113, 5)" end="(121, 73)">
                        <NullNode start="(113, 5)" end="(121, 73)">
                          <OtherNode start="(113, 5)" end="(113, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : le b.fst c.fst = true&#10;⊢ true = true →&#10;    (if le c.fst b.fst = true then decide (b.snd ≤ c.snd) else true) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;⊢ le c.fst b.fst = false ∨ b.snd ≤ c.snd → le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" tactic="simp_all">
                            <AtomNode start="(113, 5)" end="(113, 13)" leading="" trailing="&#10;    " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(114, 5)" end="(114, 12)" kind="Lean.Parser.Tactic.intro" state_before="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;⊢ le c.fst b.fst = false ∨ b.snd ≤ c.snd → le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" state_after="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" tactic="intro h">
                            <AtomNode start="(114, 5)" end="(114, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(114, 11)" end="(114, 12)">
                              <IdentNode start="(114, 11)" end="(114, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(115, 5)" end="(115, 37)" kind="Lean.Parser.Tactic.refine" state_before="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le a.fst c.fst = true ∧ (le c.fst a.fst = false ∨ a.snd ≤ c.snd)" state_after="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" tactic="refine ⟨trans _ _ _ ab₂ bc₂, ?_⟩">
                            <AtomNode start="(115, 5)" end="(115, 11)" leading="" trailing=" " val="refine"/>
                            <OtherNode start="(115, 12)" end="(115, 37)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(115, 12)" end="(115, 13)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(115, 13)" end="(115, 36)">
                                <OtherNode start="(115, 13)" end="(115, 32)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(115, 13)" end="(115, 18)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                  <NullNode start="(115, 19)" end="(115, 32)">
                                    <TermHoleNode start="(115, 19)" end="(115, 20)">
                                      <AtomNode start="(115, 19)" end="(115, 20)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <TermHoleNode start="(115, 21)" end="(115, 22)">
                                      <AtomNode start="(115, 21)" end="(115, 22)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <TermHoleNode start="(115, 23)" end="(115, 24)">
                                      <AtomNode start="(115, 23)" end="(115, 24)" leading="" trailing=" " val="_"/>
                                    </TermHoleNode>
                                    <IdentNode start="(115, 25)" end="(115, 28)" leading="" trailing=" " raw_val="ab₂" val="ab₂"/>
                                    <IdentNode start="(115, 29)" end="(115, 32)" leading="" trailing="" raw_val="bc₂" val="bc₂"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(115, 32)" end="(115, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(115, 34)" end="(115, 36)" kind="Lean.Parser.Term.syntheticHole">
                                  <AtomNode start="(115, 34)" end="(115, 35)" leading="" trailing="" val="?"/>
                                  <AtomNode start="(115, 35)" end="(115, 36)" leading="" trailing="" val="_"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(115, 36)" end="(115, 37)" leading="" trailing="&#10;    " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(116, 5)" end="(116, 9)" kind="Lean.Parser.Tactic.left" state_before="case isTrue.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false ∨ a.snd ≤ c.snd" state_after="case isTrue.isFalse.isTrue.h&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" tactic="left">
                            <AtomNode start="(116, 5)" end="(116, 9)" leading="" trailing="&#10;    " val="left"/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(117, 5)" end="(117, 28)" kind="Lean.Parser.Tactic.rcases" state_before="case isTrue.isFalse.isTrue.h&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h : le c.fst b.fst = false ∨ b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" state_after="case isTrue.isFalse.isTrue.h.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;cb₂ : le c.fst b.fst = false&#10;⊢ le c.fst a.fst = false&#10;&#10;case isTrue.isFalse.isTrue.h.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" tactic="rcases h with (cb₂ | _)">
                            <AtomNode start="(117, 5)" end="(117, 11)" leading="" trailing=" " val="rcases"/>
                            <NullNode start="(117, 12)" end="(117, 13)">
                              <OtherNode start="(117, 12)" end="(117, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(117, 12)" end="(117, 13)" leading="" trailing=" " raw_val="h" val="h"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(117, 14)" end="(117, 28)">
                              <AtomNode start="(117, 14)" end="(117, 18)" leading="" trailing=" " val="with"/>
                              <OtherNode start="(117, 19)" end="(117, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(117, 19)" end="(117, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(117, 19)" end="(117, 28)">
                                    <OtherNode start="(117, 19)" end="(117, 28)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                      <AtomNode start="(117, 19)" end="(117, 20)" leading="" trailing="" val="("/>
                                      <OtherNode start="(117, 20)" end="(117, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(117, 20)" end="(117, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(117, 20)" end="(117, 27)">
                                            <OtherNode start="(117, 20)" end="(117, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(117, 20)" end="(117, 23)" leading="" trailing=" " raw_val="cb₂" val="cb₂"/>
                                            </OtherNode>
                                            <AtomNode start="(117, 24)" end="(117, 25)" leading="" trailing=" " val="|"/>
                                            <OtherNode start="(117, 26)" end="(117, 27)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                              <AtomNode start="(117, 26)" end="(117, 27)" leading="" trailing="" val="_"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(117, 27)" end="(117, 28)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(118, 5)" end="(119, 73)" kind="Lean.cdot" state_before="case isTrue.isFalse.isTrue.h.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;cb₂ : le c.fst b.fst = false&#10;⊢ le c.fst a.fst = false&#10;&#10;case isTrue.isFalse.isTrue.h.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" state_after="case isTrue.isFalse.isTrue.h.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" tactic="· exact (Decidable.byContradiction&#10;    (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ (by simpa using ca₂) ab₂]))">
                            <OtherNode start="(118, 5)" end="(118, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(118, 5)" end="(118, 6)" kind="patternIgnore">
                                <OtherNode start="(118, 5)" end="(118, 6)" kind="token.«· »">
                                  <AtomNode start="(118, 5)" end="(118, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(118, 7)" end="(119, 73)">
                              <TacticTacticseq1IndentedNode start="(118, 7)" end="(119, 73)">
                                <NullNode start="(118, 7)" end="(119, 73)">
                                  <OtherNode start="(118, 7)" end="(119, 73)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue.isFalse.isTrue.h.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;cb₂ : le c.fst b.fst = false&#10;⊢ le c.fst a.fst = false" state_after="no goals" tactic="exact (Decidable.byContradiction&#10;  (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ (by simpa using ca₂) ab₂]))">
                                    <AtomNode start="(118, 7)" end="(118, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(118, 13)" end="(119, 73)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(118, 13)" end="(118, 14)" leading="" trailing="" val="("/>
                                      <OtherNode start="(118, 14)" end="(119, 72)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(118, 14)" end="(118, 39)" leading="" trailing="&#10;        " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        <NullNode start="(119, 9)" end="(119, 72)">
                                          <OtherNode start="(119, 9)" end="(119, 72)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(119, 9)" end="(119, 10)" leading="" trailing="" val="("/>
                                            <OtherNode start="(119, 10)" end="(119, 71)" kind="Lean.Parser.Term.fun">
                                              <AtomNode start="(119, 10)" end="(119, 13)" leading="" trailing=" " val="fun"/>
                                              <OtherNode start="(119, 14)" end="(119, 71)" kind="Lean.Parser.Term.basicFun">
                                                <NullNode start="(119, 14)" end="(119, 17)">
                                                  <IdentNode start="(119, 14)" end="(119, 17)" leading="" trailing=" " raw_val="ca₂" val="ca₂"/>
                                                </NullNode>
                                                <NullNode/>
                                                <AtomNode start="(119, 18)" end="(119, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TermBytacticNode start="(119, 21)" end="(119, 71)">
                                                  <AtomNode start="(119, 21)" end="(119, 23)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(119, 24)" end="(119, 71)">
                                                    <TacticTacticseq1IndentedNode start="(119, 24)" end="(119, 71)">
                                                      <NullNode start="(119, 24)" end="(119, 71)">
                                                        <OtherNode start="(119, 24)" end="(119, 71)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;cb₂ : le c.fst b.fst = false&#10;ca₂ : ¬le c.fst a.fst = false&#10;⊢ False" state_after="no goals" tactic="simp_all [trans _ _ _ (by simpa using ca₂) ab₂]">
                                                          <AtomNode start="(119, 24)" end="(119, 32)" leading="" trailing=" " val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(119, 33)" end="(119, 71)">
                                                            <AtomNode start="(119, 33)" end="(119, 34)" leading="" trailing="" val="["/>
                                                            <NullNode start="(119, 34)" end="(119, 70)">
                                                            <OtherNode start="(119, 34)" end="(119, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(119, 34)" end="(119, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(119, 34)" end="(119, 39)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                                            <NullNode start="(119, 40)" end="(119, 70)">
                                                            <TermHoleNode start="(119, 40)" end="(119, 41)">
                                                            <AtomNode start="(119, 40)" end="(119, 41)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(119, 42)" end="(119, 43)">
                                                            <AtomNode start="(119, 42)" end="(119, 43)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(119, 44)" end="(119, 45)">
                                                            <AtomNode start="(119, 44)" end="(119, 45)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(119, 46)" end="(119, 66)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(119, 46)" end="(119, 47)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(119, 47)" end="(119, 65)">
                                                            <AtomNode start="(119, 47)" end="(119, 49)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(119, 50)" end="(119, 65)">
                                                            <TacticTacticseq1IndentedNode start="(119, 50)" end="(119, 65)">
                                                            <NullNode start="(119, 50)" end="(119, 65)">
                                                            <OtherNode start="(119, 50)" end="(119, 65)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;cb₂ : le c.fst b.fst = false&#10;ca₂ : ¬le c.fst a.fst = false&#10;⊢ le ?m.36778 a.fst = true" state_after="no goals" tactic="simpa using ca₂">
                                                            <AtomNode start="(119, 50)" end="(119, 55)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(119, 56)" end="(119, 65)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(119, 56)" end="(119, 65)">
                                                            <AtomNode start="(119, 56)" end="(119, 61)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(119, 62)" end="(119, 65)" leading="" trailing="" raw_val="ca₂" val="ca₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(119, 65)" end="(119, 66)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <IdentNode start="(119, 67)" end="(119, 70)" leading="" trailing="" raw_val="ab₂" val="ab₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(119, 70)" end="(119, 71)" leading="" trailing="" val="]"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(119, 71)" end="(119, 72)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(119, 72)" end="(119, 73)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(120, 5)" end="(121, 73)" kind="Lean.cdot" state_before="case isTrue.isFalse.isTrue.h.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" state_after="no goals" tactic="· exact (Decidable.byContradiction&#10;    (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ bc₂ (by simpa using ca₂)]))">
                            <OtherNode start="(120, 5)" end="(120, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(120, 5)" end="(120, 6)" kind="patternIgnore">
                                <OtherNode start="(120, 5)" end="(120, 6)" kind="token.«· »">
                                  <AtomNode start="(120, 5)" end="(120, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(120, 7)" end="(121, 73)">
                              <TacticTacticseq1IndentedNode start="(120, 7)" end="(121, 73)">
                                <NullNode start="(120, 7)" end="(121, 73)">
                                  <OtherNode start="(120, 7)" end="(121, 73)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue.isFalse.isTrue.h.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;⊢ le c.fst a.fst = false" state_after="no goals" tactic="exact (Decidable.byContradiction&#10;  (fun ca₂ =&amp;gt; by simp_all [trans _ _ _ bc₂ (by simpa using ca₂)]))">
                                    <AtomNode start="(120, 7)" end="(120, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(120, 13)" end="(121, 73)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(120, 13)" end="(120, 14)" leading="" trailing="" val="("/>
                                      <OtherNode start="(120, 14)" end="(121, 72)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(120, 14)" end="(120, 39)" leading="" trailing="&#10;        " raw_val="Decidable.byContradiction" val="Decidable.byContradiction" full_name="Decidable.byContradiction" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        <NullNode start="(121, 9)" end="(121, 72)">
                                          <OtherNode start="(121, 9)" end="(121, 72)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(121, 9)" end="(121, 10)" leading="" trailing="" val="("/>
                                            <OtherNode start="(121, 10)" end="(121, 71)" kind="Lean.Parser.Term.fun">
                                              <AtomNode start="(121, 10)" end="(121, 13)" leading="" trailing=" " val="fun"/>
                                              <OtherNode start="(121, 14)" end="(121, 71)" kind="Lean.Parser.Term.basicFun">
                                                <NullNode start="(121, 14)" end="(121, 17)">
                                                  <IdentNode start="(121, 14)" end="(121, 17)" leading="" trailing=" " raw_val="ca₂" val="ca₂"/>
                                                </NullNode>
                                                <NullNode/>
                                                <AtomNode start="(121, 18)" end="(121, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TermBytacticNode start="(121, 21)" end="(121, 71)">
                                                  <AtomNode start="(121, 21)" end="(121, 23)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(121, 24)" end="(121, 71)">
                                                    <TacticTacticseq1IndentedNode start="(121, 24)" end="(121, 71)">
                                                      <NullNode start="(121, 24)" end="(121, 71)">
                                                        <OtherNode start="(121, 24)" end="(121, 71)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;ca₂ : ¬le c.fst a.fst = false&#10;⊢ False" state_after="no goals" tactic="simp_all [trans _ _ _ bc₂ (by simpa using ca₂)]">
                                                          <AtomNode start="(121, 24)" end="(121, 32)" leading="" trailing=" " val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(121, 33)" end="(121, 71)">
                                                            <AtomNode start="(121, 33)" end="(121, 34)" leading="" trailing="" val="["/>
                                                            <NullNode start="(121, 34)" end="(121, 70)">
                                                            <OtherNode start="(121, 34)" end="(121, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(121, 34)" end="(121, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(121, 34)" end="(121, 39)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                                            <NullNode start="(121, 40)" end="(121, 70)">
                                                            <TermHoleNode start="(121, 40)" end="(121, 41)">
                                                            <AtomNode start="(121, 40)" end="(121, 41)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(121, 42)" end="(121, 43)">
                                                            <AtomNode start="(121, 42)" end="(121, 43)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(121, 44)" end="(121, 45)">
                                                            <AtomNode start="(121, 44)" end="(121, 45)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(121, 46)" end="(121, 49)" leading="" trailing=" " raw_val="bc₂" val="bc₂"/>
                                                            <OtherNode start="(121, 50)" end="(121, 70)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(121, 50)" end="(121, 51)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(121, 51)" end="(121, 69)">
                                                            <AtomNode start="(121, 51)" end="(121, 53)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(121, 54)" end="(121, 69)">
                                                            <TacticTacticseq1IndentedNode start="(121, 54)" end="(121, 69)">
                                                            <NullNode start="(121, 54)" end="(121, 69)">
                                                            <OtherNode start="(121, 54)" end="(121, 69)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : le b.fst a.fst = false&#10;bc₂ : le b.fst c.fst = true&#10;h✝ : b.snd ≤ c.snd&#10;ca₂ : ¬le c.fst a.fst = false&#10;⊢ le c.fst ?m.37647 = true" state_after="no goals" tactic="simpa using ca₂">
                                                            <AtomNode start="(121, 54)" end="(121, 59)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(121, 60)" end="(121, 69)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(121, 60)" end="(121, 69)">
                                                            <AtomNode start="(121, 60)" end="(121, 65)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(121, 66)" end="(121, 69)" leading="" trailing="" raw_val="ca₂" val="ca₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(121, 69)" end="(121, 70)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(121, 70)" end="(121, 71)" leading="" trailing="" val="]"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(121, 71)" end="(121, 72)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(121, 72)" end="(121, 73)" leading="" trailing="&#10;  " val=")"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(122, 3)" end="(122, 13)" kind="Lean.cdot" state_before="case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all">
                    <OtherNode start="(122, 3)" end="(122, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(122, 3)" end="(122, 4)" kind="patternIgnore">
                        <OtherNode start="(122, 3)" end="(122, 4)" kind="token.«· »">
                          <AtomNode start="(122, 3)" end="(122, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(122, 5)" end="(122, 13)">
                      <TacticTacticseq1IndentedNode start="(122, 5)" end="(122, 13)">
                        <NullNode start="(122, 5)" end="(122, 13)">
                          <OtherNode start="(122, 5)" end="(122, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isTrue.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : le a.fst b.fst = true&#10;ba₂ : ¬le b.fst a.fst = true&#10;bc₂ : ¬le b.fst c.fst = true&#10;⊢ true = true →&#10;    false = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(122, 5)" end="(122, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(123, 3)" end="(123, 13)" kind="Lean.cdot" state_before="case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all">
                    <OtherNode start="(123, 3)" end="(123, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(123, 3)" end="(123, 4)" kind="patternIgnore">
                        <OtherNode start="(123, 3)" end="(123, 4)" kind="token.«· »">
                          <AtomNode start="(123, 3)" end="(123, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(123, 5)" end="(123, 13)">
                      <TacticTacticseq1IndentedNode start="(123, 5)" end="(123, 13)">
                        <NullNode start="(123, 5)" end="(123, 13)">
                          <OtherNode start="(123, 5)" end="(123, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : le c.fst b.fst = true&#10;⊢ false = true →&#10;    decide (b.snd ≤ c.snd) = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(123, 5)" end="(123, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(124, 3)" end="(124, 13)" kind="Lean.cdot" state_before="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true&#10;&#10;case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all">
                    <OtherNode start="(124, 3)" end="(124, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(124, 3)" end="(124, 4)" kind="patternIgnore">
                        <OtherNode start="(124, 3)" end="(124, 4)" kind="token.«· »">
                          <AtomNode start="(124, 3)" end="(124, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(124, 5)" end="(124, 13)">
                      <TacticTacticseq1IndentedNode start="(124, 5)" end="(124, 13)">
                        <NullNode start="(124, 5)" end="(124, 13)">
                          <OtherNode start="(124, 5)" end="(124, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : le b.fst c.fst = true&#10;bc₂ : ¬le c.fst b.fst = true&#10;⊢ false = true →&#10;    true = true →&#10;      (if le a.fst c.fst = true then if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true else false) = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(124, 5)" end="(124, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(125, 3)" end="(125, 13)" kind="Lean.cdot" state_before="case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true&#10;&#10;case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" tactic="· simp_all">
                    <OtherNode start="(125, 3)" end="(125, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(125, 3)" end="(125, 4)" kind="patternIgnore">
                        <OtherNode start="(125, 3)" end="(125, 4)" kind="token.«· »">
                          <AtomNode start="(125, 3)" end="(125, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(125, 5)" end="(125, 13)">
                      <TacticTacticseq1IndentedNode start="(125, 5)" end="(125, 13)">
                        <NullNode start="(125, 5)" end="(125, 13)">
                          <OtherNode start="(125, 5)" end="(125, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : le a.fst c.fst = true&#10;⊢ false = true → false = true → (if le c.fst a.fst = true then decide (a.snd ≤ c.snd) else true) = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(125, 5)" end="(125, 13)" leading="" trailing="&#10;  " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(126, 3)" end="(126, 13)" kind="Lean.cdot" state_before="case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="no goals" tactic="· simp_all">
                    <OtherNode start="(126, 3)" end="(126, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(126, 3)" end="(126, 4)" kind="patternIgnore">
                        <OtherNode start="(126, 3)" end="(126, 4)" kind="token.«· »">
                          <AtomNode start="(126, 3)" end="(126, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(126, 5)" end="(126, 13)">
                      <TacticTacticseq1IndentedNode start="(126, 5)" end="(126, 13)">
                        <NullNode start="(126, 5)" end="(126, 13)">
                          <OtherNode start="(126, 5)" end="(126, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;a b c : α × Nat&#10;ab₂ : ¬le a.fst b.fst = true&#10;ba₂ : ¬le b.fst c.fst = true&#10;bc₂ : ¬le a.fst c.fst = true&#10;⊢ false = true → false = true → false = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(126, 5)" end="(126, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(128, 1)" end="(136, 13)" name="zipIdxLE_total" full_name="List.zipIdxLE_total">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(128, 1)" end="(136, 13)" name="zipIdxLE_total" full_name="List.zipIdxLE_total" _is_private_decl="False">
        <AtomNode start="(128, 1)" end="(128, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(128, 9)" end="(128, 23)">
          <IdentNode start="(128, 9)" end="(128, 23)" leading="" trailing=" " raw_val="zipIdxLE_total" val="zipIdxLE_total"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(128, 24)" end="(129, 57)">
          <NullNode start="(128, 24)" end="(129, 20)">
            <TermExplicitbinderNode start="(128, 24)" end="(128, 57)">
              <AtomNode start="(128, 24)" end="(128, 25)" leading="" trailing="" val="("/>
              <NullNode start="(128, 25)" end="(128, 30)">
                <IdentNode start="(128, 25)" end="(128, 30)" leading="" trailing=" " raw_val="total" val="total"/>
              </NullNode>
              <NullNode start="(128, 31)" end="(128, 56)">
                <AtomNode start="(128, 31)" end="(128, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(128, 33)" end="(128, 56)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(128, 33)" end="(128, 34)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(128, 35)" end="(128, 38)">
                    <IdentNode start="(128, 35)" end="(128, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(128, 37)" end="(128, 38)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(128, 38)" end="(128, 39)" leading="" trailing=" " val=","/>
                  <OtherNode start="(128, 40)" end="(128, 56)" kind="«term_||_»">
                    <OtherNode start="(128, 40)" end="(128, 46)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(128, 40)" end="(128, 42)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(128, 43)" end="(128, 46)">
                        <IdentNode start="(128, 43)" end="(128, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(128, 45)" end="(128, 46)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(128, 47)" end="(128, 49)" leading="" trailing=" " val="||"/>
                    <OtherNode start="(128, 50)" end="(128, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(128, 50)" end="(128, 52)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(128, 53)" end="(128, 56)">
                        <IdentNode start="(128, 53)" end="(128, 54)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(128, 55)" end="(128, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(128, 56)" end="(128, 57)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(129, 5)" end="(129, 20)">
              <AtomNode start="(129, 5)" end="(129, 6)" leading="" trailing="" val="("/>
              <NullNode start="(129, 6)" end="(129, 9)">
                <IdentNode start="(129, 6)" end="(129, 7)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(129, 8)" end="(129, 9)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(129, 10)" end="(129, 19)">
                <AtomNode start="(129, 10)" end="(129, 11)" leading="" trailing=" " val=":"/>
                <OtherNode start="(129, 12)" end="(129, 19)" kind="«term_×_»">
                  <IdentNode start="(129, 12)" end="(129, 13)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(129, 14)" end="(129, 15)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(129, 16)" end="(129, 19)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(129, 19)" end="(129, 20)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(129, 21)" end="(129, 57)">
            <AtomNode start="(129, 21)" end="(129, 22)" leading="" trailing=" " val=":"/>
            <OtherNode start="(129, 23)" end="(129, 57)" kind="«term_||_»">
              <OtherNode start="(129, 23)" end="(129, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(129, 23)" end="(129, 31)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(129, 32)" end="(129, 38)">
                  <IdentNode start="(129, 32)" end="(129, 34)" leading="" trailing=" " raw_val="le" val="le"/>
                  <IdentNode start="(129, 35)" end="(129, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                  <IdentNode start="(129, 37)" end="(129, 38)" leading="" trailing=" " raw_val="b" val="b"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(129, 39)" end="(129, 41)" leading="" trailing=" " val="||"/>
              <OtherNode start="(129, 42)" end="(129, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(129, 42)" end="(129, 50)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(129, 51)" end="(129, 57)">
                  <IdentNode start="(129, 51)" end="(129, 53)" leading="" trailing=" " raw_val="le" val="le"/>
                  <IdentNode start="(129, 54)" end="(129, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                  <IdentNode start="(129, 56)" end="(129, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(129, 58)" end="(136, 13)">
          <AtomNode start="(129, 58)" end="(129, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(129, 61)" end="(136, 13)">
            <AtomNode start="(129, 61)" end="(129, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(130, 3)" end="(136, 13)">
              <TacticTacticseq1IndentedNode start="(130, 3)" end="(136, 13)">
                <NullNode start="(130, 3)" end="(136, 13)">
                  <OtherNode start="(130, 3)" end="(130, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;⊢ (zipIdxLE le a b || zipIdxLE le b a) = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;⊢ ((if le a.fst b.fst = true then if le b.fst a.fst = true then decide (a.snd ≤ b.snd) else true else false) ||&#10;      if le b.fst a.fst = true then if le a.fst b.fst = true then decide (b.snd ≤ a.snd) else true else false) =&#10;    true" tactic="simp only [zipIdxLE]">
                    <AtomNode start="(130, 3)" end="(130, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(130, 8)" end="(130, 12)">
                      <AtomNode start="(130, 8)" end="(130, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(130, 13)" end="(130, 23)">
                      <AtomNode start="(130, 13)" end="(130, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(130, 14)" end="(130, 22)">
                        <OtherNode start="(130, 14)" end="(130, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(130, 14)" end="(130, 22)" leading="" trailing="" raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(130, 22)" end="(130, 23)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(131, 3)" end="(131, 18)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;⊢ ((if le a.fst b.fst = true then if le b.fst a.fst = true then decide (a.snd ≤ b.snd) else true else false) ||&#10;      if le b.fst a.fst = true then if le a.fst b.fst = true then decide (b.snd ≤ a.snd) else true else false) =&#10;    true" state_after="case isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (decide (a.snd ≤ b.snd) || decide (b.snd ≤ a.snd)) = true&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (true || false) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" tactic="split &amp;lt;;&amp;gt; split">
                    <OtherNode start="(131, 3)" end="(131, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(131, 3)" end="(131, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(131, 9)" end="(131, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(131, 13)" end="(131, 18)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(131, 13)" end="(131, 18)" leading="" trailing="&#10;  " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(132, 3)" end="(132, 37)" kind="Lean.cdot" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (decide (a.snd ≤ b.snd) || decide (b.snd ≤ a.snd)) = true&#10;&#10;case isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (true || false) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" state_after="case isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (true || false) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" tactic="· simpa using Nat.le_total a.2 b.2">
                    <OtherNode start="(132, 3)" end="(132, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(132, 3)" end="(132, 4)" kind="patternIgnore">
                        <OtherNode start="(132, 3)" end="(132, 4)" kind="token.«· »">
                          <AtomNode start="(132, 3)" end="(132, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(132, 5)" end="(132, 37)">
                      <TacticTacticseq1IndentedNode start="(132, 5)" end="(132, 37)">
                        <NullNode start="(132, 5)" end="(132, 37)">
                          <OtherNode start="(132, 5)" end="(132, 37)" kind="Lean.Parser.Tactic.simpa" state_before="case isTrue.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (decide (a.snd ≤ b.snd) || decide (b.snd ≤ a.snd)) = true" state_after="no goals" tactic="simpa using Nat.le_total a.2 b.2">
                            <AtomNode start="(132, 5)" end="(132, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(132, 11)" end="(132, 37)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(132, 11)" end="(132, 37)">
                                <AtomNode start="(132, 11)" end="(132, 16)" leading="" trailing=" " val="using"/>
                                <OtherNode start="(132, 17)" end="(132, 37)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(132, 17)" end="(132, 29)" leading="" trailing=" " raw_val="Nat.le_total" val="Nat.le_total" full_name="Nat.le_total" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                  <NullNode start="(132, 30)" end="(132, 37)">
                                    <OtherNode start="(132, 30)" end="(132, 33)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(132, 30)" end="(132, 31)" leading="" trailing="" raw_val="a" val="a"/>
                                      <AtomNode start="(132, 31)" end="(132, 32)" leading="" trailing="" val="."/>
                                      <OtherNode start="(132, 32)" end="(132, 33)" kind="fieldIdx">
                                        <AtomNode start="(132, 32)" end="(132, 33)" leading="" trailing=" " val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <OtherNode start="(132, 34)" end="(132, 37)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(132, 34)" end="(132, 35)" leading="" trailing="" raw_val="b" val="b"/>
                                      <AtomNode start="(132, 35)" end="(132, 36)" leading="" trailing="" val="."/>
                                      <OtherNode start="(132, 36)" end="(132, 37)" kind="fieldIdx">
                                        <AtomNode start="(132, 36)" end="(132, 37)" leading="" trailing="&#10;  " val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(133, 3)" end="(133, 9)" kind="Lean.cdot" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (true || false) = true&#10;&#10;case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" state_after="case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" tactic="· simp">
                    <OtherNode start="(133, 3)" end="(133, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(133, 3)" end="(133, 4)" kind="patternIgnore">
                        <OtherNode start="(133, 3)" end="(133, 4)" kind="token.«· »">
                          <AtomNode start="(133, 3)" end="(133, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(133, 5)" end="(133, 9)">
                      <TacticTacticseq1IndentedNode start="(133, 5)" end="(133, 9)">
                        <NullNode start="(133, 5)" end="(133, 9)">
                          <OtherNode start="(133, 5)" end="(133, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (true || false) = true" state_after="no goals" tactic="simp">
                            <AtomNode start="(133, 5)" end="(133, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(134, 3)" end="(134, 9)" kind="Lean.cdot" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true&#10;&#10;case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" tactic="· simp">
                    <OtherNode start="(134, 3)" end="(134, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(134, 3)" end="(134, 4)" kind="patternIgnore">
                        <OtherNode start="(134, 3)" end="(134, 4)" kind="token.«· »">
                          <AtomNode start="(134, 3)" end="(134, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(134, 5)" end="(134, 9)">
                      <TacticTacticseq1IndentedNode start="(134, 5)" end="(134, 9)">
                        <NullNode start="(134, 5)" end="(134, 9)">
                          <OtherNode start="(134, 5)" end="(134, 9)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : le b.fst a.fst = true&#10;⊢ (false || true) = true" state_after="no goals" tactic="simp">
                            <AtomNode start="(134, 5)" end="(134, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(135, 3)" end="(136, 13)" kind="Lean.cdot" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" state_after="no goals" tactic="· have := total a.1 b.1&#10;  simp_all">
                    <OtherNode start="(135, 3)" end="(135, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(135, 3)" end="(135, 4)" kind="patternIgnore">
                        <OtherNode start="(135, 3)" end="(135, 4)" kind="token.«· »">
                          <AtomNode start="(135, 3)" end="(135, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(135, 5)" end="(136, 13)">
                      <TacticTacticseq1IndentedNode start="(135, 5)" end="(136, 13)">
                        <NullNode start="(135, 5)" end="(136, 13)">
                          <OtherNode start="(135, 5)" end="(135, 26)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;⊢ (false || false) = true" state_after="case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;this : (le a.fst b.fst || le b.fst a.fst) = true&#10;⊢ (false || false) = true" tactic="have := total a.1 b.1">
                            <AtomNode start="(135, 5)" end="(135, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(135, 10)" end="(135, 26)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(135, 10)" end="(135, 26)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(135, 10)" end="(135, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(135, 10)" end="(135, 10)" kind="hygieneInfo">
                                    <IdentNode start="(135, 10)" end="(135, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(135, 10)" end="(135, 12)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(135, 13)" end="(135, 26)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(135, 13)" end="(135, 18)" leading="" trailing=" " raw_val="total" val="total"/>
                                  <NullNode start="(135, 19)" end="(135, 26)">
                                    <OtherNode start="(135, 19)" end="(135, 22)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(135, 19)" end="(135, 20)" leading="" trailing="" raw_val="a" val="a"/>
                                      <AtomNode start="(135, 20)" end="(135, 21)" leading="" trailing="" val="."/>
                                      <OtherNode start="(135, 21)" end="(135, 22)" kind="fieldIdx">
                                        <AtomNode start="(135, 21)" end="(135, 22)" leading="" trailing=" " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <OtherNode start="(135, 23)" end="(135, 26)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(135, 23)" end="(135, 24)" leading="" trailing="" raw_val="b" val="b"/>
                                      <AtomNode start="(135, 24)" end="(135, 25)" leading="" trailing="" val="."/>
                                      <OtherNode start="(135, 25)" end="(135, 26)" kind="fieldIdx">
                                        <AtomNode start="(135, 25)" end="(135, 26)" leading="" trailing="&#10;    " val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(136, 5)" end="(136, 13)" kind="Lean.Parser.Tactic.simpAll" state_before="case isFalse.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α × Nat&#10;h✝¹ : ¬le a.fst b.fst = true&#10;h✝ : ¬le b.fst a.fst = true&#10;this : (le a.fst b.fst || le b.fst a.fst) = true&#10;⊢ (false || false) = true" state_after="no goals" tactic="simp_all">
                            <AtomNode start="(136, 5)" end="(136, 13)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(138, 1)" end="(138, 17)" comment="### merge -/">
      <AtomNode start="(138, 1)" end="(138, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(138, 5)" end="(138, 17)" leading="" trailing="&#10;&#10;" val="### merge -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(140, 1)" end="(142, 20)" name="cons_merge_cons" full_name="List.cons_merge_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(140, 1)" end="(142, 20)" name="cons_merge_cons" full_name="List.cons_merge_cons" _is_private_decl="False">
        <AtomNode start="(140, 1)" end="(140, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(140, 9)" end="(140, 24)">
          <IdentNode start="(140, 9)" end="(140, 24)" leading="" trailing=" " raw_val="cons_merge_cons" val="cons_merge_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(140, 25)" end="(141, 91)">
          <NullNode start="(140, 25)" end="(140, 53)">
            <TermExplicitbinderNode start="(140, 25)" end="(140, 43)">
              <AtomNode start="(140, 25)" end="(140, 26)" leading="" trailing="" val="("/>
              <NullNode start="(140, 26)" end="(140, 27)">
                <IdentNode start="(140, 26)" end="(140, 27)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(140, 28)" end="(140, 42)">
                <AtomNode start="(140, 28)" end="(140, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(140, 30)" end="(140, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(140, 30)" end="(140, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(140, 32)" end="(140, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(140, 34)" end="(140, 42)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(140, 34)" end="(140, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(140, 36)" end="(140, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(140, 38)" end="(140, 42)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(140, 42)" end="(140, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(140, 44)" end="(140, 53)">
              <AtomNode start="(140, 44)" end="(140, 45)" leading="" trailing="" val="("/>
              <NullNode start="(140, 45)" end="(140, 52)">
                <IdentNode start="(140, 45)" end="(140, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(140, 47)" end="(140, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(140, 49)" end="(140, 50)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(140, 51)" end="(140, 52)" leading="" trailing="" raw_val="r" val="r"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(140, 52)" end="(140, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(140, 54)" end="(141, 91)">
            <AtomNode start="(140, 54)" end="(140, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(141, 5)" end="(141, 91)" kind="«term_=_»">
              <OtherNode start="(141, 5)" end="(141, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(141, 5)" end="(141, 10)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(141, 11)" end="(141, 26)">
                  <OtherNode start="(141, 11)" end="(141, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(141, 11)" end="(141, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(141, 12)" end="(141, 16)" kind="«term_::_»">
                      <IdentNode start="(141, 12)" end="(141, 13)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(141, 13)" end="(141, 15)" leading="" trailing="" val="::"/>
                      <IdentNode start="(141, 15)" end="(141, 16)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(141, 16)" end="(141, 17)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(141, 18)" end="(141, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(141, 18)" end="(141, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(141, 19)" end="(141, 23)" kind="«term_::_»">
                      <IdentNode start="(141, 19)" end="(141, 20)" leading="" trailing="" raw_val="b" val="b"/>
                      <AtomNode start="(141, 20)" end="(141, 22)" leading="" trailing="" val="::"/>
                      <IdentNode start="(141, 22)" end="(141, 23)" leading="" trailing="" raw_val="r" val="r"/>
                    </OtherNode>
                    <AtomNode start="(141, 23)" end="(141, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(141, 25)" end="(141, 26)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(141, 27)" end="(141, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(141, 29)" end="(141, 91)" kind="termIfThenElse">
                <AtomNode start="(141, 29)" end="(141, 31)" leading="" trailing=" " val="if"/>
                <OtherNode start="(141, 32)" end="(141, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(141, 32)" end="(141, 33)" leading="" trailing=" " raw_val="s" val="s"/>
                  <NullNode start="(141, 34)" end="(141, 37)">
                    <IdentNode start="(141, 34)" end="(141, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(141, 36)" end="(141, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(141, 38)" end="(141, 42)" leading="" trailing=" " val="then"/>
                <OtherNode start="(141, 43)" end="(141, 64)" kind="«term_::_»">
                  <IdentNode start="(141, 43)" end="(141, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(141, 45)" end="(141, 47)" leading="" trailing=" " val="::"/>
                  <OtherNode start="(141, 48)" end="(141, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(141, 48)" end="(141, 53)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(141, 54)" end="(141, 64)">
                      <IdentNode start="(141, 54)" end="(141, 55)" leading="" trailing=" " raw_val="l" val="l"/>
                      <OtherNode start="(141, 56)" end="(141, 62)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(141, 56)" end="(141, 57)" leading="" trailing="" val="("/>
                        <OtherNode start="(141, 57)" end="(141, 61)" kind="«term_::_»">
                          <IdentNode start="(141, 57)" end="(141, 58)" leading="" trailing="" raw_val="b" val="b"/>
                          <AtomNode start="(141, 58)" end="(141, 60)" leading="" trailing="" val="::"/>
                          <IdentNode start="(141, 60)" end="(141, 61)" leading="" trailing="" raw_val="r" val="r"/>
                        </OtherNode>
                        <AtomNode start="(141, 61)" end="(141, 62)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(141, 63)" end="(141, 64)" leading="" trailing=" " raw_val="s" val="s"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(141, 65)" end="(141, 69)" leading="" trailing=" " val="else"/>
                <OtherNode start="(141, 70)" end="(141, 91)" kind="«term_::_»">
                  <IdentNode start="(141, 70)" end="(141, 71)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(141, 72)" end="(141, 74)" leading="" trailing=" " val="::"/>
                  <OtherNode start="(141, 75)" end="(141, 91)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(141, 75)" end="(141, 80)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(141, 81)" end="(141, 91)">
                      <OtherNode start="(141, 81)" end="(141, 87)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(141, 81)" end="(141, 82)" leading="" trailing="" val="("/>
                        <OtherNode start="(141, 82)" end="(141, 86)" kind="«term_::_»">
                          <IdentNode start="(141, 82)" end="(141, 83)" leading="" trailing="" raw_val="a" val="a"/>
                          <AtomNode start="(141, 83)" end="(141, 85)" leading="" trailing="" val="::"/>
                          <IdentNode start="(141, 85)" end="(141, 86)" leading="" trailing="" raw_val="l" val="l"/>
                        </OtherNode>
                        <AtomNode start="(141, 86)" end="(141, 87)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(141, 88)" end="(141, 89)" leading="" trailing=" " raw_val="r" val="r"/>
                      <IdentNode start="(141, 90)" end="(141, 91)" leading="" trailing=" " raw_val="s" val="s"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(141, 92)" end="(142, 20)">
          <AtomNode start="(141, 92)" end="(141, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(141, 95)" end="(142, 20)">
            <AtomNode start="(141, 95)" end="(141, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(142, 3)" end="(142, 20)">
              <TacticTacticseq1IndentedNode start="(142, 3)" end="(142, 20)">
                <NullNode start="(142, 3)" end="(142, 20)">
                  <OtherNode start="(142, 3)" end="(142, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;s : α → α → Bool&#10;a b : α&#10;l r : List α&#10;⊢ (a :: l).merge (b :: r) s = if s a b = true then a :: l.merge (b :: r) s else b :: (a :: l).merge r s" state_after="no goals" tactic="simp only [merge]">
                    <AtomNode start="(142, 3)" end="(142, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(142, 8)" end="(142, 12)">
                      <AtomNode start="(142, 8)" end="(142, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(142, 13)" end="(142, 20)">
                      <AtomNode start="(142, 13)" end="(142, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(142, 14)" end="(142, 19)">
                        <OtherNode start="(142, 14)" end="(142, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(142, 14)" end="(142, 19)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(142, 19)" end="(142, 20)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(144, 1)" end="(146, 33)" name="cons_merge_cons_pos" full_name="List.cons_merge_cons_pos">
      <CommandDeclmodifiersNode start="(144, 1)" end="(144, 8)">
        <NullNode/>
        <NullNode start="(144, 1)" end="(144, 8)">
          <OtherNode start="(144, 1)" end="(144, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(144, 1)" end="(144, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(144, 3)" end="(144, 7)">
              <OtherNode start="(144, 3)" end="(144, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(144, 3)" end="(144, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(144, 3)" end="(144, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(144, 7)" end="(144, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(144, 9)" end="(146, 33)" name="cons_merge_cons_pos" full_name="List.cons_merge_cons_pos" _is_private_decl="False">
        <AtomNode start="(144, 9)" end="(144, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(144, 17)" end="(144, 36)">
          <IdentNode start="(144, 17)" end="(144, 36)" leading="" trailing=" " raw_val="cons_merge_cons_pos" val="cons_merge_cons_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(144, 37)" end="(145, 50)">
          <NullNode start="(144, 37)" end="(144, 73)">
            <TermExplicitbinderNode start="(144, 37)" end="(144, 55)">
              <AtomNode start="(144, 37)" end="(144, 38)" leading="" trailing="" val="("/>
              <NullNode start="(144, 38)" end="(144, 39)">
                <IdentNode start="(144, 38)" end="(144, 39)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(144, 40)" end="(144, 54)">
                <AtomNode start="(144, 40)" end="(144, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 42)" end="(144, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(144, 42)" end="(144, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(144, 44)" end="(144, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(144, 46)" end="(144, 54)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(144, 46)" end="(144, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(144, 48)" end="(144, 49)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(144, 50)" end="(144, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 54)" end="(144, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(144, 56)" end="(144, 61)">
              <AtomNode start="(144, 56)" end="(144, 57)" leading="" trailing="" val="("/>
              <NullNode start="(144, 57)" end="(144, 60)">
                <IdentNode start="(144, 57)" end="(144, 58)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(144, 59)" end="(144, 60)" leading="" trailing="" raw_val="r" val="r"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(144, 60)" end="(144, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(144, 62)" end="(144, 73)">
              <AtomNode start="(144, 62)" end="(144, 63)" leading="" trailing="" val="("/>
              <NullNode start="(144, 63)" end="(144, 64)">
                <IdentNode start="(144, 63)" end="(144, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(144, 65)" end="(144, 72)">
                <AtomNode start="(144, 65)" end="(144, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(144, 67)" end="(144, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(144, 67)" end="(144, 68)" leading="" trailing=" " raw_val="s" val="s"/>
                  <NullNode start="(144, 69)" end="(144, 72)">
                    <IdentNode start="(144, 69)" end="(144, 70)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(144, 71)" end="(144, 72)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(144, 72)" end="(144, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(144, 74)" end="(145, 50)">
            <AtomNode start="(144, 74)" end="(144, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(145, 5)" end="(145, 50)" kind="«term_=_»">
              <OtherNode start="(145, 5)" end="(145, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(145, 5)" end="(145, 10)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(145, 11)" end="(145, 26)">
                  <OtherNode start="(145, 11)" end="(145, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 11)" end="(145, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 12)" end="(145, 16)" kind="«term_::_»">
                      <IdentNode start="(145, 12)" end="(145, 13)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(145, 13)" end="(145, 15)" leading="" trailing="" val="::"/>
                      <IdentNode start="(145, 15)" end="(145, 16)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(145, 16)" end="(145, 17)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(145, 18)" end="(145, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(145, 18)" end="(145, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(145, 19)" end="(145, 23)" kind="«term_::_»">
                      <IdentNode start="(145, 19)" end="(145, 20)" leading="" trailing="" raw_val="b" val="b"/>
                      <AtomNode start="(145, 20)" end="(145, 22)" leading="" trailing="" val="::"/>
                      <IdentNode start="(145, 22)" end="(145, 23)" leading="" trailing="" raw_val="r" val="r"/>
                    </OtherNode>
                    <AtomNode start="(145, 23)" end="(145, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(145, 25)" end="(145, 26)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(145, 27)" end="(145, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(145, 29)" end="(145, 50)" kind="«term_::_»">
                <IdentNode start="(145, 29)" end="(145, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(145, 31)" end="(145, 33)" leading="" trailing=" " val="::"/>
                <OtherNode start="(145, 34)" end="(145, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(145, 34)" end="(145, 39)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(145, 40)" end="(145, 50)">
                    <IdentNode start="(145, 40)" end="(145, 41)" leading="" trailing=" " raw_val="l" val="l"/>
                    <OtherNode start="(145, 42)" end="(145, 48)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(145, 42)" end="(145, 43)" leading="" trailing="" val="("/>
                      <OtherNode start="(145, 43)" end="(145, 47)" kind="«term_::_»">
                        <IdentNode start="(145, 43)" end="(145, 44)" leading="" trailing="" raw_val="b" val="b"/>
                        <AtomNode start="(145, 44)" end="(145, 46)" leading="" trailing="" val="::"/>
                        <IdentNode start="(145, 46)" end="(145, 47)" leading="" trailing="" raw_val="r" val="r"/>
                      </OtherNode>
                      <AtomNode start="(145, 47)" end="(145, 48)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(145, 49)" end="(145, 50)" leading="" trailing=" " raw_val="s" val="s"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(145, 51)" end="(146, 33)">
          <AtomNode start="(145, 51)" end="(145, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(145, 54)" end="(146, 33)">
            <AtomNode start="(145, 54)" end="(145, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(146, 3)" end="(146, 33)">
              <TacticTacticseq1IndentedNode start="(146, 3)" end="(146, 33)">
                <NullNode start="(146, 3)" end="(146, 33)">
                  <OtherNode start="(146, 3)" end="(146, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;a b : α&#10;s : α → α → Bool&#10;l r : List α&#10;h : s a b = true&#10;⊢ (a :: l).merge (b :: r) s = a :: l.merge (b :: r) s" state_after="no goals" tactic="rw [cons_merge_cons, if_pos h]">
                    <AtomNode start="(146, 3)" end="(146, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(146, 6)" end="(146, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(146, 6)" end="(146, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(146, 7)" end="(146, 32)">
                        <OtherNode start="(146, 7)" end="(146, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(146, 7)" end="(146, 22)" leading="" trailing="" raw_val="cons_merge_cons" val="cons_merge_cons" full_name="List.cons_merge_cons" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(140, 9)" def_end="(140, 24)"/>
                        </OtherNode>
                        <AtomNode start="(146, 22)" end="(146, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(146, 24)" end="(146, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(146, 24)" end="(146, 32)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(146, 24)" end="(146, 30)" leading="" trailing=" " raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(146, 31)" end="(146, 32)">
                              <IdentNode start="(146, 31)" end="(146, 32)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(146, 32)" end="(146, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(148, 1)" end="(150, 33)" name="cons_merge_cons_neg" full_name="List.cons_merge_cons_neg">
      <CommandDeclmodifiersNode start="(148, 1)" end="(148, 8)">
        <NullNode/>
        <NullNode start="(148, 1)" end="(148, 8)">
          <OtherNode start="(148, 1)" end="(148, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(148, 1)" end="(148, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(148, 3)" end="(148, 7)">
              <OtherNode start="(148, 3)" end="(148, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(148, 3)" end="(148, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(148, 3)" end="(148, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(148, 7)" end="(148, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(148, 9)" end="(150, 33)" name="cons_merge_cons_neg" full_name="List.cons_merge_cons_neg" _is_private_decl="False">
        <AtomNode start="(148, 9)" end="(148, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(148, 17)" end="(148, 36)">
          <IdentNode start="(148, 17)" end="(148, 36)" leading="" trailing=" " raw_val="cons_merge_cons_neg" val="cons_merge_cons_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(148, 37)" end="(149, 50)">
          <NullNode start="(148, 37)" end="(148, 75)">
            <TermExplicitbinderNode start="(148, 37)" end="(148, 55)">
              <AtomNode start="(148, 37)" end="(148, 38)" leading="" trailing="" val="("/>
              <NullNode start="(148, 38)" end="(148, 39)">
                <IdentNode start="(148, 38)" end="(148, 39)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(148, 40)" end="(148, 54)">
                <AtomNode start="(148, 40)" end="(148, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(148, 42)" end="(148, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(148, 42)" end="(148, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(148, 44)" end="(148, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(148, 46)" end="(148, 54)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(148, 46)" end="(148, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(148, 48)" end="(148, 49)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(148, 50)" end="(148, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(148, 54)" end="(148, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(148, 56)" end="(148, 61)">
              <AtomNode start="(148, 56)" end="(148, 57)" leading="" trailing="" val="("/>
              <NullNode start="(148, 57)" end="(148, 60)">
                <IdentNode start="(148, 57)" end="(148, 58)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(148, 59)" end="(148, 60)" leading="" trailing="" raw_val="r" val="r"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(148, 60)" end="(148, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(148, 62)" end="(148, 75)">
              <AtomNode start="(148, 62)" end="(148, 63)" leading="" trailing="" val="("/>
              <NullNode start="(148, 63)" end="(148, 64)">
                <IdentNode start="(148, 63)" end="(148, 64)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(148, 65)" end="(148, 74)">
                <AtomNode start="(148, 65)" end="(148, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(148, 67)" end="(148, 74)" kind="«term¬_»">
                  <AtomNode start="(148, 67)" end="(148, 68)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(148, 69)" end="(148, 74)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(148, 69)" end="(148, 70)" leading="" trailing=" " raw_val="s" val="s"/>
                    <NullNode start="(148, 71)" end="(148, 74)">
                      <IdentNode start="(148, 71)" end="(148, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                      <IdentNode start="(148, 73)" end="(148, 74)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(148, 74)" end="(148, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(148, 76)" end="(149, 50)">
            <AtomNode start="(148, 76)" end="(148, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(149, 5)" end="(149, 50)" kind="«term_=_»">
              <OtherNode start="(149, 5)" end="(149, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 5)" end="(149, 10)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(149, 11)" end="(149, 26)">
                  <OtherNode start="(149, 11)" end="(149, 17)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 11)" end="(149, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 12)" end="(149, 16)" kind="«term_::_»">
                      <IdentNode start="(149, 12)" end="(149, 13)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(149, 13)" end="(149, 15)" leading="" trailing="" val="::"/>
                      <IdentNode start="(149, 15)" end="(149, 16)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(149, 16)" end="(149, 17)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(149, 18)" end="(149, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 18)" end="(149, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 19)" end="(149, 23)" kind="«term_::_»">
                      <IdentNode start="(149, 19)" end="(149, 20)" leading="" trailing="" raw_val="b" val="b"/>
                      <AtomNode start="(149, 20)" end="(149, 22)" leading="" trailing="" val="::"/>
                      <IdentNode start="(149, 22)" end="(149, 23)" leading="" trailing="" raw_val="r" val="r"/>
                    </OtherNode>
                    <AtomNode start="(149, 23)" end="(149, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(149, 25)" end="(149, 26)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(149, 27)" end="(149, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(149, 29)" end="(149, 50)" kind="«term_::_»">
                <IdentNode start="(149, 29)" end="(149, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                <AtomNode start="(149, 31)" end="(149, 33)" leading="" trailing=" " val="::"/>
                <OtherNode start="(149, 34)" end="(149, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(149, 34)" end="(149, 39)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(149, 40)" end="(149, 50)">
                    <OtherNode start="(149, 40)" end="(149, 46)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(149, 40)" end="(149, 41)" leading="" trailing="" val="("/>
                      <OtherNode start="(149, 41)" end="(149, 45)" kind="«term_::_»">
                        <IdentNode start="(149, 41)" end="(149, 42)" leading="" trailing="" raw_val="a" val="a"/>
                        <AtomNode start="(149, 42)" end="(149, 44)" leading="" trailing="" val="::"/>
                        <IdentNode start="(149, 44)" end="(149, 45)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(149, 45)" end="(149, 46)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(149, 47)" end="(149, 48)" leading="" trailing=" " raw_val="r" val="r"/>
                    <IdentNode start="(149, 49)" end="(149, 50)" leading="" trailing=" " raw_val="s" val="s"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(149, 51)" end="(150, 33)">
          <AtomNode start="(149, 51)" end="(149, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(149, 54)" end="(150, 33)">
            <AtomNode start="(149, 54)" end="(149, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(150, 3)" end="(150, 33)">
              <TacticTacticseq1IndentedNode start="(150, 3)" end="(150, 33)">
                <NullNode start="(150, 3)" end="(150, 33)">
                  <OtherNode start="(150, 3)" end="(150, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;a b : α&#10;s : α → α → Bool&#10;l r : List α&#10;h : ¬s a b = true&#10;⊢ (a :: l).merge (b :: r) s = b :: (a :: l).merge r s" state_after="no goals" tactic="rw [cons_merge_cons, if_neg h]">
                    <AtomNode start="(150, 3)" end="(150, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(150, 6)" end="(150, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(150, 6)" end="(150, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(150, 7)" end="(150, 32)">
                        <OtherNode start="(150, 7)" end="(150, 22)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(150, 7)" end="(150, 22)" leading="" trailing="" raw_val="cons_merge_cons" val="cons_merge_cons" full_name="List.cons_merge_cons" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(140, 9)" def_end="(140, 24)"/>
                        </OtherNode>
                        <AtomNode start="(150, 22)" end="(150, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(150, 24)" end="(150, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(150, 24)" end="(150, 32)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(150, 24)" end="(150, 30)" leading="" trailing=" " raw_val="if_neg" val="if_neg" full_name="if_neg" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                            <NullNode start="(150, 31)" end="(150, 32)">
                              <IdentNode start="(150, 31)" end="(150, 32)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(150, 32)" end="(150, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(152, 1)" end="(161, 44)" name="length_merge" full_name="List.length_merge">
      <CommandDeclmodifiersNode start="(152, 1)" end="(152, 8)">
        <NullNode/>
        <NullNode start="(152, 1)" end="(152, 8)">
          <OtherNode start="(152, 1)" end="(152, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(152, 1)" end="(152, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(152, 3)" end="(152, 7)">
              <OtherNode start="(152, 3)" end="(152, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(152, 3)" end="(152, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(152, 3)" end="(152, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(152, 7)" end="(152, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(152, 9)" end="(161, 44)" name="length_merge" full_name="List.length_merge" _is_private_decl="False">
        <AtomNode start="(152, 9)" end="(152, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(152, 17)" end="(152, 29)">
          <IdentNode start="(152, 17)" end="(152, 29)" leading="" trailing=" " raw_val="length_merge" val="length_merge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(152, 30)" end="(153, 47)">
          <NullNode start="(152, 30)" end="(152, 54)">
            <TermExplicitbinderNode start="(152, 30)" end="(152, 48)">
              <AtomNode start="(152, 30)" end="(152, 31)" leading="" trailing="" val="("/>
              <NullNode start="(152, 31)" end="(152, 32)">
                <IdentNode start="(152, 31)" end="(152, 32)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(152, 33)" end="(152, 47)">
                <AtomNode start="(152, 33)" end="(152, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(152, 35)" end="(152, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(152, 35)" end="(152, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(152, 37)" end="(152, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(152, 39)" end="(152, 47)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(152, 39)" end="(152, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(152, 41)" end="(152, 42)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(152, 43)" end="(152, 47)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(152, 47)" end="(152, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(152, 49)" end="(152, 54)">
              <AtomNode start="(152, 49)" end="(152, 50)" leading="" trailing="" val="("/>
              <NullNode start="(152, 50)" end="(152, 53)">
                <IdentNode start="(152, 50)" end="(152, 51)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(152, 52)" end="(152, 53)" leading="" trailing="" raw_val="r" val="r"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(152, 53)" end="(152, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(152, 55)" end="(153, 47)">
            <AtomNode start="(152, 55)" end="(152, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(153, 5)" end="(153, 47)" kind="«term_=_»">
              <OtherNode start="(153, 5)" end="(153, 25)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(153, 5)" end="(153, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(153, 5)" end="(153, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(153, 6)" end="(153, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(153, 6)" end="(153, 11)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(153, 12)" end="(153, 17)">
                      <IdentNode start="(153, 12)" end="(153, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(153, 14)" end="(153, 15)" leading="" trailing=" " raw_val="r" val="r"/>
                      <IdentNode start="(153, 16)" end="(153, 17)" leading="" trailing="" raw_val="s" val="s"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(153, 17)" end="(153, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(153, 18)" end="(153, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(153, 19)" end="(153, 25)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(153, 26)" end="(153, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(153, 28)" end="(153, 47)" kind="«term_+_»">
                <IdentNode start="(153, 28)" end="(153, 36)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                <AtomNode start="(153, 37)" end="(153, 38)" leading="" trailing=" " val="+"/>
                <IdentNode start="(153, 39)" end="(153, 47)" leading="" trailing=" " raw_val="r.length" val="r.length"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(153, 48)" end="(161, 44)">
          <AtomNode start="(153, 48)" end="(153, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(153, 51)" end="(161, 44)">
            <AtomNode start="(153, 51)" end="(153, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(154, 3)" end="(161, 44)">
              <TacticTacticseq1IndentedNode start="(154, 3)" end="(161, 44)">
                <NullNode start="(154, 3)" end="(161, 44)">
                  <OtherNode start="(154, 3)" end="(161, 44)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_1&#10;s : α → α → Bool&#10;l r : List α&#10;⊢ (l.merge r s).length = l.length + r.length" state_after="no goals" tactic="match l, r with&#10;| [], r =&amp;gt; simp&#10;| l, [] =&amp;gt; simp&#10;| a::l, b::r =&amp;gt;&#10;  rw [cons_merge_cons]&#10;  split&#10;  · simp +arith [length_merge s l (b::r)]&#10;  · simp +arith [length_merge s (a::l) r]">
                    <AtomNode start="(154, 3)" end="(154, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(154, 9)" end="(154, 13)">
                      <OtherNode start="(154, 9)" end="(154, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(154, 9)" end="(154, 10)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(154, 10)" end="(154, 11)" leading="" trailing=" " val=","/>
                      <OtherNode start="(154, 12)" end="(154, 13)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(154, 12)" end="(154, 13)" leading="" trailing=" " raw_val="r" val="r"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(154, 14)" end="(154, 18)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(155, 3)" end="(161, 44)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(155, 3)" end="(161, 44)">
                        <OtherNode start="(155, 3)" end="(155, 18)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(155, 3)" end="(155, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(155, 5)" end="(155, 10)">
                            <NullNode start="(155, 5)" end="(155, 10)">
                              <OtherNode start="(155, 5)" end="(155, 7)" kind="«term[_]»">
                                <AtomNode start="(155, 5)" end="(155, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(155, 6)" end="(155, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(155, 7)" end="(155, 8)" leading="" trailing=" " val=","/>
                              <IdentNode start="(155, 9)" end="(155, 10)" leading="" trailing=" " raw_val="r" val="r"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(155, 11)" end="(155, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(155, 14)" end="(155, 18)">
                            <TacticTacticseq1IndentedNode start="(155, 14)" end="(155, 18)">
                              <NullNode start="(155, 14)" end="(155, 18)">
                                <OtherNode start="(155, 14)" end="(155, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;s : α → α → Bool&#10;l r✝ r : List α&#10;⊢ ([].merge r s).length = [].length + r.length" state_after="no goals" tactic="simp">
                                  <AtomNode start="(155, 14)" end="(155, 18)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(156, 3)" end="(156, 18)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(156, 3)" end="(156, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(156, 5)" end="(156, 10)">
                            <NullNode start="(156, 5)" end="(156, 10)">
                              <IdentNode start="(156, 5)" end="(156, 6)" leading="" trailing="" raw_val="l" val="l"/>
                              <AtomNode start="(156, 6)" end="(156, 7)" leading="" trailing=" " val=","/>
                              <OtherNode start="(156, 8)" end="(156, 10)" kind="«term[_]»">
                                <AtomNode start="(156, 8)" end="(156, 9)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(156, 9)" end="(156, 10)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(156, 11)" end="(156, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(156, 14)" end="(156, 18)">
                            <TacticTacticseq1IndentedNode start="(156, 14)" end="(156, 18)">
                              <NullNode start="(156, 14)" end="(156, 18)">
                                <OtherNode start="(156, 14)" end="(156, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;s : α → α → Bool&#10;l✝ r l : List α&#10;⊢ (l.merge [] s).length = l.length + [].length" state_after="no goals" tactic="simp">
                                  <AtomNode start="(156, 14)" end="(156, 18)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(157, 3)" end="(161, 44)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(157, 3)" end="(157, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(157, 5)" end="(157, 15)">
                            <NullNode start="(157, 5)" end="(157, 15)">
                              <OtherNode start="(157, 5)" end="(157, 9)" kind="«term_::_»">
                                <IdentNode start="(157, 5)" end="(157, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(157, 6)" end="(157, 8)" leading="" trailing="" val="::"/>
                                <IdentNode start="(157, 8)" end="(157, 9)" leading="" trailing="" raw_val="l" val="l"/>
                              </OtherNode>
                              <AtomNode start="(157, 9)" end="(157, 10)" leading="" trailing=" " val=","/>
                              <OtherNode start="(157, 11)" end="(157, 15)" kind="«term_::_»">
                                <IdentNode start="(157, 11)" end="(157, 12)" leading="" trailing="" raw_val="b" val="b"/>
                                <AtomNode start="(157, 12)" end="(157, 14)" leading="" trailing="" val="::"/>
                                <IdentNode start="(157, 14)" end="(157, 15)" leading="" trailing=" " raw_val="r" val="r"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(157, 16)" end="(157, 18)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(158, 5)" end="(161, 44)">
                            <TacticTacticseq1IndentedNode start="(158, 5)" end="(161, 44)">
                              <NullNode start="(158, 5)" end="(161, 44)">
                                <OtherNode start="(158, 5)" end="(158, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;⊢ ((a :: l).merge (b :: r) s).length = (a :: l).length + (b :: r).length" state_after="α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;⊢ (if s a b = true then a :: l.merge (b :: r) s else b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" tactic="rw [cons_merge_cons]">
                                  <AtomNode start="(158, 5)" end="(158, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(158, 8)" end="(158, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(158, 8)" end="(158, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(158, 9)" end="(158, 24)">
                                      <OtherNode start="(158, 9)" end="(158, 24)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(158, 9)" end="(158, 24)" leading="" trailing="" raw_val="cons_merge_cons" val="cons_merge_cons" full_name="List.cons_merge_cons" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(140, 9)" def_end="(140, 24)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(158, 24)" end="(158, 25)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(159, 5)" end="(159, 10)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;⊢ (if s a b = true then a :: l.merge (b :: r) s else b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" state_after="case isTrue&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : s a b = true&#10;⊢ (a :: l.merge (b :: r) s).length = (a :: l).length + (b :: r).length&#10;&#10;case isFalse&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : ¬s a b = true&#10;⊢ (b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" tactic="split">
                                  <AtomNode start="(159, 5)" end="(159, 10)" leading="" trailing="&#10;    " val="split"/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(160, 5)" end="(160, 44)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : s a b = true&#10;⊢ (a :: l.merge (b :: r) s).length = (a :: l).length + (b :: r).length&#10;&#10;case isFalse&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : ¬s a b = true&#10;⊢ (b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" state_after="case isFalse&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : ¬s a b = true&#10;⊢ (b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" tactic="· simp +arith [length_merge s l (b::r)]">
                                  <OtherNode start="(160, 5)" end="(160, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(160, 5)" end="(160, 6)" kind="patternIgnore">
                                      <OtherNode start="(160, 5)" end="(160, 6)" kind="token.«· »">
                                        <AtomNode start="(160, 5)" end="(160, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(160, 7)" end="(160, 44)">
                                    <TacticTacticseq1IndentedNode start="(160, 7)" end="(160, 44)">
                                      <NullNode start="(160, 7)" end="(160, 44)">
                                        <OtherNode start="(160, 7)" end="(160, 44)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : s a b = true&#10;⊢ (a :: l.merge (b :: r) s).length = (a :: l).length + (b :: r).length" state_after="no goals" tactic="simp +arith [length_merge s l (b::r)]">
                                          <AtomNode start="(160, 7)" end="(160, 11)" leading="" trailing=" " val="simp"/>
                                          <OtherNode start="(160, 12)" end="(160, 18)" kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode start="(160, 12)" end="(160, 18)">
                                              <OtherNode start="(160, 12)" end="(160, 18)" kind="Lean.Parser.Tactic.configItem">
                                                <OtherNode start="(160, 12)" end="(160, 18)" kind="Lean.Parser.Tactic.posConfigItem">
                                                  <AtomNode start="(160, 12)" end="(160, 13)" leading="" trailing="" val="+"/>
                                                  <IdentNode start="(160, 13)" end="(160, 18)" leading="" trailing=" " raw_val="arith" val="arith"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(160, 19)" end="(160, 44)">
                                            <AtomNode start="(160, 19)" end="(160, 20)" leading="" trailing="" val="["/>
                                            <NullNode start="(160, 20)" end="(160, 43)">
                                              <OtherNode start="(160, 20)" end="(160, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <OtherNode start="(160, 20)" end="(160, 43)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(160, 20)" end="(160, 32)" leading="" trailing=" " raw_val="length_merge" val="length_merge"/>
                                                  <NullNode start="(160, 33)" end="(160, 43)">
                                                    <IdentNode start="(160, 33)" end="(160, 34)" leading="" trailing=" " raw_val="s" val="s"/>
                                                    <IdentNode start="(160, 35)" end="(160, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                                                    <OtherNode start="(160, 37)" end="(160, 43)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(160, 37)" end="(160, 38)" leading="" trailing="" val="("/>
                                                      <OtherNode start="(160, 38)" end="(160, 42)" kind="«term_::_»">
                                                        <IdentNode start="(160, 38)" end="(160, 39)" leading="" trailing="" raw_val="b" val="b"/>
                                                        <AtomNode start="(160, 39)" end="(160, 41)" leading="" trailing="" val="::"/>
                                                        <IdentNode start="(160, 41)" end="(160, 42)" leading="" trailing="" raw_val="r" val="r"/>
                                                      </OtherNode>
                                                      <AtomNode start="(160, 42)" end="(160, 43)" leading="" trailing="" val=")"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(160, 43)" end="(160, 44)" leading="" trailing="&#10;    " val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(161, 5)" end="(161, 44)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : ¬s a b = true&#10;⊢ (b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" state_after="no goals" tactic="· simp +arith [length_merge s (a::l) r]">
                                  <OtherNode start="(161, 5)" end="(161, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(161, 5)" end="(161, 6)" kind="patternIgnore">
                                      <OtherNode start="(161, 5)" end="(161, 6)" kind="token.«· »">
                                        <AtomNode start="(161, 5)" end="(161, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(161, 7)" end="(161, 44)">
                                    <TacticTacticseq1IndentedNode start="(161, 7)" end="(161, 44)">
                                      <NullNode start="(161, 7)" end="(161, 44)">
                                        <OtherNode start="(161, 7)" end="(161, 44)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;s : α → α → Bool&#10;l✝ r✝ : List α&#10;a : α&#10;l : List α&#10;b : α&#10;r : List α&#10;h✝ : ¬s a b = true&#10;⊢ (b :: (a :: l).merge r s).length = (a :: l).length + (b :: r).length" state_after="no goals" tactic="simp +arith [length_merge s (a::l) r]">
                                          <AtomNode start="(161, 7)" end="(161, 11)" leading="" trailing=" " val="simp"/>
                                          <OtherNode start="(161, 12)" end="(161, 18)" kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode start="(161, 12)" end="(161, 18)">
                                              <OtherNode start="(161, 12)" end="(161, 18)" kind="Lean.Parser.Tactic.configItem">
                                                <OtherNode start="(161, 12)" end="(161, 18)" kind="Lean.Parser.Tactic.posConfigItem">
                                                  <AtomNode start="(161, 12)" end="(161, 13)" leading="" trailing="" val="+"/>
                                                  <IdentNode start="(161, 13)" end="(161, 18)" leading="" trailing=" " raw_val="arith" val="arith"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(161, 19)" end="(161, 44)">
                                            <AtomNode start="(161, 19)" end="(161, 20)" leading="" trailing="" val="["/>
                                            <NullNode start="(161, 20)" end="(161, 43)">
                                              <OtherNode start="(161, 20)" end="(161, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <OtherNode start="(161, 20)" end="(161, 43)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(161, 20)" end="(161, 32)" leading="" trailing=" " raw_val="length_merge" val="length_merge"/>
                                                  <NullNode start="(161, 33)" end="(161, 43)">
                                                    <IdentNode start="(161, 33)" end="(161, 34)" leading="" trailing=" " raw_val="s" val="s"/>
                                                    <OtherNode start="(161, 35)" end="(161, 41)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(161, 35)" end="(161, 36)" leading="" trailing="" val="("/>
                                                      <OtherNode start="(161, 36)" end="(161, 40)" kind="«term_::_»">
                                                        <IdentNode start="(161, 36)" end="(161, 37)" leading="" trailing="" raw_val="a" val="a"/>
                                                        <AtomNode start="(161, 37)" end="(161, 39)" leading="" trailing="" val="::"/>
                                                        <IdentNode start="(161, 39)" end="(161, 40)" leading="" trailing="" raw_val="l" val="l"/>
                                                      </OtherNode>
                                                      <AtomNode start="(161, 40)" end="(161, 41)" leading="" trailing=" " val=")"/>
                                                    </OtherNode>
                                                    <IdentNode start="(161, 42)" end="(161, 43)" leading="" trailing="" raw_val="r" val="r"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(161, 43)" end="(161, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(163, 1)" end="(179, 51)" name="mem_merge" full_name="List.mem_merge">
      <CommandDeclmodifiersNode start="(163, 1)" end="(165, 3)">
        <NullNode start="(163, 1)" end="(165, 3)">
          <CommandDoccommentNode start="(163, 1)" end="(165, 3)" comment="The elements of `merge le xs ys` are exactly the elements of `xs` and `ys`.&#10;-/">
            <AtomNode start="(163, 1)" end="(163, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(164, 1)" end="(165, 3)" leading="" trailing="&#10;-- We subsequently prove that `mergeSort_perm : merge le xs ys ~ xs ++ ys`.&#10;" val="The elements of `merge le xs ys` are exactly the elements of `xs` and `ys`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(167, 1)" end="(179, 51)" name="mem_merge" full_name="List.mem_merge" _is_private_decl="False">
        <AtomNode start="(167, 1)" end="(167, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(167, 9)" end="(167, 18)">
          <IdentNode start="(167, 9)" end="(167, 18)" leading="" trailing=" " raw_val="mem_merge" val="mem_merge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(167, 19)" end="(167, 82)">
          <NullNode start="(167, 19)" end="(167, 43)">
            <OtherNode start="(167, 19)" end="(167, 26)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 19)" end="(167, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 20)" end="(167, 21)">
                <IdentNode start="(167, 20)" end="(167, 21)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(167, 22)" end="(167, 25)">
                <AtomNode start="(167, 22)" end="(167, 23)" leading="" trailing=" " val=":"/>
                <IdentNode start="(167, 24)" end="(167, 25)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(167, 25)" end="(167, 26)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(167, 27)" end="(167, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(167, 27)" end="(167, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(167, 28)" end="(167, 33)">
                <IdentNode start="(167, 28)" end="(167, 30)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(167, 31)" end="(167, 33)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(167, 34)" end="(167, 42)">
                <AtomNode start="(167, 34)" end="(167, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(167, 36)" end="(167, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(167, 36)" end="(167, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(167, 41)" end="(167, 42)">
                    <IdentNode start="(167, 41)" end="(167, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(167, 42)" end="(167, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(167, 44)" end="(167, 82)">
            <AtomNode start="(167, 44)" end="(167, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(167, 46)" end="(167, 82)" kind="«term_↔_»">
              <OtherNode start="(167, 46)" end="(167, 64)" kind="«term_∈_»">
                <IdentNode start="(167, 46)" end="(167, 47)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(167, 48)" end="(167, 49)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(167, 50)" end="(167, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(167, 50)" end="(167, 55)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(167, 56)" end="(167, 64)">
                    <IdentNode start="(167, 56)" end="(167, 58)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(167, 59)" end="(167, 61)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    <IdentNode start="(167, 62)" end="(167, 64)" leading="" trailing=" " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(167, 65)" end="(167, 66)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(167, 67)" end="(167, 82)" kind="«term_∨_»">
                <OtherNode start="(167, 67)" end="(167, 73)" kind="«term_∈_»">
                  <IdentNode start="(167, 67)" end="(167, 68)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(167, 69)" end="(167, 70)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(167, 71)" end="(167, 73)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(167, 74)" end="(167, 75)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(167, 76)" end="(167, 82)" kind="«term_∈_»">
                  <IdentNode start="(167, 76)" end="(167, 77)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(167, 78)" end="(167, 79)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(167, 80)" end="(167, 82)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(167, 83)" end="(179, 51)">
          <AtomNode start="(167, 83)" end="(167, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(167, 86)" end="(179, 51)">
            <AtomNode start="(167, 86)" end="(167, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(168, 3)" end="(179, 51)">
              <TacticTacticseq1IndentedNode start="(168, 3)" end="(179, 51)">
                <NullNode start="(168, 3)" end="(179, 51)">
                  <OtherNode start="(168, 3)" end="(179, 51)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a : α&#10;xs ys : List α&#10;⊢ a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys" state_after="no goals" tactic="induction xs generalizing ys with&#10;| nil =&amp;gt; simp [merge]&#10;| cons x xs ih =&amp;gt;&#10;  induction ys with&#10;  | nil =&amp;gt; simp [merge]&#10;  | cons y ys ih =&amp;gt;&#10;    simp only [merge]&#10;    split &amp;lt;;&amp;gt; rename_i h&#10;    · simp_all [or_assoc]&#10;    · simp only [mem_cons, or_assoc, Bool.not_eq_true, ih, ← or_assoc]&#10;      apply or_congr_left&#10;      simp only [or_comm (a := a = y), or_assoc]">
                    <AtomNode start="(168, 3)" end="(168, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(168, 13)" end="(168, 15)">
                      <OtherNode start="(168, 13)" end="(168, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(168, 13)" end="(168, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(168, 16)" end="(168, 31)">
                      <AtomNode start="(168, 16)" end="(168, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(168, 29)" end="(168, 31)">
                        <IdentNode start="(168, 29)" end="(168, 31)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(168, 32)" end="(179, 51)">
                      <OtherNode start="(168, 32)" end="(179, 51)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(168, 32)" end="(168, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(169, 3)" end="(179, 51)">
                          <OtherNode start="(169, 3)" end="(169, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(169, 3)" end="(169, 8)">
                              <OtherNode start="(169, 3)" end="(169, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(169, 3)" end="(169, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(169, 5)" end="(169, 8)">
                                  <NullNode/>
                                  <IdentNode start="(169, 5)" end="(169, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(169, 9)" end="(169, 24)">
                              <AtomNode start="(169, 9)" end="(169, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(169, 12)" end="(169, 24)">
                                <TacticTacticseq1IndentedNode start="(169, 12)" end="(169, 24)">
                                  <NullNode start="(169, 12)" end="(169, 24)">
                                    <OtherNode start="(169, 12)" end="(169, 24)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;le : α → α → Bool&#10;a : α&#10;ys : List α&#10;⊢ a ∈ [].merge ys le ↔ a ∈ [] ∨ a ∈ ys" state_after="no goals" tactic="simp [merge]">
                                      <AtomNode start="(169, 12)" end="(169, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(169, 17)" end="(169, 24)">
                                        <AtomNode start="(169, 17)" end="(169, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(169, 18)" end="(169, 23)">
                                          <OtherNode start="(169, 18)" end="(169, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(169, 18)" end="(169, 23)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(169, 23)" end="(169, 24)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(170, 3)" end="(179, 51)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(170, 3)" end="(170, 17)">
                              <OtherNode start="(170, 3)" end="(170, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(170, 3)" end="(170, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(170, 5)" end="(170, 9)">
                                  <NullNode/>
                                  <IdentNode start="(170, 5)" end="(170, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(170, 10)" end="(170, 17)">
                                  <IdentNode start="(170, 10)" end="(170, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(170, 12)" end="(170, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(170, 15)" end="(170, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(170, 18)" end="(179, 51)">
                              <AtomNode start="(170, 18)" end="(170, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(171, 5)" end="(179, 51)">
                                <TacticTacticseq1IndentedNode start="(171, 5)" end="(179, 51)">
                                  <NullNode start="(171, 5)" end="(179, 51)">
                                    <OtherNode start="(171, 5)" end="(179, 51)" kind="Lean.Parser.Tactic.induction" state_before="case cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;ys : List α&#10;⊢ a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys" state_after="no goals" tactic="induction ys with&#10;| nil =&amp;gt; simp [merge]&#10;| cons y ys ih =&amp;gt;&#10;  simp only [merge]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · simp_all [or_assoc]&#10;  · simp only [mem_cons, or_assoc, Bool.not_eq_true, ih, ← or_assoc]&#10;    apply or_congr_left&#10;    simp only [or_comm (a := a = y), or_assoc]">
                                      <AtomNode start="(171, 5)" end="(171, 14)" leading="" trailing=" " val="induction"/>
                                      <NullNode start="(171, 15)" end="(171, 17)">
                                        <OtherNode start="(171, 15)" end="(171, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(171, 15)" end="(171, 17)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(171, 18)" end="(179, 51)">
                                        <OtherNode start="(171, 18)" end="(179, 51)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(171, 18)" end="(171, 22)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(172, 5)" end="(179, 51)">
                                            <OtherNode start="(172, 5)" end="(172, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(172, 5)" end="(172, 10)">
                                                <OtherNode start="(172, 5)" end="(172, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(172, 5)" end="(172, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(172, 7)" end="(172, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(172, 7)" end="(172, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(172, 11)" end="(172, 26)">
                                                <AtomNode start="(172, 11)" end="(172, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(172, 14)" end="(172, 26)">
                                                  <TacticTacticseq1IndentedNode start="(172, 14)" end="(172, 26)">
                                                    <NullNode start="(172, 14)" end="(172, 26)">
                                                      <OtherNode start="(172, 14)" end="(172, 26)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;⊢ a ∈ (x :: xs).merge [] le ↔ a ∈ x :: xs ∨ a ∈ []" state_after="no goals" tactic="simp [merge]">
                                                        <AtomNode start="(172, 14)" end="(172, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(172, 19)" end="(172, 26)">
                                                          <AtomNode start="(172, 19)" end="(172, 20)" leading="" trailing="" val="["/>
                                                          <NullNode start="(172, 20)" end="(172, 25)">
                                                            <OtherNode start="(172, 20)" end="(172, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(172, 20)" end="(172, 25)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(172, 25)" end="(172, 26)" leading="" trailing="&#10;    " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(173, 5)" end="(179, 51)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(173, 5)" end="(173, 19)">
                                                <OtherNode start="(173, 5)" end="(173, 19)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(173, 5)" end="(173, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(173, 7)" end="(173, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(173, 7)" end="(173, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(173, 12)" end="(173, 19)">
                                                    <IdentNode start="(173, 12)" end="(173, 13)" leading="" trailing=" " raw_val="y" val="y"/>
                                                    <IdentNode start="(173, 14)" end="(173, 16)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                                    <IdentNode start="(173, 17)" end="(173, 19)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(173, 20)" end="(179, 51)">
                                                <AtomNode start="(173, 20)" end="(173, 22)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(174, 7)" end="(179, 51)">
                                                  <TacticTacticseq1IndentedNode start="(174, 7)" end="(179, 51)">
                                                    <NullNode start="(174, 7)" end="(179, 51)">
                                                      <OtherNode start="(174, 7)" end="(174, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;⊢ a ∈ (x :: xs).merge (y :: ys) le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" state_after="case cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;⊢ (a ∈ if le x y = true then x :: xs.merge (y :: ys) le else y :: (x :: xs).merge ys le) ↔ a ∈ x :: xs ∨ a ∈ y :: ys" tactic="simp only [merge]">
                                                        <AtomNode start="(174, 7)" end="(174, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(174, 12)" end="(174, 16)">
                                                          <AtomNode start="(174, 12)" end="(174, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(174, 17)" end="(174, 24)">
                                                          <AtomNode start="(174, 17)" end="(174, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(174, 18)" end="(174, 23)">
                                                            <OtherNode start="(174, 18)" end="(174, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(174, 18)" end="(174, 23)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(174, 23)" end="(174, 24)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(175, 7)" end="(175, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;⊢ (a ∈ if le x y = true then x :: xs.merge (y :: ys) le else y :: (x :: xs).merge ys le) ↔ a ∈ x :: xs ∨ a ∈ y :: ys" state_after="case cons.cons.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : le x y = true&#10;⊢ a ∈ x :: xs.merge (y :: ys) le ↔ a ∈ x :: xs ∨ a ∈ y :: ys&#10;&#10;case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ a ∈ y :: (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                                        <OtherNode start="(175, 7)" end="(175, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(175, 7)" end="(175, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(175, 13)" end="(175, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(175, 17)" end="(175, 27)" kind="Lean.Parser.Tactic.renameI">
                                                          <AtomNode start="(175, 17)" end="(175, 25)" leading="" trailing=" " val="rename_i"/>
                                                          <NullNode start="(175, 26)" end="(175, 27)">
                                                            <LeanBinderidentNode start="(175, 26)" end="(175, 27)">
                                                            <IdentNode start="(175, 26)" end="(175, 27)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                            </LeanBinderidentNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(176, 7)" end="(176, 28)" kind="Lean.cdot" state_before="case cons.cons.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : le x y = true&#10;⊢ a ∈ x :: xs.merge (y :: ys) le ↔ a ∈ x :: xs ∨ a ∈ y :: ys&#10;&#10;case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ a ∈ y :: (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" state_after="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ a ∈ y :: (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" tactic="· simp_all [or_assoc]">
                                                        <OtherNode start="(176, 7)" end="(176, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(176, 7)" end="(176, 8)" kind="patternIgnore">
                                                            <OtherNode start="(176, 7)" end="(176, 8)" kind="token.«· »">
                                                            <AtomNode start="(176, 7)" end="(176, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(176, 9)" end="(176, 28)">
                                                          <TacticTacticseq1IndentedNode start="(176, 9)" end="(176, 28)">
                                                            <NullNode start="(176, 9)" end="(176, 28)">
                                                            <OtherNode start="(176, 9)" end="(176, 28)" kind="Lean.Parser.Tactic.simpAll" state_before="case cons.cons.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : le x y = true&#10;⊢ a ∈ x :: xs.merge (y :: ys) le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" state_after="no goals" tactic="simp_all [or_assoc]">
                                                            <AtomNode start="(176, 9)" end="(176, 17)" leading="" trailing=" " val="simp_all"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(176, 18)" end="(176, 28)">
                                                            <AtomNode start="(176, 18)" end="(176, 19)" leading="" trailing="" val="["/>
                                                            <NullNode start="(176, 19)" end="(176, 27)">
                                                            <OtherNode start="(176, 19)" end="(176, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(176, 19)" end="(176, 27)" leading="" trailing="" raw_val="or_assoc" val="or_assoc" full_name="or_assoc" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(176, 27)" end="(176, 28)" leading="" trailing="&#10;      " val="]"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(177, 7)" end="(179, 51)" kind="Lean.cdot" state_before="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ a ∈ y :: (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" state_after="no goals" tactic="· simp only [mem_cons, or_assoc, Bool.not_eq_true, ih, ← or_assoc]&#10;  apply or_congr_left&#10;  simp only [or_comm (a := a = y), or_assoc]">
                                                        <OtherNode start="(177, 7)" end="(177, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(177, 7)" end="(177, 8)" kind="patternIgnore">
                                                            <OtherNode start="(177, 7)" end="(177, 8)" kind="token.«· »">
                                                            <AtomNode start="(177, 7)" end="(177, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(177, 9)" end="(179, 51)">
                                                          <TacticTacticseq1IndentedNode start="(177, 9)" end="(179, 51)">
                                                            <NullNode start="(177, 9)" end="(179, 51)">
                                                            <OtherNode start="(177, 9)" end="(177, 73)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ a ∈ y :: (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ y :: ys" state_after="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ ((a = y ∨ a = x) ∨ a ∈ xs) ∨ a ∈ ys ↔ ((a = x ∨ a ∈ xs) ∨ a = y) ∨ a ∈ ys" tactic="simp only [mem_cons, or_assoc, Bool.not_eq_true, ih, ← or_assoc]">
                                                            <AtomNode start="(177, 9)" end="(177, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(177, 14)" end="(177, 18)">
                                                            <AtomNode start="(177, 14)" end="(177, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(177, 19)" end="(177, 73)">
                                                            <AtomNode start="(177, 19)" end="(177, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(177, 20)" end="(177, 72)">
                                                            <OtherNode start="(177, 20)" end="(177, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(177, 20)" end="(177, 28)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(177, 28)" end="(177, 29)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(177, 30)" end="(177, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(177, 30)" end="(177, 38)" leading="" trailing="" raw_val="or_assoc" val="or_assoc" full_name="or_assoc" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(177, 38)" end="(177, 39)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(177, 40)" end="(177, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(177, 40)" end="(177, 56)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(177, 56)" end="(177, 57)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(177, 58)" end="(177, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(177, 58)" end="(177, 60)" leading="" trailing="" raw_val="ih" val="ih"/>
                                                            </OtherNode>
                                                            <AtomNode start="(177, 60)" end="(177, 61)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(177, 62)" end="(177, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode start="(177, 62)" end="(177, 63)">
                                                            <OtherNode start="(177, 62)" end="(177, 63)" kind="patternIgnore">
                                                            <OtherNode start="(177, 62)" end="(177, 63)" kind="token.«← »">
                                                            <AtomNode start="(177, 62)" end="(177, 63)" leading="" trailing=" " val="←"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <IdentNode start="(177, 64)" end="(177, 72)" leading="" trailing="" raw_val="or_assoc" val="or_assoc" full_name="or_assoc" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(177, 72)" end="(177, 73)" leading="" trailing="&#10;        " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(178, 9)" end="(178, 28)" kind="Lean.Parser.Tactic.apply" state_before="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ ((a = y ∨ a = x) ∨ a ∈ xs) ∨ a ∈ ys ↔ ((a = x ∨ a ∈ xs) ∨ a = y) ∨ a ∈ ys" state_after="case cons.cons.isFalse.h&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ (a = y ∨ a = x) ∨ a ∈ xs ↔ (a = x ∨ a ∈ xs) ∨ a = y" tactic="apply or_congr_left">
                                                            <AtomNode start="(178, 9)" end="(178, 14)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(178, 15)" end="(178, 28)" leading="" trailing="&#10;        " raw_val="or_congr_left" val="or_congr_left" full_name="or_congr_left" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(179, 9)" end="(179, 51)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.isFalse.h&#10;α : Type u_1&#10;le : α → α → Bool&#10;a x : α&#10;xs : List α&#10;ih✝ : ∀ {ys : List α}, a ∈ xs.merge ys le ↔ a ∈ xs ∨ a ∈ ys&#10;y : α&#10;ys : List α&#10;ih : a ∈ (x :: xs).merge ys le ↔ a ∈ x :: xs ∨ a ∈ ys&#10;h : ¬le x y = true&#10;⊢ (a = y ∨ a = x) ∨ a ∈ xs ↔ (a = x ∨ a ∈ xs) ∨ a = y" state_after="no goals" tactic="simp only [or_comm (a := a = y), or_assoc]">
                                                            <AtomNode start="(179, 9)" end="(179, 13)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(179, 14)" end="(179, 18)">
                                                            <AtomNode start="(179, 14)" end="(179, 18)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(179, 19)" end="(179, 51)">
                                                            <AtomNode start="(179, 19)" end="(179, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(179, 20)" end="(179, 50)">
                                                            <OtherNode start="(179, 20)" end="(179, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(179, 20)" end="(179, 40)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(179, 20)" end="(179, 27)" leading="" trailing=" " raw_val="or_comm" val="or_comm" full_name="or_comm" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                            <NullNode start="(179, 28)" end="(179, 40)">
                                                            <OtherNode start="(179, 28)" end="(179, 40)" kind="Lean.Parser.Term.namedArgument">
                                                            <AtomNode start="(179, 28)" end="(179, 29)" leading="" trailing="" val="("/>
                                                            <IdentNode start="(179, 29)" end="(179, 30)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <AtomNode start="(179, 31)" end="(179, 33)" leading="" trailing=" " val=":="/>
                                                            <OtherNode start="(179, 34)" end="(179, 39)" kind="«term_=_»">
                                                            <IdentNode start="(179, 34)" end="(179, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <AtomNode start="(179, 36)" end="(179, 37)" leading="" trailing=" " val="="/>
                                                            <IdentNode start="(179, 38)" end="(179, 39)" leading="" trailing="" raw_val="y" val="y"/>
                                                            </OtherNode>
                                                            <AtomNode start="(179, 39)" end="(179, 40)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(179, 40)" end="(179, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(179, 42)" end="(179, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(179, 42)" end="(179, 50)" leading="" trailing="" raw_val="or_assoc" val="or_assoc" full_name="or_assoc" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(179, 50)" end="(179, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(181, 1)" end="(182, 24)" name="mem_merge_left" full_name="List.mem_merge_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(181, 1)" end="(182, 24)" name="mem_merge_left" full_name="List.mem_merge_left" _is_private_decl="False">
        <AtomNode start="(181, 1)" end="(181, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(181, 9)" end="(181, 23)">
          <IdentNode start="(181, 9)" end="(181, 23)" leading="" trailing=" " raw_val="mem_merge_left" val="mem_merge_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(181, 24)" end="(181, 72)">
          <NullNode start="(181, 24)" end="(181, 54)">
            <TermExplicitbinderNode start="(181, 24)" end="(181, 42)">
              <AtomNode start="(181, 24)" end="(181, 25)" leading="" trailing="" val="("/>
              <NullNode start="(181, 25)" end="(181, 26)">
                <IdentNode start="(181, 25)" end="(181, 26)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(181, 27)" end="(181, 41)">
                <AtomNode start="(181, 27)" end="(181, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(181, 29)" end="(181, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(181, 29)" end="(181, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(181, 31)" end="(181, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(181, 33)" end="(181, 41)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(181, 33)" end="(181, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(181, 35)" end="(181, 36)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(181, 37)" end="(181, 41)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(181, 41)" end="(181, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(181, 43)" end="(181, 54)">
              <AtomNode start="(181, 43)" end="(181, 44)" leading="" trailing="" val="("/>
              <NullNode start="(181, 44)" end="(181, 45)">
                <IdentNode start="(181, 44)" end="(181, 45)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(181, 46)" end="(181, 53)">
                <AtomNode start="(181, 46)" end="(181, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(181, 48)" end="(181, 53)" kind="«term_∈_»">
                  <IdentNode start="(181, 48)" end="(181, 49)" leading="" trailing=" " raw_val="x" val="x"/>
                  <AtomNode start="(181, 50)" end="(181, 51)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(181, 52)" end="(181, 53)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(181, 53)" end="(181, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(181, 55)" end="(181, 72)">
            <AtomNode start="(181, 55)" end="(181, 56)" leading="" trailing=" " val=":"/>
            <OtherNode start="(181, 57)" end="(181, 72)" kind="«term_∈_»">
              <IdentNode start="(181, 57)" end="(181, 58)" leading="" trailing=" " raw_val="x" val="x"/>
              <AtomNode start="(181, 59)" end="(181, 60)" leading="" trailing=" " val="∈"/>
              <OtherNode start="(181, 61)" end="(181, 72)" kind="Lean.Parser.Term.app">
                <IdentNode start="(181, 61)" end="(181, 66)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(181, 67)" end="(181, 72)">
                  <IdentNode start="(181, 67)" end="(181, 68)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(181, 69)" end="(181, 70)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(181, 71)" end="(181, 72)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(181, 73)" end="(182, 24)">
          <AtomNode start="(181, 73)" end="(181, 75)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(182, 3)" end="(182, 24)" kind="«term_&amp;lt;|_»">
            <OtherNode start="(182, 3)" end="(182, 14)" kind="Lean.Parser.Term.proj">
              <IdentNode start="(182, 3)" end="(182, 12)" leading="" trailing="" raw_val="mem_merge" val="mem_merge" full_name="List.mem_merge" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(167, 9)" def_end="(167, 18)"/>
              <AtomNode start="(182, 12)" end="(182, 13)" leading="" trailing="" val="."/>
              <OtherNode start="(182, 13)" end="(182, 14)" kind="fieldIdx">
                <AtomNode start="(182, 13)" end="(182, 14)" leading="" trailing=" " val="2"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(182, 15)" end="(182, 17)" leading="" trailing=" " val="&amp;lt;|"/>
            <OtherNode start="(182, 18)" end="(182, 24)" kind="Lean.Parser.Term.app">
              <OtherNode start="(182, 18)" end="(182, 22)" kind="Lean.Parser.Term.dotIdent">
                <AtomNode start="(182, 18)" end="(182, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(182, 19)" end="(182, 22)" leading="" trailing=" " raw_val="inl" val="inl"/>
              </OtherNode>
              <NullNode start="(182, 23)" end="(182, 24)">
                <IdentNode start="(182, 23)" end="(182, 24)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(184, 1)" end="(185, 24)" name="mem_merge_right" full_name="List.mem_merge_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(184, 1)" end="(185, 24)" name="mem_merge_right" full_name="List.mem_merge_right" _is_private_decl="False">
        <AtomNode start="(184, 1)" end="(184, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(184, 9)" end="(184, 24)">
          <IdentNode start="(184, 9)" end="(184, 24)" leading="" trailing=" " raw_val="mem_merge_right" val="mem_merge_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(184, 25)" end="(184, 73)">
          <NullNode start="(184, 25)" end="(184, 55)">
            <TermExplicitbinderNode start="(184, 25)" end="(184, 43)">
              <AtomNode start="(184, 25)" end="(184, 26)" leading="" trailing="" val="("/>
              <NullNode start="(184, 26)" end="(184, 27)">
                <IdentNode start="(184, 26)" end="(184, 27)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(184, 28)" end="(184, 42)">
                <AtomNode start="(184, 28)" end="(184, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(184, 30)" end="(184, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(184, 30)" end="(184, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(184, 32)" end="(184, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(184, 34)" end="(184, 42)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(184, 34)" end="(184, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(184, 36)" end="(184, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(184, 38)" end="(184, 42)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(184, 42)" end="(184, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(184, 44)" end="(184, 55)">
              <AtomNode start="(184, 44)" end="(184, 45)" leading="" trailing="" val="("/>
              <NullNode start="(184, 45)" end="(184, 46)">
                <IdentNode start="(184, 45)" end="(184, 46)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(184, 47)" end="(184, 54)">
                <AtomNode start="(184, 47)" end="(184, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(184, 49)" end="(184, 54)" kind="«term_∈_»">
                  <IdentNode start="(184, 49)" end="(184, 50)" leading="" trailing=" " raw_val="x" val="x"/>
                  <AtomNode start="(184, 51)" end="(184, 52)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(184, 53)" end="(184, 54)" leading="" trailing="" raw_val="r" val="r"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(184, 54)" end="(184, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(184, 56)" end="(184, 73)">
            <AtomNode start="(184, 56)" end="(184, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(184, 58)" end="(184, 73)" kind="«term_∈_»">
              <IdentNode start="(184, 58)" end="(184, 59)" leading="" trailing=" " raw_val="x" val="x"/>
              <AtomNode start="(184, 60)" end="(184, 61)" leading="" trailing=" " val="∈"/>
              <OtherNode start="(184, 62)" end="(184, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(184, 62)" end="(184, 67)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(184, 68)" end="(184, 73)">
                  <IdentNode start="(184, 68)" end="(184, 69)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(184, 70)" end="(184, 71)" leading="" trailing=" " raw_val="r" val="r"/>
                  <IdentNode start="(184, 72)" end="(184, 73)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(184, 74)" end="(185, 24)">
          <AtomNode start="(184, 74)" end="(184, 76)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(185, 3)" end="(185, 24)" kind="«term_&amp;lt;|_»">
            <OtherNode start="(185, 3)" end="(185, 14)" kind="Lean.Parser.Term.proj">
              <IdentNode start="(185, 3)" end="(185, 12)" leading="" trailing="" raw_val="mem_merge" val="mem_merge" full_name="List.mem_merge" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(167, 9)" def_end="(167, 18)"/>
              <AtomNode start="(185, 12)" end="(185, 13)" leading="" trailing="" val="."/>
              <OtherNode start="(185, 13)" end="(185, 14)" kind="fieldIdx">
                <AtomNode start="(185, 13)" end="(185, 14)" leading="" trailing=" " val="2"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(185, 15)" end="(185, 17)" leading="" trailing=" " val="&amp;lt;|"/>
            <OtherNode start="(185, 18)" end="(185, 24)" kind="Lean.Parser.Term.app">
              <OtherNode start="(185, 18)" end="(185, 22)" kind="Lean.Parser.Term.dotIdent">
                <AtomNode start="(185, 18)" end="(185, 19)" leading="" trailing="" val="."/>
                <IdentNode start="(185, 19)" end="(185, 22)" leading="" trailing=" " raw_val="inr" val="inr"/>
              </OtherNode>
              <NullNode start="(185, 23)" end="(185, 24)">
                <IdentNode start="(185, 23)" end="(185, 24)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(187, 1)" end="(200, 70)" name="merge_stable" full_name="List.merge_stable">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(187, 1)" end="(200, 70)" name="merge_stable" full_name="List.merge_stable" _is_private_decl="False">
        <AtomNode start="(187, 1)" end="(187, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(187, 9)" end="(187, 21)">
          <IdentNode start="(187, 9)" end="(187, 21)" leading="" trailing=" " raw_val="merge_stable" val="merge_stable"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(187, 22)" end="(188, 83)">
          <NullNode/>
          <TermTypespecNode start="(187, 22)" end="(188, 83)">
            <AtomNode start="(187, 22)" end="(187, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(187, 24)" end="(188, 83)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(187, 24)" end="(187, 25)" leading="" trailing=" " val="∀"/>
              <NullNode start="(187, 26)" end="(187, 74)">
                <TermExplicitbinderNode start="(187, 26)" end="(187, 33)">
                  <AtomNode start="(187, 26)" end="(187, 27)" leading="" trailing="" val="("/>
                  <NullNode start="(187, 27)" end="(187, 32)">
                    <IdentNode start="(187, 27)" end="(187, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(187, 30)" end="(187, 32)" leading="" trailing="" raw_val="ys" val="ys"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode/>
                  <AtomNode start="(187, 32)" end="(187, 33)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(187, 34)" end="(187, 74)">
                  <AtomNode start="(187, 34)" end="(187, 35)" leading="" trailing="" val="("/>
                  <NullNode start="(187, 35)" end="(187, 36)">
                    <TermHoleNode start="(187, 35)" end="(187, 36)">
                      <AtomNode start="(187, 35)" end="(187, 36)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(187, 37)" end="(187, 73)">
                    <AtomNode start="(187, 37)" end="(187, 38)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(187, 39)" end="(187, 73)" kind="Lean.Parser.Term.forall">
                      <AtomNode start="(187, 39)" end="(187, 40)" leading="" trailing=" " val="∀"/>
                      <NullNode start="(187, 41)" end="(187, 44)">
                        <IdentNode start="(187, 41)" end="(187, 42)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(187, 43)" end="(187, 44)" leading="" trailing="" raw_val="y" val="y"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(187, 44)" end="(187, 45)" leading="" trailing=" " val=","/>
                      <OtherNode start="(187, 46)" end="(187, 73)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(187, 46)" end="(187, 52)" kind="«term_∈_»">
                          <IdentNode start="(187, 46)" end="(187, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                          <AtomNode start="(187, 48)" end="(187, 49)" leading="" trailing=" " val="∈"/>
                          <IdentNode start="(187, 50)" end="(187, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </OtherNode>
                        <AtomNode start="(187, 53)" end="(187, 54)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(187, 55)" end="(187, 73)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(187, 55)" end="(187, 61)" kind="«term_∈_»">
                            <IdentNode start="(187, 55)" end="(187, 56)" leading="" trailing=" " raw_val="y" val="y"/>
                            <AtomNode start="(187, 57)" end="(187, 58)" leading="" trailing=" " val="∈"/>
                            <IdentNode start="(187, 59)" end="(187, 61)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          </OtherNode>
                          <AtomNode start="(187, 62)" end="(187, 63)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(187, 64)" end="(187, 73)" kind="«term_≤_»">
                            <OtherNode start="(187, 64)" end="(187, 67)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(187, 64)" end="(187, 65)" leading="" trailing="" raw_val="x" val="x"/>
                              <AtomNode start="(187, 65)" end="(187, 66)" leading="" trailing="" val="."/>
                              <OtherNode start="(187, 66)" end="(187, 67)" kind="fieldIdx">
                                <AtomNode start="(187, 66)" end="(187, 67)" leading="" trailing=" " val="2"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(187, 68)" end="(187, 69)" leading="" trailing=" " val="≤"/>
                            <OtherNode start="(187, 70)" end="(187, 73)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(187, 70)" end="(187, 71)" leading="" trailing="" raw_val="y" val="y"/>
                              <AtomNode start="(187, 71)" end="(187, 72)" leading="" trailing="" val="."/>
                              <OtherNode start="(187, 72)" end="(187, 73)" kind="fieldIdx">
                                <AtomNode start="(187, 72)" end="(187, 73)" leading="" trailing="" val="2"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(187, 73)" end="(187, 74)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(187, 74)" end="(187, 75)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(188, 5)" end="(188, 83)" kind="«term_=_»">
                <OtherNode start="(188, 5)" end="(188, 42)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(188, 5)" end="(188, 36)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(188, 5)" end="(188, 32)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(188, 5)" end="(188, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(188, 6)" end="(188, 31)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(188, 6)" end="(188, 11)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        <NullNode start="(188, 12)" end="(188, 31)">
                          <IdentNode start="(188, 12)" end="(188, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <IdentNode start="(188, 15)" end="(188, 17)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          <OtherNode start="(188, 18)" end="(188, 31)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(188, 18)" end="(188, 19)" leading="" trailing="" val="("/>
                            <OtherNode start="(188, 19)" end="(188, 30)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(188, 19)" end="(188, 27)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                              <NullNode start="(188, 28)" end="(188, 30)">
                                <IdentNode start="(188, 28)" end="(188, 30)" leading="" trailing="" raw_val="le" val="le"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(188, 30)" end="(188, 31)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(188, 31)" end="(188, 32)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(188, 32)" end="(188, 33)" leading="" trailing="" val="."/>
                    <IdentNode start="(188, 33)" end="(188, 36)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(188, 37)" end="(188, 42)">
                    <OtherNode start="(188, 37)" end="(188, 42)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(188, 37)" end="(188, 38)" leading="" trailing="" val="("/>
                      <OtherNode start="(188, 38)" end="(188, 41)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(188, 38)" end="(188, 39)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(188, 38)" end="(188, 39)" leading="" trailing="" val="·"/>
                        </OtherNode>
                        <AtomNode start="(188, 39)" end="(188, 40)" leading="" trailing="" val="."/>
                        <OtherNode start="(188, 40)" end="(188, 41)" kind="fieldIdx">
                          <AtomNode start="(188, 40)" end="(188, 41)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(188, 41)" end="(188, 42)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(188, 43)" end="(188, 44)" leading="" trailing=" " val="="/>
                <OtherNode start="(188, 45)" end="(188, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(188, 45)" end="(188, 50)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(188, 51)" end="(188, 83)">
                    <OtherNode start="(188, 51)" end="(188, 65)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(188, 51)" end="(188, 52)" leading="" trailing="" val="("/>
                      <OtherNode start="(188, 52)" end="(188, 64)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(188, 52)" end="(188, 58)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                        <NullNode start="(188, 59)" end="(188, 64)">
                          <OtherNode start="(188, 59)" end="(188, 64)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(188, 59)" end="(188, 60)" leading="" trailing="" val="("/>
                            <OtherNode start="(188, 60)" end="(188, 63)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(188, 60)" end="(188, 61)" kind="Lean.Parser.Term.cdot">
                                <AtomNode start="(188, 60)" end="(188, 61)" leading="" trailing="" val="·"/>
                              </OtherNode>
                              <AtomNode start="(188, 61)" end="(188, 62)" leading="" trailing="" val="."/>
                              <OtherNode start="(188, 62)" end="(188, 63)" kind="fieldIdx">
                                <AtomNode start="(188, 62)" end="(188, 63)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(188, 63)" end="(188, 64)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(188, 64)" end="(188, 65)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(188, 66)" end="(188, 80)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(188, 66)" end="(188, 67)" leading="" trailing="" val="("/>
                      <OtherNode start="(188, 67)" end="(188, 79)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(188, 67)" end="(188, 73)" leading="" trailing=" " raw_val="ys.map" val="ys.map"/>
                        <NullNode start="(188, 74)" end="(188, 79)">
                          <OtherNode start="(188, 74)" end="(188, 79)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(188, 74)" end="(188, 75)" leading="" trailing="" val="("/>
                            <OtherNode start="(188, 75)" end="(188, 78)" kind="Lean.Parser.Term.proj">
                              <OtherNode start="(188, 75)" end="(188, 76)" kind="Lean.Parser.Term.cdot">
                                <AtomNode start="(188, 75)" end="(188, 76)" leading="" trailing="" val="·"/>
                              </OtherNode>
                              <AtomNode start="(188, 76)" end="(188, 77)" leading="" trailing="" val="."/>
                              <OtherNode start="(188, 77)" end="(188, 78)" kind="fieldIdx">
                                <AtomNode start="(188, 77)" end="(188, 78)" leading="" trailing="" val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(188, 78)" end="(188, 79)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(188, 79)" end="(188, 80)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(188, 81)" end="(188, 83)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(189, 3)" end="(200, 70)">
          <OtherNode start="(189, 3)" end="(200, 70)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(189, 3)" end="(200, 70)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(189, 3)" end="(200, 70)">
                <OtherNode start="(189, 3)" end="(189, 33)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(189, 3)" end="(189, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(189, 5)" end="(189, 14)">
                    <NullNode start="(189, 5)" end="(189, 14)">
                      <OtherNode start="(189, 5)" end="(189, 7)" kind="«term[_]»">
                        <AtomNode start="(189, 5)" end="(189, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(189, 6)" end="(189, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(189, 7)" end="(189, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(189, 9)" end="(189, 11)" leading="" trailing="" raw_val="ys" val="ys"/>
                      <AtomNode start="(189, 11)" end="(189, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(189, 13)" end="(189, 14)">
                        <AtomNode start="(189, 13)" end="(189, 14)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(189, 15)" end="(189, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(189, 18)" end="(189, 33)">
                    <AtomNode start="(189, 18)" end="(189, 20)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(189, 21)" end="(189, 33)">
                      <TacticTacticseq1IndentedNode start="(189, 21)" end="(189, 33)">
                        <NullNode start="(189, 21)" end="(189, 33)">
                          <OtherNode start="(189, 21)" end="(189, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;ys : List (α × Nat)&#10;x✝ : ∀ (x y : α × Nat), x ∈ [] → y ∈ ys → x.snd ≤ y.snd&#10;⊢ map (fun x =&amp;gt; x.fst) ([].merge ys (zipIdxLE le)) = (map (fun x =&amp;gt; x.fst) []).merge (map (fun x =&amp;gt; x.fst) ys) le" state_after="no goals" tactic="simp [merge]">
                            <AtomNode start="(189, 21)" end="(189, 25)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(189, 26)" end="(189, 33)">
                              <AtomNode start="(189, 26)" end="(189, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(189, 27)" end="(189, 32)">
                                <OtherNode start="(189, 27)" end="(189, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(189, 27)" end="(189, 32)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(189, 32)" end="(189, 33)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(190, 3)" end="(190, 33)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(190, 3)" end="(190, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(190, 5)" end="(190, 14)">
                    <NullNode start="(190, 5)" end="(190, 14)">
                      <IdentNode start="(190, 5)" end="(190, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(190, 7)" end="(190, 8)" leading="" trailing=" " val=","/>
                      <OtherNode start="(190, 9)" end="(190, 11)" kind="«term[_]»">
                        <AtomNode start="(190, 9)" end="(190, 10)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(190, 10)" end="(190, 11)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(190, 11)" end="(190, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(190, 13)" end="(190, 14)">
                        <AtomNode start="(190, 13)" end="(190, 14)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(190, 15)" end="(190, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(190, 18)" end="(190, 33)">
                    <AtomNode start="(190, 18)" end="(190, 20)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(190, 21)" end="(190, 33)">
                      <TacticTacticseq1IndentedNode start="(190, 21)" end="(190, 33)">
                        <NullNode start="(190, 21)" end="(190, 33)">
                          <OtherNode start="(190, 21)" end="(190, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;xs : List (α × Nat)&#10;x✝ : ∀ (x y : α × Nat), x ∈ xs → y ∈ [] → x.snd ≤ y.snd&#10;⊢ map (fun x =&amp;gt; x.fst) (xs.merge [] (zipIdxLE le)) = (map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) []) le" state_after="no goals" tactic="simp [merge]">
                            <AtomNode start="(190, 21)" end="(190, 25)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(190, 26)" end="(190, 33)">
                              <AtomNode start="(190, 26)" end="(190, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(190, 27)" end="(190, 32)">
                                <OtherNode start="(190, 27)" end="(190, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(190, 27)" end="(190, 32)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(190, 32)" end="(190, 33)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(191, 3)" end="(200, 70)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(191, 3)" end="(191, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(191, 5)" end="(191, 34)">
                    <NullNode start="(191, 5)" end="(191, 34)">
                      <OtherNode start="(191, 5)" end="(191, 17)" kind="«term_::_»">
                        <OtherNode start="(191, 5)" end="(191, 11)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(191, 5)" end="(191, 6)" leading="" trailing="" val="("/>
                          <NullNode start="(191, 6)" end="(191, 10)">
                            <IdentNode start="(191, 6)" end="(191, 7)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(191, 7)" end="(191, 8)" leading="" trailing=" " val=","/>
                            <NullNode start="(191, 9)" end="(191, 10)">
                              <IdentNode start="(191, 9)" end="(191, 10)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(191, 10)" end="(191, 11)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(191, 12)" end="(191, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(191, 15)" end="(191, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(191, 17)" end="(191, 18)" leading="" trailing=" " val=","/>
                      <OtherNode start="(191, 19)" end="(191, 31)" kind="«term_::_»">
                        <OtherNode start="(191, 19)" end="(191, 25)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(191, 19)" end="(191, 20)" leading="" trailing="" val="("/>
                          <NullNode start="(191, 20)" end="(191, 24)">
                            <IdentNode start="(191, 20)" end="(191, 21)" leading="" trailing="" raw_val="j" val="j"/>
                            <AtomNode start="(191, 21)" end="(191, 22)" leading="" trailing=" " val=","/>
                            <NullNode start="(191, 23)" end="(191, 24)">
                              <IdentNode start="(191, 23)" end="(191, 24)" leading="" trailing="" raw_val="y" val="y"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(191, 24)" end="(191, 25)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <AtomNode start="(191, 26)" end="(191, 28)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(191, 29)" end="(191, 31)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                      <AtomNode start="(191, 31)" end="(191, 32)" leading="" trailing=" " val=","/>
                      <IdentNode start="(191, 33)" end="(191, 34)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(191, 35)" end="(191, 37)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(191, 38)" end="(200, 70)">
                    <AtomNode start="(191, 38)" end="(191, 40)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(192, 5)" end="(200, 70)">
                      <TacticTacticseq1IndentedNode start="(192, 5)" end="(200, 70)">
                        <NullNode start="(192, 5)" end="(200, 70)">
                          <OtherNode start="(192, 5)" end="(192, 42)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;⊢ map (fun x =&amp;gt; x.fst) (((i, x) :: xs).merge ((j, y) :: ys) (zipIdxLE le)) =&#10;    (map (fun x =&amp;gt; x.fst) ((i, x) :: xs)).merge (map (fun x =&amp;gt; x.fst) ((j, y) :: ys)) le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if (if le i j = true then if le j i = true then decide (x ≤ y) else true else false) = true then&#10;        (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    if le i j = true then i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le&#10;    else j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" tactic="simp only [merge, zipIdxLE, map_cons]">
                            <AtomNode start="(192, 5)" end="(192, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(192, 10)" end="(192, 14)">
                              <AtomNode start="(192, 10)" end="(192, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(192, 15)" end="(192, 42)">
                              <AtomNode start="(192, 15)" end="(192, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(192, 16)" end="(192, 41)">
                                <OtherNode start="(192, 16)" end="(192, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(192, 16)" end="(192, 21)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(192, 21)" end="(192, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(192, 23)" end="(192, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(192, 23)" end="(192, 31)" leading="" trailing="" raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(192, 31)" end="(192, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(192, 33)" end="(192, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(192, 33)" end="(192, 41)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(192, 41)" end="(192, 42)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(193, 5)" end="(193, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if (if le i j = true then if le j i = true then decide (x ≤ y) else true else false) = true then&#10;        (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    if le i j = true then i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le&#10;    else j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" state_after="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if (if le j i = true then decide (x ≤ y) else true) = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le&#10;&#10;case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if false = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" tactic="split &amp;lt;;&amp;gt; rename_i w">
                            <OtherNode start="(193, 5)" end="(193, 10)" kind="Lean.Parser.Tactic.split">
                              <AtomNode start="(193, 5)" end="(193, 10)" leading="" trailing=" " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(193, 11)" end="(193, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(193, 15)" end="(193, 25)" kind="Lean.Parser.Tactic.renameI">
                              <AtomNode start="(193, 15)" end="(193, 23)" leading="" trailing=" " val="rename_i"/>
                              <NullNode start="(193, 24)" end="(193, 25)">
                                <LeanBinderidentNode start="(193, 24)" end="(193, 25)">
                                  <IdentNode start="(193, 24)" end="(193, 25)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                </LeanBinderidentNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(194, 5)" end="(197, 70)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if (if le j i = true then decide (x ≤ y) else true) = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le&#10;&#10;case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if false = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" state_after="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if false = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" tactic="· rw [if_pos (by simp [h _ _ (mem_cons_self ..) (mem_cons_self ..)])]&#10;  simp only [map_cons, cons.injEq, true_and]&#10;  rw [merge_stable, map_cons]&#10;  exact fun x' y' mx my =&amp;gt; h x' y' (mem_cons_of_mem (i, x) mx) my">
                            <OtherNode start="(194, 5)" end="(194, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(194, 5)" end="(194, 6)" kind="patternIgnore">
                                <OtherNode start="(194, 5)" end="(194, 6)" kind="token.«· »">
                                  <AtomNode start="(194, 5)" end="(194, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(194, 7)" end="(197, 70)">
                              <TacticTacticseq1IndentedNode start="(194, 7)" end="(197, 70)">
                                <NullNode start="(194, 7)" end="(197, 70)">
                                  <OtherNode start="(194, 7)" end="(194, 74)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if (if le j i = true then decide (x ≤ y) else true) = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le" state_after="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst) ((i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)) =&#10;    i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le" tactic="rw [if_pos (by simp [h _ _ (mem_cons_self ..) (mem_cons_self ..)])]">
                                    <AtomNode start="(194, 7)" end="(194, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(194, 10)" end="(194, 74)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(194, 10)" end="(194, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(194, 11)" end="(194, 73)">
                                        <OtherNode start="(194, 11)" end="(194, 73)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <OtherNode start="(194, 11)" end="(194, 73)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(194, 11)" end="(194, 17)" leading="" trailing=" " raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                            <NullNode start="(194, 18)" end="(194, 73)">
                                              <OtherNode start="(194, 18)" end="(194, 73)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(194, 18)" end="(194, 19)" leading="" trailing="" val="("/>
                                                <TermBytacticNode start="(194, 19)" end="(194, 72)">
                                                  <AtomNode start="(194, 19)" end="(194, 21)" leading="" trailing=" " val="by"/>
                                                  <TacticTacticseqNode start="(194, 22)" end="(194, 72)">
                                                    <TacticTacticseq1IndentedNode start="(194, 22)" end="(194, 72)">
                                                      <NullNode start="(194, 22)" end="(194, 72)">
                                                        <OtherNode start="(194, 22)" end="(194, 72)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ (if le j i = true then decide (x ≤ y) else true) = true" state_after="no goals" tactic="simp [h _ _ (mem_cons_self ..) (mem_cons_self ..)]">
                                                          <AtomNode start="(194, 22)" end="(194, 26)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(194, 27)" end="(194, 72)">
                                                            <AtomNode start="(194, 27)" end="(194, 28)" leading="" trailing="" val="["/>
                                                            <NullNode start="(194, 28)" end="(194, 71)">
                                                            <OtherNode start="(194, 28)" end="(194, 71)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(194, 28)" end="(194, 71)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 28)" end="(194, 29)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <NullNode start="(194, 30)" end="(194, 71)">
                                                            <TermHoleNode start="(194, 30)" end="(194, 31)">
                                                            <AtomNode start="(194, 30)" end="(194, 31)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(194, 32)" end="(194, 33)">
                                                            <AtomNode start="(194, 32)" end="(194, 33)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(194, 34)" end="(194, 52)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(194, 34)" end="(194, 35)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(194, 35)" end="(194, 51)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 35)" end="(194, 48)" leading="" trailing=" " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(194, 49)" end="(194, 51)">
                                                            <OtherNode start="(194, 49)" end="(194, 51)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(194, 49)" end="(194, 51)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(194, 51)" end="(194, 52)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(194, 53)" end="(194, 71)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(194, 53)" end="(194, 54)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(194, 54)" end="(194, 70)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(194, 54)" end="(194, 67)" leading="" trailing=" " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            <NullNode start="(194, 68)" end="(194, 70)">
                                                            <OtherNode start="(194, 68)" end="(194, 70)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(194, 68)" end="(194, 70)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(194, 70)" end="(194, 71)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(194, 71)" end="(194, 72)" leading="" trailing="" val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </TacticTacticseq1IndentedNode>
                                                  </TacticTacticseqNode>
                                                </TermBytacticNode>
                                                <AtomNode start="(194, 72)" end="(194, 73)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(194, 73)" end="(194, 74)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(195, 7)" end="(195, 49)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst) ((i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)) =&#10;    i :: (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le" state_after="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst) (xs.merge ((j, y) :: ys) (zipIdxLE le)) =&#10;    (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le" tactic="simp only [map_cons, cons.injEq, true_and]">
                                    <AtomNode start="(195, 7)" end="(195, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(195, 12)" end="(195, 16)">
                                      <AtomNode start="(195, 12)" end="(195, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(195, 17)" end="(195, 49)">
                                      <AtomNode start="(195, 17)" end="(195, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(195, 18)" end="(195, 48)">
                                        <OtherNode start="(195, 18)" end="(195, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(195, 18)" end="(195, 26)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(195, 26)" end="(195, 27)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(195, 28)" end="(195, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(195, 28)" end="(195, 38)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(195, 38)" end="(195, 39)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(195, 40)" end="(195, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(195, 40)" end="(195, 48)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(195, 48)" end="(195, 49)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(196, 7)" end="(196, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst) (xs.merge ((j, y) :: ys) (zipIdxLE le)) =&#10;    (map (fun x =&amp;gt; x.fst) xs).merge (j :: map (fun x =&amp;gt; x.fst) ys) le" state_after="case isTrue.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ ∀ (x y_1 : α × Nat), x ∈ xs → y_1 ∈ (j, y) :: ys → x.snd ≤ y_1.snd" tactic="rw [merge_stable, map_cons]">
                                    <AtomNode start="(196, 7)" end="(196, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(196, 10)" end="(196, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(196, 10)" end="(196, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(196, 11)" end="(196, 33)">
                                        <OtherNode start="(196, 11)" end="(196, 23)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(196, 11)" end="(196, 23)" leading="" trailing="" raw_val="merge_stable" val="merge_stable"/>
                                        </OtherNode>
                                        <AtomNode start="(196, 23)" end="(196, 24)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(196, 25)" end="(196, 33)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(196, 25)" end="(196, 33)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(196, 33)" end="(196, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(197, 7)" end="(197, 70)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : le i j = true&#10;⊢ ∀ (x y_1 : α × Nat), x ∈ xs → y_1 ∈ (j, y) :: ys → x.snd ≤ y_1.snd" state_after="no goals" tactic="exact fun x' y' mx my =&amp;gt; h x' y' (mem_cons_of_mem (i, x) mx) my">
                                    <AtomNode start="(197, 7)" end="(197, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(197, 13)" end="(197, 70)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(197, 13)" end="(197, 16)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(197, 17)" end="(197, 70)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(197, 17)" end="(197, 28)">
                                          <IdentNode start="(197, 17)" end="(197, 19)" leading="" trailing=" " raw_val="x'" val="x'"/>
                                          <IdentNode start="(197, 20)" end="(197, 22)" leading="" trailing=" " raw_val="y'" val="y'"/>
                                          <IdentNode start="(197, 23)" end="(197, 25)" leading="" trailing=" " raw_val="mx" val="mx"/>
                                          <IdentNode start="(197, 26)" end="(197, 28)" leading="" trailing=" " raw_val="my" val="my"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(197, 29)" end="(197, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <OtherNode start="(197, 32)" end="(197, 70)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(197, 32)" end="(197, 33)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <NullNode start="(197, 34)" end="(197, 70)">
                                            <IdentNode start="(197, 34)" end="(197, 36)" leading="" trailing=" " raw_val="x'" val="x'"/>
                                            <IdentNode start="(197, 37)" end="(197, 39)" leading="" trailing=" " raw_val="y'" val="y'"/>
                                            <OtherNode start="(197, 40)" end="(197, 67)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(197, 40)" end="(197, 41)" leading="" trailing="" val="("/>
                                              <OtherNode start="(197, 41)" end="(197, 66)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(197, 41)" end="(197, 56)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                <NullNode start="(197, 57)" end="(197, 66)">
                                                  <OtherNode start="(197, 57)" end="(197, 63)" kind="Lean.Parser.Term.tuple">
                                                    <AtomNode start="(197, 57)" end="(197, 58)" leading="" trailing="" val="("/>
                                                    <NullNode start="(197, 58)" end="(197, 62)">
                                                      <IdentNode start="(197, 58)" end="(197, 59)" leading="" trailing="" raw_val="i" val="i"/>
                                                      <AtomNode start="(197, 59)" end="(197, 60)" leading="" trailing=" " val=","/>
                                                      <NullNode start="(197, 61)" end="(197, 62)">
                                                        <IdentNode start="(197, 61)" end="(197, 62)" leading="" trailing="" raw_val="x" val="x"/>
                                                      </NullNode>
                                                    </NullNode>
                                                    <AtomNode start="(197, 62)" end="(197, 63)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                  <IdentNode start="(197, 64)" end="(197, 66)" leading="" trailing="" raw_val="mx" val="mx"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(197, 66)" end="(197, 67)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                            <IdentNode start="(197, 68)" end="(197, 70)" leading="" trailing="&#10;    " raw_val="my" val="my"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(198, 5)" end="(200, 70)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if false = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" state_after="no goals" tactic="· simp only [↓reduceIte, map_cons, cons.injEq, true_and, reduceCtorEq]&#10;  rw [merge_stable, map_cons]&#10;  exact fun x' y' mx my =&amp;gt; h x' y' mx (mem_cons_of_mem (j, y) my)">
                            <OtherNode start="(198, 5)" end="(198, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(198, 5)" end="(198, 6)" kind="patternIgnore">
                                <OtherNode start="(198, 5)" end="(198, 6)" kind="token.«· »">
                                  <AtomNode start="(198, 5)" end="(198, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(198, 7)" end="(200, 70)">
                              <TacticTacticseq1IndentedNode start="(198, 7)" end="(200, 70)">
                                <NullNode start="(198, 7)" end="(200, 70)">
                                  <OtherNode start="(198, 7)" end="(198, 75)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (if false = true then (i, x) :: xs.merge ((j, y) :: ys) (zipIdxLE le)&#10;      else (j, y) :: ((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    j :: (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" state_after="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst) (((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" tactic="simp only [↓reduceIte, map_cons, cons.injEq, true_and, reduceCtorEq]">
                                    <AtomNode start="(198, 7)" end="(198, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(198, 12)" end="(198, 16)">
                                      <AtomNode start="(198, 12)" end="(198, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(198, 17)" end="(198, 75)">
                                      <AtomNode start="(198, 17)" end="(198, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(198, 18)" end="(198, 74)">
                                        <OtherNode start="(198, 18)" end="(198, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode start="(198, 18)" end="(198, 19)">
                                            <OtherNode start="(198, 18)" end="(198, 19)" kind="Lean.Parser.Tactic.simpPre">
                                              <AtomNode start="(198, 18)" end="(198, 19)" leading="" trailing="" val="↓"/>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode/>
                                          <IdentNode start="(198, 19)" end="(198, 28)" leading="" trailing="" raw_val="reduceIte" val="reduceIte"/>
                                        </OtherNode>
                                        <AtomNode start="(198, 28)" end="(198, 29)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(198, 30)" end="(198, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(198, 30)" end="(198, 38)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(198, 38)" end="(198, 39)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(198, 40)" end="(198, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(198, 40)" end="(198, 50)" leading="" trailing="" raw_val="cons.injEq" val="cons.injEq" full_name="List.cons.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(198, 50)" end="(198, 51)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(198, 52)" end="(198, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(198, 52)" end="(198, 60)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(198, 60)" end="(198, 61)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(198, 62)" end="(198, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(198, 62)" end="(198, 74)" leading="" trailing="" raw_val="reduceCtorEq" val="reduceCtorEq"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(198, 74)" end="(198, 75)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(199, 7)" end="(199, 34)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ map (fun x =&amp;gt; x.fst) (((i, x) :: xs).merge ys (zipIdxLE le)) =&#10;    (i :: map (fun x =&amp;gt; x.fst) xs).merge (map (fun x =&amp;gt; x.fst) ys) le" state_after="case isFalse.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ ∀ (x_1 y : α × Nat), x_1 ∈ (i, x) :: xs → y ∈ ys → x_1.snd ≤ y.snd" tactic="rw [merge_stable, map_cons]">
                                    <AtomNode start="(199, 7)" end="(199, 9)" leading="" trailing=" " val="rw"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <OtherNode start="(199, 10)" end="(199, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                      <AtomNode start="(199, 10)" end="(199, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(199, 11)" end="(199, 33)">
                                        <OtherNode start="(199, 11)" end="(199, 23)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(199, 11)" end="(199, 23)" leading="" trailing="" raw_val="merge_stable" val="merge_stable" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(199, 23)" end="(199, 24)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(199, 25)" end="(199, 33)" kind="Lean.Parser.Tactic.rwRule">
                                          <NullNode/>
                                          <IdentNode start="(199, 25)" end="(199, 33)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(199, 33)" end="(199, 34)" leading="" trailing="&#10;      " val="]"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(200, 7)" end="(200, 70)" kind="Lean.Parser.Tactic.exact" state_before="case isFalse.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;i : α&#10;x : Nat&#10;xs : List (α × Nat)&#10;j : α&#10;y : Nat&#10;ys : List (α × Nat)&#10;h : ∀ (x_1 y_1 : α × Nat), x_1 ∈ (i, x) :: xs → y_1 ∈ (j, y) :: ys → x_1.snd ≤ y_1.snd&#10;w : ¬le i j = true&#10;⊢ ∀ (x_1 y : α × Nat), x_1 ∈ (i, x) :: xs → y ∈ ys → x_1.snd ≤ y.snd" state_after="no goals" tactic="exact fun x' y' mx my =&amp;gt; h x' y' mx (mem_cons_of_mem (j, y) my)">
                                    <AtomNode start="(200, 7)" end="(200, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(200, 13)" end="(200, 70)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(200, 13)" end="(200, 16)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(200, 17)" end="(200, 70)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(200, 17)" end="(200, 28)">
                                          <IdentNode start="(200, 17)" end="(200, 19)" leading="" trailing=" " raw_val="x'" val="x'"/>
                                          <IdentNode start="(200, 20)" end="(200, 22)" leading="" trailing=" " raw_val="y'" val="y'"/>
                                          <IdentNode start="(200, 23)" end="(200, 25)" leading="" trailing=" " raw_val="mx" val="mx"/>
                                          <IdentNode start="(200, 26)" end="(200, 28)" leading="" trailing=" " raw_val="my" val="my"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(200, 29)" end="(200, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <OtherNode start="(200, 32)" end="(200, 70)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(200, 32)" end="(200, 33)" leading="" trailing=" " raw_val="h" val="h"/>
                                          <NullNode start="(200, 34)" end="(200, 70)">
                                            <IdentNode start="(200, 34)" end="(200, 36)" leading="" trailing=" " raw_val="x'" val="x'"/>
                                            <IdentNode start="(200, 37)" end="(200, 39)" leading="" trailing=" " raw_val="y'" val="y'"/>
                                            <IdentNode start="(200, 40)" end="(200, 42)" leading="" trailing=" " raw_val="mx" val="mx"/>
                                            <OtherNode start="(200, 43)" end="(200, 70)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(200, 43)" end="(200, 44)" leading="" trailing="" val="("/>
                                              <OtherNode start="(200, 44)" end="(200, 69)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(200, 44)" end="(200, 59)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                <NullNode start="(200, 60)" end="(200, 69)">
                                                  <OtherNode start="(200, 60)" end="(200, 66)" kind="Lean.Parser.Term.tuple">
                                                    <AtomNode start="(200, 60)" end="(200, 61)" leading="" trailing="" val="("/>
                                                    <NullNode start="(200, 61)" end="(200, 65)">
                                                      <IdentNode start="(200, 61)" end="(200, 62)" leading="" trailing="" raw_val="j" val="j"/>
                                                      <AtomNode start="(200, 62)" end="(200, 63)" leading="" trailing=" " val=","/>
                                                      <NullNode start="(200, 64)" end="(200, 65)">
                                                        <IdentNode start="(200, 64)" end="(200, 65)" leading="" trailing="" raw_val="y" val="y"/>
                                                      </NullNode>
                                                    </NullNode>
                                                    <AtomNode start="(200, 65)" end="(200, 66)" leading="" trailing=" " val=")"/>
                                                  </OtherNode>
                                                  <IdentNode start="(200, 67)" end="(200, 69)" leading="" trailing="" raw_val="my" val="my"/>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(200, 69)" end="(200, 70)" leading="" trailing="&#10;&#10;-- We enable this instance locally so we can write `Pairwise le` instead of `Pairwise (le · ·)` everywhere.&#10;" val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(203, 1)" end="(203, 40)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(203, 1)" end="(203, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(203, 11)" end="(203, 12)" leading="" trailing="" val="["/>
      <NullNode start="(203, 12)" end="(203, 26)">
        <OtherNode start="(203, 12)" end="(203, 26)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode start="(203, 12)" end="(203, 17)">
            <NullNode start="(203, 12)" end="(203, 17)">
              <OtherNode start="(203, 12)" end="(203, 17)" kind="Lean.Parser.Term.local">
                <AtomNode start="(203, 12)" end="(203, 17)" leading="" trailing=" " val="local"/>
              </OtherNode>
            </NullNode>
          </TermAttrkindNode>
          <OtherNode start="(203, 18)" end="(203, 26)" kind="Lean.Parser.Attr.instance">
            <AtomNode start="(203, 18)" end="(203, 26)" leading="" trailing="" val="instance"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(203, 26)" end="(203, 27)" leading="" trailing=" " val="]"/>
      <NullNode start="(203, 28)" end="(203, 40)">
        <IdentNode start="(203, 28)" end="(203, 40)" leading="" trailing="&#10;&#10;" raw_val="boolRelToRel" val="boolRelToRel" full_name="boolRelToRel" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(205, 1)" end="(237, 28)" name="sorted_merge" full_name="List.sorted_merge">
      <CommandDeclmodifiersNode start="(205, 1)" end="(208, 3)">
        <NullNode start="(205, 1)" end="(208, 3)">
          <CommandDoccommentNode start="(205, 1)" end="(208, 3)" comment="If the ordering relation `le` is transitive and total (i.e. `le a b || le b a` for all `a, b`)&#10;then the `merge` of two sorted lists is sorted.&#10;-/">
            <AtomNode start="(205, 1)" end="(205, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(206, 1)" end="(208, 3)" leading="" trailing="&#10;" val="If the ordering relation `le` is transitive and total (i.e. `le a b || le b a` for all `a, b`)&#10;then the `merge` of two sorted lists is sorted.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(209, 1)" end="(237, 28)" name="sorted_merge" full_name="List.sorted_merge" _is_private_decl="False">
        <AtomNode start="(209, 1)" end="(209, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(209, 9)" end="(209, 21)">
          <IdentNode start="(209, 9)" end="(209, 21)" leading="" trailing="&#10;    " raw_val="sorted_merge" val="sorted_merge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(210, 5)" end="(212, 96)">
          <NullNode start="(210, 5)" end="(212, 65)">
            <TermExplicitbinderNode start="(210, 5)" end="(210, 54)">
              <AtomNode start="(210, 5)" end="(210, 6)" leading="" trailing="" val="("/>
              <NullNode start="(210, 6)" end="(210, 11)">
                <IdentNode start="(210, 6)" end="(210, 11)" leading="" trailing=" " raw_val="trans" val="trans"/>
              </NullNode>
              <NullNode start="(210, 12)" end="(210, 53)">
                <AtomNode start="(210, 12)" end="(210, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(210, 14)" end="(210, 53)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(210, 14)" end="(210, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(210, 16)" end="(210, 27)">
                    <TermExplicitbinderNode start="(210, 16)" end="(210, 27)">
                      <AtomNode start="(210, 16)" end="(210, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(210, 17)" end="(210, 22)">
                        <IdentNode start="(210, 17)" end="(210, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(210, 19)" end="(210, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(210, 21)" end="(210, 22)" leading="" trailing=" " raw_val="c" val="c"/>
                      </NullNode>
                      <NullNode start="(210, 23)" end="(210, 26)">
                        <AtomNode start="(210, 23)" end="(210, 24)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(210, 25)" end="(210, 26)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(210, 26)" end="(210, 27)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(210, 27)" end="(210, 28)" leading="" trailing=" " val=","/>
                  <OtherNode start="(210, 29)" end="(210, 53)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(210, 29)" end="(210, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(210, 29)" end="(210, 31)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(210, 32)" end="(210, 35)">
                        <IdentNode start="(210, 32)" end="(210, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(210, 34)" end="(210, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(210, 36)" end="(210, 37)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(210, 38)" end="(210, 53)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(210, 38)" end="(210, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(210, 38)" end="(210, 40)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(210, 41)" end="(210, 44)">
                          <IdentNode start="(210, 41)" end="(210, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(210, 43)" end="(210, 44)" leading="" trailing=" " raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(210, 45)" end="(210, 46)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(210, 47)" end="(210, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(210, 47)" end="(210, 49)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(210, 50)" end="(210, 53)">
                          <IdentNode start="(210, 50)" end="(210, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(210, 52)" end="(210, 53)" leading="" trailing="" raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(210, 53)" end="(210, 54)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(211, 5)" end="(211, 44)">
              <AtomNode start="(211, 5)" end="(211, 6)" leading="" trailing="" val="("/>
              <NullNode start="(211, 6)" end="(211, 11)">
                <IdentNode start="(211, 6)" end="(211, 11)" leading="" trailing=" " raw_val="total" val="total"/>
              </NullNode>
              <NullNode start="(211, 12)" end="(211, 43)">
                <AtomNode start="(211, 12)" end="(211, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 14)" end="(211, 43)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(211, 14)" end="(211, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(211, 16)" end="(211, 25)">
                    <TermExplicitbinderNode start="(211, 16)" end="(211, 25)">
                      <AtomNode start="(211, 16)" end="(211, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(211, 17)" end="(211, 20)">
                        <IdentNode start="(211, 17)" end="(211, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(211, 19)" end="(211, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode start="(211, 21)" end="(211, 24)">
                        <AtomNode start="(211, 21)" end="(211, 22)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(211, 23)" end="(211, 24)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(211, 24)" end="(211, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(211, 25)" end="(211, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(211, 27)" end="(211, 43)" kind="«term_||_»">
                    <OtherNode start="(211, 27)" end="(211, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(211, 27)" end="(211, 29)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(211, 30)" end="(211, 33)">
                        <IdentNode start="(211, 30)" end="(211, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(211, 32)" end="(211, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(211, 34)" end="(211, 36)" leading="" trailing=" " val="||"/>
                    <OtherNode start="(211, 37)" end="(211, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(211, 37)" end="(211, 39)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(211, 40)" end="(211, 43)">
                        <IdentNode start="(211, 40)" end="(211, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(211, 42)" end="(211, 43)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(211, 43)" end="(211, 44)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(212, 5)" end="(212, 21)">
              <AtomNode start="(212, 5)" end="(212, 6)" leading="" trailing="" val="("/>
              <NullNode start="(212, 6)" end="(212, 11)">
                <IdentNode start="(212, 6)" end="(212, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(212, 9)" end="(212, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(212, 12)" end="(212, 20)">
                <AtomNode start="(212, 12)" end="(212, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(212, 14)" end="(212, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(212, 14)" end="(212, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(212, 19)" end="(212, 20)">
                    <IdentNode start="(212, 19)" end="(212, 20)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(212, 20)" end="(212, 21)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(212, 22)" end="(212, 43)">
              <AtomNode start="(212, 22)" end="(212, 23)" leading="" trailing="" val="("/>
              <NullNode start="(212, 23)" end="(212, 25)">
                <IdentNode start="(212, 23)" end="(212, 25)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
              </NullNode>
              <NullNode start="(212, 26)" end="(212, 42)">
                <AtomNode start="(212, 26)" end="(212, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(212, 28)" end="(212, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(212, 28)" end="(212, 39)" leading="" trailing=" " raw_val="l₁.Pairwise" val="l₁.Pairwise"/>
                  <NullNode start="(212, 40)" end="(212, 42)">
                    <IdentNode start="(212, 40)" end="(212, 42)" leading="" trailing="" raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(212, 42)" end="(212, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(212, 44)" end="(212, 65)">
              <AtomNode start="(212, 44)" end="(212, 45)" leading="" trailing="" val="("/>
              <NullNode start="(212, 45)" end="(212, 47)">
                <IdentNode start="(212, 45)" end="(212, 47)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
              </NullNode>
              <NullNode start="(212, 48)" end="(212, 64)">
                <AtomNode start="(212, 48)" end="(212, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(212, 50)" end="(212, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(212, 50)" end="(212, 61)" leading="" trailing=" " raw_val="l₂.Pairwise" val="l₂.Pairwise"/>
                  <NullNode start="(212, 62)" end="(212, 64)">
                    <IdentNode start="(212, 62)" end="(212, 64)" leading="" trailing="" raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(212, 64)" end="(212, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(212, 66)" end="(212, 96)">
            <AtomNode start="(212, 66)" end="(212, 67)" leading="" trailing=" " val=":"/>
            <OtherNode start="(212, 68)" end="(212, 96)" kind="Lean.Parser.Term.app">
              <OtherNode start="(212, 68)" end="(212, 93)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(212, 68)" end="(212, 84)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(212, 68)" end="(212, 69)" leading="" trailing="" val="("/>
                  <OtherNode start="(212, 69)" end="(212, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(212, 69)" end="(212, 74)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(212, 75)" end="(212, 83)">
                      <IdentNode start="(212, 75)" end="(212, 77)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <IdentNode start="(212, 78)" end="(212, 80)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      <IdentNode start="(212, 81)" end="(212, 83)" leading="" trailing="" raw_val="le" val="le"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(212, 83)" end="(212, 84)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(212, 84)" end="(212, 85)" leading="" trailing="" val="."/>
                <IdentNode start="(212, 85)" end="(212, 93)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <NullNode start="(212, 94)" end="(212, 96)">
                <IdentNode start="(212, 94)" end="(212, 96)" leading="" trailing=" " raw_val="le" val="le"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(212, 97)" end="(237, 28)">
          <AtomNode start="(212, 97)" end="(212, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(212, 100)" end="(237, 28)">
            <AtomNode start="(212, 100)" end="(212, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(213, 3)" end="(237, 28)">
              <TacticTacticseq1IndentedNode start="(213, 3)" end="(237, 28)">
                <NullNode start="(213, 3)" end="(237, 28)">
                  <OtherNode start="(213, 3)" end="(237, 28)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;l₁ l₂ : List α&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) l₁&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)" state_after="no goals" tactic="induction l₁ generalizing l₂ with&#10;| nil =&amp;gt; simpa only [merge]&#10;| cons x l₁ ih₁ =&amp;gt;&#10;  induction l₂ with&#10;  | nil =&amp;gt; simpa only [merge]&#10;  | cons y l₂ ih₂ =&amp;gt;&#10;    simp only [merge]&#10;    split &amp;lt;;&amp;gt; rename_i h&#10;    · apply Pairwise.cons&#10;      · intro z m&#10;        rw [mem_merge, mem_cons] at m&#10;        rcases m with (m|rfl|m)&#10;        · exact rel_of_pairwise_cons h₁ m&#10;        · exact h&#10;        · exact trans _ _ _ h (rel_of_pairwise_cons h₂ m)&#10;      · exact ih₁ _ h₁.tail h₂&#10;    · apply Pairwise.cons&#10;      · intro z m&#10;        rw [mem_merge, mem_cons] at m&#10;        simp only [Bool.not_eq_true] at h&#10;        rcases m with (⟨rfl|m⟩|m)&#10;        · simpa [h] using total y z&#10;        · exact trans _ _ _ (by simpa [h] using total x y) (rel_of_pairwise_cons h₁ m)&#10;        · exact rel_of_pairwise_cons h₂ m&#10;      · exact ih₂ h₂.tail">
                    <AtomNode start="(213, 3)" end="(213, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(213, 13)" end="(213, 15)">
                      <OtherNode start="(213, 13)" end="(213, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(213, 13)" end="(213, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(213, 16)" end="(213, 31)">
                      <AtomNode start="(213, 16)" end="(213, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(213, 29)" end="(213, 31)">
                        <IdentNode start="(213, 29)" end="(213, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(213, 32)" end="(237, 28)">
                      <OtherNode start="(213, 32)" end="(237, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(213, 32)" end="(213, 36)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(214, 3)" end="(237, 28)">
                          <OtherNode start="(214, 3)" end="(214, 30)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(214, 3)" end="(214, 8)">
                              <OtherNode start="(214, 3)" end="(214, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(214, 3)" end="(214, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(214, 5)" end="(214, 8)">
                                  <NullNode/>
                                  <IdentNode start="(214, 5)" end="(214, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(214, 9)" end="(214, 30)">
                              <AtomNode start="(214, 9)" end="(214, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(214, 12)" end="(214, 30)">
                                <TacticTacticseq1IndentedNode start="(214, 12)" end="(214, 30)">
                                  <NullNode start="(214, 12)" end="(214, 30)">
                                    <OtherNode start="(214, 12)" end="(214, 30)" kind="Lean.Parser.Tactic.simpa" state_before="case nil&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;l₂ : List α&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) []&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ([].merge l₂ le)" state_after="no goals" tactic="simpa only [merge]">
                                      <AtomNode start="(214, 12)" end="(214, 17)" leading="" trailing=" " val="simpa"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <OtherNode start="(214, 18)" end="(214, 30)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(214, 18)" end="(214, 22)">
                                          <AtomNode start="(214, 18)" end="(214, 22)" leading="" trailing=" " val="only"/>
                                        </NullNode>
                                        <NullNode start="(214, 23)" end="(214, 30)">
                                          <OtherNode start="(214, 23)" end="(214, 30)" kind="Lean.Parser.Tactic.simpArgs">
                                            <AtomNode start="(214, 23)" end="(214, 24)" leading="" trailing="" val="["/>
                                            <NullNode start="(214, 24)" end="(214, 29)">
                                              <OtherNode start="(214, 24)" end="(214, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(214, 24)" end="(214, 29)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(214, 29)" end="(214, 30)" leading="" trailing="&#10;  " val="]"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(215, 3)" end="(237, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(215, 3)" end="(215, 18)">
                              <OtherNode start="(215, 3)" end="(215, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(215, 3)" end="(215, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(215, 5)" end="(215, 9)">
                                  <NullNode/>
                                  <IdentNode start="(215, 5)" end="(215, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(215, 10)" end="(215, 18)">
                                  <IdentNode start="(215, 10)" end="(215, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(215, 12)" end="(215, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(215, 15)" end="(215, 18)" leading="" trailing=" " raw_val="ih₁" val="ih₁"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(215, 19)" end="(237, 28)">
                              <AtomNode start="(215, 19)" end="(215, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(216, 5)" end="(237, 28)">
                                <TacticTacticseq1IndentedNode start="(216, 5)" end="(237, 28)">
                                  <NullNode start="(216, 5)" end="(237, 28)">
                                    <OtherNode start="(216, 5)" end="(237, 28)" kind="Lean.Parser.Tactic.induction" state_before="case cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;l₂ : List α&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)" state_after="no goals" tactic="induction l₂ with&#10;| nil =&amp;gt; simpa only [merge]&#10;| cons y l₂ ih₂ =&amp;gt;&#10;  simp only [merge]&#10;  split &amp;lt;;&amp;gt; rename_i h&#10;  · apply Pairwise.cons&#10;    · intro z m&#10;      rw [mem_merge, mem_cons] at m&#10;      rcases m with (m|rfl|m)&#10;      · exact rel_of_pairwise_cons h₁ m&#10;      · exact h&#10;      · exact trans _ _ _ h (rel_of_pairwise_cons h₂ m)&#10;    · exact ih₁ _ h₁.tail h₂&#10;  · apply Pairwise.cons&#10;    · intro z m&#10;      rw [mem_merge, mem_cons] at m&#10;      simp only [Bool.not_eq_true] at h&#10;      rcases m with (⟨rfl|m⟩|m)&#10;      · simpa [h] using total y z&#10;      · exact trans _ _ _ (by simpa [h] using total x y) (rel_of_pairwise_cons h₁ m)&#10;      · exact rel_of_pairwise_cons h₂ m&#10;    · exact ih₂ h₂.tail">
                                      <AtomNode start="(216, 5)" end="(216, 14)" leading="" trailing=" " val="induction"/>
                                      <NullNode start="(216, 15)" end="(216, 17)">
                                        <OtherNode start="(216, 15)" end="(216, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(216, 15)" end="(216, 17)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(216, 18)" end="(237, 28)">
                                        <OtherNode start="(216, 18)" end="(237, 28)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(216, 18)" end="(216, 22)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(217, 5)" end="(237, 28)">
                                            <OtherNode start="(217, 5)" end="(217, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(217, 5)" end="(217, 10)">
                                                <OtherNode start="(217, 5)" end="(217, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(217, 5)" end="(217, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(217, 7)" end="(217, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(217, 7)" end="(217, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(217, 11)" end="(217, 32)">
                                                <AtomNode start="(217, 11)" end="(217, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(217, 14)" end="(217, 32)">
                                                  <TacticTacticseq1IndentedNode start="(217, 14)" end="(217, 32)">
                                                    <NullNode start="(217, 14)" end="(217, 32)">
                                                      <OtherNode start="(217, 14)" end="(217, 32)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.nil&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) []&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge [] le)" state_after="no goals" tactic="simpa only [merge]">
                                                        <AtomNode start="(217, 14)" end="(217, 19)" leading="" trailing=" " val="simpa"/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <OtherNode start="(217, 20)" end="(217, 32)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode start="(217, 20)" end="(217, 24)">
                                                            <AtomNode start="(217, 20)" end="(217, 24)" leading="" trailing=" " val="only"/>
                                                          </NullNode>
                                                          <NullNode start="(217, 25)" end="(217, 32)">
                                                            <OtherNode start="(217, 25)" end="(217, 32)" kind="Lean.Parser.Tactic.simpArgs">
                                                            <AtomNode start="(217, 25)" end="(217, 26)" leading="" trailing="" val="["/>
                                                            <NullNode start="(217, 26)" end="(217, 31)">
                                                            <OtherNode start="(217, 26)" end="(217, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(217, 26)" end="(217, 31)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(217, 31)" end="(217, 32)" leading="" trailing="&#10;    " val="]"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(218, 5)" end="(237, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(218, 5)" end="(218, 20)">
                                                <OtherNode start="(218, 5)" end="(218, 20)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(218, 5)" end="(218, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(218, 7)" end="(218, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(218, 7)" end="(218, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(218, 12)" end="(218, 20)">
                                                    <IdentNode start="(218, 12)" end="(218, 13)" leading="" trailing=" " raw_val="y" val="y"/>
                                                    <IdentNode start="(218, 14)" end="(218, 16)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                    <IdentNode start="(218, 17)" end="(218, 20)" leading="" trailing=" " raw_val="ih₂" val="ih₂"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(218, 21)" end="(237, 28)">
                                                <AtomNode start="(218, 21)" end="(218, 23)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(219, 7)" end="(237, 28)">
                                                  <TacticTacticseq1IndentedNode start="(219, 7)" end="(237, 28)">
                                                    <NullNode start="(219, 7)" end="(237, 28)">
                                                      <OtherNode start="(219, 7)" end="(219, 24)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge (y :: l₂) le)" state_after="case cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (if le x y = true then x :: l₁.merge (y :: l₂) le else y :: (x :: l₁).merge l₂ le)" tactic="simp only [merge]">
                                                        <AtomNode start="(219, 7)" end="(219, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode start="(219, 12)" end="(219, 16)">
                                                          <AtomNode start="(219, 12)" end="(219, 16)" leading="" trailing=" " val="only"/>
                                                        </NullNode>
                                                        <NullNode start="(219, 17)" end="(219, 24)">
                                                          <AtomNode start="(219, 17)" end="(219, 18)" leading="" trailing="" val="["/>
                                                          <NullNode start="(219, 18)" end="(219, 23)">
                                                            <OtherNode start="(219, 18)" end="(219, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(219, 18)" end="(219, 23)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(219, 23)" end="(219, 24)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(220, 7)" end="(220, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (if le x y = true then x :: l₁.merge (y :: l₂) le else y :: (x :: l₁).merge l₂ le)" state_after="case cons.cons.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁.merge (y :: l₂) le)&#10;&#10;case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (y :: (x :: l₁).merge l₂ le)" tactic="split &amp;lt;;&amp;gt; rename_i h">
                                                        <OtherNode start="(220, 7)" end="(220, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(220, 7)" end="(220, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(220, 13)" end="(220, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(220, 17)" end="(220, 27)" kind="Lean.Parser.Tactic.renameI">
                                                          <AtomNode start="(220, 17)" end="(220, 25)" leading="" trailing=" " val="rename_i"/>
                                                          <NullNode start="(220, 26)" end="(220, 27)">
                                                            <LeanBinderidentNode start="(220, 26)" end="(220, 27)">
                                                            <IdentNode start="(220, 26)" end="(220, 27)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                            </LeanBinderidentNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(221, 7)" end="(228, 33)" kind="Lean.cdot" state_before="case cons.cons.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁.merge (y :: l₂) le)&#10;&#10;case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (y :: (x :: l₁).merge l₂ le)" state_after="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (y :: (x :: l₁).merge l₂ le)" tactic="· apply Pairwise.cons&#10;  · intro z m&#10;    rw [mem_merge, mem_cons] at m&#10;    rcases m with (m|rfl|m)&#10;    · exact rel_of_pairwise_cons h₁ m&#10;    · exact h&#10;    · exact trans _ _ _ h (rel_of_pairwise_cons h₂ m)&#10;  · exact ih₁ _ h₁.tail h₂">
                                                        <OtherNode start="(221, 7)" end="(221, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(221, 7)" end="(221, 8)" kind="patternIgnore">
                                                            <OtherNode start="(221, 7)" end="(221, 8)" kind="token.«· »">
                                                            <AtomNode start="(221, 7)" end="(221, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(221, 9)" end="(228, 33)">
                                                          <TacticTacticseq1IndentedNode start="(221, 9)" end="(228, 33)">
                                                            <NullNode start="(221, 9)" end="(228, 33)">
                                                            <OtherNode start="(221, 9)" end="(221, 28)" kind="Lean.Parser.Tactic.apply" state_before="case cons.cons.isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁.merge (y :: l₂) le)" state_after="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ ∀ (a' : α), a' ∈ l₁.merge (y :: l₂) le → le x a' = true&#10;&#10;case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge (y :: l₂) le)" tactic="apply Pairwise.cons">
                                                            <AtomNode start="(221, 9)" end="(221, 14)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(221, 15)" end="(221, 28)" leading="" trailing="&#10;        " raw_val="Pairwise.cons" val="Pairwise.cons" full_name="List.Pairwise.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(222, 9)" end="(227, 60)" kind="Lean.cdot" state_before="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ ∀ (a' : α), a' ∈ l₁.merge (y :: l₂) le → le x a' = true&#10;&#10;case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge (y :: l₂) le)" state_after="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge (y :: l₂) le)" tactic="· intro z m&#10;  rw [mem_merge, mem_cons] at m&#10;  rcases m with (m|rfl|m)&#10;  · exact rel_of_pairwise_cons h₁ m&#10;  · exact h&#10;  · exact trans _ _ _ h (rel_of_pairwise_cons h₂ m)">
                                                            <OtherNode start="(222, 9)" end="(222, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(222, 9)" end="(222, 10)" kind="patternIgnore">
                                                            <OtherNode start="(222, 9)" end="(222, 10)" kind="token.«· »">
                                                            <AtomNode start="(222, 9)" end="(222, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(222, 11)" end="(227, 60)">
                                                            <TacticTacticseq1IndentedNode start="(222, 11)" end="(227, 60)">
                                                            <NullNode start="(222, 11)" end="(227, 60)">
                                                            <OtherNode start="(222, 11)" end="(222, 20)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ ∀ (a' : α), a' ∈ l₁.merge (y :: l₂) le → le x a' = true" state_after="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁.merge (y :: l₂) le&#10;⊢ le x z = true" tactic="intro z m">
                                                            <AtomNode start="(222, 11)" end="(222, 16)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(222, 17)" end="(222, 20)">
                                                            <IdentNode start="(222, 17)" end="(222, 18)" leading="" trailing=" " raw_val="z" val="z"/>
                                                            <IdentNode start="(222, 19)" end="(222, 20)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(223, 11)" end="(223, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁.merge (y :: l₂) le&#10;⊢ le x z = true" state_after="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁ ∨ z = y ∨ z ∈ l₂&#10;⊢ le x z = true" tactic="rw [mem_merge, mem_cons] at m">
                                                            <AtomNode start="(223, 11)" end="(223, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(223, 14)" end="(223, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(223, 14)" end="(223, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(223, 15)" end="(223, 34)">
                                                            <OtherNode start="(223, 15)" end="(223, 24)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(223, 15)" end="(223, 24)" leading="" trailing="" raw_val="mem_merge" val="mem_merge" full_name="List.mem_merge" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(167, 9)" def_end="(167, 18)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(223, 24)" end="(223, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(223, 26)" end="(223, 34)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(223, 26)" end="(223, 34)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(223, 34)" end="(223, 35)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(223, 36)" end="(223, 40)">
                                                            <OtherNode start="(223, 36)" end="(223, 40)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(223, 36)" end="(223, 38)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(223, 39)" end="(223, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(223, 39)" end="(223, 40)">
                                                            <IdentNode start="(223, 39)" end="(223, 40)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(224, 11)" end="(224, 34)" kind="Lean.Parser.Tactic.rcases" state_before="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁ ∨ z = y ∨ z ∈ l₂&#10;⊢ le x z = true" state_after="case cons.cons.isTrue.a.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁&#10;⊢ le x z = true&#10;&#10;case cons.cons.isTrue.a.inr.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;z : α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₂)&#10;h : le x z = true&#10;⊢ le x z = true&#10;&#10;case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" tactic="rcases m with (m|rfl|m)">
                                                            <AtomNode start="(224, 11)" end="(224, 17)" leading="" trailing=" " val="rcases"/>
                                                            <NullNode start="(224, 18)" end="(224, 19)">
                                                            <OtherNode start="(224, 18)" end="(224, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(224, 18)" end="(224, 19)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(224, 20)" end="(224, 34)">
                                                            <AtomNode start="(224, 20)" end="(224, 24)" leading="" trailing=" " val="with"/>
                                                            <OtherNode start="(224, 25)" end="(224, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(224, 25)" end="(224, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(224, 25)" end="(224, 34)">
                                                            <OtherNode start="(224, 25)" end="(224, 34)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(224, 25)" end="(224, 26)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(224, 26)" end="(224, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(224, 26)" end="(224, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(224, 26)" end="(224, 33)">
                                                            <OtherNode start="(224, 26)" end="(224, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(224, 26)" end="(224, 27)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            <AtomNode start="(224, 27)" end="(224, 28)" leading="" trailing="" val="|"/>
                                                            <OtherNode start="(224, 28)" end="(224, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(224, 28)" end="(224, 31)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            <AtomNode start="(224, 31)" end="(224, 32)" leading="" trailing="" val="|"/>
                                                            <OtherNode start="(224, 32)" end="(224, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(224, 32)" end="(224, 33)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(224, 33)" end="(224, 34)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(225, 11)" end="(225, 44)" kind="Lean.cdot" state_before="case cons.cons.isTrue.a.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁&#10;⊢ le x z = true&#10;&#10;case cons.cons.isTrue.a.inr.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;z : α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₂)&#10;h : le x z = true&#10;⊢ le x z = true&#10;&#10;case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" state_after="case cons.cons.isTrue.a.inr.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;z : α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₂)&#10;h : le x z = true&#10;⊢ le x z = true&#10;&#10;case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" tactic="· exact rel_of_pairwise_cons h₁ m">
                                                            <OtherNode start="(225, 11)" end="(225, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(225, 11)" end="(225, 12)" kind="patternIgnore">
                                                            <OtherNode start="(225, 11)" end="(225, 12)" kind="token.«· »">
                                                            <AtomNode start="(225, 11)" end="(225, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(225, 13)" end="(225, 44)">
                                                            <TacticTacticseq1IndentedNode start="(225, 13)" end="(225, 44)">
                                                            <NullNode start="(225, 13)" end="(225, 44)">
                                                            <OtherNode start="(225, 13)" end="(225, 44)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isTrue.a.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₁&#10;⊢ le x z = true" state_after="no goals" tactic="exact rel_of_pairwise_cons h₁ m">
                                                            <AtomNode start="(225, 13)" end="(225, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(225, 19)" end="(225, 44)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(225, 19)" end="(225, 39)" leading="" trailing=" " raw_val="rel_of_pairwise_cons" val="rel_of_pairwise_cons" full_name="List.rel_of_pairwise_cons" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
                                                            <NullNode start="(225, 40)" end="(225, 44)">
                                                            <IdentNode start="(225, 40)" end="(225, 42)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                            <IdentNode start="(225, 43)" end="(225, 44)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(226, 11)" end="(226, 20)" kind="Lean.cdot" state_before="case cons.cons.isTrue.a.inr.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;z : α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₂)&#10;h : le x z = true&#10;⊢ le x z = true&#10;&#10;case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" state_after="case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" tactic="· exact h">
                                                            <OtherNode start="(226, 11)" end="(226, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(226, 11)" end="(226, 12)" kind="patternIgnore">
                                                            <OtherNode start="(226, 11)" end="(226, 12)" kind="token.«· »">
                                                            <AtomNode start="(226, 11)" end="(226, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(226, 13)" end="(226, 20)">
                                                            <TacticTacticseq1IndentedNode start="(226, 13)" end="(226, 20)">
                                                            <NullNode start="(226, 13)" end="(226, 20)">
                                                            <OtherNode start="(226, 13)" end="(226, 20)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isTrue.a.inr.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;z : α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₂)&#10;h : le x z = true&#10;⊢ le x z = true" state_after="no goals" tactic="exact h">
                                                            <AtomNode start="(226, 13)" end="(226, 18)" leading="" trailing=" " val="exact"/>
                                                            <IdentNode start="(226, 19)" end="(226, 20)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(227, 11)" end="(227, 60)" kind="Lean.cdot" state_before="case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" state_after="no goals" tactic="· exact trans _ _ _ h (rel_of_pairwise_cons h₂ m)">
                                                            <OtherNode start="(227, 11)" end="(227, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(227, 11)" end="(227, 12)" kind="patternIgnore">
                                                            <OtherNode start="(227, 11)" end="(227, 12)" kind="token.«· »">
                                                            <AtomNode start="(227, 11)" end="(227, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(227, 13)" end="(227, 60)">
                                                            <TacticTacticseq1IndentedNode start="(227, 13)" end="(227, 60)">
                                                            <NullNode start="(227, 13)" end="(227, 60)">
                                                            <OtherNode start="(227, 13)" end="(227, 60)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isTrue.a.inr.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;z : α&#10;m : z ∈ l₂&#10;⊢ le x z = true" state_after="no goals" tactic="exact trans _ _ _ h (rel_of_pairwise_cons h₂ m)">
                                                            <AtomNode start="(227, 13)" end="(227, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(227, 19)" end="(227, 60)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(227, 19)" end="(227, 24)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                                            <NullNode start="(227, 25)" end="(227, 60)">
                                                            <TermHoleNode start="(227, 25)" end="(227, 26)">
                                                            <AtomNode start="(227, 25)" end="(227, 26)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(227, 27)" end="(227, 28)">
                                                            <AtomNode start="(227, 27)" end="(227, 28)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(227, 29)" end="(227, 30)">
                                                            <AtomNode start="(227, 29)" end="(227, 30)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(227, 31)" end="(227, 32)" leading="" trailing=" " raw_val="h" val="h"/>
                                                            <OtherNode start="(227, 33)" end="(227, 60)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(227, 33)" end="(227, 34)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(227, 34)" end="(227, 59)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(227, 34)" end="(227, 54)" leading="" trailing=" " raw_val="rel_of_pairwise_cons" val="rel_of_pairwise_cons" full_name="List.rel_of_pairwise_cons" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
                                                            <NullNode start="(227, 55)" end="(227, 59)">
                                                            <IdentNode start="(227, 55)" end="(227, 57)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            <IdentNode start="(227, 58)" end="(227, 59)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(227, 59)" end="(227, 60)" leading="" trailing="&#10;        " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(228, 9)" end="(228, 33)" kind="Lean.cdot" state_before="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge (y :: l₂) le)" state_after="no goals" tactic="· exact ih₁ _ h₁.tail h₂">
                                                            <OtherNode start="(228, 9)" end="(228, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(228, 9)" end="(228, 10)" kind="patternIgnore">
                                                            <OtherNode start="(228, 9)" end="(228, 10)" kind="token.«· »">
                                                            <AtomNode start="(228, 9)" end="(228, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(228, 11)" end="(228, 33)">
                                                            <TacticTacticseq1IndentedNode start="(228, 11)" end="(228, 33)">
                                                            <NullNode start="(228, 11)" end="(228, 33)">
                                                            <OtherNode start="(228, 11)" end="(228, 33)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isTrue.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge (y :: l₂) le)" state_after="no goals" tactic="exact ih₁ _ h₁.tail h₂">
                                                            <AtomNode start="(228, 11)" end="(228, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(228, 17)" end="(228, 33)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(228, 17)" end="(228, 20)" leading="" trailing=" " raw_val="ih₁" val="ih₁"/>
                                                            <NullNode start="(228, 21)" end="(228, 33)">
                                                            <TermHoleNode start="(228, 21)" end="(228, 22)">
                                                            <AtomNode start="(228, 21)" end="(228, 22)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(228, 23)" end="(228, 30)" leading="" trailing=" " raw_val="h₁.tail" val="h₁.tail"/>
                                                            <IdentNode start="(228, 31)" end="(228, 33)" leading="" trailing="&#10;      " raw_val="h₂" val="h₂"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(229, 7)" end="(237, 28)" kind="Lean.cdot" state_before="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (y :: (x :: l₁).merge l₂ le)" state_after="no goals" tactic="· apply Pairwise.cons&#10;  · intro z m&#10;    rw [mem_merge, mem_cons] at m&#10;    simp only [Bool.not_eq_true] at h&#10;    rcases m with (⟨rfl|m⟩|m)&#10;    · simpa [h] using total y z&#10;    · exact trans _ _ _ (by simpa [h] using total x y) (rel_of_pairwise_cons h₁ m)&#10;    · exact rel_of_pairwise_cons h₂ m&#10;  · exact ih₂ h₂.tail">
                                                        <OtherNode start="(229, 7)" end="(229, 8)" kind="Lean.cdotTk">
                                                          <OtherNode start="(229, 7)" end="(229, 8)" kind="patternIgnore">
                                                            <OtherNode start="(229, 7)" end="(229, 8)" kind="token.«· »">
                                                            <AtomNode start="(229, 7)" end="(229, 8)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <TacticTacticseqNode start="(229, 9)" end="(237, 28)">
                                                          <TacticTacticseq1IndentedNode start="(229, 9)" end="(237, 28)">
                                                            <NullNode start="(229, 9)" end="(237, 28)">
                                                            <OtherNode start="(229, 9)" end="(229, 28)" kind="Lean.Parser.Tactic.apply" state_before="case cons.cons.isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) (y :: (x :: l₁).merge l₂ le)" state_after="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ ∀ (a' : α), a' ∈ (x :: l₁).merge l₂ le → le y a' = true&#10;&#10;case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)" tactic="apply Pairwise.cons">
                                                            <AtomNode start="(229, 9)" end="(229, 14)" leading="" trailing=" " val="apply"/>
                                                            <IdentNode start="(229, 15)" end="(229, 28)" leading="" trailing="&#10;        " raw_val="Pairwise.cons" val="Pairwise.cons" full_name="List.Pairwise.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(230, 9)" end="(236, 44)" kind="Lean.cdot" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ ∀ (a' : α), a' ∈ (x :: l₁).merge l₂ le → le y a' = true&#10;&#10;case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)" state_after="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)" tactic="· intro z m&#10;  rw [mem_merge, mem_cons] at m&#10;  simp only [Bool.not_eq_true] at h&#10;  rcases m with (⟨rfl|m⟩|m)&#10;  · simpa [h] using total y z&#10;  · exact trans _ _ _ (by simpa [h] using total x y) (rel_of_pairwise_cons h₁ m)&#10;  · exact rel_of_pairwise_cons h₂ m">
                                                            <OtherNode start="(230, 9)" end="(230, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(230, 9)" end="(230, 10)" kind="patternIgnore">
                                                            <OtherNode start="(230, 9)" end="(230, 10)" kind="token.«· »">
                                                            <AtomNode start="(230, 9)" end="(230, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(230, 11)" end="(236, 44)">
                                                            <TacticTacticseq1IndentedNode start="(230, 11)" end="(236, 44)">
                                                            <NullNode start="(230, 11)" end="(236, 44)">
                                                            <OtherNode start="(230, 11)" end="(230, 20)" kind="Lean.Parser.Tactic.intro" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ ∀ (a' : α), a' ∈ (x :: l₁).merge l₂ le → le y a' = true" state_after="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;z : α&#10;m : z ∈ (x :: l₁).merge l₂ le&#10;⊢ le y z = true" tactic="intro z m">
                                                            <AtomNode start="(230, 11)" end="(230, 16)" leading="" trailing=" " val="intro"/>
                                                            <NullNode start="(230, 17)" end="(230, 20)">
                                                            <IdentNode start="(230, 17)" end="(230, 18)" leading="" trailing=" " raw_val="z" val="z"/>
                                                            <IdentNode start="(230, 19)" end="(230, 20)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(231, 11)" end="(231, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;z : α&#10;m : z ∈ (x :: l₁).merge l₂ le&#10;⊢ le y z = true" state_after="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;z : α&#10;m : (z = x ∨ z ∈ l₁) ∨ z ∈ l₂&#10;⊢ le y z = true" tactic="rw [mem_merge, mem_cons] at m">
                                                            <AtomNode start="(231, 11)" end="(231, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(231, 14)" end="(231, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(231, 14)" end="(231, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(231, 15)" end="(231, 34)">
                                                            <OtherNode start="(231, 15)" end="(231, 24)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(231, 15)" end="(231, 24)" leading="" trailing="" raw_val="mem_merge" val="mem_merge" full_name="List.mem_merge" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(167, 9)" def_end="(167, 18)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(231, 24)" end="(231, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(231, 26)" end="(231, 34)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(231, 26)" end="(231, 34)" leading="" trailing="" raw_val="mem_cons" val="mem_cons" full_name="List.mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(231, 34)" end="(231, 35)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            <NullNode start="(231, 36)" end="(231, 40)">
                                                            <OtherNode start="(231, 36)" end="(231, 40)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(231, 36)" end="(231, 38)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(231, 39)" end="(231, 40)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(231, 39)" end="(231, 40)">
                                                            <IdentNode start="(231, 39)" end="(231, 40)" leading="" trailing="&#10;          " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(232, 11)" end="(232, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;z : α&#10;m : (z = x ∨ z ∈ l₁) ∨ z ∈ l₂&#10;⊢ le y z = true" state_after="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;m : (z = x ∨ z ∈ l₁) ∨ z ∈ l₂&#10;h : le x y = false&#10;⊢ le y z = true" tactic="simp only [Bool.not_eq_true] at h">
                                                            <AtomNode start="(232, 11)" end="(232, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(232, 16)" end="(232, 20)">
                                                            <AtomNode start="(232, 16)" end="(232, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(232, 21)" end="(232, 39)">
                                                            <AtomNode start="(232, 21)" end="(232, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(232, 22)" end="(232, 38)">
                                                            <OtherNode start="(232, 22)" end="(232, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(232, 22)" end="(232, 38)" leading="" trailing="" raw_val="Bool.not_eq_true" val="Bool.not_eq_true" full_name="Bool.not_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(232, 38)" end="(232, 39)" leading="" trailing=" " val="]"/>
                                                            </NullNode>
                                                            <NullNode start="(232, 40)" end="(232, 44)">
                                                            <OtherNode start="(232, 40)" end="(232, 44)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(232, 40)" end="(232, 42)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(232, 43)" end="(232, 44)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(232, 43)" end="(232, 44)">
                                                            <IdentNode start="(232, 43)" end="(232, 44)" leading="" trailing="&#10;          " raw_val="h" val="h"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(233, 11)" end="(233, 36)" kind="Lean.Parser.Tactic.rcases" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;m : (z = x ∨ z ∈ l₁) ∨ z ∈ l₂&#10;h : le x y = false&#10;⊢ le y z = true" state_after="case cons.cons.isFalse.a.inl.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;y : α&#10;l₂ : List α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₁)&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((z :: l₁).merge l₂ le)&#10;h : le z y = false&#10;⊢ le y z = true&#10;&#10;case cons.cons.isFalse.a.inl.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₁&#10;⊢ le y z = true&#10;&#10;case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" tactic="rcases m with (⟨rfl|m⟩|m)">
                                                            <AtomNode start="(233, 11)" end="(233, 17)" leading="" trailing=" " val="rcases"/>
                                                            <NullNode start="(233, 18)" end="(233, 19)">
                                                            <OtherNode start="(233, 18)" end="(233, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                                            <NullNode/>
                                                            <IdentNode start="(233, 18)" end="(233, 19)" leading="" trailing=" " raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(233, 20)" end="(233, 36)">
                                                            <AtomNode start="(233, 20)" end="(233, 24)" leading="" trailing=" " val="with"/>
                                                            <OtherNode start="(233, 25)" end="(233, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 25)" end="(233, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 25)" end="(233, 36)">
                                                            <OtherNode start="(233, 25)" end="(233, 36)" kind="Lean.Parser.Tactic.rcasesPat.paren">
                                                            <AtomNode start="(233, 25)" end="(233, 26)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(233, 26)" end="(233, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 26)" end="(233, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 26)" end="(233, 35)">
                                                            <OtherNode start="(233, 26)" end="(233, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                                            <AtomNode start="(233, 26)" end="(233, 27)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(233, 27)" end="(233, 32)">
                                                            <OtherNode start="(233, 27)" end="(233, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                            <OtherNode start="(233, 27)" end="(233, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                            <NullNode start="(233, 27)" end="(233, 32)">
                                                            <OtherNode start="(233, 27)" end="(233, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 27)" end="(233, 30)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 30)" end="(233, 31)" leading="" trailing="" val="|"/>
                                                            <OtherNode start="(233, 31)" end="(233, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 31)" end="(233, 32)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(233, 32)" end="(233, 33)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 33)" end="(233, 34)" leading="" trailing="" val="|"/>
                                                            <OtherNode start="(233, 34)" end="(233, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                            <IdentNode start="(233, 34)" end="(233, 35)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <AtomNode start="(233, 35)" end="(233, 36)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(234, 11)" end="(234, 38)" kind="Lean.cdot" state_before="case cons.cons.isFalse.a.inl.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;y : α&#10;l₂ : List α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₁)&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((z :: l₁).merge l₂ le)&#10;h : le z y = false&#10;⊢ le y z = true&#10;&#10;case cons.cons.isFalse.a.inl.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₁&#10;⊢ le y z = true&#10;&#10;case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" state_after="case cons.cons.isFalse.a.inl.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₁&#10;⊢ le y z = true&#10;&#10;case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" tactic="· simpa [h] using total y z">
                                                            <OtherNode start="(234, 11)" end="(234, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(234, 11)" end="(234, 12)" kind="patternIgnore">
                                                            <OtherNode start="(234, 11)" end="(234, 12)" kind="token.«· »">
                                                            <AtomNode start="(234, 11)" end="(234, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(234, 13)" end="(234, 38)">
                                                            <TacticTacticseq1IndentedNode start="(234, 13)" end="(234, 38)">
                                                            <NullNode start="(234, 13)" end="(234, 38)">
                                                            <OtherNode start="(234, 13)" end="(234, 38)" kind="Lean.Parser.Tactic.simpa" state_before="case cons.cons.isFalse.a.inl.inl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;y : α&#10;l₂ : List α&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (z :: l₁)&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((z :: l₁).merge l₂ le)&#10;h : le z y = false&#10;⊢ le y z = true" state_after="no goals" tactic="simpa [h] using total y z">
                                                            <AtomNode start="(234, 13)" end="(234, 18)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(234, 19)" end="(234, 38)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(234, 19)" end="(234, 22)">
                                                            <OtherNode start="(234, 19)" end="(234, 22)" kind="Lean.Parser.Tactic.simpArgs">
                                                            <AtomNode start="(234, 19)" end="(234, 20)" leading="" trailing="" val="["/>
                                                            <NullNode start="(234, 20)" end="(234, 21)">
                                                            <OtherNode start="(234, 20)" end="(234, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(234, 20)" end="(234, 21)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(234, 21)" end="(234, 22)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(234, 23)" end="(234, 38)">
                                                            <AtomNode start="(234, 23)" end="(234, 28)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(234, 29)" end="(234, 38)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(234, 29)" end="(234, 34)" leading="" trailing=" " raw_val="total" val="total"/>
                                                            <NullNode start="(234, 35)" end="(234, 38)">
                                                            <IdentNode start="(234, 35)" end="(234, 36)" leading="" trailing=" " raw_val="y" val="y"/>
                                                            <IdentNode start="(234, 37)" end="(234, 38)" leading="" trailing="&#10;          " raw_val="z" val="z"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(235, 11)" end="(235, 89)" kind="Lean.cdot" state_before="case cons.cons.isFalse.a.inl.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₁&#10;⊢ le y z = true&#10;&#10;case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" state_after="case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" tactic="· exact trans _ _ _ (by simpa [h] using total x y) (rel_of_pairwise_cons h₁ m)">
                                                            <OtherNode start="(235, 11)" end="(235, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(235, 11)" end="(235, 12)" kind="patternIgnore">
                                                            <OtherNode start="(235, 11)" end="(235, 12)" kind="token.«· »">
                                                            <AtomNode start="(235, 11)" end="(235, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(235, 13)" end="(235, 89)">
                                                            <TacticTacticseq1IndentedNode start="(235, 13)" end="(235, 89)">
                                                            <NullNode start="(235, 13)" end="(235, 89)">
                                                            <OtherNode start="(235, 13)" end="(235, 89)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isFalse.a.inl.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₁&#10;⊢ le y z = true" state_after="no goals" tactic="exact trans _ _ _ (by simpa [h] using total x y) (rel_of_pairwise_cons h₁ m)">
                                                            <AtomNode start="(235, 13)" end="(235, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(235, 19)" end="(235, 89)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(235, 19)" end="(235, 24)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                                            <NullNode start="(235, 25)" end="(235, 89)">
                                                            <TermHoleNode start="(235, 25)" end="(235, 26)">
                                                            <AtomNode start="(235, 25)" end="(235, 26)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(235, 27)" end="(235, 28)">
                                                            <AtomNode start="(235, 27)" end="(235, 28)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <TermHoleNode start="(235, 29)" end="(235, 30)">
                                                            <AtomNode start="(235, 29)" end="(235, 30)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <OtherNode start="(235, 31)" end="(235, 61)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(235, 31)" end="(235, 32)" leading="" trailing="" val="("/>
                                                            <TermBytacticNode start="(235, 32)" end="(235, 60)">
                                                            <AtomNode start="(235, 32)" end="(235, 34)" leading="" trailing=" " val="by"/>
                                                            <TacticTacticseqNode start="(235, 35)" end="(235, 60)">
                                                            <TacticTacticseq1IndentedNode start="(235, 35)" end="(235, 60)">
                                                            <NullNode start="(235, 35)" end="(235, 60)">
                                                            <OtherNode start="(235, 35)" end="(235, 60)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₁&#10;⊢ le y x = true" state_after="no goals" tactic="simpa [h] using total x y">
                                                            <AtomNode start="(235, 35)" end="(235, 40)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(235, 41)" end="(235, 60)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(235, 41)" end="(235, 44)">
                                                            <OtherNode start="(235, 41)" end="(235, 44)" kind="Lean.Parser.Tactic.simpArgs">
                                                            <AtomNode start="(235, 41)" end="(235, 42)" leading="" trailing="" val="["/>
                                                            <NullNode start="(235, 42)" end="(235, 43)">
                                                            <OtherNode start="(235, 42)" end="(235, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(235, 42)" end="(235, 43)" leading="" trailing="" raw_val="h" val="h"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(235, 43)" end="(235, 44)" leading="" trailing=" " val="]"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(235, 45)" end="(235, 60)">
                                                            <AtomNode start="(235, 45)" end="(235, 50)" leading="" trailing=" " val="using"/>
                                                            <OtherNode start="(235, 51)" end="(235, 60)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(235, 51)" end="(235, 56)" leading="" trailing=" " raw_val="total" val="total"/>
                                                            <NullNode start="(235, 57)" end="(235, 60)">
                                                            <IdentNode start="(235, 57)" end="(235, 58)" leading="" trailing=" " raw_val="x" val="x"/>
                                                            <IdentNode start="(235, 59)" end="(235, 60)" leading="" trailing="" raw_val="y" val="y"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </TermBytacticNode>
                                                            <AtomNode start="(235, 60)" end="(235, 61)" leading="" trailing=" " val=")"/>
                                                            </OtherNode>
                                                            <OtherNode start="(235, 62)" end="(235, 89)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(235, 62)" end="(235, 63)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(235, 63)" end="(235, 88)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(235, 63)" end="(235, 83)" leading="" trailing=" " raw_val="rel_of_pairwise_cons" val="rel_of_pairwise_cons" full_name="List.rel_of_pairwise_cons" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
                                                            <NullNode start="(235, 84)" end="(235, 88)">
                                                            <IdentNode start="(235, 84)" end="(235, 86)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                                            <IdentNode start="(235, 87)" end="(235, 88)" leading="" trailing="" raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(235, 88)" end="(235, 89)" leading="" trailing="&#10;          " val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(236, 11)" end="(236, 44)" kind="Lean.cdot" state_before="case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" state_after="no goals" tactic="· exact rel_of_pairwise_cons h₂ m">
                                                            <OtherNode start="(236, 11)" end="(236, 12)" kind="Lean.cdotTk">
                                                            <OtherNode start="(236, 11)" end="(236, 12)" kind="patternIgnore">
                                                            <OtherNode start="(236, 11)" end="(236, 12)" kind="token.«· »">
                                                            <AtomNode start="(236, 11)" end="(236, 12)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(236, 13)" end="(236, 44)">
                                                            <TacticTacticseq1IndentedNode start="(236, 13)" end="(236, 44)">
                                                            <NullNode start="(236, 13)" end="(236, 44)">
                                                            <OtherNode start="(236, 13)" end="(236, 44)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isFalse.a.inr&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;z : α&#10;h : le x y = false&#10;m : z ∈ l₂&#10;⊢ le y z = true" state_after="no goals" tactic="exact rel_of_pairwise_cons h₂ m">
                                                            <AtomNode start="(236, 13)" end="(236, 18)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(236, 19)" end="(236, 44)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(236, 19)" end="(236, 39)" leading="" trailing=" " raw_val="rel_of_pairwise_cons" val="rel_of_pairwise_cons" full_name="List.rel_of_pairwise_cons" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
                                                            <NullNode start="(236, 40)" end="(236, 44)">
                                                            <IdentNode start="(236, 40)" end="(236, 42)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                            <IdentNode start="(236, 43)" end="(236, 44)" leading="" trailing="&#10;        " raw_val="m" val="m"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(237, 9)" end="(237, 28)" kind="Lean.cdot" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)" state_after="no goals" tactic="· exact ih₂ h₂.tail">
                                                            <OtherNode start="(237, 9)" end="(237, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(237, 9)" end="(237, 10)" kind="patternIgnore">
                                                            <OtherNode start="(237, 9)" end="(237, 10)" kind="token.«· »">
                                                            <AtomNode start="(237, 9)" end="(237, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(237, 11)" end="(237, 28)">
                                                            <TacticTacticseq1IndentedNode start="(237, 11)" end="(237, 28)">
                                                            <NullNode start="(237, 11)" end="(237, 28)">
                                                            <OtherNode start="(237, 11)" end="(237, 28)" kind="Lean.Parser.Tactic.exact" state_before="case cons.cons.isFalse.a&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;x : α&#10;l₁ : List α&#10;ih₁ :&#10;  ∀ (l₂ : List α),&#10;    Pairwise (fun a b =&amp;gt; le a b = true) l₁ →&#10;      Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) (l₁.merge l₂ le)&#10;h₁ : Pairwise (fun a b =&amp;gt; le a b = true) (x :: l₁)&#10;y : α&#10;l₂ : List α&#10;ih₂ : Pairwise (fun a b =&amp;gt; le a b = true) l₂ → Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)&#10;h₂ : Pairwise (fun a b =&amp;gt; le a b = true) (y :: l₂)&#10;h : ¬le x y = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((x :: l₁).merge l₂ le)" state_after="no goals" tactic="exact ih₂ h₂.tail">
                                                            <AtomNode start="(237, 11)" end="(237, 16)" leading="" trailing=" " val="exact"/>
                                                            <OtherNode start="(237, 17)" end="(237, 28)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(237, 17)" end="(237, 20)" leading="" trailing=" " raw_val="ih₂" val="ih₂"/>
                                                            <NullNode start="(237, 21)" end="(237, 28)">
                                                            <IdentNode start="(237, 21)" end="(237, 28)" leading="" trailing="&#10;&#10;" raw_val="h₂.tail" val="h₂.tail"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(239, 1)" end="(248, 46)" name="merge_of_le" full_name="List.merge_of_le">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(239, 1)" end="(248, 46)" name="merge_of_le" full_name="List.merge_of_le" _is_private_decl="False">
        <AtomNode start="(239, 1)" end="(239, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(239, 9)" end="(239, 20)">
          <IdentNode start="(239, 9)" end="(239, 20)" leading="" trailing=" " raw_val="merge_of_le" val="merge_of_le"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(239, 21)" end="(240, 30)">
          <NullNode/>
          <TermTypespecNode start="(239, 21)" end="(240, 30)">
            <AtomNode start="(239, 21)" end="(239, 22)" leading="" trailing=" " val=":"/>
            <OtherNode start="(239, 23)" end="(240, 30)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(239, 23)" end="(239, 24)" leading="" trailing=" " val="∀"/>
              <NullNode start="(239, 25)" end="(239, 79)">
                <OtherNode start="(239, 25)" end="(239, 41)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(239, 25)" end="(239, 26)" leading="" trailing="" val="{"/>
                  <NullNode start="(239, 26)" end="(239, 31)">
                    <IdentNode start="(239, 26)" end="(239, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(239, 29)" end="(239, 31)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  </NullNode>
                  <NullNode start="(239, 32)" end="(239, 40)">
                    <AtomNode start="(239, 32)" end="(239, 33)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(239, 34)" end="(239, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(239, 34)" end="(239, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(239, 39)" end="(239, 40)">
                        <IdentNode start="(239, 39)" end="(239, 40)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(239, 40)" end="(239, 41)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <TermExplicitbinderNode start="(239, 42)" end="(239, 79)">
                  <AtomNode start="(239, 42)" end="(239, 43)" leading="" trailing="" val="("/>
                  <NullNode start="(239, 43)" end="(239, 44)">
                    <TermHoleNode start="(239, 43)" end="(239, 44)">
                      <AtomNode start="(239, 43)" end="(239, 44)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(239, 45)" end="(239, 78)">
                    <AtomNode start="(239, 45)" end="(239, 46)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(239, 47)" end="(239, 78)" kind="Lean.Parser.Term.forall">
                      <AtomNode start="(239, 47)" end="(239, 48)" leading="" trailing=" " val="∀"/>
                      <NullNode start="(239, 49)" end="(239, 52)">
                        <IdentNode start="(239, 49)" end="(239, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(239, 51)" end="(239, 52)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(239, 52)" end="(239, 53)" leading="" trailing=" " val=","/>
                      <OtherNode start="(239, 54)" end="(239, 78)" kind="Lean.Parser.Term.arrow">
                        <OtherNode start="(239, 54)" end="(239, 60)" kind="«term_∈_»">
                          <IdentNode start="(239, 54)" end="(239, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                          <AtomNode start="(239, 56)" end="(239, 57)" leading="" trailing=" " val="∈"/>
                          <IdentNode start="(239, 58)" end="(239, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </OtherNode>
                        <AtomNode start="(239, 61)" end="(239, 62)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(239, 63)" end="(239, 78)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(239, 63)" end="(239, 69)" kind="«term_∈_»">
                            <IdentNode start="(239, 63)" end="(239, 64)" leading="" trailing=" " raw_val="b" val="b"/>
                            <AtomNode start="(239, 65)" end="(239, 66)" leading="" trailing=" " val="∈"/>
                            <IdentNode start="(239, 67)" end="(239, 69)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          </OtherNode>
                          <AtomNode start="(239, 70)" end="(239, 71)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(239, 72)" end="(239, 78)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(239, 72)" end="(239, 74)" leading="" trailing=" " raw_val="le" val="le"/>
                            <NullNode start="(239, 75)" end="(239, 78)">
                              <IdentNode start="(239, 75)" end="(239, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                              <IdentNode start="(239, 77)" end="(239, 78)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(239, 78)" end="(239, 79)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(239, 79)" end="(239, 80)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(240, 5)" end="(240, 30)" kind="«term_=_»">
                <OtherNode start="(240, 5)" end="(240, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(240, 5)" end="(240, 10)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(240, 11)" end="(240, 19)">
                    <IdentNode start="(240, 11)" end="(240, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(240, 14)" end="(240, 16)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    <IdentNode start="(240, 17)" end="(240, 19)" leading="" trailing=" " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(240, 20)" end="(240, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(240, 22)" end="(240, 30)" kind="«term_++_»">
                  <IdentNode start="(240, 22)" end="(240, 24)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(240, 25)" end="(240, 27)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(240, 28)" end="(240, 30)" leading="" trailing="&#10;  " raw_val="ys" val="ys"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(241, 3)" end="(248, 46)">
          <OtherNode start="(241, 3)" end="(248, 46)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(241, 3)" end="(248, 46)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(241, 3)" end="(248, 46)">
                <OtherNode start="(241, 3)" end="(242, 33)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(241, 3)" end="(241, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(241, 5)" end="(242, 14)">
                    <NullNode start="(241, 5)" end="(241, 14)">
                      <OtherNode start="(241, 5)" end="(241, 7)" kind="«term[_]»">
                        <AtomNode start="(241, 5)" end="(241, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(241, 6)" end="(241, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(241, 7)" end="(241, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(241, 9)" end="(241, 11)" leading="" trailing="" raw_val="ys" val="ys"/>
                      <AtomNode start="(241, 11)" end="(241, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(241, 13)" end="(241, 14)">
                        <AtomNode start="(241, 13)" end="(241, 14)" leading="" trailing="&#10;  " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                    <AtomNode start="(242, 3)" end="(242, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(242, 5)" end="(242, 14)">
                      <IdentNode start="(242, 5)" end="(242, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                      <AtomNode start="(242, 7)" end="(242, 8)" leading="" trailing=" " val=","/>
                      <OtherNode start="(242, 9)" end="(242, 11)" kind="«term[_]»">
                        <AtomNode start="(242, 9)" end="(242, 10)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(242, 10)" end="(242, 11)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(242, 11)" end="(242, 12)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(242, 13)" end="(242, 14)">
                        <AtomNode start="(242, 13)" end="(242, 14)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(242, 15)" end="(242, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(242, 18)" end="(242, 33)">
                    <AtomNode start="(242, 18)" end="(242, 20)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(242, 21)" end="(242, 33)">
                      <TacticTacticseq1IndentedNode start="(242, 21)" end="(242, 33)">
                        <NullNode start="(242, 21)" end="(242, 33)">
                          <OtherNode start="(242, 21)" end="(242, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;x✝ : ∀ (a b : α), a ∈ xs → b ∈ [] → le a b = true&#10;⊢ xs.merge [] le = xs ++ []" state_after="no goals" tactic="simp [merge]">
                            <AtomNode start="(242, 21)" end="(242, 25)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(242, 26)" end="(242, 33)">
                              <AtomNode start="(242, 26)" end="(242, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(242, 27)" end="(242, 32)">
                                <OtherNode start="(242, 27)" end="(242, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(242, 27)" end="(242, 32)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(242, 32)" end="(242, 33)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(243, 3)" end="(248, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(243, 3)" end="(243, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(243, 5)" end="(243, 24)">
                    <NullNode start="(243, 5)" end="(243, 24)">
                      <OtherNode start="(243, 5)" end="(243, 12)" kind="«term_::_»">
                        <IdentNode start="(243, 5)" end="(243, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                        <AtomNode start="(243, 7)" end="(243, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(243, 10)" end="(243, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                      <AtomNode start="(243, 12)" end="(243, 13)" leading="" trailing=" " val=","/>
                      <OtherNode start="(243, 14)" end="(243, 21)" kind="«term_::_»">
                        <IdentNode start="(243, 14)" end="(243, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                        <AtomNode start="(243, 16)" end="(243, 18)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(243, 19)" end="(243, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                      <AtomNode start="(243, 21)" end="(243, 22)" leading="" trailing=" " val=","/>
                      <IdentNode start="(243, 23)" end="(243, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(243, 25)" end="(243, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(243, 28)" end="(248, 46)">
                    <AtomNode start="(243, 28)" end="(243, 30)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(244, 5)" end="(248, 46)">
                      <TacticTacticseq1IndentedNode start="(244, 5)" end="(248, 46)">
                        <NullNode start="(244, 5)" end="(248, 46)">
                          <OtherNode start="(244, 5)" end="(244, 35)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ (x :: xs).merge (y :: ys) le = x :: xs ++ y :: ys" state_after="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ (if le x y = true then x :: xs.merge (y :: ys) le else y :: (x :: xs).merge ys le) = x :: (xs ++ y :: ys)" tactic="simp only [merge, cons_append]">
                            <AtomNode start="(244, 5)" end="(244, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(244, 10)" end="(244, 14)">
                              <AtomNode start="(244, 10)" end="(244, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(244, 15)" end="(244, 35)">
                              <AtomNode start="(244, 15)" end="(244, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(244, 16)" end="(244, 34)">
                                <OtherNode start="(244, 16)" end="(244, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(244, 16)" end="(244, 21)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(244, 21)" end="(244, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(244, 23)" end="(244, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(244, 23)" end="(244, 34)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(244, 34)" end="(244, 35)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(245, 5)" end="(245, 29)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ (if le x y = true then x :: xs.merge (y :: ys) le else y :: (x :: xs).merge ys le) = x :: (xs ++ y :: ys)" state_after="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ ∀ (a b : α), a ∈ xs → b ∈ y :: ys → le a b = true&#10;&#10;case hc&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ le x y = true" tactic="rw [if_pos, merge_of_le]">
                            <AtomNode start="(245, 5)" end="(245, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(245, 8)" end="(245, 29)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(245, 8)" end="(245, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(245, 9)" end="(245, 28)">
                                <OtherNode start="(245, 9)" end="(245, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(245, 9)" end="(245, 15)" leading="" trailing="" raw_val="if_pos" val="if_pos" full_name="if_pos" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                </OtherNode>
                                <AtomNode start="(245, 15)" end="(245, 16)" leading="" trailing=" " val=","/>
                                <OtherNode start="(245, 17)" end="(245, 28)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(245, 17)" end="(245, 28)" leading="" trailing="" raw_val="merge_of_le" val="merge_of_le"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(245, 28)" end="(245, 29)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(246, 5)" end="(247, 44)" kind="Lean.cdot" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ ∀ (a b : α), a ∈ xs → b ∈ y :: ys → le a b = true&#10;&#10;case hc&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ le x y = true" state_after="case hc&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ le x y = true" tactic="· intro a b ma mb&#10;  exact h a b (mem_cons_of_mem _ ma) mb">
                            <OtherNode start="(246, 5)" end="(246, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(246, 5)" end="(246, 6)" kind="patternIgnore">
                                <OtherNode start="(246, 5)" end="(246, 6)" kind="token.«· »">
                                  <AtomNode start="(246, 5)" end="(246, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(246, 7)" end="(247, 44)">
                              <TacticTacticseq1IndentedNode start="(246, 7)" end="(247, 44)">
                                <NullNode start="(246, 7)" end="(247, 44)">
                                  <OtherNode start="(246, 7)" end="(246, 22)" kind="Lean.Parser.Tactic.intro" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ ∀ (a b : α), a ∈ xs → b ∈ y :: ys → le a b = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;a b : α&#10;ma : a ∈ xs&#10;mb : b ∈ y :: ys&#10;⊢ le a b = true" tactic="intro a b ma mb">
                                    <AtomNode start="(246, 7)" end="(246, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(246, 13)" end="(246, 22)">
                                      <IdentNode start="(246, 13)" end="(246, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                                      <IdentNode start="(246, 15)" end="(246, 16)" leading="" trailing=" " raw_val="b" val="b"/>
                                      <IdentNode start="(246, 17)" end="(246, 19)" leading="" trailing=" " raw_val="ma" val="ma"/>
                                      <IdentNode start="(246, 20)" end="(246, 22)" leading="" trailing="&#10;      " raw_val="mb" val="mb"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(247, 7)" end="(247, 44)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;a b : α&#10;ma : a ∈ xs&#10;mb : b ∈ y :: ys&#10;⊢ le a b = true" state_after="no goals" tactic="exact h a b (mem_cons_of_mem _ ma) mb">
                                    <AtomNode start="(247, 7)" end="(247, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(247, 13)" end="(247, 44)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(247, 13)" end="(247, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                      <NullNode start="(247, 15)" end="(247, 44)">
                                        <IdentNode start="(247, 15)" end="(247, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <IdentNode start="(247, 17)" end="(247, 18)" leading="" trailing=" " raw_val="b" val="b"/>
                                        <OtherNode start="(247, 19)" end="(247, 41)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(247, 19)" end="(247, 20)" leading="" trailing="" val="("/>
                                          <OtherNode start="(247, 20)" end="(247, 40)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(247, 20)" end="(247, 35)" leading="" trailing=" " raw_val="mem_cons_of_mem" val="mem_cons_of_mem" full_name="List.mem_cons_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                            <NullNode start="(247, 36)" end="(247, 40)">
                                              <TermHoleNode start="(247, 36)" end="(247, 37)">
                                                <AtomNode start="(247, 36)" end="(247, 37)" leading="" trailing=" " val="_"/>
                                              </TermHoleNode>
                                              <IdentNode start="(247, 38)" end="(247, 40)" leading="" trailing="" raw_val="ma" val="ma"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(247, 40)" end="(247, 41)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <IdentNode start="(247, 42)" end="(247, 44)" leading="" trailing="&#10;    " raw_val="mb" val="mb"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(248, 5)" end="(248, 46)" kind="Lean.cdot" state_before="case hc&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ le x y = true" state_after="no goals" tactic="· exact h x y mem_cons_self mem_cons_self">
                            <OtherNode start="(248, 5)" end="(248, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(248, 5)" end="(248, 6)" kind="patternIgnore">
                                <OtherNode start="(248, 5)" end="(248, 6)" kind="token.«· »">
                                  <AtomNode start="(248, 5)" end="(248, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(248, 7)" end="(248, 46)">
                              <TacticTacticseq1IndentedNode start="(248, 7)" end="(248, 46)">
                                <NullNode start="(248, 7)" end="(248, 46)">
                                  <OtherNode start="(248, 7)" end="(248, 46)" kind="Lean.Parser.Tactic.exact" state_before="case hc&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h : ∀ (a b : α), a ∈ x :: xs → b ∈ y :: ys → le a b = true&#10;⊢ le x y = true" state_after="no goals" tactic="exact h x y mem_cons_self mem_cons_self">
                                    <AtomNode start="(248, 7)" end="(248, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(248, 13)" end="(248, 46)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(248, 13)" end="(248, 14)" leading="" trailing=" " raw_val="h" val="h"/>
                                      <NullNode start="(248, 15)" end="(248, 46)">
                                        <IdentNode start="(248, 15)" end="(248, 16)" leading="" trailing=" " raw_val="x" val="x"/>
                                        <IdentNode start="(248, 17)" end="(248, 18)" leading="" trailing=" " raw_val="y" val="y"/>
                                        <IdentNode start="(248, 19)" end="(248, 32)" leading="" trailing=" " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        <IdentNode start="(248, 33)" end="(248, 46)" leading="" trailing="&#10;&#10;" raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(250, 1)" end="(259, 60)" kind="Lean.Parser.Command.in">
      <OtherNode start="(250, 1)" end="(250, 14)" kind="Lean.Parser.Command.variable">
        <AtomNode start="(250, 1)" end="(250, 9)" leading="" trailing=" " val="variable"/>
        <NullNode start="(250, 10)" end="(250, 14)">
          <TermExplicitbinderNode start="(250, 10)" end="(250, 14)">
            <AtomNode start="(250, 10)" end="(250, 11)" leading="" trailing="" val="("/>
            <NullNode start="(250, 11)" end="(250, 13)">
              <IdentNode start="(250, 11)" end="(250, 13)" leading="" trailing="" raw_val="le" val="le"/>
            </NullNode>
            <NullNode/>
            <NullNode/>
            <AtomNode start="(250, 13)" end="(250, 14)" leading="" trailing=" " val=")"/>
          </TermExplicitbinderNode>
        </NullNode>
      </OtherNode>
      <AtomNode start="(250, 15)" end="(250, 17)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(251, 1)" end="(259, 60)" name="merge_perm_append" full_name="List.merge_perm_append">
        <CommandDeclmodifiersNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandTheoremNode start="(251, 1)" end="(259, 60)" name="merge_perm_append" full_name="List.merge_perm_append" _is_private_decl="False">
          <AtomNode start="(251, 1)" end="(251, 8)" leading="" trailing=" " val="theorem"/>
          <CommandDeclidNode start="(251, 9)" end="(251, 26)">
            <IdentNode start="(251, 9)" end="(251, 26)" leading="" trailing=" " raw_val="merge_perm_append" val="merge_perm_append" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </CommandDeclidNode>
          <CommandDeclsigNode start="(251, 27)" end="(251, 74)">
            <NullNode/>
            <TermTypespecNode start="(251, 27)" end="(251, 74)">
              <AtomNode start="(251, 27)" end="(251, 28)" leading="" trailing=" " val=":"/>
              <OtherNode start="(251, 29)" end="(251, 74)" kind="Lean.Parser.Term.forall">
                <AtomNode start="(251, 29)" end="(251, 30)" leading="" trailing=" " val="∀"/>
                <NullNode start="(251, 31)" end="(251, 47)">
                  <OtherNode start="(251, 31)" end="(251, 47)" kind="Lean.Parser.Term.implicitBinder">
                    <AtomNode start="(251, 31)" end="(251, 32)" leading="" trailing="" val="{"/>
                    <NullNode start="(251, 32)" end="(251, 37)">
                      <IdentNode start="(251, 32)" end="(251, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <IdentNode start="(251, 35)" end="(251, 37)" leading="" trailing=" " raw_val="ys" val="ys"/>
                    </NullNode>
                    <NullNode start="(251, 38)" end="(251, 46)">
                      <AtomNode start="(251, 38)" end="(251, 39)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(251, 40)" end="(251, 46)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(251, 40)" end="(251, 44)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(251, 45)" end="(251, 46)">
                          <IdentNode start="(251, 45)" end="(251, 46)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(251, 46)" end="(251, 47)" leading="" trailing="" val="}"/>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(251, 47)" end="(251, 48)" leading="" trailing=" " val=","/>
                <OtherNode start="(251, 49)" end="(251, 74)" kind="List.«term_~_»">
                  <OtherNode start="(251, 49)" end="(251, 63)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(251, 49)" end="(251, 54)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(251, 55)" end="(251, 63)">
                      <IdentNode start="(251, 55)" end="(251, 57)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <IdentNode start="(251, 58)" end="(251, 60)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      <IdentNode start="(251, 61)" end="(251, 63)" leading="" trailing=" " raw_val="le" val="le"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(251, 64)" end="(251, 65)" leading="" trailing=" " val="~"/>
                  <OtherNode start="(251, 66)" end="(251, 74)" kind="«term_++_»">
                    <IdentNode start="(251, 66)" end="(251, 68)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <AtomNode start="(251, 69)" end="(251, 71)" leading="" trailing=" " val="++"/>
                    <IdentNode start="(251, 72)" end="(251, 74)" leading="" trailing="&#10;  " raw_val="ys" val="ys"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </CommandDeclsigNode>
          <CommandDeclvaleqnsNode start="(252, 3)" end="(259, 60)">
            <OtherNode start="(252, 3)" end="(259, 60)" kind="Lean.Parser.Term.matchAltsWhereDecls">
              <OtherNode start="(252, 3)" end="(259, 60)" kind="Lean.Parser.Term.matchAlts">
                <NullNode start="(252, 3)" end="(259, 60)">
                  <OtherNode start="(252, 3)" end="(252, 30)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(252, 3)" end="(252, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(252, 5)" end="(252, 11)">
                      <NullNode start="(252, 5)" end="(252, 11)">
                        <OtherNode start="(252, 5)" end="(252, 7)" kind="«term[_]»">
                          <AtomNode start="(252, 5)" end="(252, 6)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(252, 6)" end="(252, 7)" leading="" trailing="" val="]"/>
                        </OtherNode>
                        <AtomNode start="(252, 7)" end="(252, 8)" leading="" trailing=" " val=","/>
                        <IdentNode start="(252, 9)" end="(252, 11)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(252, 12)" end="(252, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                    <TermBytacticNode start="(252, 15)" end="(252, 30)">
                      <AtomNode start="(252, 15)" end="(252, 17)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(252, 18)" end="(252, 30)">
                        <TacticTacticseq1IndentedNode start="(252, 18)" end="(252, 30)">
                          <NullNode start="(252, 18)" end="(252, 30)">
                            <OtherNode start="(252, 18)" end="(252, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;ys : List α&#10;⊢ [].merge ys le ~ [] ++ ys" state_after="no goals" tactic="simp [merge]">
                              <AtomNode start="(252, 18)" end="(252, 22)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(252, 23)" end="(252, 30)">
                                <AtomNode start="(252, 23)" end="(252, 24)" leading="" trailing="" val="["/>
                                <NullNode start="(252, 24)" end="(252, 29)">
                                  <OtherNode start="(252, 24)" end="(252, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(252, 24)" end="(252, 29)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(252, 29)" end="(252, 30)" leading="" trailing="&#10;  " val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                  <OtherNode start="(253, 3)" end="(253, 30)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(253, 3)" end="(253, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(253, 5)" end="(253, 11)">
                      <NullNode start="(253, 5)" end="(253, 11)">
                        <IdentNode start="(253, 5)" end="(253, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(253, 7)" end="(253, 8)" leading="" trailing=" " val=","/>
                        <OtherNode start="(253, 9)" end="(253, 11)" kind="«term[_]»">
                          <AtomNode start="(253, 9)" end="(253, 10)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(253, 10)" end="(253, 11)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(253, 12)" end="(253, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                    <TermBytacticNode start="(253, 15)" end="(253, 30)">
                      <AtomNode start="(253, 15)" end="(253, 17)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(253, 18)" end="(253, 30)">
                        <TacticTacticseq1IndentedNode start="(253, 18)" end="(253, 30)">
                          <NullNode start="(253, 18)" end="(253, 30)">
                            <OtherNode start="(253, 18)" end="(253, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;⊢ xs.merge [] le ~ xs ++ []" state_after="no goals" tactic="simp [merge]">
                              <AtomNode start="(253, 18)" end="(253, 22)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(253, 23)" end="(253, 30)">
                                <AtomNode start="(253, 23)" end="(253, 24)" leading="" trailing="" val="["/>
                                <NullNode start="(253, 24)" end="(253, 29)">
                                  <OtherNode start="(253, 24)" end="(253, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(253, 24)" end="(253, 29)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(253, 29)" end="(253, 30)" leading="" trailing="&#10;  " val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                  <OtherNode start="(254, 3)" end="(259, 60)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(254, 3)" end="(254, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(254, 5)" end="(254, 21)">
                      <NullNode start="(254, 5)" end="(254, 21)">
                        <OtherNode start="(254, 5)" end="(254, 12)" kind="«term_::_»">
                          <IdentNode start="(254, 5)" end="(254, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                          <AtomNode start="(254, 7)" end="(254, 9)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(254, 10)" end="(254, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </OtherNode>
                        <AtomNode start="(254, 12)" end="(254, 13)" leading="" trailing=" " val=","/>
                        <OtherNode start="(254, 14)" end="(254, 21)" kind="«term_::_»">
                          <IdentNode start="(254, 14)" end="(254, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                          <AtomNode start="(254, 16)" end="(254, 18)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(254, 19)" end="(254, 21)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(254, 22)" end="(254, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                    <TermBytacticNode start="(254, 25)" end="(259, 60)">
                      <AtomNode start="(254, 25)" end="(254, 27)" leading="" trailing="&#10;    " val="by"/>
                      <TacticTacticseqNode start="(255, 5)" end="(259, 60)">
                        <TacticTacticseq1IndentedNode start="(255, 5)" end="(259, 60)">
                          <NullNode start="(255, 5)" end="(259, 60)">
                            <OtherNode start="(255, 5)" end="(255, 22)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;⊢ (x :: xs).merge (y :: ys) le ~ x :: xs ++ y :: ys" state_after="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;⊢ (if le x y = true then x :: xs.merge (y :: ys) le else y :: (x :: xs).merge ys le) ~ x :: xs ++ y :: ys" tactic="simp only [merge]">
                              <AtomNode start="(255, 5)" end="(255, 9)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode start="(255, 10)" end="(255, 14)">
                                <AtomNode start="(255, 10)" end="(255, 14)" leading="" trailing=" " val="only"/>
                              </NullNode>
                              <NullNode start="(255, 15)" end="(255, 22)">
                                <AtomNode start="(255, 15)" end="(255, 16)" leading="" trailing="" val="["/>
                                <NullNode start="(255, 16)" end="(255, 21)">
                                  <OtherNode start="(255, 16)" end="(255, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(255, 16)" end="(255, 21)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(255, 21)" end="(255, 22)" leading="" trailing="&#10;    " val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(256, 5)" end="(256, 10)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;⊢ (if le x y = true then x :: xs.merge (y :: ys) le else y :: (x :: xs).merge ys le) ~ x :: xs ++ y :: ys" state_after="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : le x y = true&#10;⊢ x :: xs.merge (y :: ys) le ~ x :: xs ++ y :: ys&#10;&#10;case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : ¬le x y = true&#10;⊢ y :: (x :: xs).merge ys le ~ x :: xs ++ y :: ys" tactic="split">
                              <AtomNode start="(256, 5)" end="(256, 10)" leading="" trailing="&#10;    " val="split"/>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(257, 5)" end="(257, 37)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : le x y = true&#10;⊢ x :: xs.merge (y :: ys) le ~ x :: xs ++ y :: ys&#10;&#10;case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : ¬le x y = true&#10;⊢ y :: (x :: xs).merge ys le ~ x :: xs ++ y :: ys" state_after="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : ¬le x y = true&#10;⊢ y :: (x :: xs).merge ys le ~ x :: xs ++ y :: ys" tactic="· exact merge_perm_append.cons x">
                              <OtherNode start="(257, 5)" end="(257, 6)" kind="Lean.cdotTk">
                                <OtherNode start="(257, 5)" end="(257, 6)" kind="patternIgnore">
                                  <OtherNode start="(257, 5)" end="(257, 6)" kind="token.«· »">
                                    <AtomNode start="(257, 5)" end="(257, 6)" leading="" trailing=" " val="·"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <TacticTacticseqNode start="(257, 7)" end="(257, 37)">
                                <TacticTacticseq1IndentedNode start="(257, 7)" end="(257, 37)">
                                  <NullNode start="(257, 7)" end="(257, 37)">
                                    <OtherNode start="(257, 7)" end="(257, 37)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : le x y = true&#10;⊢ x :: xs.merge (y :: ys) le ~ x :: xs ++ y :: ys" state_after="no goals" tactic="exact merge_perm_append.cons x">
                                      <AtomNode start="(257, 7)" end="(257, 12)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(257, 13)" end="(257, 37)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(257, 13)" end="(257, 35)" leading="" trailing=" " raw_val="merge_perm_append.cons" val="merge_perm_append.cons"/>
                                        <NullNode start="(257, 36)" end="(257, 37)">
                                          <IdentNode start="(257, 36)" end="(257, 37)" leading="" trailing="&#10;    " raw_val="x" val="x"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </OtherNode>
                            <NullNode/>
                            <OtherNode start="(258, 5)" end="(259, 60)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : ¬le x y = true&#10;⊢ y :: (x :: xs).merge ys le ~ x :: xs ++ y :: ys" state_after="no goals" tactic="· exact (merge_perm_append.cons y).trans&#10;    ((Perm.swap x y _).trans (perm_middle.symm.cons x))">
                              <OtherNode start="(258, 5)" end="(258, 6)" kind="Lean.cdotTk">
                                <OtherNode start="(258, 5)" end="(258, 6)" kind="patternIgnore">
                                  <OtherNode start="(258, 5)" end="(258, 6)" kind="token.«· »">
                                    <AtomNode start="(258, 5)" end="(258, 6)" leading="" trailing=" " val="·"/>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <TacticTacticseqNode start="(258, 7)" end="(259, 60)">
                                <TacticTacticseq1IndentedNode start="(258, 7)" end="(259, 60)">
                                  <NullNode start="(258, 7)" end="(259, 60)">
                                    <OtherNode start="(258, 7)" end="(259, 60)" kind="Lean.Parser.Tactic.exact" state_before="case isFalse&#10;α : Type u_1&#10;le : α → α → Bool&#10;x : α&#10;xs : List α&#10;y : α&#10;ys : List α&#10;h✝ : ¬le x y = true&#10;⊢ y :: (x :: xs).merge ys le ~ x :: xs ++ y :: ys" state_after="no goals" tactic="exact (merge_perm_append.cons y).trans&#10;  ((Perm.swap x y _).trans (perm_middle.symm.cons x))">
                                      <AtomNode start="(258, 7)" end="(258, 12)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(258, 13)" end="(259, 60)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(258, 13)" end="(258, 45)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(258, 13)" end="(258, 39)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(258, 13)" end="(258, 14)" leading="" trailing="" val="("/>
                                            <OtherNode start="(258, 14)" end="(258, 38)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(258, 14)" end="(258, 36)" leading="" trailing=" " raw_val="merge_perm_append.cons" val="merge_perm_append.cons"/>
                                              <NullNode start="(258, 37)" end="(258, 38)">
                                                <IdentNode start="(258, 37)" end="(258, 38)" leading="" trailing="" raw_val="y" val="y"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(258, 38)" end="(258, 39)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                          <AtomNode start="(258, 39)" end="(258, 40)" leading="" trailing="" val="."/>
                                          <IdentNode start="(258, 40)" end="(258, 45)" leading="" trailing="&#10;        " raw_val="trans" val="trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <NullNode start="(259, 9)" end="(259, 60)">
                                          <OtherNode start="(259, 9)" end="(259, 60)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(259, 9)" end="(259, 10)" leading="" trailing="" val="("/>
                                            <OtherNode start="(259, 10)" end="(259, 59)" kind="Lean.Parser.Term.app">
                                              <OtherNode start="(259, 10)" end="(259, 33)" kind="Lean.Parser.Term.proj">
                                                <OtherNode start="(259, 10)" end="(259, 27)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(259, 10)" end="(259, 11)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(259, 11)" end="(259, 26)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(259, 11)" end="(259, 20)" leading="" trailing=" " raw_val="Perm.swap" val="Perm.swap" full_name="List.Perm.swap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                    <NullNode start="(259, 21)" end="(259, 26)">
                                                      <IdentNode start="(259, 21)" end="(259, 22)" leading="" trailing=" " raw_val="x" val="x"/>
                                                      <IdentNode start="(259, 23)" end="(259, 24)" leading="" trailing=" " raw_val="y" val="y"/>
                                                      <TermHoleNode start="(259, 25)" end="(259, 26)">
                                                        <AtomNode start="(259, 25)" end="(259, 26)" leading="" trailing="" val="_"/>
                                                      </TermHoleNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(259, 26)" end="(259, 27)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                                <AtomNode start="(259, 27)" end="(259, 28)" leading="" trailing="" val="."/>
                                                <IdentNode start="(259, 28)" end="(259, 33)" leading="" trailing=" " raw_val="trans" val="trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                              </OtherNode>
                                              <NullNode start="(259, 34)" end="(259, 59)">
                                                <OtherNode start="(259, 34)" end="(259, 59)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(259, 34)" end="(259, 35)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(259, 35)" end="(259, 58)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(259, 35)" end="(259, 56)" leading="" trailing=" " raw_val="perm_middle.symm.cons" val="perm_middle.symm.cons"/>
                                                    <NullNode start="(259, 57)" end="(259, 58)">
                                                      <IdentNode start="(259, 57)" end="(259, 58)" leading="" trailing="" raw_val="x" val="x"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(259, 58)" end="(259, 59)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(259, 59)" end="(259, 60)" leading="" trailing="&#10;&#10;" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode kind="Lean.Parser.Termination.suffix">
                <NullNode/>
                <NullNode/>
              </OtherNode>
              <NullNode/>
            </OtherNode>
          </CommandDeclvaleqnsNode>
        </CommandTheoremNode>
      </CommandDeclarationNode>
    </OtherNode>
    <CommandDeclarationNode start="(261, 1)" end="(263, 106)" name="Perm.merge" full_name="List.Perm.merge">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(261, 1)" end="(263, 106)" name="Perm.merge" full_name="List.Perm.merge" _is_private_decl="False">
        <AtomNode start="(261, 1)" end="(261, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(261, 9)" end="(261, 19)">
          <IdentNode start="(261, 9)" end="(261, 19)" leading="" trailing=" " raw_val="Perm.merge" val="Perm.merge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(261, 20)" end="(262, 36)">
          <NullNode start="(261, 20)" end="(261, 72)">
            <TermExplicitbinderNode start="(261, 20)" end="(261, 42)">
              <AtomNode start="(261, 20)" end="(261, 21)" leading="" trailing="" val="("/>
              <NullNode start="(261, 21)" end="(261, 26)">
                <IdentNode start="(261, 21)" end="(261, 23)" leading="" trailing=" " raw_val="s₁" val="s₁"/>
                <IdentNode start="(261, 24)" end="(261, 26)" leading="" trailing=" " raw_val="s₂" val="s₂"/>
              </NullNode>
              <NullNode start="(261, 27)" end="(261, 41)">
                <AtomNode start="(261, 27)" end="(261, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(261, 29)" end="(261, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(261, 29)" end="(261, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(261, 31)" end="(261, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(261, 33)" end="(261, 41)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(261, 33)" end="(261, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(261, 35)" end="(261, 36)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(261, 37)" end="(261, 41)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 41)" end="(261, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(261, 43)" end="(261, 57)">
              <AtomNode start="(261, 43)" end="(261, 44)" leading="" trailing="" val="("/>
              <NullNode start="(261, 44)" end="(261, 46)">
                <IdentNode start="(261, 44)" end="(261, 46)" leading="" trailing=" " raw_val="hl" val="hl"/>
              </NullNode>
              <NullNode start="(261, 47)" end="(261, 56)">
                <AtomNode start="(261, 47)" end="(261, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(261, 49)" end="(261, 56)" kind="List.«term_~_»">
                  <IdentNode start="(261, 49)" end="(261, 51)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <AtomNode start="(261, 52)" end="(261, 53)" leading="" trailing=" " val="~"/>
                  <IdentNode start="(261, 54)" end="(261, 56)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 56)" end="(261, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(261, 58)" end="(261, 72)">
              <AtomNode start="(261, 58)" end="(261, 59)" leading="" trailing="" val="("/>
              <NullNode start="(261, 59)" end="(261, 61)">
                <IdentNode start="(261, 59)" end="(261, 61)" leading="" trailing=" " raw_val="hr" val="hr"/>
              </NullNode>
              <NullNode start="(261, 62)" end="(261, 71)">
                <AtomNode start="(261, 62)" end="(261, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(261, 64)" end="(261, 71)" kind="List.«term_~_»">
                  <IdentNode start="(261, 64)" end="(261, 66)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                  <AtomNode start="(261, 67)" end="(261, 68)" leading="" trailing=" " val="~"/>
                  <IdentNode start="(261, 69)" end="(261, 71)" leading="" trailing="" raw_val="r₂" val="r₂"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(261, 71)" end="(261, 72)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(261, 73)" end="(262, 36)">
            <AtomNode start="(261, 73)" end="(261, 74)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(262, 5)" end="(262, 36)" kind="List.«term_~_»">
              <OtherNode start="(262, 5)" end="(262, 19)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 5)" end="(262, 10)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(262, 11)" end="(262, 19)">
                  <IdentNode start="(262, 11)" end="(262, 13)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(262, 14)" end="(262, 16)" leading="" trailing=" " raw_val="r₁" val="r₁"/>
                  <IdentNode start="(262, 17)" end="(262, 19)" leading="" trailing=" " raw_val="s₁" val="s₁"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(262, 20)" end="(262, 21)" leading="" trailing=" " val="~"/>
              <OtherNode start="(262, 22)" end="(262, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 22)" end="(262, 27)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(262, 28)" end="(262, 36)">
                  <IdentNode start="(262, 28)" end="(262, 30)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <IdentNode start="(262, 31)" end="(262, 33)" leading="" trailing=" " raw_val="r₂" val="r₂"/>
                  <IdentNode start="(262, 34)" end="(262, 36)" leading="" trailing=" " raw_val="s₂" val="s₂"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(262, 37)" end="(263, 106)">
          <AtomNode start="(262, 37)" end="(262, 39)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(263, 3)" end="(263, 106)" kind="«term_&amp;lt;|_»">
            <OtherNode start="(263, 3)" end="(263, 36)" kind="Lean.Parser.Term.app">
              <IdentNode start="(263, 3)" end="(263, 13)" leading="" trailing=" " raw_val="Perm.trans" val="Perm.trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              <NullNode start="(263, 14)" end="(263, 36)">
                <OtherNode start="(263, 14)" end="(263, 36)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(263, 14)" end="(263, 15)" leading="" trailing="" val="("/>
                  <OtherNode start="(263, 15)" end="(263, 35)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(263, 15)" end="(263, 32)" leading="" trailing=" " raw_val="merge_perm_append" val="merge_perm_append" full_name="List.merge_perm_append" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(251, 9)" def_end="(251, 26)"/>
                    <NullNode start="(263, 33)" end="(263, 35)">
                      <OtherNode start="(263, 33)" end="(263, 35)" kind="Lean.Parser.Term.ellipsis">
                        <AtomNode start="(263, 33)" end="(263, 35)" leading="" trailing="" val=".."/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(263, 35)" end="(263, 36)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(263, 37)" end="(263, 39)" leading="" trailing=" " val="&amp;lt;|"/>
            <OtherNode start="(263, 40)" end="(263, 106)" kind="«term_&amp;lt;|_»">
              <OtherNode start="(263, 40)" end="(263, 70)" kind="Lean.Parser.Term.app">
                <IdentNode start="(263, 40)" end="(263, 50)" leading="" trailing=" " raw_val="Perm.trans" val="Perm.trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                <NullNode start="(263, 51)" end="(263, 70)">
                  <OtherNode start="(263, 51)" end="(263, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(263, 51)" end="(263, 52)" leading="" trailing="" val="("/>
                    <OtherNode start="(263, 52)" end="(263, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(263, 52)" end="(263, 63)" leading="" trailing=" " raw_val="Perm.append" val="Perm.append" full_name="List.Perm.append" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                      <NullNode start="(263, 64)" end="(263, 69)">
                        <IdentNode start="(263, 64)" end="(263, 66)" leading="" trailing=" " raw_val="hl" val="hl"/>
                        <IdentNode start="(263, 67)" end="(263, 69)" leading="" trailing="" raw_val="hr" val="hr"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(263, 69)" end="(263, 70)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(263, 71)" end="(263, 73)" leading="" trailing=" " val="&amp;lt;|"/>
              <OtherNode start="(263, 74)" end="(263, 106)" kind="Lean.Parser.Term.app">
                <IdentNode start="(263, 74)" end="(263, 83)" leading="" trailing=" " raw_val="Perm.symm" val="Perm.symm" full_name="List.Perm.symm" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                <NullNode start="(263, 84)" end="(263, 106)">
                  <OtherNode start="(263, 84)" end="(263, 106)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(263, 84)" end="(263, 85)" leading="" trailing="" val="("/>
                    <OtherNode start="(263, 85)" end="(263, 105)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(263, 85)" end="(263, 102)" leading="" trailing=" " raw_val="merge_perm_append" val="merge_perm_append" full_name="List.merge_perm_append" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(251, 9)" def_end="(251, 26)"/>
                      <NullNode start="(263, 103)" end="(263, 105)">
                        <OtherNode start="(263, 103)" end="(263, 105)" kind="Lean.Parser.Term.ellipsis">
                          <AtomNode start="(263, 103)" end="(263, 105)" leading="" trailing="" val=".."/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(263, 105)" end="(263, 106)" leading="" trailing="&#10;&#10;" val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(265, 1)" end="(265, 21)" comment="### mergeSort -/">
      <AtomNode start="(265, 1)" end="(265, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(265, 5)" end="(265, 21)" leading="" trailing="&#10;&#10;" val="### mergeSort -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(267, 1)" end="(267, 78)" name="mergeSort_nil" full_name="List.mergeSort_nil">
      <CommandDeclmodifiersNode start="(267, 1)" end="(267, 8)">
        <NullNode/>
        <NullNode start="(267, 1)" end="(267, 8)">
          <OtherNode start="(267, 1)" end="(267, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(267, 1)" end="(267, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(267, 3)" end="(267, 7)">
              <OtherNode start="(267, 3)" end="(267, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(267, 3)" end="(267, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(267, 3)" end="(267, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(267, 7)" end="(267, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(267, 9)" end="(267, 78)" name="mergeSort_nil" full_name="List.mergeSort_nil" _is_private_decl="False">
        <AtomNode start="(267, 9)" end="(267, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(267, 17)" end="(267, 30)">
          <IdentNode start="(267, 17)" end="(267, 30)" leading="" trailing=" " raw_val="mergeSort_nil" val="mergeSort_nil"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(267, 31)" end="(267, 52)">
          <NullNode/>
          <TermTypespecNode start="(267, 31)" end="(267, 52)">
            <AtomNode start="(267, 31)" end="(267, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(267, 33)" end="(267, 52)" kind="«term_=_»">
              <OtherNode start="(267, 33)" end="(267, 47)" kind="Lean.Parser.Term.app">
                <OtherNode start="(267, 33)" end="(267, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(267, 33)" end="(267, 35)" kind="«term[_]»">
                    <AtomNode start="(267, 33)" end="(267, 34)" leading="" trailing="" val="["/>
                    <NullNode/>
                    <AtomNode start="(267, 34)" end="(267, 35)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(267, 35)" end="(267, 36)" leading="" trailing="" val="."/>
                  <IdentNode start="(267, 36)" end="(267, 45)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                </OtherNode>
                <NullNode start="(267, 46)" end="(267, 47)">
                  <IdentNode start="(267, 46)" end="(267, 47)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(267, 48)" end="(267, 49)" leading="" trailing=" " val="="/>
              <OtherNode start="(267, 50)" end="(267, 52)" kind="«term[_]»">
                <AtomNode start="(267, 50)" end="(267, 51)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(267, 51)" end="(267, 52)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(267, 53)" end="(267, 78)">
          <AtomNode start="(267, 53)" end="(267, 55)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(267, 56)" end="(267, 78)">
            <AtomNode start="(267, 56)" end="(267, 58)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(267, 59)" end="(267, 78)">
              <TacticTacticseq1IndentedNode start="(267, 59)" end="(267, 78)">
                <NullNode start="(267, 59)" end="(267, 78)">
                  <OtherNode start="(267, 59)" end="(267, 78)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type u_1&#10;r : α✝ → α✝ → Bool&#10;⊢ [].mergeSort r = []" state_after="no goals" tactic="rw [List.mergeSort]">
                    <AtomNode start="(267, 59)" end="(267, 61)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(267, 62)" end="(267, 78)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(267, 62)" end="(267, 63)" leading="" trailing="" val="["/>
                      <NullNode start="(267, 63)" end="(267, 77)">
                        <OtherNode start="(267, 63)" end="(267, 77)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(267, 63)" end="(267, 77)" leading="" trailing="" raw_val="List.mergeSort" val="List.mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(267, 77)" end="(267, 78)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(269, 1)" end="(269, 94)" name="mergeSort_singleton" full_name="List.mergeSort_singleton">
      <CommandDeclmodifiersNode start="(269, 1)" end="(269, 8)">
        <NullNode/>
        <NullNode start="(269, 1)" end="(269, 8)">
          <OtherNode start="(269, 1)" end="(269, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(269, 1)" end="(269, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(269, 3)" end="(269, 7)">
              <OtherNode start="(269, 3)" end="(269, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(269, 3)" end="(269, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(269, 3)" end="(269, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(269, 7)" end="(269, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(269, 9)" end="(269, 94)" name="mergeSort_singleton" full_name="List.mergeSort_singleton" _is_private_decl="False">
        <AtomNode start="(269, 9)" end="(269, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(269, 17)" end="(269, 36)">
          <IdentNode start="(269, 17)" end="(269, 36)" leading="" trailing=" " raw_val="mergeSort_singleton" val="mergeSort_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(269, 37)" end="(269, 68)">
          <NullNode start="(269, 37)" end="(269, 44)">
            <TermExplicitbinderNode start="(269, 37)" end="(269, 44)">
              <AtomNode start="(269, 37)" end="(269, 38)" leading="" trailing="" val="("/>
              <NullNode start="(269, 38)" end="(269, 39)">
                <IdentNode start="(269, 38)" end="(269, 39)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(269, 40)" end="(269, 43)">
                <AtomNode start="(269, 40)" end="(269, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(269, 42)" end="(269, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(269, 43)" end="(269, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(269, 45)" end="(269, 68)">
            <AtomNode start="(269, 45)" end="(269, 46)" leading="" trailing=" " val=":"/>
            <OtherNode start="(269, 47)" end="(269, 68)" kind="«term_=_»">
              <OtherNode start="(269, 47)" end="(269, 62)" kind="Lean.Parser.Term.app">
                <OtherNode start="(269, 47)" end="(269, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(269, 47)" end="(269, 50)" kind="«term[_]»">
                    <AtomNode start="(269, 47)" end="(269, 48)" leading="" trailing="" val="["/>
                    <NullNode start="(269, 48)" end="(269, 49)">
                      <IdentNode start="(269, 48)" end="(269, 49)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(269, 49)" end="(269, 50)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(269, 50)" end="(269, 51)" leading="" trailing="" val="."/>
                  <IdentNode start="(269, 51)" end="(269, 60)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                </OtherNode>
                <NullNode start="(269, 61)" end="(269, 62)">
                  <IdentNode start="(269, 61)" end="(269, 62)" leading="" trailing=" " raw_val="r" val="r"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(269, 63)" end="(269, 64)" leading="" trailing=" " val="="/>
              <OtherNode start="(269, 65)" end="(269, 68)" kind="«term[_]»">
                <AtomNode start="(269, 65)" end="(269, 66)" leading="" trailing="" val="["/>
                <NullNode start="(269, 66)" end="(269, 67)">
                  <IdentNode start="(269, 66)" end="(269, 67)" leading="" trailing="" raw_val="a" val="a"/>
                </NullNode>
                <AtomNode start="(269, 67)" end="(269, 68)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(269, 69)" end="(269, 94)">
          <AtomNode start="(269, 69)" end="(269, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(269, 72)" end="(269, 94)">
            <AtomNode start="(269, 72)" end="(269, 74)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(269, 75)" end="(269, 94)">
              <TacticTacticseq1IndentedNode start="(269, 75)" end="(269, 94)">
                <NullNode start="(269, 75)" end="(269, 94)">
                  <OtherNode start="(269, 75)" end="(269, 94)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;r : α → α → Bool&#10;a : α&#10;⊢ [a].mergeSort r = [a]" state_after="no goals" tactic="rw [List.mergeSort]">
                    <AtomNode start="(269, 75)" end="(269, 77)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(269, 78)" end="(269, 94)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(269, 78)" end="(269, 79)" leading="" trailing="" val="["/>
                      <NullNode start="(269, 79)" end="(269, 93)">
                        <OtherNode start="(269, 79)" end="(269, 93)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(269, 79)" end="(269, 93)" leading="" trailing="" raw_val="List.mergeSort" val="List.mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(269, 93)" end="(269, 94)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(271, 1)" end="(281, 29)" name="mergeSort_perm" full_name="List.mergeSort_perm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(271, 1)" end="(281, 29)" name="mergeSort_perm" full_name="List.mergeSort_perm" _is_private_decl="False">
        <AtomNode start="(271, 1)" end="(271, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(271, 9)" end="(271, 23)">
          <IdentNode start="(271, 9)" end="(271, 23)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(271, 24)" end="(271, 65)">
          <NullNode/>
          <TermTypespecNode start="(271, 24)" end="(271, 65)">
            <AtomNode start="(271, 24)" end="(271, 25)" leading="" trailing=" " val=":"/>
            <OtherNode start="(271, 26)" end="(271, 65)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(271, 26)" end="(271, 27)" leading="" trailing=" " val="∀"/>
              <NullNode start="(271, 28)" end="(271, 45)">
                <TermExplicitbinderNode start="(271, 28)" end="(271, 40)">
                  <AtomNode start="(271, 28)" end="(271, 29)" leading="" trailing="" val="("/>
                  <NullNode start="(271, 29)" end="(271, 30)">
                    <IdentNode start="(271, 29)" end="(271, 30)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(271, 31)" end="(271, 39)">
                    <AtomNode start="(271, 31)" end="(271, 32)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(271, 33)" end="(271, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(271, 33)" end="(271, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(271, 38)" end="(271, 39)">
                        <IdentNode start="(271, 38)" end="(271, 39)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(271, 39)" end="(271, 40)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(271, 41)" end="(271, 45)">
                  <AtomNode start="(271, 41)" end="(271, 42)" leading="" trailing="" val="("/>
                  <NullNode start="(271, 42)" end="(271, 44)">
                    <IdentNode start="(271, 42)" end="(271, 44)" leading="" trailing="" raw_val="le" val="le"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode/>
                  <AtomNode start="(271, 44)" end="(271, 45)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(271, 45)" end="(271, 46)" leading="" trailing=" " val=","/>
              <OtherNode start="(271, 47)" end="(271, 65)" kind="List.«term_~_»">
                <OtherNode start="(271, 47)" end="(271, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(271, 47)" end="(271, 56)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(271, 57)" end="(271, 61)">
                    <IdentNode start="(271, 57)" end="(271, 58)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(271, 59)" end="(271, 61)" leading="" trailing=" " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(271, 62)" end="(271, 63)" leading="" trailing=" " val="~"/>
                <IdentNode start="(271, 64)" end="(271, 65)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(272, 3)" end="(281, 29)">
          <OtherNode start="(272, 3)" end="(281, 29)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(272, 3)" end="(280, 63)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(272, 3)" end="(280, 63)">
                <OtherNode start="(272, 3)" end="(272, 33)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(272, 3)" end="(272, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(272, 5)" end="(272, 10)">
                    <NullNode start="(272, 5)" end="(272, 10)">
                      <OtherNode start="(272, 5)" end="(272, 7)" kind="«term[_]»">
                        <AtomNode start="(272, 5)" end="(272, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(272, 6)" end="(272, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(272, 7)" end="(272, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(272, 9)" end="(272, 10)">
                        <AtomNode start="(272, 9)" end="(272, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(272, 11)" end="(272, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(272, 14)" end="(272, 33)">
                    <AtomNode start="(272, 14)" end="(272, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(272, 17)" end="(272, 33)">
                      <TacticTacticseq1IndentedNode start="(272, 17)" end="(272, 33)">
                        <NullNode start="(272, 17)" end="(272, 33)">
                          <OtherNode start="(272, 17)" end="(272, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x✝ : α → α → Bool&#10;⊢ [].mergeSort x✝ ~ []" state_after="no goals" tactic="simp [mergeSort]">
                            <AtomNode start="(272, 17)" end="(272, 21)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(272, 22)" end="(272, 33)">
                              <AtomNode start="(272, 22)" end="(272, 23)" leading="" trailing="" val="["/>
                              <NullNode start="(272, 23)" end="(272, 32)">
                                <OtherNode start="(272, 23)" end="(272, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(272, 23)" end="(272, 32)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(272, 32)" end="(272, 33)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(273, 3)" end="(273, 34)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(273, 3)" end="(273, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(273, 5)" end="(273, 11)">
                    <NullNode start="(273, 5)" end="(273, 11)">
                      <OtherNode start="(273, 5)" end="(273, 8)" kind="«term[_]»">
                        <AtomNode start="(273, 5)" end="(273, 6)" leading="" trailing="" val="["/>
                        <NullNode start="(273, 6)" end="(273, 7)">
                          <IdentNode start="(273, 6)" end="(273, 7)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                        <AtomNode start="(273, 7)" end="(273, 8)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(273, 8)" end="(273, 9)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(273, 10)" end="(273, 11)">
                        <AtomNode start="(273, 10)" end="(273, 11)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(273, 12)" end="(273, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(273, 15)" end="(273, 34)">
                    <AtomNode start="(273, 15)" end="(273, 17)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(273, 18)" end="(273, 34)">
                      <TacticTacticseq1IndentedNode start="(273, 18)" end="(273, 34)">
                        <NullNode start="(273, 18)" end="(273, 34)">
                          <OtherNode start="(273, 18)" end="(273, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;x✝ : α → α → Bool&#10;⊢ [a].mergeSort x✝ ~ [a]" state_after="no goals" tactic="simp [mergeSort]">
                            <AtomNode start="(273, 18)" end="(273, 22)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(273, 23)" end="(273, 34)">
                              <AtomNode start="(273, 23)" end="(273, 24)" leading="" trailing="" val="["/>
                              <NullNode start="(273, 24)" end="(273, 33)">
                                <OtherNode start="(273, 24)" end="(273, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(273, 24)" end="(273, 33)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(273, 33)" end="(273, 34)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(274, 3)" end="(280, 63)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(274, 3)" end="(274, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(274, 5)" end="(274, 21)">
                    <NullNode start="(274, 5)" end="(274, 21)">
                      <OtherNode start="(274, 5)" end="(274, 17)" kind="«term_::_»">
                        <IdentNode start="(274, 5)" end="(274, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(274, 7)" end="(274, 9)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(274, 10)" end="(274, 17)" kind="«term_::_»">
                          <IdentNode start="(274, 10)" end="(274, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                          <AtomNode start="(274, 12)" end="(274, 14)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(274, 15)" end="(274, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(274, 17)" end="(274, 18)" leading="" trailing=" " val=","/>
                      <IdentNode start="(274, 19)" end="(274, 21)" leading="" trailing=" " raw_val="le" val="le"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(274, 22)" end="(274, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(274, 25)" end="(280, 63)">
                    <AtomNode start="(274, 25)" end="(274, 27)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(275, 5)" end="(280, 63)">
                      <TacticTacticseq1IndentedNode start="(275, 5)" end="(280, 63)">
                        <NullNode start="(275, 5)" end="(280, 63)">
                          <OtherNode start="(275, 5)" end="(275, 26)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;⊢ (a :: b :: xs).mergeSort le ~ a :: b :: xs" state_after="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le ~&#10;    a :: b :: xs" tactic="simp only [mergeSort]">
                            <AtomNode start="(275, 5)" end="(275, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(275, 10)" end="(275, 14)">
                              <AtomNode start="(275, 10)" end="(275, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(275, 15)" end="(275, 26)">
                              <AtomNode start="(275, 15)" end="(275, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(275, 16)" end="(275, 25)">
                                <OtherNode start="(275, 16)" end="(275, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(275, 16)" end="(275, 25)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(275, 25)" end="(275, 26)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(276, 5)" end="(276, 110)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le ~&#10;    a :: b :: xs" state_after="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le ~&#10;    a :: b :: xs" tactic="have : (splitInTwo ⟨a :: b :: xs, rfl⟩).1.1.length &amp;lt; xs.length + 1 + 1 := by simp [splitInTwo_fst]; omega">
                            <AtomNode start="(276, 5)" end="(276, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(276, 10)" end="(276, 110)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(276, 10)" end="(276, 110)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(276, 10)" end="(276, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(276, 10)" end="(276, 10)" kind="hygieneInfo">
                                    <IdentNode start="(276, 10)" end="(276, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(276, 10)" end="(276, 75)">
                                  <TermTypespecNode start="(276, 10)" end="(276, 75)">
                                    <AtomNode start="(276, 10)" end="(276, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(276, 12)" end="(276, 75)" kind="«term_&amp;lt;_»">
                                      <OtherNode start="(276, 12)" end="(276, 55)" kind="Lean.Parser.Term.proj">
                                        <OtherNode start="(276, 12)" end="(276, 48)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(276, 12)" end="(276, 46)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(276, 12)" end="(276, 44)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(276, 12)" end="(276, 13)" leading="" trailing="" val="("/>
                                              <OtherNode start="(276, 13)" end="(276, 43)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(276, 13)" end="(276, 23)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                <NullNode start="(276, 24)" end="(276, 43)">
                                                  <OtherNode start="(276, 24)" end="(276, 43)" kind="Lean.Parser.Term.anonymousCtor">
                                                    <AtomNode start="(276, 24)" end="(276, 25)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(276, 25)" end="(276, 42)">
                                                      <OtherNode start="(276, 25)" end="(276, 37)" kind="«term_::_»">
                                                        <IdentNode start="(276, 25)" end="(276, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <AtomNode start="(276, 27)" end="(276, 29)" leading="" trailing=" " val="::"/>
                                                        <OtherNode start="(276, 30)" end="(276, 37)" kind="«term_::_»">
                                                          <IdentNode start="(276, 30)" end="(276, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                                                          <AtomNode start="(276, 32)" end="(276, 34)" leading="" trailing=" " val="::"/>
                                                          <IdentNode start="(276, 35)" end="(276, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(276, 37)" end="(276, 38)" leading="" trailing=" " val=","/>
                                                      <IdentNode start="(276, 39)" end="(276, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </NullNode>
                                                    <AtomNode start="(276, 42)" end="(276, 43)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(276, 43)" end="(276, 44)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(276, 44)" end="(276, 45)" leading="" trailing="" val="."/>
                                            <OtherNode start="(276, 45)" end="(276, 46)" kind="fieldIdx">
                                              <AtomNode start="(276, 45)" end="(276, 46)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(276, 46)" end="(276, 47)" leading="" trailing="" val="."/>
                                          <OtherNode start="(276, 47)" end="(276, 48)" kind="fieldIdx">
                                            <AtomNode start="(276, 47)" end="(276, 48)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(276, 48)" end="(276, 49)" leading="" trailing="" val="."/>
                                        <IdentNode start="(276, 49)" end="(276, 55)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(276, 56)" end="(276, 57)" leading="" trailing=" " val="&amp;lt;"/>
                                      <OtherNode start="(276, 58)" end="(276, 75)" kind="«term_+_»">
                                        <OtherNode start="(276, 58)" end="(276, 71)" kind="«term_+_»">
                                          <IdentNode start="(276, 58)" end="(276, 67)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                          <AtomNode start="(276, 68)" end="(276, 69)" leading="" trailing=" " val="+"/>
                                          <OtherNode start="(276, 70)" end="(276, 71)" kind="num">
                                            <AtomNode start="(276, 70)" end="(276, 71)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(276, 72)" end="(276, 73)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(276, 74)" end="(276, 75)" kind="num">
                                          <AtomNode start="(276, 74)" end="(276, 75)" leading="" trailing=" " val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(276, 76)" end="(276, 78)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(276, 79)" end="(276, 110)">
                                  <AtomNode start="(276, 79)" end="(276, 81)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(276, 82)" end="(276, 110)">
                                    <TacticTacticseq1IndentedNode start="(276, 82)" end="(276, 110)">
                                      <NullNode start="(276, 82)" end="(276, 110)">
                                        <OtherNode start="(276, 82)" end="(276, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1" state_after="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;⊢ min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1" tactic="simp [splitInTwo_fst]">
                                          <AtomNode start="(276, 82)" end="(276, 86)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(276, 87)" end="(276, 103)">
                                            <AtomNode start="(276, 87)" end="(276, 88)" leading="" trailing="" val="["/>
                                            <NullNode start="(276, 88)" end="(276, 102)">
                                              <OtherNode start="(276, 88)" end="(276, 102)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(276, 88)" end="(276, 102)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(276, 102)" end="(276, 103)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(276, 103)" end="(276, 104)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(276, 105)" end="(276, 110)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;⊢ min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(276, 105)" end="(276, 110)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(277, 5)" end="(277, 110)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le ~&#10;    a :: b :: xs" state_after="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le ~&#10;    a :: b :: xs" tactic="have : (splitInTwo ⟨a :: b :: xs, rfl⟩).2.1.length &amp;lt; xs.length + 1 + 1 := by simp [splitInTwo_snd]; omega">
                            <AtomNode start="(277, 5)" end="(277, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(277, 10)" end="(277, 110)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(277, 10)" end="(277, 110)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(277, 10)" end="(277, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(277, 10)" end="(277, 10)" kind="hygieneInfo">
                                    <IdentNode start="(277, 10)" end="(277, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(277, 10)" end="(277, 75)">
                                  <TermTypespecNode start="(277, 10)" end="(277, 75)">
                                    <AtomNode start="(277, 10)" end="(277, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(277, 12)" end="(277, 75)" kind="«term_&amp;lt;_»">
                                      <OtherNode start="(277, 12)" end="(277, 55)" kind="Lean.Parser.Term.proj">
                                        <OtherNode start="(277, 12)" end="(277, 48)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(277, 12)" end="(277, 46)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(277, 12)" end="(277, 44)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(277, 12)" end="(277, 13)" leading="" trailing="" val="("/>
                                              <OtherNode start="(277, 13)" end="(277, 43)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(277, 13)" end="(277, 23)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                <NullNode start="(277, 24)" end="(277, 43)">
                                                  <OtherNode start="(277, 24)" end="(277, 43)" kind="Lean.Parser.Term.anonymousCtor">
                                                    <AtomNode start="(277, 24)" end="(277, 25)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(277, 25)" end="(277, 42)">
                                                      <OtherNode start="(277, 25)" end="(277, 37)" kind="«term_::_»">
                                                        <IdentNode start="(277, 25)" end="(277, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <AtomNode start="(277, 27)" end="(277, 29)" leading="" trailing=" " val="::"/>
                                                        <OtherNode start="(277, 30)" end="(277, 37)" kind="«term_::_»">
                                                          <IdentNode start="(277, 30)" end="(277, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                                                          <AtomNode start="(277, 32)" end="(277, 34)" leading="" trailing=" " val="::"/>
                                                          <IdentNode start="(277, 35)" end="(277, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(277, 37)" end="(277, 38)" leading="" trailing=" " val=","/>
                                                      <IdentNode start="(277, 39)" end="(277, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </NullNode>
                                                    <AtomNode start="(277, 42)" end="(277, 43)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(277, 43)" end="(277, 44)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(277, 44)" end="(277, 45)" leading="" trailing="" val="."/>
                                            <OtherNode start="(277, 45)" end="(277, 46)" kind="fieldIdx">
                                              <AtomNode start="(277, 45)" end="(277, 46)" leading="" trailing="" val="2"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(277, 46)" end="(277, 47)" leading="" trailing="" val="."/>
                                          <OtherNode start="(277, 47)" end="(277, 48)" kind="fieldIdx">
                                            <AtomNode start="(277, 47)" end="(277, 48)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(277, 48)" end="(277, 49)" leading="" trailing="" val="."/>
                                        <IdentNode start="(277, 49)" end="(277, 55)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(277, 56)" end="(277, 57)" leading="" trailing=" " val="&amp;lt;"/>
                                      <OtherNode start="(277, 58)" end="(277, 75)" kind="«term_+_»">
                                        <OtherNode start="(277, 58)" end="(277, 71)" kind="«term_+_»">
                                          <IdentNode start="(277, 58)" end="(277, 67)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                          <AtomNode start="(277, 68)" end="(277, 69)" leading="" trailing=" " val="+"/>
                                          <OtherNode start="(277, 70)" end="(277, 71)" kind="num">
                                            <AtomNode start="(277, 70)" end="(277, 71)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(277, 72)" end="(277, 73)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(277, 74)" end="(277, 75)" kind="num">
                                          <AtomNode start="(277, 74)" end="(277, 75)" leading="" trailing=" " val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(277, 76)" end="(277, 78)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(277, 79)" end="(277, 110)">
                                  <AtomNode start="(277, 79)" end="(277, 81)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(277, 82)" end="(277, 110)">
                                    <TacticTacticseq1IndentedNode start="(277, 82)" end="(277, 110)">
                                      <NullNode start="(277, 82)" end="(277, 110)">
                                        <OtherNode start="(277, 82)" end="(277, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1" state_after="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1" tactic="simp [splitInTwo_snd]">
                                          <AtomNode start="(277, 82)" end="(277, 86)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(277, 87)" end="(277, 103)">
                                            <AtomNode start="(277, 87)" end="(277, 88)" leading="" trailing="" val="["/>
                                            <NullNode start="(277, 88)" end="(277, 102)">
                                              <OtherNode start="(277, 88)" end="(277, 102)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(277, 88)" end="(277, 102)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(277, 102)" end="(277, 103)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(277, 103)" end="(277, 104)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(277, 105)" end="(277, 110)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(277, 105)" end="(277, 110)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(278, 5)" end="(280, 63)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;a b : α&#10;xs : List α&#10;le : α → α → Bool&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le ~&#10;    a :: b :: xs" state_after="no goals" tactic="exact (merge_perm_append le).trans&#10;  (((mergeSort_perm _ _).append (mergeSort_perm _ _)).trans&#10;    (Perm.of_eq (splitInTwo_fst_append_splitInTwo_snd _)))">
                            <AtomNode start="(278, 5)" end="(278, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(278, 11)" end="(280, 63)" kind="Lean.Parser.Term.app">
                              <OtherNode start="(278, 11)" end="(278, 39)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(278, 11)" end="(278, 33)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(278, 11)" end="(278, 12)" leading="" trailing="" val="("/>
                                  <OtherNode start="(278, 12)" end="(278, 32)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(278, 12)" end="(278, 29)" leading="" trailing=" " raw_val="merge_perm_append" val="merge_perm_append" full_name="List.merge_perm_append" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(251, 9)" def_end="(251, 26)"/>
                                    <NullNode start="(278, 30)" end="(278, 32)">
                                      <IdentNode start="(278, 30)" end="(278, 32)" leading="" trailing="" raw_val="le" val="le"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(278, 32)" end="(278, 33)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(278, 33)" end="(278, 34)" leading="" trailing="" val="."/>
                                <IdentNode start="(278, 34)" end="(278, 39)" leading="" trailing="&#10;      " raw_val="trans" val="trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              </OtherNode>
                              <NullNode start="(279, 7)" end="(280, 63)">
                                <OtherNode start="(279, 7)" end="(280, 63)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(279, 7)" end="(279, 8)" leading="" trailing="" val="("/>
                                  <OtherNode start="(279, 8)" end="(280, 62)" kind="Lean.Parser.Term.app">
                                    <OtherNode start="(279, 8)" end="(279, 64)" kind="Lean.Parser.Term.proj">
                                      <OtherNode start="(279, 8)" end="(279, 58)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(279, 8)" end="(279, 9)" leading="" trailing="" val="("/>
                                        <OtherNode start="(279, 9)" end="(279, 57)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(279, 9)" end="(279, 36)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(279, 9)" end="(279, 29)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(279, 9)" end="(279, 10)" leading="" trailing="" val="("/>
                                              <OtherNode start="(279, 10)" end="(279, 28)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(279, 10)" end="(279, 24)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm"/>
                                                <NullNode start="(279, 25)" end="(279, 28)">
                                                  <TermHoleNode start="(279, 25)" end="(279, 26)">
                                                    <AtomNode start="(279, 25)" end="(279, 26)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <TermHoleNode start="(279, 27)" end="(279, 28)">
                                                    <AtomNode start="(279, 27)" end="(279, 28)" leading="" trailing="" val="_"/>
                                                  </TermHoleNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(279, 28)" end="(279, 29)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(279, 29)" end="(279, 30)" leading="" trailing="" val="."/>
                                            <IdentNode start="(279, 30)" end="(279, 36)" leading="" trailing=" " raw_val="append" val="append" full_name="List.Perm.append" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                                          </OtherNode>
                                          <NullNode start="(279, 37)" end="(279, 57)">
                                            <OtherNode start="(279, 37)" end="(279, 57)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(279, 37)" end="(279, 38)" leading="" trailing="" val="("/>
                                              <OtherNode start="(279, 38)" end="(279, 56)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(279, 38)" end="(279, 52)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm"/>
                                                <NullNode start="(279, 53)" end="(279, 56)">
                                                  <TermHoleNode start="(279, 53)" end="(279, 54)">
                                                    <AtomNode start="(279, 53)" end="(279, 54)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <TermHoleNode start="(279, 55)" end="(279, 56)">
                                                    <AtomNode start="(279, 55)" end="(279, 56)" leading="" trailing="" val="_"/>
                                                  </TermHoleNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(279, 56)" end="(279, 57)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(279, 57)" end="(279, 58)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(279, 58)" end="(279, 59)" leading="" trailing="" val="."/>
                                      <IdentNode start="(279, 59)" end="(279, 64)" leading="" trailing="&#10;        " raw_val="trans" val="trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    </OtherNode>
                                    <NullNode start="(280, 9)" end="(280, 62)">
                                      <OtherNode start="(280, 9)" end="(280, 62)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(280, 9)" end="(280, 10)" leading="" trailing="" val="("/>
                                        <OtherNode start="(280, 10)" end="(280, 61)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(280, 10)" end="(280, 20)" leading="" trailing=" " raw_val="Perm.of_eq" val="Perm.of_eq" full_name="List.Perm.of_eq" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                                          <NullNode start="(280, 21)" end="(280, 61)">
                                            <OtherNode start="(280, 21)" end="(280, 61)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(280, 21)" end="(280, 22)" leading="" trailing="" val="("/>
                                              <OtherNode start="(280, 22)" end="(280, 60)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(280, 22)" end="(280, 58)" leading="" trailing=" " raw_val="splitInTwo_fst_append_splitInTwo_snd" val="splitInTwo_fst_append_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_append_splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(43, 9)" def_end="(43, 45)"/>
                                                <NullNode start="(280, 59)" end="(280, 60)">
                                                  <TermHoleNode start="(280, 59)" end="(280, 60)">
                                                    <AtomNode start="(280, 59)" end="(280, 60)" leading="" trailing="" val="_"/>
                                                  </TermHoleNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(280, 60)" end="(280, 61)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(280, 61)" end="(280, 62)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(280, 62)" end="(280, 63)" leading="" trailing="&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode start="(281, 1)" end="(281, 29)" kind="Lean.Parser.Termination.suffix">
              <NullNode start="(281, 1)" end="(281, 29)">
                <OtherNode start="(281, 1)" end="(281, 29)" kind="Lean.Parser.Termination.terminationBy">
                  <AtomNode start="(281, 1)" end="(281, 15)" leading="" trailing=" " val="termination_by"/>
                  <NullNode/>
                  <NullNode start="(281, 16)" end="(281, 20)">
                    <NullNode start="(281, 16)" end="(281, 17)">
                      <IdentNode start="(281, 16)" end="(281, 17)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                    <AtomNode start="(281, 18)" end="(281, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  </NullNode>
                  <IdentNode start="(281, 21)" end="(281, 29)" leading="" trailing="&#10;&#10;" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(283, 1)" end="(284, 34)" name="length_mergeSort" full_name="List.length_mergeSort">
      <CommandDeclmodifiersNode start="(283, 1)" end="(283, 8)">
        <NullNode/>
        <NullNode start="(283, 1)" end="(283, 8)">
          <OtherNode start="(283, 1)" end="(283, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(283, 1)" end="(283, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(283, 3)" end="(283, 7)">
              <OtherNode start="(283, 3)" end="(283, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(283, 3)" end="(283, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(283, 3)" end="(283, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(283, 7)" end="(283, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(283, 9)" end="(284, 34)" name="length_mergeSort" full_name="List.length_mergeSort" _is_private_decl="False">
        <AtomNode start="(283, 9)" end="(283, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(283, 17)" end="(283, 33)">
          <IdentNode start="(283, 17)" end="(283, 33)" leading="" trailing=" " raw_val="length_mergeSort" val="length_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(283, 34)" end="(283, 83)">
          <NullNode start="(283, 34)" end="(283, 46)">
            <TermExplicitbinderNode start="(283, 34)" end="(283, 46)">
              <AtomNode start="(283, 34)" end="(283, 35)" leading="" trailing="" val="("/>
              <NullNode start="(283, 35)" end="(283, 36)">
                <IdentNode start="(283, 35)" end="(283, 36)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(283, 37)" end="(283, 45)">
                <AtomNode start="(283, 37)" end="(283, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(283, 39)" end="(283, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(283, 39)" end="(283, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(283, 44)" end="(283, 45)">
                    <IdentNode start="(283, 44)" end="(283, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(283, 45)" end="(283, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(283, 47)" end="(283, 83)">
            <AtomNode start="(283, 47)" end="(283, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(283, 49)" end="(283, 83)" kind="«term_=_»">
              <OtherNode start="(283, 49)" end="(283, 72)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(283, 49)" end="(283, 65)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(283, 49)" end="(283, 50)" leading="" trailing="" val="("/>
                  <OtherNode start="(283, 50)" end="(283, 64)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(283, 50)" end="(283, 59)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(283, 60)" end="(283, 64)">
                      <IdentNode start="(283, 60)" end="(283, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(283, 62)" end="(283, 64)" leading="" trailing="" raw_val="le" val="le"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(283, 64)" end="(283, 65)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(283, 65)" end="(283, 66)" leading="" trailing="" val="."/>
                <IdentNode start="(283, 66)" end="(283, 72)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(283, 73)" end="(283, 74)" leading="" trailing=" " val="="/>
              <IdentNode start="(283, 75)" end="(283, 83)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(283, 84)" end="(284, 34)">
          <AtomNode start="(283, 84)" end="(283, 86)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(284, 3)" end="(284, 34)" kind="Lean.Parser.Term.proj">
            <OtherNode start="(284, 3)" end="(284, 24)" kind="Lean.Parser.Term.paren">
              <AtomNode start="(284, 3)" end="(284, 4)" leading="" trailing="" val="("/>
              <OtherNode start="(284, 4)" end="(284, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(284, 4)" end="(284, 18)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm" full_name="List.mergeSort_perm" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(271, 9)" def_end="(271, 23)"/>
                <NullNode start="(284, 19)" end="(284, 23)">
                  <IdentNode start="(284, 19)" end="(284, 20)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(284, 21)" end="(284, 23)" leading="" trailing="" raw_val="le" val="le"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(284, 23)" end="(284, 24)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(284, 24)" end="(284, 25)" leading="" trailing="" val="."/>
            <IdentNode start="(284, 25)" end="(284, 34)" leading="" trailing="&#10;&#10;" raw_val="length_eq" val="length_eq" full_name="List.Perm.length_eq" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(286, 1)" end="(287, 32)" name="mem_mergeSort" full_name="List.mem_mergeSort">
      <CommandDeclmodifiersNode start="(286, 1)" end="(286, 8)">
        <NullNode/>
        <NullNode start="(286, 1)" end="(286, 8)">
          <OtherNode start="(286, 1)" end="(286, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(286, 1)" end="(286, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(286, 3)" end="(286, 7)">
              <OtherNode start="(286, 3)" end="(286, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(286, 3)" end="(286, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(286, 3)" end="(286, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(286, 7)" end="(286, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(286, 9)" end="(287, 32)" name="mem_mergeSort" full_name="List.mem_mergeSort" _is_private_decl="False">
        <AtomNode start="(286, 9)" end="(286, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(286, 17)" end="(286, 30)">
          <IdentNode start="(286, 17)" end="(286, 30)" leading="" trailing=" " raw_val="mem_mergeSort" val="mem_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(286, 31)" end="(286, 80)">
          <NullNode start="(286, 31)" end="(286, 51)">
            <OtherNode start="(286, 31)" end="(286, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(286, 31)" end="(286, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(286, 32)" end="(286, 33)">
                <IdentNode start="(286, 32)" end="(286, 33)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(286, 34)" end="(286, 37)">
                <AtomNode start="(286, 34)" end="(286, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(286, 36)" end="(286, 37)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(286, 37)" end="(286, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(286, 39)" end="(286, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(286, 39)" end="(286, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(286, 40)" end="(286, 41)">
                <IdentNode start="(286, 40)" end="(286, 41)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(286, 42)" end="(286, 50)">
                <AtomNode start="(286, 42)" end="(286, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(286, 44)" end="(286, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(286, 44)" end="(286, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(286, 49)" end="(286, 50)">
                    <IdentNode start="(286, 49)" end="(286, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(286, 50)" end="(286, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(286, 52)" end="(286, 80)">
            <AtomNode start="(286, 52)" end="(286, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(286, 54)" end="(286, 80)" kind="«term_↔_»">
              <OtherNode start="(286, 54)" end="(286, 72)" kind="«term_∈_»">
                <IdentNode start="(286, 54)" end="(286, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(286, 56)" end="(286, 57)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(286, 58)" end="(286, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(286, 58)" end="(286, 67)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(286, 68)" end="(286, 72)">
                    <IdentNode start="(286, 68)" end="(286, 69)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(286, 70)" end="(286, 72)" leading="" trailing=" " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(286, 73)" end="(286, 74)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(286, 75)" end="(286, 80)" kind="«term_∈_»">
                <IdentNode start="(286, 75)" end="(286, 76)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(286, 77)" end="(286, 78)" leading="" trailing=" " val="∈"/>
                <IdentNode start="(286, 79)" end="(286, 80)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(286, 81)" end="(287, 32)">
          <AtomNode start="(286, 81)" end="(286, 83)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(287, 3)" end="(287, 32)" kind="Lean.Parser.Term.proj">
            <OtherNode start="(287, 3)" end="(287, 24)" kind="Lean.Parser.Term.paren">
              <AtomNode start="(287, 3)" end="(287, 4)" leading="" trailing="" val="("/>
              <OtherNode start="(287, 4)" end="(287, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(287, 4)" end="(287, 18)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm" full_name="List.mergeSort_perm" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(271, 9)" def_end="(271, 23)"/>
                <NullNode start="(287, 19)" end="(287, 23)">
                  <IdentNode start="(287, 19)" end="(287, 20)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(287, 21)" end="(287, 23)" leading="" trailing="" raw_val="le" val="le"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(287, 23)" end="(287, 24)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(287, 24)" end="(287, 25)" leading="" trailing="" val="."/>
            <IdentNode start="(287, 25)" end="(287, 32)" leading="" trailing="&#10;&#10;" raw_val="mem_iff" val="mem_iff" full_name="List.Perm.mem_iff" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(289, 1)" end="(307, 29)" name="sorted_mergeSort" full_name="List.sorted_mergeSort">
      <CommandDeclmodifiersNode start="(289, 1)" end="(295, 3)">
        <NullNode start="(289, 1)" end="(295, 3)">
          <CommandDoccommentNode start="(289, 1)" end="(295, 3)" comment="The result of `mergeSort` is sorted,&#10;as long as the comparison function is transitive (`le a b → le b c → le a c`)&#10;and total in the sense that `le a b || le b a`.&#10;&#10;The comparison function need not be irreflexive, i.e. `le a b` and `le b a` is allowed even when `a ≠ b`.&#10;-/">
            <AtomNode start="(289, 1)" end="(289, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(290, 1)" end="(295, 3)" leading="" trailing="&#10;" val="The result of `mergeSort` is sorted,&#10;as long as the comparison function is transitive (`le a b → le b c → le a c`)&#10;and total in the sense that `le a b || le b a`.&#10;&#10;The comparison function need not be irreflexive, i.e. `le a b` and `le b a` is allowed even when `a ≠ b`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(296, 1)" end="(307, 29)" name="sorted_mergeSort" full_name="List.sorted_mergeSort" _is_private_decl="False">
        <AtomNode start="(296, 1)" end="(296, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(296, 9)" end="(296, 25)">
          <IdentNode start="(296, 9)" end="(296, 25)" leading="" trailing="&#10;    " raw_val="sorted_mergeSort" val="sorted_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(297, 5)" end="(299, 48)">
          <NullNode start="(297, 5)" end="(298, 44)">
            <TermExplicitbinderNode start="(297, 5)" end="(297, 54)">
              <AtomNode start="(297, 5)" end="(297, 6)" leading="" trailing="" val="("/>
              <NullNode start="(297, 6)" end="(297, 11)">
                <IdentNode start="(297, 6)" end="(297, 11)" leading="" trailing=" " raw_val="trans" val="trans"/>
              </NullNode>
              <NullNode start="(297, 12)" end="(297, 53)">
                <AtomNode start="(297, 12)" end="(297, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(297, 14)" end="(297, 53)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(297, 14)" end="(297, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(297, 16)" end="(297, 27)">
                    <TermExplicitbinderNode start="(297, 16)" end="(297, 27)">
                      <AtomNode start="(297, 16)" end="(297, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(297, 17)" end="(297, 22)">
                        <IdentNode start="(297, 17)" end="(297, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(297, 19)" end="(297, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(297, 21)" end="(297, 22)" leading="" trailing=" " raw_val="c" val="c"/>
                      </NullNode>
                      <NullNode start="(297, 23)" end="(297, 26)">
                        <AtomNode start="(297, 23)" end="(297, 24)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(297, 25)" end="(297, 26)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(297, 26)" end="(297, 27)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(297, 27)" end="(297, 28)" leading="" trailing=" " val=","/>
                  <OtherNode start="(297, 29)" end="(297, 53)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(297, 29)" end="(297, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(297, 29)" end="(297, 31)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(297, 32)" end="(297, 35)">
                        <IdentNode start="(297, 32)" end="(297, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(297, 34)" end="(297, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(297, 36)" end="(297, 37)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(297, 38)" end="(297, 53)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(297, 38)" end="(297, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(297, 38)" end="(297, 40)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(297, 41)" end="(297, 44)">
                          <IdentNode start="(297, 41)" end="(297, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(297, 43)" end="(297, 44)" leading="" trailing=" " raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(297, 45)" end="(297, 46)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(297, 47)" end="(297, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(297, 47)" end="(297, 49)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(297, 50)" end="(297, 53)">
                          <IdentNode start="(297, 50)" end="(297, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(297, 52)" end="(297, 53)" leading="" trailing="" raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(297, 53)" end="(297, 54)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(298, 5)" end="(298, 44)">
              <AtomNode start="(298, 5)" end="(298, 6)" leading="" trailing="" val="("/>
              <NullNode start="(298, 6)" end="(298, 11)">
                <IdentNode start="(298, 6)" end="(298, 11)" leading="" trailing=" " raw_val="total" val="total"/>
              </NullNode>
              <NullNode start="(298, 12)" end="(298, 43)">
                <AtomNode start="(298, 12)" end="(298, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(298, 14)" end="(298, 43)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(298, 14)" end="(298, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(298, 16)" end="(298, 25)">
                    <TermExplicitbinderNode start="(298, 16)" end="(298, 25)">
                      <AtomNode start="(298, 16)" end="(298, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(298, 17)" end="(298, 20)">
                        <IdentNode start="(298, 17)" end="(298, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(298, 19)" end="(298, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode start="(298, 21)" end="(298, 24)">
                        <AtomNode start="(298, 21)" end="(298, 22)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(298, 23)" end="(298, 24)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(298, 24)" end="(298, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(298, 25)" end="(298, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(298, 27)" end="(298, 43)" kind="«term_||_»">
                    <OtherNode start="(298, 27)" end="(298, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(298, 27)" end="(298, 29)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(298, 30)" end="(298, 33)">
                        <IdentNode start="(298, 30)" end="(298, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(298, 32)" end="(298, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(298, 34)" end="(298, 36)" leading="" trailing=" " val="||"/>
                    <OtherNode start="(298, 37)" end="(298, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(298, 37)" end="(298, 39)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(298, 40)" end="(298, 43)">
                        <IdentNode start="(298, 40)" end="(298, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(298, 42)" end="(298, 43)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(298, 43)" end="(298, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(298, 45)" end="(299, 48)">
            <AtomNode start="(298, 45)" end="(298, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(299, 5)" end="(299, 48)" kind="Lean.Parser.Term.depArrow">
              <TermExplicitbinderNode start="(299, 5)" end="(299, 17)">
                <AtomNode start="(299, 5)" end="(299, 6)" leading="" trailing="" val="("/>
                <NullNode start="(299, 6)" end="(299, 7)">
                  <IdentNode start="(299, 6)" end="(299, 7)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
                <NullNode start="(299, 8)" end="(299, 16)">
                  <AtomNode start="(299, 8)" end="(299, 9)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(299, 10)" end="(299, 16)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(299, 10)" end="(299, 14)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(299, 15)" end="(299, 16)">
                      <IdentNode start="(299, 15)" end="(299, 16)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(299, 16)" end="(299, 17)" leading="" trailing=" " val=")"/>
              </TermExplicitbinderNode>
              <AtomNode start="(299, 18)" end="(299, 19)" leading="" trailing=" " val="→"/>
              <OtherNode start="(299, 20)" end="(299, 48)" kind="Lean.Parser.Term.app">
                <OtherNode start="(299, 20)" end="(299, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(299, 20)" end="(299, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(299, 20)" end="(299, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(299, 21)" end="(299, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(299, 21)" end="(299, 30)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                      <NullNode start="(299, 31)" end="(299, 35)">
                        <IdentNode start="(299, 31)" end="(299, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(299, 33)" end="(299, 35)" leading="" trailing="" raw_val="le" val="le"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(299, 35)" end="(299, 36)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(299, 36)" end="(299, 37)" leading="" trailing="" val="."/>
                  <IdentNode start="(299, 37)" end="(299, 45)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(299, 46)" end="(299, 48)">
                  <IdentNode start="(299, 46)" end="(299, 48)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(300, 3)" end="(307, 29)">
          <OtherNode start="(300, 3)" end="(307, 29)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(300, 3)" end="(306, 39)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(300, 3)" end="(306, 39)">
                <OtherNode start="(300, 3)" end="(300, 30)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(300, 3)" end="(300, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(300, 5)" end="(300, 7)">
                    <NullNode start="(300, 5)" end="(300, 7)">
                      <OtherNode start="(300, 5)" end="(300, 7)" kind="«term[_]»">
                        <AtomNode start="(300, 5)" end="(300, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(300, 6)" end="(300, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(300, 8)" end="(300, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(300, 11)" end="(300, 30)">
                    <AtomNode start="(300, 11)" end="(300, 13)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(300, 14)" end="(300, 30)">
                      <TacticTacticseq1IndentedNode start="(300, 14)" end="(300, 30)">
                        <NullNode start="(300, 14)" end="(300, 30)">
                          <OtherNode start="(300, 14)" end="(300, 30)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ([].mergeSort le)" state_after="no goals" tactic="simp [mergeSort]">
                            <AtomNode start="(300, 14)" end="(300, 18)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(300, 19)" end="(300, 30)">
                              <AtomNode start="(300, 19)" end="(300, 20)" leading="" trailing="" val="["/>
                              <NullNode start="(300, 20)" end="(300, 29)">
                                <OtherNode start="(300, 20)" end="(300, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(300, 20)" end="(300, 29)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(300, 29)" end="(300, 30)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(301, 3)" end="(301, 31)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(301, 3)" end="(301, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(301, 5)" end="(301, 8)">
                    <NullNode start="(301, 5)" end="(301, 8)">
                      <OtherNode start="(301, 5)" end="(301, 8)" kind="«term[_]»">
                        <AtomNode start="(301, 5)" end="(301, 6)" leading="" trailing="" val="["/>
                        <NullNode start="(301, 6)" end="(301, 7)">
                          <IdentNode start="(301, 6)" end="(301, 7)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                        <AtomNode start="(301, 7)" end="(301, 8)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(301, 9)" end="(301, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(301, 12)" end="(301, 31)">
                    <AtomNode start="(301, 12)" end="(301, 14)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(301, 15)" end="(301, 31)">
                      <TacticTacticseq1IndentedNode start="(301, 15)" end="(301, 31)">
                        <NullNode start="(301, 15)" end="(301, 31)">
                          <OtherNode start="(301, 15)" end="(301, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ([a].mergeSort le)" state_after="no goals" tactic="simp [mergeSort]">
                            <AtomNode start="(301, 15)" end="(301, 19)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(301, 20)" end="(301, 31)">
                              <AtomNode start="(301, 20)" end="(301, 21)" leading="" trailing="" val="["/>
                              <NullNode start="(301, 21)" end="(301, 30)">
                                <OtherNode start="(301, 21)" end="(301, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(301, 21)" end="(301, 30)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(301, 30)" end="(301, 31)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(302, 3)" end="(306, 39)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(302, 3)" end="(302, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(302, 5)" end="(302, 17)">
                    <NullNode start="(302, 5)" end="(302, 17)">
                      <OtherNode start="(302, 5)" end="(302, 17)" kind="«term_::_»">
                        <IdentNode start="(302, 5)" end="(302, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(302, 7)" end="(302, 9)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(302, 10)" end="(302, 17)" kind="«term_::_»">
                          <IdentNode start="(302, 10)" end="(302, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                          <AtomNode start="(302, 12)" end="(302, 14)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(302, 15)" end="(302, 17)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(302, 18)" end="(302, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(302, 21)" end="(306, 39)">
                    <AtomNode start="(302, 21)" end="(302, 23)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(303, 5)" end="(306, 39)">
                      <TacticTacticseq1IndentedNode start="(303, 5)" end="(306, 39)">
                        <NullNode start="(303, 5)" end="(306, 39)">
                          <OtherNode start="(303, 5)" end="(303, 19)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((a :: b :: xs).mergeSort le)" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true)&#10;    (((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le)&#10;      le)" tactic="rw [mergeSort]">
                            <AtomNode start="(303, 5)" end="(303, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(303, 8)" end="(303, 19)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(303, 8)" end="(303, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(303, 9)" end="(303, 18)">
                                <OtherNode start="(303, 9)" end="(303, 18)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(303, 9)" end="(303, 18)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(303, 18)" end="(303, 19)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(304, 5)" end="(304, 37)" kind="Lean.Parser.Tactic.apply" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true)&#10;    (((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le)&#10;      le)" state_after="case h₁&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le)&#10;&#10;case h₂&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le)" tactic="apply sorted_merge @trans @total">
                            <AtomNode start="(304, 5)" end="(304, 10)" leading="" trailing=" " val="apply"/>
                            <OtherNode start="(304, 11)" end="(304, 37)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(304, 11)" end="(304, 23)" leading="" trailing=" " raw_val="sorted_merge" val="sorted_merge" full_name="List.sorted_merge" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(209, 9)" def_end="(209, 21)"/>
                              <NullNode start="(304, 24)" end="(304, 37)">
                                <OtherNode start="(304, 24)" end="(304, 30)" kind="Lean.Parser.Term.explicit">
                                  <AtomNode start="(304, 24)" end="(304, 25)" leading="" trailing="" val="@"/>
                                  <IdentNode start="(304, 25)" end="(304, 30)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                </OtherNode>
                                <OtherNode start="(304, 31)" end="(304, 37)" kind="Lean.Parser.Term.explicit">
                                  <AtomNode start="(304, 31)" end="(304, 32)" leading="" trailing="" val="@"/>
                                  <IdentNode start="(304, 32)" end="(304, 37)" leading="" trailing="&#10;    " raw_val="total" val="total"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(305, 5)" end="(305, 39)" kind="Lean.Parser.Tactic.apply" state_before="case h₁&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le)&#10;&#10;case h₂&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le)" state_after="case h₂&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le)" tactic="apply sorted_mergeSort trans total">
                            <AtomNode start="(305, 5)" end="(305, 10)" leading="" trailing=" " val="apply"/>
                            <OtherNode start="(305, 11)" end="(305, 39)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(305, 11)" end="(305, 27)" leading="" trailing=" " raw_val="sorted_mergeSort" val="sorted_mergeSort"/>
                              <NullNode start="(305, 28)" end="(305, 39)">
                                <IdentNode start="(305, 28)" end="(305, 33)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                <IdentNode start="(305, 34)" end="(305, 39)" leading="" trailing="&#10;    " raw_val="total" val="total"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(306, 5)" end="(306, 39)" kind="Lean.Parser.Tactic.apply" state_before="case h₂&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a b : α&#10;xs : List α&#10;⊢ Pairwise (fun a b =&amp;gt; le a b = true) ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le)" state_after="no goals" tactic="apply sorted_mergeSort trans total">
                            <AtomNode start="(306, 5)" end="(306, 10)" leading="" trailing=" " val="apply"/>
                            <OtherNode start="(306, 11)" end="(306, 39)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(306, 11)" end="(306, 27)" leading="" trailing=" " raw_val="sorted_mergeSort" val="sorted_mergeSort"/>
                              <NullNode start="(306, 28)" end="(306, 39)">
                                <IdentNode start="(306, 28)" end="(306, 33)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                <IdentNode start="(306, 34)" end="(306, 39)" leading="" trailing="&#10;" raw_val="total" val="total"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode start="(307, 1)" end="(307, 29)" kind="Lean.Parser.Termination.suffix">
              <NullNode start="(307, 1)" end="(307, 29)">
                <OtherNode start="(307, 1)" end="(307, 29)" kind="Lean.Parser.Termination.terminationBy">
                  <AtomNode start="(307, 1)" end="(307, 15)" leading="" trailing=" " val="termination_by"/>
                  <NullNode/>
                  <NullNode start="(307, 16)" end="(307, 20)">
                    <NullNode start="(307, 16)" end="(307, 17)">
                      <IdentNode start="(307, 16)" end="(307, 17)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                    <AtomNode start="(307, 18)" end="(307, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  </NullNode>
                  <IdentNode start="(307, 21)" end="(307, 29)" leading="" trailing="&#10;&#10;" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(309, 1)" end="(309, 100)" name="mergeSort_sorted" full_name="List.mergeSort_sorted">
      <CommandDeclmodifiersNode start="(309, 1)" end="(309, 55)">
        <NullNode/>
        <NullNode start="(309, 1)" end="(309, 55)">
          <OtherNode start="(309, 1)" end="(309, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(309, 1)" end="(309, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(309, 3)" end="(309, 54)">
              <OtherNode start="(309, 3)" end="(309, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(309, 3)" end="(309, 54)" kind="Lean.deprecated">
                  <AtomNode start="(309, 3)" end="(309, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(309, 14)" end="(309, 30)">
                    <IdentNode start="(309, 14)" end="(309, 30)" leading="" trailing=" " raw_val="sorted_mergeSort" val="sorted_mergeSort" full_name="List.sorted_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(296, 9)" def_end="(296, 25)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(309, 31)" end="(309, 54)">
                    <AtomNode start="(309, 31)" end="(309, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(309, 32)" end="(309, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(309, 38)" end="(309, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(309, 41)" end="(309, 53)" kind="str">
                      <AtomNode start="(309, 41)" end="(309, 53)" leading="" trailing="" val="&amp;quot;2024-09-02&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(309, 53)" end="(309, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(309, 54)" end="(309, 55)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(309, 56)" end="(309, 100)" name="mergeSort_sorted">
        <AtomNode start="(309, 56)" end="(309, 62)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(309, 63)" end="(309, 79)">
          <IdentNode start="(309, 63)" end="(309, 79)" leading="" trailing=" " raw_val="mergeSort_sorted" val="mergeSort_sorted"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(309, 80)" end="(309, 100)">
          <AtomNode start="(309, 80)" end="(309, 82)" leading="" trailing=" " val=":="/>
          <OtherNode start="(309, 83)" end="(309, 100)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(309, 83)" end="(309, 84)" leading="" trailing="" val="@"/>
            <IdentNode start="(309, 84)" end="(309, 100)" leading="" trailing="&#10;&#10;" raw_val="sorted_mergeSort" val="sorted_mergeSort" full_name="List.sorted_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(296, 9)" def_end="(296, 25)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(311, 1)" end="(325, 29)" name="mergeSort_of_sorted" full_name="List.mergeSort_of_sorted">
      <CommandDeclmodifiersNode start="(311, 1)" end="(313, 3)">
        <NullNode start="(311, 1)" end="(313, 3)">
          <CommandDoccommentNode start="(311, 1)" end="(313, 3)" comment="If the input list is already sorted, then `mergeSort` does not change the list.&#10;-/">
            <AtomNode start="(311, 1)" end="(311, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(312, 1)" end="(313, 3)" leading="" trailing="&#10;" val="If the input list is already sorted, then `mergeSort` does not change the list.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(314, 1)" end="(325, 29)" name="mergeSort_of_sorted" full_name="List.mergeSort_of_sorted" _is_private_decl="False">
        <AtomNode start="(314, 1)" end="(314, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(314, 9)" end="(314, 28)">
          <IdentNode start="(314, 9)" end="(314, 28)" leading="" trailing=" " raw_val="mergeSort_of_sorted" val="mergeSort_of_sorted"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(314, 29)" end="(314, 85)">
          <NullNode/>
          <TermTypespecNode start="(314, 29)" end="(314, 85)">
            <AtomNode start="(314, 29)" end="(314, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(314, 31)" end="(314, 85)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(314, 31)" end="(314, 32)" leading="" trailing=" " val="∀"/>
              <NullNode start="(314, 33)" end="(314, 65)">
                <OtherNode start="(314, 33)" end="(314, 45)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(314, 33)" end="(314, 34)" leading="" trailing="" val="{"/>
                  <NullNode start="(314, 34)" end="(314, 35)">
                    <IdentNode start="(314, 34)" end="(314, 35)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(314, 36)" end="(314, 44)">
                    <AtomNode start="(314, 36)" end="(314, 37)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(314, 38)" end="(314, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(314, 38)" end="(314, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(314, 43)" end="(314, 44)">
                        <IdentNode start="(314, 43)" end="(314, 44)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(314, 44)" end="(314, 45)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <TermExplicitbinderNode start="(314, 46)" end="(314, 65)">
                  <AtomNode start="(314, 46)" end="(314, 47)" leading="" trailing="" val="("/>
                  <NullNode start="(314, 47)" end="(314, 48)">
                    <TermHoleNode start="(314, 47)" end="(314, 48)">
                      <AtomNode start="(314, 47)" end="(314, 48)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(314, 49)" end="(314, 64)">
                    <AtomNode start="(314, 49)" end="(314, 50)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(314, 51)" end="(314, 64)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(314, 51)" end="(314, 59)" leading="" trailing=" " raw_val="Pairwise" val="Pairwise" full_name="List.Pairwise" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(314, 60)" end="(314, 64)">
                        <IdentNode start="(314, 60)" end="(314, 62)" leading="" trailing=" " raw_val="le" val="le"/>
                        <IdentNode start="(314, 63)" end="(314, 64)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(314, 64)" end="(314, 65)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(314, 65)" end="(314, 66)" leading="" trailing=" " val=","/>
              <OtherNode start="(314, 67)" end="(314, 85)" kind="«term_=_»">
                <OtherNode start="(314, 67)" end="(314, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(314, 67)" end="(314, 76)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(314, 77)" end="(314, 81)">
                    <IdentNode start="(314, 77)" end="(314, 78)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(314, 79)" end="(314, 81)" leading="" trailing=" " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(314, 82)" end="(314, 83)" leading="" trailing=" " val="="/>
                <IdentNode start="(314, 84)" end="(314, 85)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(315, 3)" end="(325, 29)">
          <OtherNode start="(315, 3)" end="(325, 29)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(315, 3)" end="(324, 46)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(315, 3)" end="(324, 46)">
                <OtherNode start="(315, 3)" end="(315, 33)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(315, 3)" end="(315, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(315, 5)" end="(315, 10)">
                    <NullNode start="(315, 5)" end="(315, 10)">
                      <OtherNode start="(315, 5)" end="(315, 7)" kind="«term[_]»">
                        <AtomNode start="(315, 5)" end="(315, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(315, 6)" end="(315, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(315, 7)" end="(315, 8)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(315, 9)" end="(315, 10)">
                        <AtomNode start="(315, 9)" end="(315, 10)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(315, 11)" end="(315, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(315, 14)" end="(315, 33)">
                    <AtomNode start="(315, 14)" end="(315, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(315, 17)" end="(315, 33)">
                      <TacticTacticseq1IndentedNode start="(315, 17)" end="(315, 33)">
                        <NullNode start="(315, 17)" end="(315, 33)">
                          <OtherNode start="(315, 17)" end="(315, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;x✝ : Pairwise (fun a b =&amp;gt; le a b = true) []&#10;⊢ [].mergeSort le = []" state_after="no goals" tactic="simp [mergeSort]">
                            <AtomNode start="(315, 17)" end="(315, 21)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(315, 22)" end="(315, 33)">
                              <AtomNode start="(315, 22)" end="(315, 23)" leading="" trailing="" val="["/>
                              <NullNode start="(315, 23)" end="(315, 32)">
                                <OtherNode start="(315, 23)" end="(315, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(315, 23)" end="(315, 32)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(315, 32)" end="(315, 33)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(316, 3)" end="(316, 34)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(316, 3)" end="(316, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(316, 5)" end="(316, 11)">
                    <NullNode start="(316, 5)" end="(316, 11)">
                      <OtherNode start="(316, 5)" end="(316, 8)" kind="«term[_]»">
                        <AtomNode start="(316, 5)" end="(316, 6)" leading="" trailing="" val="["/>
                        <NullNode start="(316, 6)" end="(316, 7)">
                          <IdentNode start="(316, 6)" end="(316, 7)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                        <AtomNode start="(316, 7)" end="(316, 8)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(316, 8)" end="(316, 9)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(316, 10)" end="(316, 11)">
                        <AtomNode start="(316, 10)" end="(316, 11)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(316, 12)" end="(316, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(316, 15)" end="(316, 34)">
                    <AtomNode start="(316, 15)" end="(316, 17)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(316, 18)" end="(316, 34)">
                      <TacticTacticseq1IndentedNode start="(316, 18)" end="(316, 34)">
                        <NullNode start="(316, 18)" end="(316, 34)">
                          <OtherNode start="(316, 18)" end="(316, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a : α&#10;x✝ : Pairwise (fun a b =&amp;gt; le a b = true) [a]&#10;⊢ [a].mergeSort le = [a]" state_after="no goals" tactic="simp [mergeSort]">
                            <AtomNode start="(316, 18)" end="(316, 22)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(316, 23)" end="(316, 34)">
                              <AtomNode start="(316, 23)" end="(316, 24)" leading="" trailing="" val="["/>
                              <NullNode start="(316, 24)" end="(316, 33)">
                                <OtherNode start="(316, 24)" end="(316, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(316, 24)" end="(316, 33)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(316, 33)" end="(316, 34)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(317, 3)" end="(324, 46)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(317, 3)" end="(317, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(317, 5)" end="(317, 20)">
                    <NullNode start="(317, 5)" end="(317, 20)">
                      <OtherNode start="(317, 5)" end="(317, 17)" kind="«term_::_»">
                        <IdentNode start="(317, 5)" end="(317, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(317, 7)" end="(317, 9)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(317, 10)" end="(317, 17)" kind="«term_::_»">
                          <IdentNode start="(317, 10)" end="(317, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                          <AtomNode start="(317, 12)" end="(317, 14)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(317, 15)" end="(317, 17)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(317, 17)" end="(317, 18)" leading="" trailing=" " val=","/>
                      <IdentNode start="(317, 19)" end="(317, 20)" leading="" trailing=" " raw_val="h" val="h"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(317, 21)" end="(317, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(317, 24)" end="(324, 46)">
                    <AtomNode start="(317, 24)" end="(317, 26)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(318, 5)" end="(324, 46)">
                      <TacticTacticseq1IndentedNode start="(318, 5)" end="(324, 46)">
                        <NullNode start="(318, 5)" end="(324, 46)">
                          <OtherNode start="(318, 5)" end="(318, 110)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;⊢ (a :: b :: xs).mergeSort le = a :: b :: xs" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (a :: b :: xs).mergeSort le = a :: b :: xs" tactic="have : (splitInTwo ⟨a :: b :: xs, rfl⟩).1.1.length &amp;lt; xs.length + 1 + 1 := by simp [splitInTwo_fst]; omega">
                            <AtomNode start="(318, 5)" end="(318, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(318, 10)" end="(318, 110)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(318, 10)" end="(318, 110)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(318, 10)" end="(318, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(318, 10)" end="(318, 10)" kind="hygieneInfo">
                                    <IdentNode start="(318, 10)" end="(318, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(318, 10)" end="(318, 75)">
                                  <TermTypespecNode start="(318, 10)" end="(318, 75)">
                                    <AtomNode start="(318, 10)" end="(318, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(318, 12)" end="(318, 75)" kind="«term_&amp;lt;_»">
                                      <OtherNode start="(318, 12)" end="(318, 55)" kind="Lean.Parser.Term.proj">
                                        <OtherNode start="(318, 12)" end="(318, 48)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(318, 12)" end="(318, 46)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(318, 12)" end="(318, 44)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(318, 12)" end="(318, 13)" leading="" trailing="" val="("/>
                                              <OtherNode start="(318, 13)" end="(318, 43)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(318, 13)" end="(318, 23)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                <NullNode start="(318, 24)" end="(318, 43)">
                                                  <OtherNode start="(318, 24)" end="(318, 43)" kind="Lean.Parser.Term.anonymousCtor">
                                                    <AtomNode start="(318, 24)" end="(318, 25)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(318, 25)" end="(318, 42)">
                                                      <OtherNode start="(318, 25)" end="(318, 37)" kind="«term_::_»">
                                                        <IdentNode start="(318, 25)" end="(318, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <AtomNode start="(318, 27)" end="(318, 29)" leading="" trailing=" " val="::"/>
                                                        <OtherNode start="(318, 30)" end="(318, 37)" kind="«term_::_»">
                                                          <IdentNode start="(318, 30)" end="(318, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                                                          <AtomNode start="(318, 32)" end="(318, 34)" leading="" trailing=" " val="::"/>
                                                          <IdentNode start="(318, 35)" end="(318, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(318, 37)" end="(318, 38)" leading="" trailing=" " val=","/>
                                                      <IdentNode start="(318, 39)" end="(318, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </NullNode>
                                                    <AtomNode start="(318, 42)" end="(318, 43)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(318, 43)" end="(318, 44)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(318, 44)" end="(318, 45)" leading="" trailing="" val="."/>
                                            <OtherNode start="(318, 45)" end="(318, 46)" kind="fieldIdx">
                                              <AtomNode start="(318, 45)" end="(318, 46)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(318, 46)" end="(318, 47)" leading="" trailing="" val="."/>
                                          <OtherNode start="(318, 47)" end="(318, 48)" kind="fieldIdx">
                                            <AtomNode start="(318, 47)" end="(318, 48)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(318, 48)" end="(318, 49)" leading="" trailing="" val="."/>
                                        <IdentNode start="(318, 49)" end="(318, 55)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(318, 56)" end="(318, 57)" leading="" trailing=" " val="&amp;lt;"/>
                                      <OtherNode start="(318, 58)" end="(318, 75)" kind="«term_+_»">
                                        <OtherNode start="(318, 58)" end="(318, 71)" kind="«term_+_»">
                                          <IdentNode start="(318, 58)" end="(318, 67)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                          <AtomNode start="(318, 68)" end="(318, 69)" leading="" trailing=" " val="+"/>
                                          <OtherNode start="(318, 70)" end="(318, 71)" kind="num">
                                            <AtomNode start="(318, 70)" end="(318, 71)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(318, 72)" end="(318, 73)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(318, 74)" end="(318, 75)" kind="num">
                                          <AtomNode start="(318, 74)" end="(318, 75)" leading="" trailing=" " val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(318, 76)" end="(318, 78)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(318, 79)" end="(318, 110)">
                                  <AtomNode start="(318, 79)" end="(318, 81)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(318, 82)" end="(318, 110)">
                                    <TacticTacticseq1IndentedNode start="(318, 82)" end="(318, 110)">
                                      <NullNode start="(318, 82)" end="(318, 110)">
                                        <OtherNode start="(318, 82)" end="(318, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;⊢ min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1" tactic="simp [splitInTwo_fst]">
                                          <AtomNode start="(318, 82)" end="(318, 86)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(318, 87)" end="(318, 103)">
                                            <AtomNode start="(318, 87)" end="(318, 88)" leading="" trailing="" val="["/>
                                            <NullNode start="(318, 88)" end="(318, 102)">
                                              <OtherNode start="(318, 88)" end="(318, 102)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(318, 88)" end="(318, 102)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(318, 102)" end="(318, 103)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(318, 103)" end="(318, 104)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(318, 105)" end="(318, 110)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;⊢ min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(318, 105)" end="(318, 110)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(319, 5)" end="(319, 110)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (a :: b :: xs).mergeSort le = a :: b :: xs" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (a :: b :: xs).mergeSort le = a :: b :: xs" tactic="have : (splitInTwo ⟨a :: b :: xs, rfl⟩).2.1.length &amp;lt; xs.length + 1 + 1 := by simp [splitInTwo_snd]; omega">
                            <AtomNode start="(319, 5)" end="(319, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(319, 10)" end="(319, 110)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(319, 10)" end="(319, 110)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(319, 10)" end="(319, 10)" kind="Lean.Parser.Term.haveId">
                                  <OtherNode start="(319, 10)" end="(319, 10)" kind="hygieneInfo">
                                    <IdentNode start="(319, 10)" end="(319, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(319, 10)" end="(319, 75)">
                                  <TermTypespecNode start="(319, 10)" end="(319, 75)">
                                    <AtomNode start="(319, 10)" end="(319, 11)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(319, 12)" end="(319, 75)" kind="«term_&amp;lt;_»">
                                      <OtherNode start="(319, 12)" end="(319, 55)" kind="Lean.Parser.Term.proj">
                                        <OtherNode start="(319, 12)" end="(319, 48)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(319, 12)" end="(319, 46)" kind="Lean.Parser.Term.proj">
                                            <OtherNode start="(319, 12)" end="(319, 44)" kind="Lean.Parser.Term.paren">
                                              <AtomNode start="(319, 12)" end="(319, 13)" leading="" trailing="" val="("/>
                                              <OtherNode start="(319, 13)" end="(319, 43)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(319, 13)" end="(319, 23)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                <NullNode start="(319, 24)" end="(319, 43)">
                                                  <OtherNode start="(319, 24)" end="(319, 43)" kind="Lean.Parser.Term.anonymousCtor">
                                                    <AtomNode start="(319, 24)" end="(319, 25)" leading="" trailing="" val="⟨"/>
                                                    <NullNode start="(319, 25)" end="(319, 42)">
                                                      <OtherNode start="(319, 25)" end="(319, 37)" kind="«term_::_»">
                                                        <IdentNode start="(319, 25)" end="(319, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                        <AtomNode start="(319, 27)" end="(319, 29)" leading="" trailing=" " val="::"/>
                                                        <OtherNode start="(319, 30)" end="(319, 37)" kind="«term_::_»">
                                                          <IdentNode start="(319, 30)" end="(319, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                                                          <AtomNode start="(319, 32)" end="(319, 34)" leading="" trailing=" " val="::"/>
                                                          <IdentNode start="(319, 35)" end="(319, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <AtomNode start="(319, 37)" end="(319, 38)" leading="" trailing=" " val=","/>
                                                      <IdentNode start="(319, 39)" end="(319, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                    </NullNode>
                                                    <AtomNode start="(319, 42)" end="(319, 43)" leading="" trailing="" val="⟩"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <AtomNode start="(319, 43)" end="(319, 44)" leading="" trailing="" val=")"/>
                                            </OtherNode>
                                            <AtomNode start="(319, 44)" end="(319, 45)" leading="" trailing="" val="."/>
                                            <OtherNode start="(319, 45)" end="(319, 46)" kind="fieldIdx">
                                              <AtomNode start="(319, 45)" end="(319, 46)" leading="" trailing="" val="2"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(319, 46)" end="(319, 47)" leading="" trailing="" val="."/>
                                          <OtherNode start="(319, 47)" end="(319, 48)" kind="fieldIdx">
                                            <AtomNode start="(319, 47)" end="(319, 48)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(319, 48)" end="(319, 49)" leading="" trailing="" val="."/>
                                        <IdentNode start="(319, 49)" end="(319, 55)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(319, 56)" end="(319, 57)" leading="" trailing=" " val="&amp;lt;"/>
                                      <OtherNode start="(319, 58)" end="(319, 75)" kind="«term_+_»">
                                        <OtherNode start="(319, 58)" end="(319, 71)" kind="«term_+_»">
                                          <IdentNode start="(319, 58)" end="(319, 67)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                          <AtomNode start="(319, 68)" end="(319, 69)" leading="" trailing=" " val="+"/>
                                          <OtherNode start="(319, 70)" end="(319, 71)" kind="num">
                                            <AtomNode start="(319, 70)" end="(319, 71)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(319, 72)" end="(319, 73)" leading="" trailing=" " val="+"/>
                                        <OtherNode start="(319, 74)" end="(319, 75)" kind="num">
                                          <AtomNode start="(319, 74)" end="(319, 75)" leading="" trailing=" " val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(319, 76)" end="(319, 78)" leading="" trailing=" " val=":="/>
                                <TermBytacticNode start="(319, 79)" end="(319, 110)">
                                  <AtomNode start="(319, 79)" end="(319, 81)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(319, 82)" end="(319, 110)">
                                    <TacticTacticseq1IndentedNode start="(319, 82)" end="(319, 110)">
                                      <NullNode start="(319, 82)" end="(319, 110)">
                                        <OtherNode start="(319, 82)" end="(319, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1" tactic="simp [splitInTwo_snd]">
                                          <AtomNode start="(319, 82)" end="(319, 86)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(319, 87)" end="(319, 103)">
                                            <AtomNode start="(319, 87)" end="(319, 88)" leading="" trailing="" val="["/>
                                            <NullNode start="(319, 88)" end="(319, 102)">
                                              <OtherNode start="(319, 88)" end="(319, 102)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(319, 88)" end="(319, 102)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(319, 102)" end="(319, 103)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <AtomNode start="(319, 103)" end="(319, 104)" leading="" trailing=" " val=";"/>
                                        <OtherNode start="(319, 105)" end="(319, 110)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1" state_after="no goals" tactic="omega">
                                          <AtomNode start="(319, 105)" end="(319, 110)" leading="" trailing="&#10;    " val="omega"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(320, 5)" end="(320, 19)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (a :: b :: xs).mergeSort le = a :: b :: xs" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le =&#10;    a :: b :: xs" tactic="rw [mergeSort]">
                            <AtomNode start="(320, 5)" end="(320, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(320, 8)" end="(320, 19)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(320, 8)" end="(320, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(320, 9)" end="(320, 18)">
                                <OtherNode start="(320, 9)" end="(320, 18)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(320, 9)" end="(320, 18)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(320, 18)" end="(320, 19)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(321, 5)" end="(321, 75)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le =&#10;    a :: b :: xs" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le = a :: b :: xs" tactic="rw [mergeSort_of_sorted (splitInTwo_fst_sorted ⟨a :: b :: xs, rfl⟩ h)]">
                            <AtomNode start="(321, 5)" end="(321, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(321, 8)" end="(321, 75)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(321, 8)" end="(321, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(321, 9)" end="(321, 74)">
                                <OtherNode start="(321, 9)" end="(321, 74)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(321, 9)" end="(321, 74)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(321, 9)" end="(321, 28)" leading="" trailing=" " raw_val="mergeSort_of_sorted" val="mergeSort_of_sorted"/>
                                    <NullNode start="(321, 29)" end="(321, 74)">
                                      <OtherNode start="(321, 29)" end="(321, 74)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(321, 29)" end="(321, 30)" leading="" trailing="" val="("/>
                                        <OtherNode start="(321, 30)" end="(321, 73)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(321, 30)" end="(321, 51)" leading="" trailing=" " raw_val="splitInTwo_fst_sorted" val="splitInTwo_fst_sorted" full_name="List.MergeSort.Internal.splitInTwo_fst_sorted" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(78, 9)" def_end="(78, 30)"/>
                                          <NullNode start="(321, 52)" end="(321, 73)">
                                            <OtherNode start="(321, 52)" end="(321, 71)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(321, 52)" end="(321, 53)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(321, 53)" end="(321, 70)">
                                                <OtherNode start="(321, 53)" end="(321, 65)" kind="«term_::_»">
                                                  <IdentNode start="(321, 53)" end="(321, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                                                  <AtomNode start="(321, 55)" end="(321, 57)" leading="" trailing=" " val="::"/>
                                                  <OtherNode start="(321, 58)" end="(321, 65)" kind="«term_::_»">
                                                    <IdentNode start="(321, 58)" end="(321, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <AtomNode start="(321, 60)" end="(321, 62)" leading="" trailing=" " val="::"/>
                                                    <IdentNode start="(321, 63)" end="(321, 65)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(321, 65)" end="(321, 66)" leading="" trailing=" " val=","/>
                                                <IdentNode start="(321, 67)" end="(321, 70)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </NullNode>
                                              <AtomNode start="(321, 70)" end="(321, 71)" leading="" trailing=" " val="⟩"/>
                                            </OtherNode>
                                            <IdentNode start="(321, 72)" end="(321, 73)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(321, 73)" end="(321, 74)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(321, 74)" end="(321, 75)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(322, 5)" end="(322, 75)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le = a :: b :: xs" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.merge (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val le = a :: b :: xs" tactic="rw [mergeSort_of_sorted (splitInTwo_snd_sorted ⟨a :: b :: xs, rfl⟩ h)]">
                            <AtomNode start="(322, 5)" end="(322, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(322, 8)" end="(322, 75)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(322, 8)" end="(322, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(322, 9)" end="(322, 74)">
                                <OtherNode start="(322, 9)" end="(322, 74)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(322, 9)" end="(322, 74)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(322, 9)" end="(322, 28)" leading="" trailing=" " raw_val="mergeSort_of_sorted" val="mergeSort_of_sorted"/>
                                    <NullNode start="(322, 29)" end="(322, 74)">
                                      <OtherNode start="(322, 29)" end="(322, 74)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(322, 29)" end="(322, 30)" leading="" trailing="" val="("/>
                                        <OtherNode start="(322, 30)" end="(322, 73)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(322, 30)" end="(322, 51)" leading="" trailing=" " raw_val="splitInTwo_snd_sorted" val="splitInTwo_snd_sorted" full_name="List.MergeSort.Internal.splitInTwo_snd_sorted" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(82, 9)" def_end="(82, 30)"/>
                                          <NullNode start="(322, 52)" end="(322, 73)">
                                            <OtherNode start="(322, 52)" end="(322, 71)" kind="Lean.Parser.Term.anonymousCtor">
                                              <AtomNode start="(322, 52)" end="(322, 53)" leading="" trailing="" val="⟨"/>
                                              <NullNode start="(322, 53)" end="(322, 70)">
                                                <OtherNode start="(322, 53)" end="(322, 65)" kind="«term_::_»">
                                                  <IdentNode start="(322, 53)" end="(322, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                                                  <AtomNode start="(322, 55)" end="(322, 57)" leading="" trailing=" " val="::"/>
                                                  <OtherNode start="(322, 58)" end="(322, 65)" kind="«term_::_»">
                                                    <IdentNode start="(322, 58)" end="(322, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                                                    <AtomNode start="(322, 60)" end="(322, 62)" leading="" trailing=" " val="::"/>
                                                    <IdentNode start="(322, 63)" end="(322, 65)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(322, 65)" end="(322, 66)" leading="" trailing=" " val=","/>
                                                <IdentNode start="(322, 67)" end="(322, 70)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </NullNode>
                                              <AtomNode start="(322, 70)" end="(322, 71)" leading="" trailing=" " val="⟩"/>
                                            </OtherNode>
                                            <IdentNode start="(322, 72)" end="(322, 73)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(322, 73)" end="(322, 74)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(322, 74)" end="(322, 75)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(323, 5)" end="(323, 58)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.merge (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val le = a :: b :: xs" state_after="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val ++ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val = a :: b :: xs" tactic="rw [merge_of_le (splitInTwo_fst_le_splitInTwo_snd h)]">
                            <AtomNode start="(323, 5)" end="(323, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(323, 8)" end="(323, 58)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(323, 8)" end="(323, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(323, 9)" end="(323, 57)">
                                <OtherNode start="(323, 9)" end="(323, 57)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(323, 9)" end="(323, 57)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(323, 9)" end="(323, 20)" leading="" trailing=" " raw_val="merge_of_le" val="merge_of_le" full_name="List.merge_of_le" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(239, 9)" def_end="(239, 20)"/>
                                    <NullNode start="(323, 21)" end="(323, 57)">
                                      <OtherNode start="(323, 21)" end="(323, 57)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(323, 21)" end="(323, 22)" leading="" trailing="" val="("/>
                                        <OtherNode start="(323, 22)" end="(323, 56)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(323, 22)" end="(323, 54)" leading="" trailing=" " raw_val="splitInTwo_fst_le_splitInTwo_snd" val="splitInTwo_fst_le_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_le_splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(86, 9)" def_end="(86, 41)"/>
                                          <NullNode start="(323, 55)" end="(323, 56)">
                                            <IdentNode start="(323, 55)" end="(323, 56)" leading="" trailing="" raw_val="h" val="h"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(323, 56)" end="(323, 57)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(323, 57)" end="(323, 58)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(324, 5)" end="(324, 46)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;xs : List α&#10;h : Pairwise (fun a b =&amp;gt; le a b = true) (a :: b :: xs)&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val ++ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val = a :: b :: xs" state_after="no goals" tactic="rw [splitInTwo_fst_append_splitInTwo_snd]">
                            <AtomNode start="(324, 5)" end="(324, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(324, 8)" end="(324, 46)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(324, 8)" end="(324, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(324, 9)" end="(324, 45)">
                                <OtherNode start="(324, 9)" end="(324, 45)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(324, 9)" end="(324, 45)" leading="" trailing="" raw_val="splitInTwo_fst_append_splitInTwo_snd" val="splitInTwo_fst_append_splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_fst_append_splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(43, 9)" def_end="(43, 45)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(324, 45)" end="(324, 46)" leading="" trailing="&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode start="(325, 1)" end="(325, 29)" kind="Lean.Parser.Termination.suffix">
              <NullNode start="(325, 1)" end="(325, 29)">
                <OtherNode start="(325, 1)" end="(325, 29)" kind="Lean.Parser.Termination.terminationBy">
                  <AtomNode start="(325, 1)" end="(325, 15)" leading="" trailing=" " val="termination_by"/>
                  <NullNode/>
                  <NullNode start="(325, 16)" end="(325, 20)">
                    <NullNode start="(325, 16)" end="(325, 17)">
                      <IdentNode start="(325, 16)" end="(325, 17)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                    <AtomNode start="(325, 18)" end="(325, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  </NullNode>
                  <IdentNode start="(325, 21)" end="(325, 29)" leading="" trailing="&#10;&#10;" raw_val="l.length" val="l.length"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(327, 1)" end="(360, 31)" name="mergeSort_zipIdx" full_name="List.mergeSort_zipIdx">
      <CommandDeclmodifiersNode start="(327, 1)" end="(338, 3)">
        <NullNode start="(327, 1)" end="(338, 3)">
          <CommandDoccommentNode start="(327, 1)" end="(338, 3)" comment="This merge sort algorithm is stable,&#10;in the sense that breaking ties in the ordering function using the position in the list&#10;has no effect on the output.&#10;&#10;That is, elements which are equal with respect to the ordering function will remain&#10;in the same order in the output list as they were in the input list.&#10;&#10;See also:&#10;* `sublist_mergeSort`: if `c &amp;lt;+ l` and `c.Pairwise le`, then `c &amp;lt;+ mergeSort le l`.&#10;* `pair_sublist_mergeSort`: if `[a, b] &amp;lt;+ l` and `le a b`, then `[a, b] &amp;lt;+ mergeSort le l`)&#10;-/">
            <AtomNode start="(327, 1)" end="(327, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(328, 1)" end="(338, 3)" leading="" trailing="&#10;" val="This merge sort algorithm is stable,&#10;in the sense that breaking ties in the ordering function using the position in the list&#10;has no effect on the output.&#10;&#10;That is, elements which are equal with respect to the ordering function will remain&#10;in the same order in the output list as they were in the input list.&#10;&#10;See also:&#10;* `sublist_mergeSort`: if `c &amp;lt;+ l` and `c.Pairwise le`, then `c &amp;lt;+ mergeSort le l`.&#10;* `pair_sublist_mergeSort`: if `[a, b] &amp;lt;+ l` and `le a b`, then `[a, b] &amp;lt;+ mergeSort le l`)&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(339, 1)" end="(360, 31)" name="mergeSort_zipIdx" full_name="List.mergeSort_zipIdx" _is_private_decl="False">
        <AtomNode start="(339, 1)" end="(339, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(339, 9)" end="(339, 25)">
          <IdentNode start="(339, 9)" end="(339, 25)" leading="" trailing=" " raw_val="mergeSort_zipIdx" val="mergeSort_zipIdx"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(339, 26)" end="(340, 68)">
          <NullNode start="(339, 26)" end="(339, 38)">
            <OtherNode start="(339, 26)" end="(339, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(339, 26)" end="(339, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(339, 27)" end="(339, 28)">
                <IdentNode start="(339, 27)" end="(339, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(339, 29)" end="(339, 37)">
                <AtomNode start="(339, 29)" end="(339, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(339, 31)" end="(339, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(339, 31)" end="(339, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(339, 36)" end="(339, 37)">
                    <IdentNode start="(339, 36)" end="(339, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(339, 37)" end="(339, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(339, 39)" end="(340, 68)">
            <AtomNode start="(339, 39)" end="(339, 40)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(340, 5)" end="(340, 68)" kind="«term_=_»">
              <OtherNode start="(340, 5)" end="(340, 51)" kind="Lean.Parser.Term.app">
                <OtherNode start="(340, 5)" end="(340, 45)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(340, 5)" end="(340, 41)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(340, 5)" end="(340, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(340, 6)" end="(340, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(340, 6)" end="(340, 15)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                      <NullNode start="(340, 16)" end="(340, 40)">
                        <OtherNode start="(340, 16)" end="(340, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(340, 16)" end="(340, 17)" leading="" trailing="" val="("/>
                          <IdentNode start="(340, 17)" end="(340, 25)" leading="" trailing="" raw_val="l.zipIdx" val="l.zipIdx"/>
                          <AtomNode start="(340, 25)" end="(340, 26)" leading="" trailing=" " val=")"/>
                        </OtherNode>
                        <OtherNode start="(340, 27)" end="(340, 40)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(340, 27)" end="(340, 28)" leading="" trailing="" val="("/>
                          <OtherNode start="(340, 28)" end="(340, 39)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(340, 28)" end="(340, 36)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                            <NullNode start="(340, 37)" end="(340, 39)">
                              <IdentNode start="(340, 37)" end="(340, 39)" leading="" trailing="" raw_val="le" val="le"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(340, 39)" end="(340, 40)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(340, 40)" end="(340, 41)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(340, 41)" end="(340, 42)" leading="" trailing="" val="."/>
                  <IdentNode start="(340, 42)" end="(340, 45)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(340, 46)" end="(340, 51)">
                  <OtherNode start="(340, 46)" end="(340, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(340, 46)" end="(340, 47)" leading="" trailing="" val="("/>
                    <OtherNode start="(340, 47)" end="(340, 50)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(340, 47)" end="(340, 48)" kind="Lean.Parser.Term.cdot">
                        <AtomNode start="(340, 47)" end="(340, 48)" leading="" trailing="" val="·"/>
                      </OtherNode>
                      <AtomNode start="(340, 48)" end="(340, 49)" leading="" trailing="" val="."/>
                      <OtherNode start="(340, 49)" end="(340, 50)" kind="fieldIdx">
                        <AtomNode start="(340, 49)" end="(340, 50)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(340, 50)" end="(340, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(340, 52)" end="(340, 53)" leading="" trailing=" " val="="/>
              <OtherNode start="(340, 54)" end="(340, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(340, 54)" end="(340, 63)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(340, 64)" end="(340, 68)">
                  <IdentNode start="(340, 64)" end="(340, 65)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(340, 66)" end="(340, 68)" leading="" trailing=" " raw_val="le" val="le"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(340, 69)" end="(360, 31)">
          <AtomNode start="(340, 69)" end="(340, 71)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(341, 3)" end="(341, 9)" kind="Lean.Parser.Term.app">
            <IdentNode start="(341, 3)" end="(341, 5)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(341, 6)" end="(341, 9)">
              <OtherNode start="(341, 6)" end="(341, 7)" kind="num">
                <AtomNode start="(341, 6)" end="(341, 7)" leading="" trailing=" " val="0"/>
              </OtherNode>
              <IdentNode start="(341, 8)" end="(341, 9)" leading="" trailing="&#10;" raw_val="l" val="l"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(342, 1)" end="(360, 31)">
            <OtherNode start="(342, 1)" end="(360, 31)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(342, 1)" end="(342, 6)" leading="" trailing=" " val="where"/>
              <NullNode start="(342, 7)" end="(360, 31)">
                <OtherNode start="(342, 7)" end="(360, 31)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(342, 7)" end="(359, 12)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(342, 7)" end="(359, 12)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(342, 7)" end="(342, 9)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(342, 10)" end="(343, 70)">
                        <TermTypespecNode start="(342, 10)" end="(343, 70)">
                          <AtomNode start="(342, 10)" end="(342, 11)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(342, 12)" end="(343, 70)" kind="Lean.Parser.Term.forall">
                            <AtomNode start="(342, 12)" end="(342, 13)" leading="" trailing=" " val="∀"/>
                            <NullNode start="(342, 14)" end="(342, 36)">
                              <TermExplicitbinderNode start="(342, 14)" end="(342, 23)">
                                <AtomNode start="(342, 14)" end="(342, 15)" leading="" trailing="" val="("/>
                                <NullNode start="(342, 15)" end="(342, 16)">
                                  <IdentNode start="(342, 15)" end="(342, 16)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                                <NullNode start="(342, 17)" end="(342, 22)">
                                  <AtomNode start="(342, 17)" end="(342, 18)" leading="" trailing=" " val=":"/>
                                  <IdentNode start="(342, 19)" end="(342, 22)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(342, 22)" end="(342, 23)" leading="" trailing=" " val=")"/>
                              </TermExplicitbinderNode>
                              <TermExplicitbinderNode start="(342, 24)" end="(342, 36)">
                                <AtomNode start="(342, 24)" end="(342, 25)" leading="" trailing="" val="("/>
                                <NullNode start="(342, 25)" end="(342, 26)">
                                  <IdentNode start="(342, 25)" end="(342, 26)" leading="" trailing=" " raw_val="l" val="l"/>
                                </NullNode>
                                <NullNode start="(342, 27)" end="(342, 35)">
                                  <AtomNode start="(342, 27)" end="(342, 28)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(342, 29)" end="(342, 35)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(342, 29)" end="(342, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(342, 34)" end="(342, 35)">
                                      <IdentNode start="(342, 34)" end="(342, 35)" leading="" trailing="" raw_val="α" val="α"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                                <NullNode/>
                                <AtomNode start="(342, 35)" end="(342, 36)" leading="" trailing="" val=")"/>
                              </TermExplicitbinderNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(342, 36)" end="(342, 37)" leading="" trailing="&#10;    " val=","/>
                            <OtherNode start="(343, 5)" end="(343, 70)" kind="«term_=_»">
                              <OtherNode start="(343, 5)" end="(343, 53)" kind="Lean.Parser.Term.app">
                                <OtherNode start="(343, 5)" end="(343, 47)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(343, 5)" end="(343, 43)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(343, 5)" end="(343, 6)" leading="" trailing="" val="("/>
                                    <OtherNode start="(343, 6)" end="(343, 42)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(343, 6)" end="(343, 15)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                      <NullNode start="(343, 16)" end="(343, 42)">
                                        <OtherNode start="(343, 16)" end="(343, 28)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(343, 16)" end="(343, 17)" leading="" trailing="" val="("/>
                                          <OtherNode start="(343, 17)" end="(343, 27)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(343, 17)" end="(343, 25)" leading="" trailing=" " raw_val="l.zipIdx" val="l.zipIdx"/>
                                            <NullNode start="(343, 26)" end="(343, 27)">
                                              <IdentNode start="(343, 26)" end="(343, 27)" leading="" trailing="" raw_val="i" val="i"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(343, 27)" end="(343, 28)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <OtherNode start="(343, 29)" end="(343, 42)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(343, 29)" end="(343, 30)" leading="" trailing="" val="("/>
                                          <OtherNode start="(343, 30)" end="(343, 41)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(343, 30)" end="(343, 38)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                            <NullNode start="(343, 39)" end="(343, 41)">
                                              <IdentNode start="(343, 39)" end="(343, 41)" leading="" trailing="" raw_val="le" val="le"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(343, 41)" end="(343, 42)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(343, 42)" end="(343, 43)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(343, 43)" end="(343, 44)" leading="" trailing="" val="."/>
                                  <IdentNode start="(343, 44)" end="(343, 47)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <NullNode start="(343, 48)" end="(343, 53)">
                                  <OtherNode start="(343, 48)" end="(343, 53)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(343, 48)" end="(343, 49)" leading="" trailing="" val="("/>
                                    <OtherNode start="(343, 49)" end="(343, 52)" kind="Lean.Parser.Term.proj">
                                      <OtherNode start="(343, 49)" end="(343, 50)" kind="Lean.Parser.Term.cdot">
                                        <AtomNode start="(343, 49)" end="(343, 50)" leading="" trailing="" val="·"/>
                                      </OtherNode>
                                      <AtomNode start="(343, 50)" end="(343, 51)" leading="" trailing="" val="."/>
                                      <OtherNode start="(343, 51)" end="(343, 52)" kind="fieldIdx">
                                        <AtomNode start="(343, 51)" end="(343, 52)" leading="" trailing="" val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(343, 52)" end="(343, 53)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(343, 54)" end="(343, 55)" leading="" trailing=" " val="="/>
                              <OtherNode start="(343, 56)" end="(343, 70)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(343, 56)" end="(343, 65)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                <NullNode start="(343, 66)" end="(343, 70)">
                                  <IdentNode start="(343, 66)" end="(343, 67)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(343, 68)" end="(343, 70)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(344, 3)" end="(359, 12)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(344, 3)" end="(359, 12)">
                          <OtherNode start="(344, 3)" end="(345, 34)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(344, 3)" end="(344, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(344, 5)" end="(345, 11)">
                              <NullNode start="(344, 5)" end="(344, 10)">
                                <TermHoleNode start="(344, 5)" end="(344, 6)">
                                  <AtomNode start="(344, 5)" end="(344, 6)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(344, 6)" end="(344, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(344, 8)" end="(344, 10)" kind="«term[_]»">
                                  <AtomNode start="(344, 8)" end="(344, 9)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(344, 9)" end="(344, 10)" leading="" trailing="&#10;  " val="]"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(345, 3)" end="(345, 4)" leading="" trailing=" " val="|"/>
                              <NullNode start="(345, 5)" end="(345, 11)">
                                <TermHoleNode start="(345, 5)" end="(345, 6)">
                                  <AtomNode start="(345, 5)" end="(345, 6)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(345, 6)" end="(345, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(345, 8)" end="(345, 11)" kind="«term[_]»">
                                  <AtomNode start="(345, 8)" end="(345, 9)" leading="" trailing="" val="["/>
                                  <NullNode start="(345, 9)" end="(345, 10)">
                                    <IdentNode start="(345, 9)" end="(345, 10)" leading="" trailing="" raw_val="a" val="a"/>
                                  </NullNode>
                                  <AtomNode start="(345, 10)" end="(345, 11)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(345, 12)" end="(345, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TermBytacticNode start="(345, 15)" end="(345, 34)">
                              <AtomNode start="(345, 15)" end="(345, 17)" leading="" trailing=" " val="by"/>
                              <TacticTacticseqNode start="(345, 18)" end="(345, 34)">
                                <TacticTacticseq1IndentedNode start="(345, 18)" end="(345, 34)">
                                  <NullNode start="(345, 18)" end="(345, 34)">
                                    <OtherNode start="(345, 18)" end="(345, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a : α&#10;⊢ map (fun x =&amp;gt; x.fst) (([a].zipIdx x✝).mergeSort (zipIdxLE le)) = [a].mergeSort le" state_after="no goals" tactic="simp [mergeSort]">
                                      <AtomNode start="(345, 18)" end="(345, 22)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(345, 23)" end="(345, 34)">
                                        <AtomNode start="(345, 23)" end="(345, 24)" leading="" trailing="" val="["/>
                                        <NullNode start="(345, 24)" end="(345, 33)">
                                          <OtherNode start="(345, 24)" end="(345, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(345, 24)" end="(345, 33)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(345, 33)" end="(345, 34)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </TermBytacticNode>
                          </OtherNode>
                          <OtherNode start="(346, 3)" end="(359, 12)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(346, 3)" end="(346, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(346, 5)" end="(346, 20)">
                              <NullNode start="(346, 5)" end="(346, 20)">
                                <TermHoleNode start="(346, 5)" end="(346, 6)">
                                  <AtomNode start="(346, 5)" end="(346, 6)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(346, 6)" end="(346, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(346, 8)" end="(346, 20)" kind="«term_::_»">
                                  <IdentNode start="(346, 8)" end="(346, 9)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(346, 10)" end="(346, 12)" leading="" trailing=" " val="::"/>
                                  <OtherNode start="(346, 13)" end="(346, 20)" kind="«term_::_»">
                                    <IdentNode start="(346, 13)" end="(346, 14)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <AtomNode start="(346, 15)" end="(346, 17)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(346, 18)" end="(346, 20)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(346, 21)" end="(346, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TermBytacticNode start="(346, 24)" end="(359, 12)">
                              <AtomNode start="(346, 24)" end="(346, 26)" leading="" trailing="&#10;    " val="by"/>
                              <TacticTacticseqNode start="(347, 5)" end="(359, 12)">
                                <TacticTacticseq1IndentedNode start="(347, 5)" end="(359, 12)">
                                  <NullNode start="(347, 5)" end="(359, 12)">
                                    <OtherNode start="(347, 5)" end="(347, 110)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;⊢ map (fun x =&amp;gt; x.fst) (((a :: b :: xs).zipIdx x✝).mergeSort (zipIdxLE le)) = (a :: b :: xs).mergeSort le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst) (((a :: b :: xs).zipIdx x✝).mergeSort (zipIdxLE le)) = (a :: b :: xs).mergeSort le" tactic="have : (splitInTwo ⟨a :: b :: xs, rfl⟩).1.1.length &amp;lt; xs.length + 1 + 1 := by simp [splitInTwo_fst]; omega">
                                      <AtomNode start="(347, 5)" end="(347, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(347, 10)" end="(347, 110)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(347, 10)" end="(347, 110)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(347, 10)" end="(347, 10)" kind="Lean.Parser.Term.haveId">
                                            <OtherNode start="(347, 10)" end="(347, 10)" kind="hygieneInfo">
                                              <IdentNode start="(347, 10)" end="(347, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(347, 10)" end="(347, 75)">
                                            <TermTypespecNode start="(347, 10)" end="(347, 75)">
                                              <AtomNode start="(347, 10)" end="(347, 11)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(347, 12)" end="(347, 75)" kind="«term_&amp;lt;_»">
                                                <OtherNode start="(347, 12)" end="(347, 55)" kind="Lean.Parser.Term.proj">
                                                  <OtherNode start="(347, 12)" end="(347, 48)" kind="Lean.Parser.Term.proj">
                                                    <OtherNode start="(347, 12)" end="(347, 46)" kind="Lean.Parser.Term.proj">
                                                      <OtherNode start="(347, 12)" end="(347, 44)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(347, 12)" end="(347, 13)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(347, 13)" end="(347, 43)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(347, 13)" end="(347, 23)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                          <NullNode start="(347, 24)" end="(347, 43)">
                                                            <OtherNode start="(347, 24)" end="(347, 43)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(347, 24)" end="(347, 25)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(347, 25)" end="(347, 42)">
                                                            <OtherNode start="(347, 25)" end="(347, 37)" kind="«term_::_»">
                                                            <IdentNode start="(347, 25)" end="(347, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <AtomNode start="(347, 27)" end="(347, 29)" leading="" trailing=" " val="::"/>
                                                            <OtherNode start="(347, 30)" end="(347, 37)" kind="«term_::_»">
                                                            <IdentNode start="(347, 30)" end="(347, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <AtomNode start="(347, 32)" end="(347, 34)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(347, 35)" end="(347, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(347, 37)" end="(347, 38)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(347, 39)" end="(347, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            <AtomNode start="(347, 42)" end="(347, 43)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(347, 43)" end="(347, 44)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                      <AtomNode start="(347, 44)" end="(347, 45)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(347, 45)" end="(347, 46)" kind="fieldIdx">
                                                        <AtomNode start="(347, 45)" end="(347, 46)" leading="" trailing="" val="1"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(347, 46)" end="(347, 47)" leading="" trailing="" val="."/>
                                                    <OtherNode start="(347, 47)" end="(347, 48)" kind="fieldIdx">
                                                      <AtomNode start="(347, 47)" end="(347, 48)" leading="" trailing="" val="1"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(347, 48)" end="(347, 49)" leading="" trailing="" val="."/>
                                                  <IdentNode start="(347, 49)" end="(347, 55)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(347, 56)" end="(347, 57)" leading="" trailing=" " val="&amp;lt;"/>
                                                <OtherNode start="(347, 58)" end="(347, 75)" kind="«term_+_»">
                                                  <OtherNode start="(347, 58)" end="(347, 71)" kind="«term_+_»">
                                                    <IdentNode start="(347, 58)" end="(347, 67)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                                    <AtomNode start="(347, 68)" end="(347, 69)" leading="" trailing=" " val="+"/>
                                                    <OtherNode start="(347, 70)" end="(347, 71)" kind="num">
                                                      <AtomNode start="(347, 70)" end="(347, 71)" leading="" trailing=" " val="1"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(347, 72)" end="(347, 73)" leading="" trailing=" " val="+"/>
                                                  <OtherNode start="(347, 74)" end="(347, 75)" kind="num">
                                                    <AtomNode start="(347, 74)" end="(347, 75)" leading="" trailing=" " val="1"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(347, 76)" end="(347, 78)" leading="" trailing=" " val=":="/>
                                          <TermBytacticNode start="(347, 79)" end="(347, 110)">
                                            <AtomNode start="(347, 79)" end="(347, 81)" leading="" trailing=" " val="by"/>
                                            <TacticTacticseqNode start="(347, 82)" end="(347, 110)">
                                              <TacticTacticseq1IndentedNode start="(347, 82)" end="(347, 110)">
                                                <NullNode start="(347, 82)" end="(347, 110)">
                                                  <OtherNode start="(347, 82)" end="(347, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;⊢ min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1" tactic="simp [splitInTwo_fst]">
                                                    <AtomNode start="(347, 82)" end="(347, 86)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(347, 87)" end="(347, 103)">
                                                      <AtomNode start="(347, 87)" end="(347, 88)" leading="" trailing="" val="["/>
                                                      <NullNode start="(347, 88)" end="(347, 102)">
                                                        <OtherNode start="(347, 88)" end="(347, 102)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(347, 88)" end="(347, 102)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(347, 102)" end="(347, 103)" leading="" trailing="" val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(347, 103)" end="(347, 104)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(347, 105)" end="(347, 110)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;⊢ min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(347, 105)" end="(347, 110)" leading="" trailing="&#10;    " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(348, 5)" end="(348, 110)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst) (((a :: b :: xs).zipIdx x✝).mergeSort (zipIdxLE le)) = (a :: b :: xs).mergeSort le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst) (((a :: b :: xs).zipIdx x✝).mergeSort (zipIdxLE le)) = (a :: b :: xs).mergeSort le" tactic="have : (splitInTwo ⟨a :: b :: xs, rfl⟩).2.1.length &amp;lt; xs.length + 1 + 1 := by simp [splitInTwo_snd]; omega">
                                      <AtomNode start="(348, 5)" end="(348, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(348, 10)" end="(348, 110)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(348, 10)" end="(348, 110)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(348, 10)" end="(348, 10)" kind="Lean.Parser.Term.haveId">
                                            <OtherNode start="(348, 10)" end="(348, 10)" kind="hygieneInfo">
                                              <IdentNode start="(348, 10)" end="(348, 10)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(348, 10)" end="(348, 75)">
                                            <TermTypespecNode start="(348, 10)" end="(348, 75)">
                                              <AtomNode start="(348, 10)" end="(348, 11)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(348, 12)" end="(348, 75)" kind="«term_&amp;lt;_»">
                                                <OtherNode start="(348, 12)" end="(348, 55)" kind="Lean.Parser.Term.proj">
                                                  <OtherNode start="(348, 12)" end="(348, 48)" kind="Lean.Parser.Term.proj">
                                                    <OtherNode start="(348, 12)" end="(348, 46)" kind="Lean.Parser.Term.proj">
                                                      <OtherNode start="(348, 12)" end="(348, 44)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(348, 12)" end="(348, 13)" leading="" trailing="" val="("/>
                                                        <OtherNode start="(348, 13)" end="(348, 43)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(348, 13)" end="(348, 23)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                          <NullNode start="(348, 24)" end="(348, 43)">
                                                            <OtherNode start="(348, 24)" end="(348, 43)" kind="Lean.Parser.Term.anonymousCtor">
                                                            <AtomNode start="(348, 24)" end="(348, 25)" leading="" trailing="" val="⟨"/>
                                                            <NullNode start="(348, 25)" end="(348, 42)">
                                                            <OtherNode start="(348, 25)" end="(348, 37)" kind="«term_::_»">
                                                            <IdentNode start="(348, 25)" end="(348, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                                            <AtomNode start="(348, 27)" end="(348, 29)" leading="" trailing=" " val="::"/>
                                                            <OtherNode start="(348, 30)" end="(348, 37)" kind="«term_::_»">
                                                            <IdentNode start="(348, 30)" end="(348, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <AtomNode start="(348, 32)" end="(348, 34)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(348, 35)" end="(348, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(348, 37)" end="(348, 38)" leading="" trailing=" " val=","/>
                                                            <IdentNode start="(348, 39)" end="(348, 42)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </NullNode>
                                                            <AtomNode start="(348, 42)" end="(348, 43)" leading="" trailing="" val="⟩"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                        <AtomNode start="(348, 43)" end="(348, 44)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                      <AtomNode start="(348, 44)" end="(348, 45)" leading="" trailing="" val="."/>
                                                      <OtherNode start="(348, 45)" end="(348, 46)" kind="fieldIdx">
                                                        <AtomNode start="(348, 45)" end="(348, 46)" leading="" trailing="" val="2"/>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(348, 46)" end="(348, 47)" leading="" trailing="" val="."/>
                                                    <OtherNode start="(348, 47)" end="(348, 48)" kind="fieldIdx">
                                                      <AtomNode start="(348, 47)" end="(348, 48)" leading="" trailing="" val="1"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(348, 48)" end="(348, 49)" leading="" trailing="" val="."/>
                                                  <IdentNode start="(348, 49)" end="(348, 55)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                </OtherNode>
                                                <AtomNode start="(348, 56)" end="(348, 57)" leading="" trailing=" " val="&amp;lt;"/>
                                                <OtherNode start="(348, 58)" end="(348, 75)" kind="«term_+_»">
                                                  <OtherNode start="(348, 58)" end="(348, 71)" kind="«term_+_»">
                                                    <IdentNode start="(348, 58)" end="(348, 67)" leading="" trailing=" " raw_val="xs.length" val="xs.length"/>
                                                    <AtomNode start="(348, 68)" end="(348, 69)" leading="" trailing=" " val="+"/>
                                                    <OtherNode start="(348, 70)" end="(348, 71)" kind="num">
                                                      <AtomNode start="(348, 70)" end="(348, 71)" leading="" trailing=" " val="1"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(348, 72)" end="(348, 73)" leading="" trailing=" " val="+"/>
                                                  <OtherNode start="(348, 74)" end="(348, 75)" kind="num">
                                                    <AtomNode start="(348, 74)" end="(348, 75)" leading="" trailing=" " val="1"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(348, 76)" end="(348, 78)" leading="" trailing=" " val=":="/>
                                          <TermBytacticNode start="(348, 79)" end="(348, 110)">
                                            <AtomNode start="(348, 79)" end="(348, 81)" leading="" trailing=" " val="by"/>
                                            <TacticTacticseqNode start="(348, 82)" end="(348, 110)">
                                              <TacticTacticseq1IndentedNode start="(348, 82)" end="(348, 110)">
                                                <NullNode start="(348, 82)" end="(348, 110)">
                                                  <OtherNode start="(348, 82)" end="(348, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1" tactic="simp [splitInTwo_snd]">
                                                    <AtomNode start="(348, 82)" end="(348, 86)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(348, 87)" end="(348, 103)">
                                                      <AtomNode start="(348, 87)" end="(348, 88)" leading="" trailing="" val="["/>
                                                      <NullNode start="(348, 88)" end="(348, 102)">
                                                        <OtherNode start="(348, 88)" end="(348, 102)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(348, 88)" end="(348, 102)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(348, 102)" end="(348, 103)" leading="" trailing="" val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(348, 103)" end="(348, 104)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(348, 105)" end="(348, 110)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1" state_after="no goals" tactic="omega">
                                                    <AtomNode start="(348, 105)" end="(348, 110)" leading="" trailing="&#10;    " val="omega"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(349, 5)" end="(349, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst) (((a :: b :: xs).zipIdx x✝).mergeSort (zipIdxLE le)) = (a :: b :: xs).mergeSort le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (((splitInTwo ⟨(a, x✝) :: (b, x✝ + 1) :: xs.zipIdx (x✝ + 1 + 1), ⋯⟩).fst.val.mergeSort (zipIdxLE le)).merge&#10;        ((splitInTwo ⟨(a, x✝) :: (b, x✝ + 1) :: xs.zipIdx (x✝ + 1 + 1), ⋯⟩).snd.val.mergeSort (zipIdxLE le))&#10;        (zipIdxLE le)) =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" tactic="simp only [mergeSort, zipIdx]">
                                      <AtomNode start="(349, 5)" end="(349, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(349, 10)" end="(349, 14)">
                                        <AtomNode start="(349, 10)" end="(349, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(349, 15)" end="(349, 34)">
                                        <AtomNode start="(349, 15)" end="(349, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(349, 16)" end="(349, 33)">
                                          <OtherNode start="(349, 16)" end="(349, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(349, 16)" end="(349, 25)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(349, 25)" end="(349, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(349, 27)" end="(349, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(349, 27)" end="(349, 33)" leading="" trailing="" raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(349, 33)" end="(349, 34)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(350, 5)" end="(350, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      (((splitInTwo ⟨(a, x✝) :: (b, x✝ + 1) :: xs.zipIdx (x✝ + 1 + 1), ⋯⟩).fst.val.mergeSort (zipIdxLE le)).merge&#10;        ((splitInTwo ⟨(a, x✝) :: (b, x✝ + 1) :: xs.zipIdx (x✝ + 1 + 1), ⋯⟩).snd.val.mergeSort (zipIdxLE le))&#10;        (zipIdxLE le)) =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      ((((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le)).merge&#10;        ((splitInTwo ⟨(a, x✝) :: (b, x✝ + 1) :: xs.zipIdx (x✝ + 1 + 1), ⋯⟩).snd.val.mergeSort (zipIdxLE le))&#10;        (zipIdxLE le)) =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" tactic="rw [splitInTwo_cons_cons_zipIdx_fst]">
                                      <AtomNode start="(350, 5)" end="(350, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(350, 8)" end="(350, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(350, 8)" end="(350, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(350, 9)" end="(350, 40)">
                                          <OtherNode start="(350, 9)" end="(350, 40)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(350, 9)" end="(350, 40)" leading="" trailing="" raw_val="splitInTwo_cons_cons_zipIdx_fst" val="splitInTwo_cons_cons_zipIdx_fst" full_name="List.MergeSort.Internal.splitInTwo_cons_cons_zipIdx_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(46, 9)" def_end="(46, 40)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(350, 40)" end="(350, 41)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(351, 5)" end="(351, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      ((((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le)).merge&#10;        ((splitInTwo ⟨(a, x✝) :: (b, x✝ + 1) :: xs.zipIdx (x✝ + 1 + 1), ⋯⟩).snd.val.mergeSort (zipIdxLE le))&#10;        (zipIdxLE le)) =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      ((((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le)).merge&#10;        (((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le))&#10;        (zipIdxLE le)) =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" tactic="rw [splitInTwo_cons_cons_zipIdx_snd]">
                                      <AtomNode start="(351, 5)" end="(351, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(351, 8)" end="(351, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(351, 8)" end="(351, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(351, 9)" end="(351, 40)">
                                          <OtherNode start="(351, 9)" end="(351, 40)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(351, 9)" end="(351, 40)" leading="" trailing="" raw_val="splitInTwo_cons_cons_zipIdx_snd" val="splitInTwo_cons_cons_zipIdx_snd" full_name="List.MergeSort.Internal.splitInTwo_cons_cons_zipIdx_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(63, 9)" def_end="(63, 40)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(351, 40)" end="(351, 41)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(352, 5)" end="(352, 22)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ map (fun x =&amp;gt; x.fst)&#10;      ((((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le)).merge&#10;        (((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le))&#10;        (zipIdxLE le)) =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (map (fun x =&amp;gt; x.fst) (((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le))).merge&#10;      (map (fun x =&amp;gt; x.fst)&#10;        (((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le)))&#10;      le =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le&#10;&#10;case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (x y : α × Nat),&#10;    x ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le) →&#10;      y ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le) →&#10;        x.snd ≤ y.snd" tactic="rw [merge_stable]">
                                      <AtomNode start="(352, 5)" end="(352, 7)" leading="" trailing=" " val="rw"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <OtherNode start="(352, 8)" end="(352, 22)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                        <AtomNode start="(352, 8)" end="(352, 9)" leading="" trailing="" val="["/>
                                        <NullNode start="(352, 9)" end="(352, 21)">
                                          <OtherNode start="(352, 9)" end="(352, 21)" kind="Lean.Parser.Tactic.rwRule">
                                            <NullNode/>
                                            <IdentNode start="(352, 9)" end="(352, 21)" leading="" trailing="" raw_val="merge_stable" val="merge_stable" full_name="List.merge_stable" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(187, 9)" def_end="(187, 21)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(352, 21)" end="(352, 22)" leading="" trailing="&#10;    " val="]"/>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(353, 5)" end="(353, 18)" kind="Lean.cdot" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (map (fun x =&amp;gt; x.fst) (((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le))).merge&#10;      (map (fun x =&amp;gt; x.fst)&#10;        (((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le)))&#10;      le =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le&#10;&#10;case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (x y : α × Nat),&#10;    x ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le) →&#10;      y ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le) →&#10;        x.snd ≤ y.snd" state_after="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (x y : α × Nat),&#10;    x ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le) →&#10;      y ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le) →&#10;        x.snd ≤ y.snd" tactic="· rw [go, go]">
                                      <OtherNode start="(353, 5)" end="(353, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(353, 5)" end="(353, 6)" kind="patternIgnore">
                                          <OtherNode start="(353, 5)" end="(353, 6)" kind="token.«· »">
                                            <AtomNode start="(353, 5)" end="(353, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(353, 7)" end="(353, 18)">
                                        <TacticTacticseq1IndentedNode start="(353, 7)" end="(353, 18)">
                                          <NullNode start="(353, 7)" end="(353, 18)">
                                            <OtherNode start="(353, 7)" end="(353, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ (map (fun x =&amp;gt; x.fst) (((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le))).merge&#10;      (map (fun x =&amp;gt; x.fst)&#10;        (((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le)))&#10;      le =&#10;    ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.mergeSort le) le" state_after="no goals" tactic="rw [go, go]">
                                              <AtomNode start="(353, 7)" end="(353, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(353, 10)" end="(353, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(353, 10)" end="(353, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(353, 11)" end="(353, 17)">
                                                  <OtherNode start="(353, 11)" end="(353, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(353, 11)" end="(353, 13)" leading="" trailing="" raw_val="go" val="go" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(353, 13)" end="(353, 14)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(353, 15)" end="(353, 17)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(353, 15)" end="(353, 17)" leading="" trailing="" raw_val="go" val="go"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(353, 17)" end="(353, 18)" leading="" trailing="&#10;    " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(354, 5)" end="(359, 12)" kind="Lean.cdot" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (x y : α × Nat),&#10;    x ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le) →&#10;      y ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le) →&#10;        x.snd ≤ y.snd" state_after="no goals" tactic="· simp only [mem_mergeSort, Prod.forall]&#10;  intros j x k y mx my&#10;  have := mem_zipIdx mx&#10;  have := mem_zipIdx my&#10;  simp_all&#10;  omega">
                                      <OtherNode start="(354, 5)" end="(354, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(354, 5)" end="(354, 6)" kind="patternIgnore">
                                          <OtherNode start="(354, 5)" end="(354, 6)" kind="token.«· »">
                                            <AtomNode start="(354, 5)" end="(354, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(354, 7)" end="(359, 12)">
                                        <TacticTacticseq1IndentedNode start="(354, 7)" end="(359, 12)">
                                          <NullNode start="(354, 7)" end="(359, 12)">
                                            <OtherNode start="(354, 7)" end="(354, 45)" kind="Lean.Parser.Tactic.simp" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (x y : α × Nat),&#10;    x ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝).mergeSort (zipIdxLE le) →&#10;      y ∈ ((splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)).mergeSort (zipIdxLE le) →&#10;        x.snd ≤ y.snd" state_after="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (a_1 : α) (b_1 : Nat) (a_2 : α) (b_2 : Nat),&#10;    (a_1, b_1) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝ →&#10;      (a_2, b_2) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2) → b_1 ≤ b_2" tactic="simp only [mem_mergeSort, Prod.forall]">
                                              <AtomNode start="(354, 7)" end="(354, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(354, 12)" end="(354, 16)">
                                                <AtomNode start="(354, 12)" end="(354, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(354, 17)" end="(354, 45)">
                                                <AtomNode start="(354, 17)" end="(354, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(354, 18)" end="(354, 44)">
                                                  <OtherNode start="(354, 18)" end="(354, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(354, 18)" end="(354, 31)" leading="" trailing="" raw_val="mem_mergeSort" val="mem_mergeSort" full_name="List.mem_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(286, 17)" def_end="(286, 30)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(354, 31)" end="(354, 32)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(354, 33)" end="(354, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(354, 33)" end="(354, 44)" leading="" trailing="" raw_val="Prod.forall" val="Prod.forall" full_name="Prod.forall" mod_name="Init.Data.Prod" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Prod.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(354, 44)" end="(354, 45)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(355, 7)" end="(355, 27)" kind="Lean.Parser.Tactic.intros" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;⊢ ∀ (a_1 : α) (b_1 : Nat) (a_2 : α) (b_2 : Nat),&#10;    (a_1, b_1) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝ →&#10;      (a_2, b_2) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2) → b_1 ≤ b_2" state_after="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;⊢ x ≤ y" tactic="intros j x k y mx my">
                                              <AtomNode start="(355, 7)" end="(355, 13)" leading="" trailing=" " val="intros"/>
                                              <NullNode start="(355, 14)" end="(355, 27)">
                                                <IdentNode start="(355, 14)" end="(355, 15)" leading="" trailing=" " raw_val="j" val="j"/>
                                                <IdentNode start="(355, 16)" end="(355, 17)" leading="" trailing=" " raw_val="x" val="x"/>
                                                <IdentNode start="(355, 18)" end="(355, 19)" leading="" trailing=" " raw_val="k" val="k"/>
                                                <IdentNode start="(355, 20)" end="(355, 21)" leading="" trailing=" " raw_val="y" val="y"/>
                                                <IdentNode start="(355, 22)" end="(355, 24)" leading="" trailing=" " raw_val="mx" val="mx"/>
                                                <IdentNode start="(355, 25)" end="(355, 27)" leading="" trailing="&#10;      " raw_val="my" val="my"/>
                                              </NullNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(356, 7)" end="(356, 28)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;⊢ x ≤ y" state_after="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝¹ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;this :&#10;  x✝ ≤ x ∧ x &amp;lt; x✝ + (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length ∧ j = (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val[x - x✝]&#10;⊢ x ≤ y" tactic="have := mem_zipIdx mx">
                                              <AtomNode start="(356, 7)" end="(356, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(356, 12)" end="(356, 28)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(356, 12)" end="(356, 28)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(356, 12)" end="(356, 12)" kind="Lean.Parser.Term.haveId">
                                                    <OtherNode start="(356, 12)" end="(356, 12)" kind="hygieneInfo">
                                                      <IdentNode start="(356, 12)" end="(356, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <AtomNode start="(356, 12)" end="(356, 14)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(356, 15)" end="(356, 28)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(356, 15)" end="(356, 25)" leading="" trailing=" " raw_val="mem_zipIdx" val="mem_zipIdx" full_name="List.mem_zipIdx" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                                                    <NullNode start="(356, 26)" end="(356, 28)">
                                                      <IdentNode start="(356, 26)" end="(356, 28)" leading="" trailing="&#10;      " raw_val="mx" val="mx"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(357, 7)" end="(357, 28)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝¹ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this✝ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;this :&#10;  x✝ ≤ x ∧ x &amp;lt; x✝ + (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length ∧ j = (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val[x - x✝]&#10;⊢ x ≤ y" state_after="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝² : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this✝¹ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;this✝ :&#10;  x✝ ≤ x ∧ x &amp;lt; x✝ + (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length ∧ j = (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val[x - x✝]&#10;this :&#10;  x✝ + (xs.length + 3) / 2 ≤ y ∧&#10;    y &amp;lt; x✝ + (xs.length + 3) / 2 + (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length ∧&#10;      k = (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val[y - (x✝ + (xs.length + 3) / 2)]&#10;⊢ x ≤ y" tactic="have := mem_zipIdx my">
                                              <AtomNode start="(357, 7)" end="(357, 11)" leading="" trailing=" " val="have"/>
                                              <OtherNode start="(357, 12)" end="(357, 28)" kind="Lean.Parser.Term.haveDecl">
                                                <OtherNode start="(357, 12)" end="(357, 28)" kind="Lean.Parser.Term.haveIdDecl">
                                                  <OtherNode start="(357, 12)" end="(357, 12)" kind="Lean.Parser.Term.haveId">
                                                    <OtherNode start="(357, 12)" end="(357, 12)" kind="hygieneInfo">
                                                      <IdentNode start="(357, 12)" end="(357, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <AtomNode start="(357, 12)" end="(357, 14)" leading="" trailing=" " val=":="/>
                                                  <OtherNode start="(357, 15)" end="(357, 28)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(357, 15)" end="(357, 25)" leading="" trailing=" " raw_val="mem_zipIdx" val="mem_zipIdx" full_name="List.mem_zipIdx" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                                                    <NullNode start="(357, 26)" end="(357, 28)">
                                                      <IdentNode start="(357, 26)" end="(357, 28)" leading="" trailing="&#10;      " raw_val="my" val="my"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(358, 7)" end="(358, 15)" kind="Lean.Parser.Tactic.simpAll" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;this✝² : (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length &amp;lt; xs.length + 1 + 1&#10;this✝¹ : (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length &amp;lt; xs.length + 1 + 1&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;this✝ :&#10;  x✝ ≤ x ∧ x &amp;lt; x✝ + (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.length ∧ j = (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val[x - x✝]&#10;this :&#10;  x✝ + (xs.length + 3) / 2 ≤ y ∧&#10;    y &amp;lt; x✝ + (xs.length + 3) / 2 + (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.length ∧&#10;      k = (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val[y - (x✝ + (xs.length + 3) / 2)]&#10;⊢ x ≤ y" state_after="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;this✝² : min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1&#10;this✝¹ : xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1&#10;this✝ : x✝ ≤ x ∧ x &amp;lt; x✝ + min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) ∧ j = (a :: b :: xs)[x - x✝]&#10;this :&#10;  x✝ + (xs.length + 3) / 2 ≤ y ∧&#10;    y &amp;lt; x✝ + (xs.length + 3) / 2 + (xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2) ∧&#10;      k = (a :: b :: xs)[(xs.length + 1 + 1 + 1) / 2 + (y - (x✝ + (xs.length + 3) / 2))]&#10;⊢ x ≤ y" tactic="simp_all">
                                              <AtomNode start="(358, 7)" end="(358, 15)" leading="" trailing="&#10;      " val="simp_all"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(359, 7)" end="(359, 12)" kind="Lean.Parser.Tactic.omega" state_before="case x&#10;α : Type u_1&#10;le : α → α → Bool&#10;l : List α&#10;x✝ : Nat&#10;a b : α&#10;xs : List α&#10;j : α&#10;x : Nat&#10;k : α&#10;y : Nat&#10;mx : (j, x) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).fst.val.zipIdx x✝&#10;my : (k, y) ∈ (splitInTwo ⟨a :: b :: xs, ⋯⟩).snd.val.zipIdx (x✝ + (xs.length + 3) / 2)&#10;this✝² : min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) &amp;lt; xs.length + 1 + 1&#10;this✝¹ : xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2 &amp;lt; xs.length + 1 + 1&#10;this✝ : x✝ ≤ x ∧ x &amp;lt; x✝ + min ((xs.length + 1 + 1 + 1) / 2) (xs.length + 1 + 1) ∧ j = (a :: b :: xs)[x - x✝]&#10;this :&#10;  x✝ + (xs.length + 3) / 2 ≤ y ∧&#10;    y &amp;lt; x✝ + (xs.length + 3) / 2 + (xs.length + 1 + 1 - (xs.length + 1 + 1 + 1) / 2) ∧&#10;      k = (a :: b :: xs)[(xs.length + 1 + 1 + 1) / 2 + (y - (x✝ + (xs.length + 3) / 2))]&#10;⊢ x ≤ y" state_after="no goals" tactic="omega">
                                              <AtomNode start="(359, 7)" end="(359, 12)" leading="" trailing="&#10;" val="omega"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </TermBytacticNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(360, 1)" end="(360, 31)" kind="Lean.Parser.Termination.suffix">
                    <NullNode start="(360, 1)" end="(360, 31)">
                      <OtherNode start="(360, 1)" end="(360, 31)" kind="Lean.Parser.Termination.terminationBy">
                        <AtomNode start="(360, 1)" end="(360, 15)" leading="" trailing=" " val="termination_by"/>
                        <NullNode/>
                        <NullNode start="(360, 16)" end="(360, 22)">
                          <NullNode start="(360, 16)" end="(360, 19)">
                            <TermHoleNode start="(360, 16)" end="(360, 17)">
                              <AtomNode start="(360, 16)" end="(360, 17)" leading="" trailing=" " val="_"/>
                            </TermHoleNode>
                            <IdentNode start="(360, 18)" end="(360, 19)" leading="" trailing=" " raw_val="l" val="l"/>
                          </NullNode>
                          <AtomNode start="(360, 20)" end="(360, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                        </NullNode>
                        <IdentNode start="(360, 23)" end="(360, 31)" leading="" trailing="&#10;&#10;" raw_val="l.length" val="l.length"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(362, 1)" end="(362, 98)" name="mergeSort_enum" full_name="List.mergeSort_enum">
      <CommandDeclmodifiersNode start="(362, 1)" end="(362, 55)">
        <NullNode/>
        <NullNode start="(362, 1)" end="(362, 55)">
          <OtherNode start="(362, 1)" end="(362, 55)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(362, 1)" end="(362, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(362, 3)" end="(362, 54)">
              <OtherNode start="(362, 3)" end="(362, 54)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(362, 3)" end="(362, 54)" kind="Lean.deprecated">
                  <AtomNode start="(362, 3)" end="(362, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(362, 14)" end="(362, 30)">
                    <IdentNode start="(362, 14)" end="(362, 30)" leading="" trailing=" " raw_val="mergeSort_zipIdx" val="mergeSort_zipIdx" full_name="List.mergeSort_zipIdx" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(339, 9)" def_end="(339, 25)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(362, 31)" end="(362, 54)">
                    <AtomNode start="(362, 31)" end="(362, 32)" leading="" trailing="" val="("/>
                    <AtomNode start="(362, 32)" end="(362, 37)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(362, 38)" end="(362, 40)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(362, 41)" end="(362, 53)" kind="str">
                      <AtomNode start="(362, 41)" end="(362, 53)" leading="" trailing="" val="&amp;quot;2025-01-21&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(362, 53)" end="(362, 54)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(362, 54)" end="(362, 55)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(362, 56)" end="(362, 98)" name="mergeSort_enum">
        <AtomNode start="(362, 56)" end="(362, 62)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(362, 63)" end="(362, 77)">
          <IdentNode start="(362, 63)" end="(362, 77)" leading="" trailing=" " raw_val="mergeSort_enum" val="mergeSort_enum"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(362, 78)" end="(362, 98)">
          <AtomNode start="(362, 78)" end="(362, 80)" leading="" trailing=" " val=":="/>
          <OtherNode start="(362, 81)" end="(362, 98)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(362, 81)" end="(362, 82)" leading="" trailing="" val="@"/>
            <IdentNode start="(362, 82)" end="(362, 98)" leading="" trailing="&#10;&#10;" raw_val="mergeSort_zipIdx" val="mergeSort_zipIdx" full_name="List.mergeSort_zipIdx" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(339, 9)" def_end="(339, 25)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(364, 1)" end="(416, 24)" name="mergeSort_cons" full_name="List.mergeSort_cons">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(364, 1)" end="(416, 24)" name="mergeSort_cons" full_name="List.mergeSort_cons" _is_private_decl="False">
        <AtomNode start="(364, 1)" end="(364, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(364, 9)" end="(364, 23)">
          <IdentNode start="(364, 9)" end="(364, 23)" leading="" trailing=" " raw_val="mergeSort_cons" val="mergeSort_cons"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(364, 24)" end="(369, 28)">
          <NullNode start="(364, 24)" end="(367, 25)">
            <OtherNode start="(364, 24)" end="(364, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(364, 24)" end="(364, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(364, 25)" end="(364, 27)">
                <IdentNode start="(364, 25)" end="(364, 27)" leading="" trailing=" " raw_val="le" val="le"/>
              </NullNode>
              <NullNode start="(364, 28)" end="(364, 42)">
                <AtomNode start="(364, 28)" end="(364, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(364, 30)" end="(364, 42)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(364, 30)" end="(364, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(364, 32)" end="(364, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(364, 34)" end="(364, 42)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(364, 34)" end="(364, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(364, 36)" end="(364, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(364, 38)" end="(364, 42)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(364, 42)" end="(364, 43)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(365, 5)" end="(365, 54)">
              <AtomNode start="(365, 5)" end="(365, 6)" leading="" trailing="" val="("/>
              <NullNode start="(365, 6)" end="(365, 11)">
                <IdentNode start="(365, 6)" end="(365, 11)" leading="" trailing=" " raw_val="trans" val="trans"/>
              </NullNode>
              <NullNode start="(365, 12)" end="(365, 53)">
                <AtomNode start="(365, 12)" end="(365, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(365, 14)" end="(365, 53)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(365, 14)" end="(365, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(365, 16)" end="(365, 27)">
                    <TermExplicitbinderNode start="(365, 16)" end="(365, 27)">
                      <AtomNode start="(365, 16)" end="(365, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(365, 17)" end="(365, 22)">
                        <IdentNode start="(365, 17)" end="(365, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(365, 19)" end="(365, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(365, 21)" end="(365, 22)" leading="" trailing=" " raw_val="c" val="c"/>
                      </NullNode>
                      <NullNode start="(365, 23)" end="(365, 26)">
                        <AtomNode start="(365, 23)" end="(365, 24)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(365, 25)" end="(365, 26)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(365, 26)" end="(365, 27)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(365, 27)" end="(365, 28)" leading="" trailing=" " val=","/>
                  <OtherNode start="(365, 29)" end="(365, 53)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(365, 29)" end="(365, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(365, 29)" end="(365, 31)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(365, 32)" end="(365, 35)">
                        <IdentNode start="(365, 32)" end="(365, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(365, 34)" end="(365, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(365, 36)" end="(365, 37)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(365, 38)" end="(365, 53)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(365, 38)" end="(365, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(365, 38)" end="(365, 40)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(365, 41)" end="(365, 44)">
                          <IdentNode start="(365, 41)" end="(365, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(365, 43)" end="(365, 44)" leading="" trailing=" " raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(365, 45)" end="(365, 46)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(365, 47)" end="(365, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(365, 47)" end="(365, 49)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(365, 50)" end="(365, 53)">
                          <IdentNode start="(365, 50)" end="(365, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(365, 52)" end="(365, 53)" leading="" trailing="" raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(365, 53)" end="(365, 54)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(366, 5)" end="(366, 44)">
              <AtomNode start="(366, 5)" end="(366, 6)" leading="" trailing="" val="("/>
              <NullNode start="(366, 6)" end="(366, 11)">
                <IdentNode start="(366, 6)" end="(366, 11)" leading="" trailing=" " raw_val="total" val="total"/>
              </NullNode>
              <NullNode start="(366, 12)" end="(366, 43)">
                <AtomNode start="(366, 12)" end="(366, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(366, 14)" end="(366, 43)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(366, 14)" end="(366, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(366, 16)" end="(366, 25)">
                    <TermExplicitbinderNode start="(366, 16)" end="(366, 25)">
                      <AtomNode start="(366, 16)" end="(366, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(366, 17)" end="(366, 20)">
                        <IdentNode start="(366, 17)" end="(366, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(366, 19)" end="(366, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode start="(366, 21)" end="(366, 24)">
                        <AtomNode start="(366, 21)" end="(366, 22)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(366, 23)" end="(366, 24)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(366, 24)" end="(366, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(366, 25)" end="(366, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(366, 27)" end="(366, 43)" kind="«term_||_»">
                    <OtherNode start="(366, 27)" end="(366, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(366, 27)" end="(366, 29)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(366, 30)" end="(366, 33)">
                        <IdentNode start="(366, 30)" end="(366, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(366, 32)" end="(366, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(366, 34)" end="(366, 36)" leading="" trailing=" " val="||"/>
                    <OtherNode start="(366, 37)" end="(366, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(366, 37)" end="(366, 39)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(366, 40)" end="(366, 43)">
                        <IdentNode start="(366, 40)" end="(366, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(366, 42)" end="(366, 43)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(366, 43)" end="(366, 44)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(367, 5)" end="(367, 12)">
              <AtomNode start="(367, 5)" end="(367, 6)" leading="" trailing="" val="("/>
              <NullNode start="(367, 6)" end="(367, 7)">
                <IdentNode start="(367, 6)" end="(367, 7)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(367, 8)" end="(367, 11)">
                <AtomNode start="(367, 8)" end="(367, 9)" leading="" trailing=" " val=":"/>
                <IdentNode start="(367, 10)" end="(367, 11)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(367, 11)" end="(367, 12)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(367, 13)" end="(367, 25)">
              <AtomNode start="(367, 13)" end="(367, 14)" leading="" trailing="" val="("/>
              <NullNode start="(367, 14)" end="(367, 15)">
                <IdentNode start="(367, 14)" end="(367, 15)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(367, 16)" end="(367, 24)">
                <AtomNode start="(367, 16)" end="(367, 17)" leading="" trailing=" " val=":"/>
                <OtherNode start="(367, 18)" end="(367, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(367, 18)" end="(367, 22)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(367, 23)" end="(367, 24)">
                    <IdentNode start="(367, 23)" end="(367, 24)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(367, 24)" end="(367, 25)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(367, 26)" end="(369, 28)">
            <AtomNode start="(367, 26)" end="(367, 27)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(368, 5)" end="(369, 28)" kind="«term∃_,_»">
              <AtomNode start="(368, 5)" end="(368, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(368, 7)" end="(368, 12)" kind="Lean.explicitBinders">
                <OtherNode start="(368, 7)" end="(368, 12)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(368, 7)" end="(368, 12)">
                    <LeanBinderidentNode start="(368, 7)" end="(368, 9)">
                      <IdentNode start="(368, 7)" end="(368, 9)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    </LeanBinderidentNode>
                    <LeanBinderidentNode start="(368, 10)" end="(368, 12)">
                      <IdentNode start="(368, 10)" end="(368, 12)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(368, 12)" end="(368, 13)" leading="" trailing=" " val=","/>
              <OtherNode start="(368, 14)" end="(369, 28)" kind="«term_∧_»">
                <OtherNode start="(368, 14)" end="(368, 51)" kind="«term_=_»">
                  <OtherNode start="(368, 14)" end="(368, 35)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(368, 14)" end="(368, 23)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(368, 24)" end="(368, 35)">
                      <OtherNode start="(368, 24)" end="(368, 32)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(368, 24)" end="(368, 25)" leading="" trailing="" val="("/>
                        <OtherNode start="(368, 25)" end="(368, 31)" kind="«term_::_»">
                          <IdentNode start="(368, 25)" end="(368, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                          <AtomNode start="(368, 27)" end="(368, 29)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(368, 30)" end="(368, 31)" leading="" trailing="" raw_val="l" val="l"/>
                        </OtherNode>
                        <AtomNode start="(368, 31)" end="(368, 32)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <IdentNode start="(368, 33)" end="(368, 35)" leading="" trailing=" " raw_val="le" val="le"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(368, 36)" end="(368, 37)" leading="" trailing=" " val="="/>
                  <OtherNode start="(368, 38)" end="(368, 51)" kind="«term_++_»">
                    <IdentNode start="(368, 38)" end="(368, 40)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <AtomNode start="(368, 41)" end="(368, 43)" leading="" trailing=" " val="++"/>
                    <OtherNode start="(368, 44)" end="(368, 51)" kind="«term_::_»">
                      <IdentNode start="(368, 44)" end="(368, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(368, 46)" end="(368, 48)" leading="" trailing=" " val="::"/>
                      <IdentNode start="(368, 49)" end="(368, 51)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(368, 52)" end="(368, 53)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(368, 54)" end="(369, 28)" kind="«term_∧_»">
                  <OtherNode start="(368, 54)" end="(368, 79)" kind="«term_=_»">
                    <OtherNode start="(368, 54)" end="(368, 68)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(368, 54)" end="(368, 63)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                      <NullNode start="(368, 64)" end="(368, 68)">
                        <IdentNode start="(368, 64)" end="(368, 65)" leading="" trailing=" " raw_val="l" val="l"/>
                        <IdentNode start="(368, 66)" end="(368, 68)" leading="" trailing=" " raw_val="le" val="le"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(368, 69)" end="(368, 70)" leading="" trailing=" " val="="/>
                    <OtherNode start="(368, 71)" end="(368, 79)" kind="«term_++_»">
                      <IdentNode start="(368, 71)" end="(368, 73)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      <AtomNode start="(368, 74)" end="(368, 76)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(368, 77)" end="(368, 79)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(368, 80)" end="(368, 81)" leading="" trailing="&#10;      " val="∧"/>
                  <OtherNode start="(369, 7)" end="(369, 28)" kind="Lean.Parser.Term.forall">
                    <AtomNode start="(369, 7)" end="(369, 8)" leading="" trailing=" " val="∀"/>
                    <NullNode start="(369, 9)" end="(369, 10)">
                      <IdentNode start="(369, 9)" end="(369, 10)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(369, 10)" end="(369, 11)" leading="" trailing=" " val=","/>
                    <OtherNode start="(369, 12)" end="(369, 28)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(369, 12)" end="(369, 18)" kind="«term_∈_»">
                        <IdentNode start="(369, 12)" end="(369, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                        <AtomNode start="(369, 14)" end="(369, 15)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(369, 16)" end="(369, 18)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                      <AtomNode start="(369, 19)" end="(369, 20)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(369, 21)" end="(369, 28)" kind="term!_">
                        <AtomNode start="(369, 21)" end="(369, 22)" leading="" trailing="" val="!"/>
                        <OtherNode start="(369, 22)" end="(369, 28)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(369, 22)" end="(369, 24)" leading="" trailing=" " raw_val="le" val="le"/>
                          <NullNode start="(369, 25)" end="(369, 28)">
                            <IdentNode start="(369, 25)" end="(369, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(369, 27)" end="(369, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(369, 29)" end="(416, 24)">
          <AtomNode start="(369, 29)" end="(369, 31)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(369, 32)" end="(416, 24)">
            <AtomNode start="(369, 32)" end="(369, 34)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(370, 3)" end="(416, 24)">
              <TacticTacticseq1IndentedNode start="(370, 3)" end="(416, 24)">
                <NullNode start="(370, 3)" end="(416, 24)">
                  <OtherNode start="(370, 3)" end="(370, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ ∃ l₁ l₂, (a :: l).mergeSort le = l₁ ++ a :: l₂ ∧ l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) ((a :: l).zipIdx.mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="rw [← mergeSort_zipIdx]">
                    <AtomNode start="(370, 3)" end="(370, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(370, 6)" end="(370, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(370, 6)" end="(370, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(370, 7)" end="(370, 25)">
                        <OtherNode start="(370, 7)" end="(370, 25)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(370, 7)" end="(370, 8)">
                            <OtherNode start="(370, 7)" end="(370, 8)" kind="patternIgnore">
                              <OtherNode start="(370, 7)" end="(370, 8)" kind="token.«← »">
                                <AtomNode start="(370, 7)" end="(370, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(370, 9)" end="(370, 25)" leading="" trailing="" raw_val="mergeSort_zipIdx" val="mergeSort_zipIdx" full_name="List.mergeSort_zipIdx" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(339, 9)" def_end="(339, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(370, 25)" end="(370, 26)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(371, 3)" end="(371, 19)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) ((a :: l).zipIdx.mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="rw [zipIdx_cons]">
                    <AtomNode start="(371, 3)" end="(371, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(371, 6)" end="(371, 19)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(371, 6)" end="(371, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(371, 7)" end="(371, 18)">
                        <OtherNode start="(371, 7)" end="(371, 18)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(371, 7)" end="(371, 18)" leading="" trailing="" raw_val="zipIdx_cons" val="zipIdx_cons" full_name="List.zipIdx_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(371, 18)" end="(371, 19)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(372, 3)" end="(372, 94)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="have nd : Nodup ((a :: l).zipIdx.map (·.2)) := by rw [zipIdx_map_snd]; exact nodup_range' _">
                    <AtomNode start="(372, 3)" end="(372, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(372, 8)" end="(372, 94)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(372, 8)" end="(372, 94)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(372, 8)" end="(372, 10)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(372, 8)" end="(372, 10)" leading="" trailing=" " raw_val="nd" val="nd"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode start="(372, 11)" end="(372, 46)">
                          <TermTypespecNode start="(372, 11)" end="(372, 46)">
                            <AtomNode start="(372, 11)" end="(372, 12)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(372, 13)" end="(372, 46)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(372, 13)" end="(372, 18)" leading="" trailing=" " raw_val="Nodup" val="Nodup" full_name="List.Nodup" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              <NullNode start="(372, 19)" end="(372, 46)">
                                <OtherNode start="(372, 19)" end="(372, 46)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(372, 19)" end="(372, 20)" leading="" trailing="" val="("/>
                                  <OtherNode start="(372, 20)" end="(372, 45)" kind="Lean.Parser.Term.app">
                                    <OtherNode start="(372, 20)" end="(372, 39)" kind="Lean.Parser.Term.proj">
                                      <OtherNode start="(372, 20)" end="(372, 28)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(372, 20)" end="(372, 21)" leading="" trailing="" val="("/>
                                        <OtherNode start="(372, 21)" end="(372, 27)" kind="«term_::_»">
                                          <IdentNode start="(372, 21)" end="(372, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <AtomNode start="(372, 23)" end="(372, 25)" leading="" trailing=" " val="::"/>
                                          <IdentNode start="(372, 26)" end="(372, 27)" leading="" trailing="" raw_val="l" val="l"/>
                                        </OtherNode>
                                        <AtomNode start="(372, 27)" end="(372, 28)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(372, 28)" end="(372, 29)" leading="" trailing="" val="."/>
                                      <IdentNode start="(372, 29)" end="(372, 39)" leading="" trailing=" " raw_val="zipIdx.map" val="zipIdx.map"/>
                                    </OtherNode>
                                    <NullNode start="(372, 40)" end="(372, 45)">
                                      <OtherNode start="(372, 40)" end="(372, 45)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(372, 40)" end="(372, 41)" leading="" trailing="" val="("/>
                                        <OtherNode start="(372, 41)" end="(372, 44)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(372, 41)" end="(372, 42)" kind="Lean.Parser.Term.cdot">
                                            <AtomNode start="(372, 41)" end="(372, 42)" leading="" trailing="" val="·"/>
                                          </OtherNode>
                                          <AtomNode start="(372, 42)" end="(372, 43)" leading="" trailing="" val="."/>
                                          <OtherNode start="(372, 43)" end="(372, 44)" kind="fieldIdx">
                                            <AtomNode start="(372, 43)" end="(372, 44)" leading="" trailing="" val="2"/>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(372, 44)" end="(372, 45)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(372, 45)" end="(372, 46)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </TermTypespecNode>
                        </NullNode>
                        <AtomNode start="(372, 47)" end="(372, 49)" leading="" trailing=" " val=":="/>
                        <TermBytacticNode start="(372, 50)" end="(372, 94)">
                          <AtomNode start="(372, 50)" end="(372, 52)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(372, 53)" end="(372, 94)">
                            <TacticTacticseq1IndentedNode start="(372, 53)" end="(372, 94)">
                              <NullNode start="(372, 53)" end="(372, 94)">
                                <OtherNode start="(372, 53)" end="(372, 72)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ (range' 0 (a :: l).length).Nodup" tactic="rw [zipIdx_map_snd]">
                                  <AtomNode start="(372, 53)" end="(372, 55)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(372, 56)" end="(372, 72)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(372, 56)" end="(372, 57)" leading="" trailing="" val="["/>
                                    <NullNode start="(372, 57)" end="(372, 71)">
                                      <OtherNode start="(372, 57)" end="(372, 71)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(372, 57)" end="(372, 71)" leading="" trailing="" raw_val="zipIdx_map_snd" val="zipIdx_map_snd" full_name="List.zipIdx_map_snd" mod_name="Init.Data.List.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Range.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(372, 71)" end="(372, 72)" leading="" trailing="" val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(372, 72)" end="(372, 73)" leading="" trailing=" " val=";"/>
                                <OtherNode start="(372, 74)" end="(372, 94)" kind="Lean.Parser.Tactic.exact" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;⊢ (range' 0 (a :: l).length).Nodup" state_after="no goals" tactic="exact nodup_range' _">
                                  <AtomNode start="(372, 74)" end="(372, 79)" leading="" trailing=" " val="exact"/>
                                  <OtherNode start="(372, 80)" end="(372, 94)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(372, 80)" end="(372, 92)" leading="" trailing=" " raw_val="nodup_range'" val="nodup_range'" full_name="List.nodup_range'" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                                    <NullNode start="(372, 93)" end="(372, 94)">
                                      <TermHoleNode start="(372, 93)" end="(372, 94)">
                                        <AtomNode start="(372, 93)" end="(372, 94)" leading="" trailing="&#10;  " val="_"/>
                                      </TermHoleNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(373, 3)" end="(374, 36)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="have m₁ : (a, 0) ∈ mergeSort ((a :: l).zipIdx) (zipIdxLE le) :=&#10;  mem_mergeSort.mpr mem_cons_self">
                    <AtomNode start="(373, 3)" end="(373, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(373, 8)" end="(374, 36)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(373, 8)" end="(374, 36)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(373, 8)" end="(373, 10)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(373, 8)" end="(373, 10)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode start="(373, 11)" end="(373, 63)">
                          <TermTypespecNode start="(373, 11)" end="(373, 63)">
                            <AtomNode start="(373, 11)" end="(373, 12)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(373, 13)" end="(373, 63)" kind="«term_∈_»">
                              <OtherNode start="(373, 13)" end="(373, 19)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(373, 13)" end="(373, 14)" leading="" trailing="" val="("/>
                                <NullNode start="(373, 14)" end="(373, 18)">
                                  <IdentNode start="(373, 14)" end="(373, 15)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(373, 15)" end="(373, 16)" leading="" trailing=" " val=","/>
                                  <NullNode start="(373, 17)" end="(373, 18)">
                                    <OtherNode start="(373, 17)" end="(373, 18)" kind="num">
                                      <AtomNode start="(373, 17)" end="(373, 18)" leading="" trailing="" val="0"/>
                                    </OtherNode>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(373, 18)" end="(373, 19)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <AtomNode start="(373, 20)" end="(373, 21)" leading="" trailing=" " val="∈"/>
                              <OtherNode start="(373, 22)" end="(373, 63)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(373, 22)" end="(373, 31)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                <NullNode start="(373, 32)" end="(373, 63)">
                                  <OtherNode start="(373, 32)" end="(373, 49)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(373, 32)" end="(373, 33)" leading="" trailing="" val="("/>
                                    <OtherNode start="(373, 33)" end="(373, 48)" kind="Lean.Parser.Term.proj">
                                      <OtherNode start="(373, 33)" end="(373, 41)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(373, 33)" end="(373, 34)" leading="" trailing="" val="("/>
                                        <OtherNode start="(373, 34)" end="(373, 40)" kind="«term_::_»">
                                          <IdentNode start="(373, 34)" end="(373, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                                          <AtomNode start="(373, 36)" end="(373, 38)" leading="" trailing=" " val="::"/>
                                          <IdentNode start="(373, 39)" end="(373, 40)" leading="" trailing="" raw_val="l" val="l"/>
                                        </OtherNode>
                                        <AtomNode start="(373, 40)" end="(373, 41)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(373, 41)" end="(373, 42)" leading="" trailing="" val="."/>
                                      <IdentNode start="(373, 42)" end="(373, 48)" leading="" trailing="" raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    </OtherNode>
                                    <AtomNode start="(373, 48)" end="(373, 49)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <OtherNode start="(373, 50)" end="(373, 63)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(373, 50)" end="(373, 51)" leading="" trailing="" val="("/>
                                    <OtherNode start="(373, 51)" end="(373, 62)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(373, 51)" end="(373, 59)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                      <NullNode start="(373, 60)" end="(373, 62)">
                                        <IdentNode start="(373, 60)" end="(373, 62)" leading="" trailing="" raw_val="le" val="le"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(373, 62)" end="(373, 63)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </TermTypespecNode>
                        </NullNode>
                        <AtomNode start="(373, 64)" end="(373, 66)" leading="" trailing="&#10;    " val=":="/>
                        <OtherNode start="(374, 5)" end="(374, 36)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(374, 5)" end="(374, 22)" leading="" trailing=" " raw_val="mem_mergeSort.mpr" val="mem_mergeSort.mpr"/>
                          <NullNode start="(374, 23)" end="(374, 36)">
                            <IdentNode start="(374, 23)" end="(374, 36)" leading="" trailing="&#10;  " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(375, 3)" end="(375, 41)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="obtain ⟨l₁, l₂, h⟩ := append_of_mem m₁">
                    <AtomNode start="(375, 3)" end="(375, 9)" leading="" trailing=" " val="obtain"/>
                    <NullNode start="(375, 10)" end="(375, 21)">
                      <OtherNode start="(375, 10)" end="(375, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                        <NullNode start="(375, 10)" end="(375, 21)">
                          <OtherNode start="(375, 10)" end="(375, 21)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                            <AtomNode start="(375, 10)" end="(375, 11)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(375, 11)" end="(375, 20)">
                              <OtherNode start="(375, 11)" end="(375, 13)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(375, 11)" end="(375, 13)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(375, 11)" end="(375, 13)">
                                    <OtherNode start="(375, 11)" end="(375, 13)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(375, 11)" end="(375, 13)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(375, 13)" end="(375, 14)" leading="" trailing=" " val=","/>
                              <OtherNode start="(375, 15)" end="(375, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(375, 15)" end="(375, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(375, 15)" end="(375, 17)">
                                    <OtherNode start="(375, 15)" end="(375, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(375, 15)" end="(375, 17)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(375, 17)" end="(375, 18)" leading="" trailing=" " val=","/>
                              <OtherNode start="(375, 19)" end="(375, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                <OtherNode start="(375, 19)" end="(375, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                  <NullNode start="(375, 19)" end="(375, 20)">
                                    <OtherNode start="(375, 19)" end="(375, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                      <IdentNode start="(375, 19)" end="(375, 20)" leading="" trailing="" raw_val="h" val="h"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(375, 20)" end="(375, 21)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(375, 22)" end="(375, 41)">
                      <AtomNode start="(375, 22)" end="(375, 24)" leading="" trailing=" " val=":="/>
                      <NullNode start="(375, 25)" end="(375, 41)">
                        <OtherNode start="(375, 25)" end="(375, 41)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(375, 25)" end="(375, 38)" leading="" trailing=" " raw_val="append_of_mem" val="append_of_mem" full_name="List.append_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                          <NullNode start="(375, 39)" end="(375, 41)">
                            <IdentNode start="(375, 39)" end="(375, 41)" leading="" trailing="&#10;  " raw_val="m₁" val="m₁"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(376, 3)" end="(376, 93)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((a :: l).zipIdx.mergeSort (zipIdxLE le))&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="have s := sorted_mergeSort (zipIdxLE_trans trans) (zipIdxLE_total total) ((a :: l).zipIdx)">
                    <AtomNode start="(376, 3)" end="(376, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(376, 8)" end="(376, 93)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(376, 8)" end="(376, 93)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(376, 8)" end="(376, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(376, 8)" end="(376, 9)" leading="" trailing=" " raw_val="s" val="s"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(376, 10)" end="(376, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(376, 13)" end="(376, 93)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(376, 13)" end="(376, 29)" leading="" trailing=" " raw_val="sorted_mergeSort" val="sorted_mergeSort" full_name="List.sorted_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(296, 9)" def_end="(296, 25)"/>
                          <NullNode start="(376, 30)" end="(376, 93)">
                            <OtherNode start="(376, 30)" end="(376, 52)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(376, 30)" end="(376, 31)" leading="" trailing="" val="("/>
                              <OtherNode start="(376, 31)" end="(376, 51)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(376, 31)" end="(376, 45)" leading="" trailing=" " raw_val="zipIdxLE_trans" val="zipIdxLE_trans" full_name="List.zipIdxLE_trans" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(100, 9)" def_end="(100, 23)"/>
                                <NullNode start="(376, 46)" end="(376, 51)">
                                  <IdentNode start="(376, 46)" end="(376, 51)" leading="" trailing="" raw_val="trans" val="trans"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(376, 51)" end="(376, 52)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(376, 53)" end="(376, 75)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(376, 53)" end="(376, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(376, 54)" end="(376, 74)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(376, 54)" end="(376, 68)" leading="" trailing=" " raw_val="zipIdxLE_total" val="zipIdxLE_total" full_name="List.zipIdxLE_total" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(128, 9)" def_end="(128, 23)"/>
                                <NullNode start="(376, 69)" end="(376, 74)">
                                  <IdentNode start="(376, 69)" end="(376, 74)" leading="" trailing="" raw_val="total" val="total"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(376, 74)" end="(376, 75)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(376, 76)" end="(376, 93)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(376, 76)" end="(376, 77)" leading="" trailing="" val="("/>
                              <OtherNode start="(376, 77)" end="(376, 92)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(376, 77)" end="(376, 85)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(376, 77)" end="(376, 78)" leading="" trailing="" val="("/>
                                  <OtherNode start="(376, 78)" end="(376, 84)" kind="«term_::_»">
                                    <IdentNode start="(376, 78)" end="(376, 79)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <AtomNode start="(376, 80)" end="(376, 82)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(376, 83)" end="(376, 84)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                  <AtomNode start="(376, 84)" end="(376, 85)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(376, 85)" end="(376, 86)" leading="" trailing="" val="."/>
                                <IdentNode start="(376, 86)" end="(376, 92)" leading="" trailing="" raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              </OtherNode>
                              <AtomNode start="(376, 92)" end="(376, 93)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(377, 3)" end="(377, 14)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((a :: l).zipIdx.mergeSort (zipIdxLE le))&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="rw [h] at s">
                    <AtomNode start="(377, 3)" end="(377, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(377, 6)" end="(377, 9)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(377, 6)" end="(377, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(377, 7)" end="(377, 8)">
                        <OtherNode start="(377, 7)" end="(377, 8)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(377, 7)" end="(377, 8)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(377, 8)" end="(377, 9)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(377, 10)" end="(377, 14)">
                      <OtherNode start="(377, 10)" end="(377, 14)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(377, 10)" end="(377, 12)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(377, 13)" end="(377, 14)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(377, 13)" end="(377, 14)">
                            <IdentNode start="(377, 13)" end="(377, 14)" leading="" trailing="&#10;  " raw_val="s" val="s"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(378, 3)" end="(378, 59)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : (a :: l).zipIdx.mergeSort (zipIdxLE le) ~ (a :: l).zipIdx&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="have p := mergeSort_perm ((a :: l).zipIdx) (zipIdxLE le)">
                    <AtomNode start="(378, 3)" end="(378, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(378, 8)" end="(378, 59)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(378, 8)" end="(378, 59)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(378, 8)" end="(378, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(378, 8)" end="(378, 9)" leading="" trailing=" " raw_val="p" val="p"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(378, 10)" end="(378, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(378, 13)" end="(378, 59)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(378, 13)" end="(378, 27)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm" full_name="List.mergeSort_perm" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(271, 9)" def_end="(271, 23)"/>
                          <NullNode start="(378, 28)" end="(378, 59)">
                            <OtherNode start="(378, 28)" end="(378, 45)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(378, 28)" end="(378, 29)" leading="" trailing="" val="("/>
                              <OtherNode start="(378, 29)" end="(378, 44)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(378, 29)" end="(378, 37)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(378, 29)" end="(378, 30)" leading="" trailing="" val="("/>
                                  <OtherNode start="(378, 30)" end="(378, 36)" kind="«term_::_»">
                                    <IdentNode start="(378, 30)" end="(378, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <AtomNode start="(378, 32)" end="(378, 34)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(378, 35)" end="(378, 36)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                  <AtomNode start="(378, 36)" end="(378, 37)" leading="" trailing="" val=")"/>
                                </OtherNode>
                                <AtomNode start="(378, 37)" end="(378, 38)" leading="" trailing="" val="."/>
                                <IdentNode start="(378, 38)" end="(378, 44)" leading="" trailing="" raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              </OtherNode>
                              <AtomNode start="(378, 44)" end="(378, 45)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(378, 46)" end="(378, 59)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(378, 46)" end="(378, 47)" leading="" trailing="" val="("/>
                              <OtherNode start="(378, 47)" end="(378, 58)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(378, 47)" end="(378, 55)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                <NullNode start="(378, 56)" end="(378, 58)">
                                  <IdentNode start="(378, 56)" end="(378, 58)" leading="" trailing="" raw_val="le" val="le"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(378, 58)" end="(378, 59)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(379, 3)" end="(379, 14)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : (a :: l).zipIdx.mergeSort (zipIdxLE le) ~ (a :: l).zipIdx&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" tactic="rw [h] at p">
                    <AtomNode start="(379, 3)" end="(379, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(379, 6)" end="(379, 9)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(379, 6)" end="(379, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(379, 7)" end="(379, 8)">
                        <OtherNode start="(379, 7)" end="(379, 8)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(379, 7)" end="(379, 8)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(379, 8)" end="(379, 9)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(379, 10)" end="(379, 14)">
                      <OtherNode start="(379, 10)" end="(379, 14)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(379, 10)" end="(379, 12)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(379, 13)" end="(379, 14)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(379, 13)" end="(379, 14)">
                            <IdentNode start="(379, 13)" end="(379, 14)" leading="" trailing="&#10;  " raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(380, 3)" end="(380, 50)" kind="Lean.Parser.Tactic.refine" state_before="case intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∃ l₁ l₂,&#10;    map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) = l₁ ++ a :: l₂ ∧&#10;      l.mergeSort le = l₁ ++ l₂ ∧ ∀ (b : α), b ∈ l₁ → (!le a b) = true" state_after="case intro.intro.refine_1&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) =&#10;    map (fun x =&amp;gt; x.fst) l₁ ++ a :: map (fun x =&amp;gt; x.fst) l₂&#10;&#10;case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ l.mergeSort le = map (fun x =&amp;gt; x.fst) l₁ ++ map (fun x =&amp;gt; x.fst) l₂&#10;&#10;case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" tactic="refine ⟨l₁.map (·.1), l₂.map (·.1), ?_, ?_, ?_⟩">
                    <AtomNode start="(380, 3)" end="(380, 9)" leading="" trailing=" " val="refine"/>
                    <OtherNode start="(380, 10)" end="(380, 50)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(380, 10)" end="(380, 11)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(380, 11)" end="(380, 49)">
                        <OtherNode start="(380, 11)" end="(380, 23)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(380, 11)" end="(380, 17)" leading="" trailing=" " raw_val="l₁.map" val="l₁.map"/>
                          <NullNode start="(380, 18)" end="(380, 23)">
                            <OtherNode start="(380, 18)" end="(380, 23)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(380, 18)" end="(380, 19)" leading="" trailing="" val="("/>
                              <OtherNode start="(380, 19)" end="(380, 22)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(380, 19)" end="(380, 20)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(380, 19)" end="(380, 20)" leading="" trailing="" val="·"/>
                                </OtherNode>
                                <AtomNode start="(380, 20)" end="(380, 21)" leading="" trailing="" val="."/>
                                <OtherNode start="(380, 21)" end="(380, 22)" kind="fieldIdx">
                                  <AtomNode start="(380, 21)" end="(380, 22)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(380, 22)" end="(380, 23)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(380, 23)" end="(380, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 25)" end="(380, 37)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(380, 25)" end="(380, 31)" leading="" trailing=" " raw_val="l₂.map" val="l₂.map"/>
                          <NullNode start="(380, 32)" end="(380, 37)">
                            <OtherNode start="(380, 32)" end="(380, 37)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(380, 32)" end="(380, 33)" leading="" trailing="" val="("/>
                              <OtherNode start="(380, 33)" end="(380, 36)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(380, 33)" end="(380, 34)" kind="Lean.Parser.Term.cdot">
                                  <AtomNode start="(380, 33)" end="(380, 34)" leading="" trailing="" val="·"/>
                                </OtherNode>
                                <AtomNode start="(380, 34)" end="(380, 35)" leading="" trailing="" val="."/>
                                <OtherNode start="(380, 35)" end="(380, 36)" kind="fieldIdx">
                                  <AtomNode start="(380, 35)" end="(380, 36)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(380, 36)" end="(380, 37)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(380, 37)" end="(380, 38)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 39)" end="(380, 41)" kind="Lean.Parser.Term.syntheticHole">
                          <AtomNode start="(380, 39)" end="(380, 40)" leading="" trailing="" val="?"/>
                          <AtomNode start="(380, 40)" end="(380, 41)" leading="" trailing="" val="_"/>
                        </OtherNode>
                        <AtomNode start="(380, 41)" end="(380, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 43)" end="(380, 45)" kind="Lean.Parser.Term.syntheticHole">
                          <AtomNode start="(380, 43)" end="(380, 44)" leading="" trailing="" val="?"/>
                          <AtomNode start="(380, 44)" end="(380, 45)" leading="" trailing="" val="_"/>
                        </OtherNode>
                        <AtomNode start="(380, 45)" end="(380, 46)" leading="" trailing=" " val=","/>
                        <OtherNode start="(380, 47)" end="(380, 49)" kind="Lean.Parser.Term.syntheticHole">
                          <AtomNode start="(380, 47)" end="(380, 48)" leading="" trailing="" val="?"/>
                          <AtomNode start="(380, 48)" end="(380, 49)" leading="" trailing="" val="_"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(380, 49)" end="(380, 50)" leading="" trailing="&#10;  " val="⟩"/>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(381, 3)" end="(381, 41)" kind="Lean.cdot" state_before="case intro.intro.refine_1&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) =&#10;    map (fun x =&amp;gt; x.fst) l₁ ++ a :: map (fun x =&amp;gt; x.fst) l₂&#10;&#10;case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ l.mergeSort le = map (fun x =&amp;gt; x.fst) l₁ ++ map (fun x =&amp;gt; x.fst) l₂&#10;&#10;case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" state_after="case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ l.mergeSort le = map (fun x =&amp;gt; x.fst) l₁ ++ map (fun x =&amp;gt; x.fst) l₂&#10;&#10;case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" tactic="· simpa using congrArg (·.map (·.1)) h">
                    <OtherNode start="(381, 3)" end="(381, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(381, 3)" end="(381, 4)" kind="patternIgnore">
                        <OtherNode start="(381, 3)" end="(381, 4)" kind="token.«· »">
                          <AtomNode start="(381, 3)" end="(381, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(381, 5)" end="(381, 41)">
                      <TacticTacticseq1IndentedNode start="(381, 5)" end="(381, 41)">
                        <NullNode start="(381, 5)" end="(381, 41)">
                          <OtherNode start="(381, 5)" end="(381, 41)" kind="Lean.Parser.Tactic.simpa" state_before="case intro.intro.refine_1&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ map (fun x =&amp;gt; x.fst) (((a, 0) :: l.zipIdx (0 + 1)).mergeSort (zipIdxLE le)) =&#10;    map (fun x =&amp;gt; x.fst) l₁ ++ a :: map (fun x =&amp;gt; x.fst) l₂" state_after="no goals" tactic="simpa using congrArg (·.map (·.1)) h">
                            <AtomNode start="(381, 5)" end="(381, 10)" leading="" trailing=" " val="simpa"/>
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(381, 11)" end="(381, 41)" kind="Lean.Parser.Tactic.simpaArgsRest">
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(381, 11)" end="(381, 41)">
                                <AtomNode start="(381, 11)" end="(381, 16)" leading="" trailing=" " val="using"/>
                                <OtherNode start="(381, 17)" end="(381, 41)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(381, 17)" end="(381, 25)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(381, 26)" end="(381, 41)">
                                    <OtherNode start="(381, 26)" end="(381, 39)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(381, 26)" end="(381, 27)" leading="" trailing="" val="("/>
                                      <OtherNode start="(381, 27)" end="(381, 38)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(381, 27)" end="(381, 32)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(381, 27)" end="(381, 28)" kind="Lean.Parser.Term.cdot">
                                            <AtomNode start="(381, 27)" end="(381, 28)" leading="" trailing="" val="·"/>
                                          </OtherNode>
                                          <AtomNode start="(381, 28)" end="(381, 29)" leading="" trailing="" val="."/>
                                          <IdentNode start="(381, 29)" end="(381, 32)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <NullNode start="(381, 33)" end="(381, 38)">
                                          <OtherNode start="(381, 33)" end="(381, 38)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(381, 33)" end="(381, 34)" leading="" trailing="" val="("/>
                                            <OtherNode start="(381, 34)" end="(381, 37)" kind="Lean.Parser.Term.proj">
                                              <OtherNode start="(381, 34)" end="(381, 35)" kind="Lean.Parser.Term.cdot">
                                                <AtomNode start="(381, 34)" end="(381, 35)" leading="" trailing="" val="·"/>
                                              </OtherNode>
                                              <AtomNode start="(381, 35)" end="(381, 36)" leading="" trailing="" val="."/>
                                              <OtherNode start="(381, 36)" end="(381, 37)" kind="fieldIdx">
                                                <AtomNode start="(381, 36)" end="(381, 37)" leading="" trailing="" val="1"/>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(381, 37)" end="(381, 38)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(381, 38)" end="(381, 39)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <IdentNode start="(381, 40)" end="(381, 41)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(382, 3)" end="(405, 14)" kind="Lean.cdot" state_before="case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ l.mergeSort le = map (fun x =&amp;gt; x.fst) l₁ ++ map (fun x =&amp;gt; x.fst) l₂&#10;&#10;case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" state_after="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" tactic="· rw [← mergeSort_zipIdx.go 1, ← map_append]&#10;  congr 1&#10;  have q : mergeSort (l.zipIdx 1) (zipIdxLE le) ~ l₁ ++ l₂ :=&#10;    (mergeSort_perm (l.zipIdx 1) (zipIdxLE le)).trans&#10;      (p.symm.trans perm_middle).cons_inv&#10;  apply Perm.eq_of_sorted (le := zipIdxLE le)&#10;  · rintro ⟨a, i⟩ ⟨b, j⟩  ha hb&#10;    simp only [mem_mergeSort] at ha&#10;    simp only [← q.mem_iff, mem_mergeSort] at hb&#10;    simp only [zipIdxLE]&#10;    simp only [Bool.if_false_right, Bool.and_eq_true, Prod.mk.injEq, and_imp]&#10;    intro ab h ba h'&#10;    simp only [Bool.decide_eq_true] at ba&#10;    replace h : i ≤ j := by simpa [ab, ba] using h&#10;    replace h' : j ≤ i := by simpa [ab, ba] using h'&#10;    cases Nat.le_antisymm h h'&#10;    constructor&#10;    · have := mem_zipIdx ha&#10;      have := mem_zipIdx hb&#10;      simp_all&#10;    · rfl&#10;  · exact sorted_mergeSort (zipIdxLE_trans trans) (zipIdxLE_total total) ..&#10;  · exact s.sublist ((sublist_cons_self (a, 0) l₂).append_left l₁)&#10;  · exact q">
                    <OtherNode start="(382, 3)" end="(382, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(382, 3)" end="(382, 4)" kind="patternIgnore">
                        <OtherNode start="(382, 3)" end="(382, 4)" kind="token.«· »">
                          <AtomNode start="(382, 3)" end="(382, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(382, 5)" end="(405, 14)">
                      <TacticTacticseq1IndentedNode start="(382, 5)" end="(405, 14)">
                        <NullNode start="(382, 5)" end="(405, 14)">
                          <OtherNode start="(382, 5)" end="(382, 47)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ l.mergeSort le = map (fun x =&amp;gt; x.fst) l₁ ++ map (fun x =&amp;gt; x.fst) l₂" state_after="case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ map (fun x =&amp;gt; x.fst) ((l.zipIdx 1).mergeSort (zipIdxLE le)) = map (fun x =&amp;gt; x.fst) (l₁ ++ l₂)" tactic="rw [← mergeSort_zipIdx.go 1, ← map_append]">
                            <AtomNode start="(382, 5)" end="(382, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(382, 8)" end="(382, 47)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(382, 8)" end="(382, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(382, 9)" end="(382, 46)">
                                <OtherNode start="(382, 9)" end="(382, 32)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode start="(382, 9)" end="(382, 10)">
                                    <OtherNode start="(382, 9)" end="(382, 10)" kind="patternIgnore">
                                      <OtherNode start="(382, 9)" end="(382, 10)" kind="token.«← »">
                                        <AtomNode start="(382, 9)" end="(382, 10)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <OtherNode start="(382, 11)" end="(382, 32)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(382, 11)" end="(382, 30)" leading="" trailing=" " raw_val="mergeSort_zipIdx.go" val="mergeSort_zipIdx.go" full_name="List.mergeSort_zipIdx.go" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(342, 7)" def_end="(342, 9)"/>
                                    <NullNode start="(382, 31)" end="(382, 32)">
                                      <OtherNode start="(382, 31)" end="(382, 32)" kind="num">
                                        <AtomNode start="(382, 31)" end="(382, 32)" leading="" trailing="" val="1"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(382, 32)" end="(382, 33)" leading="" trailing=" " val=","/>
                                <OtherNode start="(382, 34)" end="(382, 46)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode start="(382, 34)" end="(382, 35)">
                                    <OtherNode start="(382, 34)" end="(382, 35)" kind="patternIgnore">
                                      <OtherNode start="(382, 34)" end="(382, 35)" kind="token.«← »">
                                        <AtomNode start="(382, 34)" end="(382, 35)" leading="" trailing=" " val="←"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <IdentNode start="(382, 36)" end="(382, 46)" leading="" trailing="" raw_val="map_append" val="map_append" full_name="List.map_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(382, 46)" end="(382, 47)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(383, 5)" end="(383, 12)" kind="Lean.Parser.Tactic.congr" state_before="case intro.intro.refine_2&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ map (fun x =&amp;gt; x.fst) ((l.zipIdx 1).mergeSort (zipIdxLE le)) = map (fun x =&amp;gt; x.fst) (l₁ ++ l₂)" state_after="case intro.intro.refine_2.e_l&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) = l₁ ++ l₂" tactic="congr 1">
                            <AtomNode start="(383, 5)" end="(383, 10)" leading="" trailing=" " val="congr"/>
                            <NullNode start="(383, 11)" end="(383, 12)">
                              <OtherNode start="(383, 11)" end="(383, 12)" kind="num">
                                <AtomNode start="(383, 11)" end="(383, 12)" leading="" trailing="&#10;    " val="1"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(384, 5)" end="(386, 44)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.refine_2.e_l&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) = l₁ ++ l₂" state_after="case intro.intro.refine_2.e_l&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) = l₁ ++ l₂" tactic="have q : mergeSort (l.zipIdx 1) (zipIdxLE le) ~ l₁ ++ l₂ :=&#10;  (mergeSort_perm (l.zipIdx 1) (zipIdxLE le)).trans&#10;    (p.symm.trans perm_middle).cons_inv">
                            <AtomNode start="(384, 5)" end="(384, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(384, 10)" end="(386, 44)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(384, 10)" end="(386, 44)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(384, 10)" end="(384, 11)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(384, 10)" end="(384, 11)" leading="" trailing=" " raw_val="q" val="q"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(384, 12)" end="(384, 61)">
                                  <TermTypespecNode start="(384, 12)" end="(384, 61)">
                                    <AtomNode start="(384, 12)" end="(384, 13)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(384, 14)" end="(384, 61)" kind="List.«term_~_»">
                                      <OtherNode start="(384, 14)" end="(384, 50)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(384, 14)" end="(384, 23)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                        <NullNode start="(384, 24)" end="(384, 50)">
                                          <OtherNode start="(384, 24)" end="(384, 36)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(384, 24)" end="(384, 25)" leading="" trailing="" val="("/>
                                            <OtherNode start="(384, 25)" end="(384, 35)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(384, 25)" end="(384, 33)" leading="" trailing=" " raw_val="l.zipIdx" val="l.zipIdx"/>
                                              <NullNode start="(384, 34)" end="(384, 35)">
                                                <OtherNode start="(384, 34)" end="(384, 35)" kind="num">
                                                  <AtomNode start="(384, 34)" end="(384, 35)" leading="" trailing="" val="1"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(384, 35)" end="(384, 36)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <OtherNode start="(384, 37)" end="(384, 50)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(384, 37)" end="(384, 38)" leading="" trailing="" val="("/>
                                            <OtherNode start="(384, 38)" end="(384, 49)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(384, 38)" end="(384, 46)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                              <NullNode start="(384, 47)" end="(384, 49)">
                                                <IdentNode start="(384, 47)" end="(384, 49)" leading="" trailing="" raw_val="le" val="le"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(384, 49)" end="(384, 50)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(384, 51)" end="(384, 52)" leading="" trailing=" " val="~"/>
                                      <OtherNode start="(384, 53)" end="(384, 61)" kind="«term_++_»">
                                        <IdentNode start="(384, 53)" end="(384, 55)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                        <AtomNode start="(384, 56)" end="(384, 58)" leading="" trailing=" " val="++"/>
                                        <IdentNode start="(384, 59)" end="(384, 61)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(384, 62)" end="(384, 64)" leading="" trailing="&#10;      " val=":="/>
                                <OtherNode start="(385, 7)" end="(386, 44)" kind="Lean.Parser.Term.app">
                                  <OtherNode start="(385, 7)" end="(385, 56)" kind="Lean.Parser.Term.proj">
                                    <OtherNode start="(385, 7)" end="(385, 50)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(385, 7)" end="(385, 8)" leading="" trailing="" val="("/>
                                      <OtherNode start="(385, 8)" end="(385, 49)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(385, 8)" end="(385, 22)" leading="" trailing=" " raw_val="mergeSort_perm" val="mergeSort_perm" full_name="List.mergeSort_perm" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(271, 9)" def_end="(271, 23)"/>
                                        <NullNode start="(385, 23)" end="(385, 49)">
                                          <OtherNode start="(385, 23)" end="(385, 35)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(385, 23)" end="(385, 24)" leading="" trailing="" val="("/>
                                            <OtherNode start="(385, 24)" end="(385, 34)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(385, 24)" end="(385, 32)" leading="" trailing=" " raw_val="l.zipIdx" val="l.zipIdx"/>
                                              <NullNode start="(385, 33)" end="(385, 34)">
                                                <OtherNode start="(385, 33)" end="(385, 34)" kind="num">
                                                  <AtomNode start="(385, 33)" end="(385, 34)" leading="" trailing="" val="1"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(385, 34)" end="(385, 35)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <OtherNode start="(385, 36)" end="(385, 49)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(385, 36)" end="(385, 37)" leading="" trailing="" val="("/>
                                            <OtherNode start="(385, 37)" end="(385, 48)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(385, 37)" end="(385, 45)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                              <NullNode start="(385, 46)" end="(385, 48)">
                                                <IdentNode start="(385, 46)" end="(385, 48)" leading="" trailing="" raw_val="le" val="le"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(385, 48)" end="(385, 49)" leading="" trailing="" val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(385, 49)" end="(385, 50)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(385, 50)" end="(385, 51)" leading="" trailing="" val="."/>
                                    <IdentNode start="(385, 51)" end="(385, 56)" leading="" trailing="&#10;        " raw_val="trans" val="trans" full_name="List.Perm.trans" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  </OtherNode>
                                  <NullNode start="(386, 9)" end="(386, 44)">
                                    <OtherNode start="(386, 9)" end="(386, 44)" kind="Lean.Parser.Term.proj">
                                      <OtherNode start="(386, 9)" end="(386, 35)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(386, 9)" end="(386, 10)" leading="" trailing="" val="("/>
                                        <OtherNode start="(386, 10)" end="(386, 34)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(386, 10)" end="(386, 22)" leading="" trailing=" " raw_val="p.symm.trans" val="p.symm.trans"/>
                                          <NullNode start="(386, 23)" end="(386, 34)">
                                            <IdentNode start="(386, 23)" end="(386, 34)" leading="" trailing="" raw_val="perm_middle" val="perm_middle" full_name="List.perm_middle" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(386, 34)" end="(386, 35)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(386, 35)" end="(386, 36)" leading="" trailing="" val="."/>
                                      <IdentNode start="(386, 36)" end="(386, 44)" leading="" trailing="&#10;    " raw_val="cons_inv" val="cons_inv" full_name="List.Perm.cons_inv" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(387, 5)" end="(387, 48)" kind="Lean.Parser.Tactic.apply" state_before="case intro.intro.refine_2.e_l&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) = l₁ ++ l₂" state_after="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ ∀ (a b : α × Nat),&#10;    a ∈ (l.zipIdx 1).mergeSort (zipIdxLE le) → b ∈ l₁ ++ l₂ → zipIdxLE le a b = true → zipIdxLE le b a = true → a = b&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((l.zipIdx 1).mergeSort (zipIdxLE le))&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" tactic="apply Perm.eq_of_sorted (le := zipIdxLE le)">
                            <AtomNode start="(387, 5)" end="(387, 10)" leading="" trailing=" " val="apply"/>
                            <OtherNode start="(387, 11)" end="(387, 48)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(387, 11)" end="(387, 28)" leading="" trailing=" " raw_val="Perm.eq_of_sorted" val="Perm.eq_of_sorted" full_name="List.Perm.eq_of_sorted" mod_name="Init.Data.List.Perm" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Perm.lean"/>
                              <NullNode start="(387, 29)" end="(387, 48)">
                                <OtherNode start="(387, 29)" end="(387, 48)" kind="Lean.Parser.Term.namedArgument">
                                  <AtomNode start="(387, 29)" end="(387, 30)" leading="" trailing="" val="("/>
                                  <IdentNode start="(387, 30)" end="(387, 32)" leading="" trailing=" " raw_val="le" val="le"/>
                                  <AtomNode start="(387, 33)" end="(387, 35)" leading="" trailing=" " val=":="/>
                                  <OtherNode start="(387, 36)" end="(387, 47)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(387, 36)" end="(387, 44)" leading="" trailing=" " raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                    <NullNode start="(387, 45)" end="(387, 47)">
                                      <IdentNode start="(387, 45)" end="(387, 47)" leading="" trailing="" raw_val="le" val="le"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(387, 47)" end="(387, 48)" leading="" trailing="&#10;    " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(388, 5)" end="(402, 12)" kind="Lean.cdot" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ ∀ (a b : α × Nat),&#10;    a ∈ (l.zipIdx 1).mergeSort (zipIdxLE le) → b ∈ l₁ ++ l₂ → zipIdxLE le a b = true → zipIdxLE le b a = true → a = b&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((l.zipIdx 1).mergeSort (zipIdxLE le))&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" state_after="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((l.zipIdx 1).mergeSort (zipIdxLE le))&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" tactic="· rintro ⟨a, i⟩ ⟨b, j⟩  ha hb&#10;  simp only [mem_mergeSort] at ha&#10;  simp only [← q.mem_iff, mem_mergeSort] at hb&#10;  simp only [zipIdxLE]&#10;  simp only [Bool.if_false_right, Bool.and_eq_true, Prod.mk.injEq, and_imp]&#10;  intro ab h ba h'&#10;  simp only [Bool.decide_eq_true] at ba&#10;  replace h : i ≤ j := by simpa [ab, ba] using h&#10;  replace h' : j ≤ i := by simpa [ab, ba] using h'&#10;  cases Nat.le_antisymm h h'&#10;  constructor&#10;  · have := mem_zipIdx ha&#10;    have := mem_zipIdx hb&#10;    simp_all&#10;  · rfl">
                            <OtherNode start="(388, 5)" end="(388, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(388, 5)" end="(388, 6)" kind="patternIgnore">
                                <OtherNode start="(388, 5)" end="(388, 6)" kind="token.«· »">
                                  <AtomNode start="(388, 5)" end="(388, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(388, 7)" end="(402, 12)">
                              <TacticTacticseq1IndentedNode start="(388, 7)" end="(402, 12)">
                                <NullNode start="(388, 7)" end="(402, 12)">
                                  <OtherNode start="(388, 7)" end="(388, 34)" kind="Lean.Parser.Tactic.rintro" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ ∀ (a b : α × Nat),&#10;    a ∈ (l.zipIdx 1).mergeSort (zipIdxLE le) → b ∈ l₁ ++ l₂ → zipIdxLE le a b = true → zipIdxLE le b a = true → a = b" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ (l.zipIdx 1).mergeSort (zipIdxLE le)&#10;hb : (b, j) ∈ l₁ ++ l₂&#10;⊢ zipIdxLE le (a, i) (b, j) = true → zipIdxLE le (b, j) (a, i) = true → (a, i) = (b, j)" tactic="rintro ⟨a, i⟩ ⟨b, j⟩  ha hb">
                                    <AtomNode start="(388, 7)" end="(388, 13)" leading="" trailing=" " val="rintro"/>
                                    <NullNode start="(388, 14)" end="(388, 34)">
                                      <OtherNode start="(388, 14)" end="(388, 20)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(388, 14)" end="(388, 20)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(388, 14)" end="(388, 15)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(388, 15)" end="(388, 19)">
                                            <OtherNode start="(388, 15)" end="(388, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(388, 15)" end="(388, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(388, 15)" end="(388, 16)">
                                                  <OtherNode start="(388, 15)" end="(388, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(388, 15)" end="(388, 16)" leading="" trailing="" raw_val="a" val="a"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(388, 16)" end="(388, 17)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(388, 18)" end="(388, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(388, 18)" end="(388, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(388, 18)" end="(388, 19)">
                                                  <OtherNode start="(388, 18)" end="(388, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(388, 18)" end="(388, 19)" leading="" trailing="" raw_val="i" val="i"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(388, 19)" end="(388, 20)" leading="" trailing=" " val="⟩"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(388, 21)" end="(388, 27)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(388, 21)" end="(388, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                          <AtomNode start="(388, 21)" end="(388, 22)" leading="" trailing="" val="⟨"/>
                                          <NullNode start="(388, 22)" end="(388, 26)">
                                            <OtherNode start="(388, 22)" end="(388, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(388, 22)" end="(388, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(388, 22)" end="(388, 23)">
                                                  <OtherNode start="(388, 22)" end="(388, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(388, 22)" end="(388, 23)" leading="" trailing="" raw_val="b" val="b"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(388, 23)" end="(388, 24)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(388, 25)" end="(388, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                              <OtherNode start="(388, 25)" end="(388, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                <NullNode start="(388, 25)" end="(388, 26)">
                                                  <OtherNode start="(388, 25)" end="(388, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                    <IdentNode start="(388, 25)" end="(388, 26)" leading="" trailing="" raw_val="j" val="j"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(388, 26)" end="(388, 27)" leading="" trailing="  " val="⟩"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(388, 29)" end="(388, 31)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(388, 29)" end="(388, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(388, 29)" end="(388, 31)" leading="" trailing=" " raw_val="ha" val="ha"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <OtherNode start="(388, 32)" end="(388, 34)" kind="Lean.Parser.Tactic.rintroPat.one">
                                        <OtherNode start="(388, 32)" end="(388, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                          <IdentNode start="(388, 32)" end="(388, 34)" leading="" trailing="&#10;      " raw_val="hb" val="hb"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(389, 7)" end="(389, 38)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ (l.zipIdx 1).mergeSort (zipIdxLE le)&#10;hb : (b, j) ∈ l₁ ++ l₂&#10;⊢ zipIdxLE le (a, i) (b, j) = true → zipIdxLE le (b, j) (a, i) = true → (a, i) = (b, j)" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;hb : (b, j) ∈ l₁ ++ l₂&#10;ha : (a, i) ∈ l.zipIdx 1&#10;⊢ zipIdxLE le (a, i) (b, j) = true → zipIdxLE le (b, j) (a, i) = true → (a, i) = (b, j)" tactic="simp only [mem_mergeSort] at ha">
                                    <AtomNode start="(389, 7)" end="(389, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(389, 12)" end="(389, 16)">
                                      <AtomNode start="(389, 12)" end="(389, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(389, 17)" end="(389, 32)">
                                      <AtomNode start="(389, 17)" end="(389, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(389, 18)" end="(389, 31)">
                                        <OtherNode start="(389, 18)" end="(389, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(389, 18)" end="(389, 31)" leading="" trailing="" raw_val="mem_mergeSort" val="mem_mergeSort" full_name="List.mem_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(286, 17)" def_end="(286, 30)"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(389, 31)" end="(389, 32)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(389, 33)" end="(389, 38)">
                                      <OtherNode start="(389, 33)" end="(389, 38)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(389, 33)" end="(389, 35)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(389, 36)" end="(389, 38)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(389, 36)" end="(389, 38)">
                                            <IdentNode start="(389, 36)" end="(389, 38)" leading="" trailing="&#10;      " raw_val="ha" val="ha"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(390, 7)" end="(390, 51)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;hb : (b, j) ∈ l₁ ++ l₂&#10;ha : (a, i) ∈ l.zipIdx 1&#10;⊢ zipIdxLE le (a, i) (b, j) = true → zipIdxLE le (b, j) (a, i) = true → (a, i) = (b, j)" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;⊢ zipIdxLE le (a, i) (b, j) = true → zipIdxLE le (b, j) (a, i) = true → (a, i) = (b, j)" tactic="simp only [← q.mem_iff, mem_mergeSort] at hb">
                                    <AtomNode start="(390, 7)" end="(390, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(390, 12)" end="(390, 16)">
                                      <AtomNode start="(390, 12)" end="(390, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(390, 17)" end="(390, 45)">
                                      <AtomNode start="(390, 17)" end="(390, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(390, 18)" end="(390, 44)">
                                        <OtherNode start="(390, 18)" end="(390, 29)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode start="(390, 18)" end="(390, 19)">
                                            <OtherNode start="(390, 18)" end="(390, 19)" kind="patternIgnore">
                                              <OtherNode start="(390, 18)" end="(390, 19)" kind="token.«← »">
                                                <AtomNode start="(390, 18)" end="(390, 19)" leading="" trailing=" " val="←"/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                          <IdentNode start="(390, 20)" end="(390, 29)" leading="" trailing="" raw_val="q.mem_iff" val="q.mem_iff"/>
                                        </OtherNode>
                                        <AtomNode start="(390, 29)" end="(390, 30)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(390, 31)" end="(390, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(390, 31)" end="(390, 44)" leading="" trailing="" raw_val="mem_mergeSort" val="mem_mergeSort" full_name="List.mem_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(286, 17)" def_end="(286, 30)"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(390, 44)" end="(390, 45)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(390, 46)" end="(390, 51)">
                                      <OtherNode start="(390, 46)" end="(390, 51)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(390, 46)" end="(390, 48)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(390, 49)" end="(390, 51)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(390, 49)" end="(390, 51)">
                                            <IdentNode start="(390, 49)" end="(390, 51)" leading="" trailing="&#10;      " raw_val="hb" val="hb"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(391, 7)" end="(391, 27)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;⊢ zipIdxLE le (a, i) (b, j) = true → zipIdxLE le (b, j) (a, i) = true → (a, i) = (b, j)" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;⊢ (if le a b = true then if le b a = true then decide (i ≤ j) else true else false) = true →&#10;    (if le b a = true then if le a b = true then decide (j ≤ i) else true else false) = true → (a, i) = (b, j)" tactic="simp only [zipIdxLE]">
                                    <AtomNode start="(391, 7)" end="(391, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(391, 12)" end="(391, 16)">
                                      <AtomNode start="(391, 12)" end="(391, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(391, 17)" end="(391, 27)">
                                      <AtomNode start="(391, 17)" end="(391, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(391, 18)" end="(391, 26)">
                                        <OtherNode start="(391, 18)" end="(391, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(391, 18)" end="(391, 26)" leading="" trailing="" raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(391, 26)" end="(391, 27)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(392, 7)" end="(392, 80)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;⊢ (if le a b = true then if le b a = true then decide (i ≤ j) else true else false) = true →&#10;    (if le b a = true then if le a b = true then decide (j ≤ i) else true else false) = true → (a, i) = (b, j)" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;⊢ decide (le a b = true) = true →&#10;    (if le b a = true then decide (i ≤ j) else true) = true →&#10;      decide (le b a = true) = true → (if le a b = true then decide (j ≤ i) else true) = true → a = b ∧ i = j" tactic="simp only [Bool.if_false_right, Bool.and_eq_true, Prod.mk.injEq, and_imp]">
                                    <AtomNode start="(392, 7)" end="(392, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(392, 12)" end="(392, 16)">
                                      <AtomNode start="(392, 12)" end="(392, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(392, 17)" end="(392, 80)">
                                      <AtomNode start="(392, 17)" end="(392, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(392, 18)" end="(392, 79)">
                                        <OtherNode start="(392, 18)" end="(392, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(392, 18)" end="(392, 37)" leading="" trailing="" raw_val="Bool.if_false_right" val="Bool.if_false_right" full_name="Bool.if_false_right" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(392, 37)" end="(392, 38)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(392, 39)" end="(392, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(392, 39)" end="(392, 55)" leading="" trailing="" raw_val="Bool.and_eq_true" val="Bool.and_eq_true" full_name="Bool.and_eq_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(392, 55)" end="(392, 56)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(392, 57)" end="(392, 70)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(392, 57)" end="(392, 70)" leading="" trailing="" raw_val="Prod.mk.injEq" val="Prod.mk.injEq" full_name="Prod.mk.injEq" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(392, 70)" end="(392, 71)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(392, 72)" end="(392, 79)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(392, 72)" end="(392, 79)" leading="" trailing="" raw_val="and_imp" val="and_imp" full_name="and_imp" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(392, 79)" end="(392, 80)" leading="" trailing="&#10;      " val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(393, 7)" end="(393, 23)" kind="Lean.Parser.Tactic.intro" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;⊢ decide (le a b = true) = true →&#10;    (if le b a = true then decide (i ≤ j) else true) = true →&#10;      decide (le b a = true) = true → (if le a b = true then decide (j ≤ i) else true) = true → a = b ∧ i = j" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h : (if le b a = true then decide (i ≤ j) else true) = true&#10;ba : decide (le b a = true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;⊢ a = b ∧ i = j" tactic="intro ab h ba h'">
                                    <AtomNode start="(393, 7)" end="(393, 12)" leading="" trailing=" " val="intro"/>
                                    <NullNode start="(393, 13)" end="(393, 23)">
                                      <IdentNode start="(393, 13)" end="(393, 15)" leading="" trailing=" " raw_val="ab" val="ab"/>
                                      <IdentNode start="(393, 16)" end="(393, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                                      <IdentNode start="(393, 18)" end="(393, 20)" leading="" trailing=" " raw_val="ba" val="ba"/>
                                      <IdentNode start="(393, 21)" end="(393, 23)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(394, 7)" end="(394, 44)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h : (if le b a = true then decide (i ≤ j) else true) = true&#10;ba : decide (le b a = true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;⊢ a = b ∧ i = j" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h : (if le b a = true then decide (i ≤ j) else true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;ba : le b a = true&#10;⊢ a = b ∧ i = j" tactic="simp only [Bool.decide_eq_true] at ba">
                                    <AtomNode start="(394, 7)" end="(394, 11)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode start="(394, 12)" end="(394, 16)">
                                      <AtomNode start="(394, 12)" end="(394, 16)" leading="" trailing=" " val="only"/>
                                    </NullNode>
                                    <NullNode start="(394, 17)" end="(394, 38)">
                                      <AtomNode start="(394, 17)" end="(394, 18)" leading="" trailing="" val="["/>
                                      <NullNode start="(394, 18)" end="(394, 37)">
                                        <OtherNode start="(394, 18)" end="(394, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(394, 18)" end="(394, 37)" leading="" trailing="" raw_val="Bool.decide_eq_true" val="Bool.decide_eq_true" full_name="Bool.decide_eq_true" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(394, 37)" end="(394, 38)" leading="" trailing=" " val="]"/>
                                    </NullNode>
                                    <NullNode start="(394, 39)" end="(394, 44)">
                                      <OtherNode start="(394, 39)" end="(394, 44)" kind="Lean.Parser.Tactic.location">
                                        <AtomNode start="(394, 39)" end="(394, 41)" leading="" trailing=" " val="at"/>
                                        <OtherNode start="(394, 42)" end="(394, 44)" kind="Lean.Parser.Tactic.locationHyp">
                                          <NullNode start="(394, 42)" end="(394, 44)">
                                            <IdentNode start="(394, 42)" end="(394, 44)" leading="" trailing="&#10;      " raw_val="ba" val="ba"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(395, 7)" end="(395, 53)" kind="Lean.Parser.Tactic.replace" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h : (if le b a = true then decide (i ≤ j) else true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;ba : le b a = true&#10;⊢ a = b ∧ i = j" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;ba : le b a = true&#10;h : i ≤ j&#10;⊢ a = b ∧ i = j" tactic="replace h : i ≤ j := by simpa [ab, ba] using h">
                                    <AtomNode start="(395, 7)" end="(395, 14)" leading="" trailing=" " val="replace"/>
                                    <OtherNode start="(395, 15)" end="(395, 53)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(395, 15)" end="(395, 53)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(395, 15)" end="(395, 16)" kind="Lean.Parser.Term.haveId">
                                          <IdentNode start="(395, 15)" end="(395, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(395, 17)" end="(395, 24)">
                                          <TermTypespecNode start="(395, 17)" end="(395, 24)">
                                            <AtomNode start="(395, 17)" end="(395, 18)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(395, 19)" end="(395, 24)" kind="«term_≤_»">
                                              <IdentNode start="(395, 19)" end="(395, 20)" leading="" trailing=" " raw_val="i" val="i"/>
                                              <AtomNode start="(395, 21)" end="(395, 22)" leading="" trailing=" " val="≤"/>
                                              <IdentNode start="(395, 23)" end="(395, 24)" leading="" trailing=" " raw_val="j" val="j"/>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(395, 25)" end="(395, 27)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(395, 28)" end="(395, 53)">
                                          <AtomNode start="(395, 28)" end="(395, 30)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(395, 31)" end="(395, 53)">
                                            <TacticTacticseq1IndentedNode start="(395, 31)" end="(395, 53)">
                                              <NullNode start="(395, 31)" end="(395, 53)">
                                                <OtherNode start="(395, 31)" end="(395, 53)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h : (if le b a = true then decide (i ≤ j) else true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;ba : le b a = true&#10;⊢ i ≤ j" state_after="no goals" tactic="simpa [ab, ba] using h">
                                                  <AtomNode start="(395, 31)" end="(395, 36)" leading="" trailing=" " val="simpa"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode start="(395, 37)" end="(395, 53)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(395, 37)" end="(395, 45)">
                                                      <OtherNode start="(395, 37)" end="(395, 45)" kind="Lean.Parser.Tactic.simpArgs">
                                                        <AtomNode start="(395, 37)" end="(395, 38)" leading="" trailing="" val="["/>
                                                        <NullNode start="(395, 38)" end="(395, 44)">
                                                          <OtherNode start="(395, 38)" end="(395, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(395, 38)" end="(395, 40)" leading="" trailing="" raw_val="ab" val="ab"/>
                                                          </OtherNode>
                                                          <AtomNode start="(395, 40)" end="(395, 41)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(395, 42)" end="(395, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(395, 42)" end="(395, 44)" leading="" trailing="" raw_val="ba" val="ba"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(395, 44)" end="(395, 45)" leading="" trailing=" " val="]"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode start="(395, 46)" end="(395, 53)">
                                                      <AtomNode start="(395, 46)" end="(395, 51)" leading="" trailing=" " val="using"/>
                                                      <IdentNode start="(395, 52)" end="(395, 53)" leading="" trailing="&#10;      " raw_val="h" val="h"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(396, 7)" end="(396, 55)" kind="Lean.Parser.Tactic.replace" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;ba : le b a = true&#10;h : i ≤ j&#10;⊢ a = b ∧ i = j" state_after="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;h : i ≤ j&#10;h' : j ≤ i&#10;⊢ a = b ∧ i = j" tactic="replace h' : j ≤ i := by simpa [ab, ba] using h'">
                                    <AtomNode start="(396, 7)" end="(396, 14)" leading="" trailing=" " val="replace"/>
                                    <OtherNode start="(396, 15)" end="(396, 55)" kind="Lean.Parser.Term.haveDecl">
                                      <OtherNode start="(396, 15)" end="(396, 55)" kind="Lean.Parser.Term.haveIdDecl">
                                        <OtherNode start="(396, 15)" end="(396, 17)" kind="Lean.Parser.Term.haveId">
                                          <IdentNode start="(396, 15)" end="(396, 17)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode start="(396, 18)" end="(396, 25)">
                                          <TermTypespecNode start="(396, 18)" end="(396, 25)">
                                            <AtomNode start="(396, 18)" end="(396, 19)" leading="" trailing=" " val=":"/>
                                            <OtherNode start="(396, 20)" end="(396, 25)" kind="«term_≤_»">
                                              <IdentNode start="(396, 20)" end="(396, 21)" leading="" trailing=" " raw_val="j" val="j"/>
                                              <AtomNode start="(396, 22)" end="(396, 23)" leading="" trailing=" " val="≤"/>
                                              <IdentNode start="(396, 24)" end="(396, 25)" leading="" trailing=" " raw_val="i" val="i"/>
                                            </OtherNode>
                                          </TermTypespecNode>
                                        </NullNode>
                                        <AtomNode start="(396, 26)" end="(396, 28)" leading="" trailing=" " val=":="/>
                                        <TermBytacticNode start="(396, 29)" end="(396, 55)">
                                          <AtomNode start="(396, 29)" end="(396, 31)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(396, 32)" end="(396, 55)">
                                            <TacticTacticseq1IndentedNode start="(396, 32)" end="(396, 55)">
                                              <NullNode start="(396, 32)" end="(396, 55)">
                                                <OtherNode start="(396, 32)" end="(396, 55)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;h' : (if le a b = true then decide (j ≤ i) else true) = true&#10;ba : le b a = true&#10;h : i ≤ j&#10;⊢ j ≤ i" state_after="no goals" tactic="simpa [ab, ba] using h'">
                                                  <AtomNode start="(396, 32)" end="(396, 37)" leading="" trailing=" " val="simpa"/>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <OtherNode start="(396, 38)" end="(396, 55)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(396, 38)" end="(396, 46)">
                                                      <OtherNode start="(396, 38)" end="(396, 46)" kind="Lean.Parser.Tactic.simpArgs">
                                                        <AtomNode start="(396, 38)" end="(396, 39)" leading="" trailing="" val="["/>
                                                        <NullNode start="(396, 39)" end="(396, 45)">
                                                          <OtherNode start="(396, 39)" end="(396, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(396, 39)" end="(396, 41)" leading="" trailing="" raw_val="ab" val="ab"/>
                                                          </OtherNode>
                                                          <AtomNode start="(396, 41)" end="(396, 42)" leading="" trailing=" " val=","/>
                                                          <OtherNode start="(396, 43)" end="(396, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(396, 43)" end="(396, 45)" leading="" trailing="" raw_val="ba" val="ba"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(396, 45)" end="(396, 46)" leading="" trailing=" " val="]"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode start="(396, 47)" end="(396, 55)">
                                                      <AtomNode start="(396, 47)" end="(396, 52)" leading="" trailing=" " val="using"/>
                                                      <IdentNode start="(396, 53)" end="(396, 55)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                                    </NullNode>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(397, 7)" end="(397, 33)" kind="Lean.Parser.Tactic.cases" state_before="case intro.intro.refine_2.e_l.x.mk.mk&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;j : Nat&#10;ha : (a, i) ∈ l.zipIdx 1&#10;hb : (b, j) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;h : i ≤ j&#10;h' : j ≤ i&#10;⊢ a = b ∧ i = j" state_after="case intro.intro.refine_2.e_l.x.mk.mk.refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ a = b ∧ i = i" tactic="cases Nat.le_antisymm h h'">
                                    <AtomNode start="(397, 7)" end="(397, 12)" leading="" trailing=" " val="cases"/>
                                    <NullNode start="(397, 13)" end="(397, 33)">
                                      <OtherNode start="(397, 13)" end="(397, 33)" kind="Lean.Parser.Tactic.elimTarget">
                                        <NullNode/>
                                        <OtherNode start="(397, 13)" end="(397, 33)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(397, 13)" end="(397, 28)" leading="" trailing=" " raw_val="Nat.le_antisymm" val="Nat.le_antisymm" full_name="Nat.le_antisymm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <NullNode start="(397, 29)" end="(397, 33)">
                                            <IdentNode start="(397, 29)" end="(397, 30)" leading="" trailing=" " raw_val="h" val="h"/>
                                            <IdentNode start="(397, 31)" end="(397, 33)" leading="" trailing="&#10;      " raw_val="h'" val="h'"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(398, 7)" end="(398, 18)" kind="Lean.Parser.Tactic.constructor" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ a = b ∧ i = i" state_after="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ a = b&#10;&#10;case intro.intro.refine_2.e_l.x.mk.mk.refl.right&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ i = i" tactic="constructor">
                                    <AtomNode start="(398, 7)" end="(398, 18)" leading="" trailing="&#10;      " val="constructor"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(399, 7)" end="(401, 17)" kind="Lean.cdot" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ a = b&#10;&#10;case intro.intro.refine_2.e_l.x.mk.mk.refl.right&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ i = i" state_after="case intro.intro.refine_2.e_l.x.mk.mk.refl.right&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ i = i" tactic="· have := mem_zipIdx ha&#10;  have := mem_zipIdx hb&#10;  simp_all">
                                    <OtherNode start="(399, 7)" end="(399, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(399, 7)" end="(399, 8)" kind="patternIgnore">
                                        <OtherNode start="(399, 7)" end="(399, 8)" kind="token.«· »">
                                          <AtomNode start="(399, 7)" end="(399, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(399, 9)" end="(401, 17)">
                                      <TacticTacticseq1IndentedNode start="(399, 9)" end="(401, 17)">
                                        <NullNode start="(399, 9)" end="(401, 17)">
                                          <OtherNode start="(399, 9)" end="(399, 30)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ a = b" state_after="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;this : 1 ≤ i ∧ i &amp;lt; 1 + l.length ∧ a = l[i - 1]&#10;⊢ a = b" tactic="have := mem_zipIdx ha">
                                            <AtomNode start="(399, 9)" end="(399, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(399, 14)" end="(399, 30)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(399, 14)" end="(399, 30)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(399, 14)" end="(399, 14)" kind="Lean.Parser.Term.haveId">
                                                  <OtherNode start="(399, 14)" end="(399, 14)" kind="hygieneInfo">
                                                    <IdentNode start="(399, 14)" end="(399, 14)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <AtomNode start="(399, 14)" end="(399, 16)" leading="" trailing=" " val=":="/>
                                                <OtherNode start="(399, 17)" end="(399, 30)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(399, 17)" end="(399, 27)" leading="" trailing=" " raw_val="mem_zipIdx" val="mem_zipIdx" full_name="List.mem_zipIdx" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                                                  <NullNode start="(399, 28)" end="(399, 30)">
                                                    <IdentNode start="(399, 28)" end="(399, 30)" leading="" trailing="&#10;        " raw_val="ha" val="ha"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(400, 9)" end="(400, 30)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;this : 1 ≤ i ∧ i &amp;lt; 1 + l.length ∧ a = l[i - 1]&#10;⊢ a = b" state_after="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;this✝ : 1 ≤ i ∧ i &amp;lt; 1 + l.length ∧ a = l[i - 1]&#10;this : 1 ≤ i ∧ i &amp;lt; 1 + l.length ∧ b = l[i - 1]&#10;⊢ a = b" tactic="have := mem_zipIdx hb">
                                            <AtomNode start="(400, 9)" end="(400, 13)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(400, 14)" end="(400, 30)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(400, 14)" end="(400, 30)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(400, 14)" end="(400, 14)" kind="Lean.Parser.Term.haveId">
                                                  <OtherNode start="(400, 14)" end="(400, 14)" kind="hygieneInfo">
                                                    <IdentNode start="(400, 14)" end="(400, 14)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <AtomNode start="(400, 14)" end="(400, 16)" leading="" trailing=" " val=":="/>
                                                <OtherNode start="(400, 17)" end="(400, 30)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(400, 17)" end="(400, 27)" leading="" trailing=" " raw_val="mem_zipIdx" val="mem_zipIdx" full_name="List.mem_zipIdx" mod_name="Init.Data.List.Nat.Range" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/Range.lean"/>
                                                  <NullNode start="(400, 28)" end="(400, 30)">
                                                    <IdentNode start="(400, 28)" end="(400, 30)" leading="" trailing="&#10;        " raw_val="hb" val="hb"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <NullNode/>
                                          <OtherNode start="(401, 9)" end="(401, 17)" kind="Lean.Parser.Tactic.simpAll" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl.left&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;this✝ : 1 ≤ i ∧ i &amp;lt; 1 + l.length ∧ a = l[i - 1]&#10;this : 1 ≤ i ∧ i &amp;lt; 1 + l.length ∧ b = l[i - 1]&#10;⊢ a = b" state_after="no goals" tactic="simp_all">
                                            <AtomNode start="(401, 9)" end="(401, 17)" leading="" trailing="&#10;      " val="simp_all"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(402, 7)" end="(402, 12)" kind="Lean.cdot" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl.right&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ i = i" state_after="no goals" tactic="· rfl">
                                    <OtherNode start="(402, 7)" end="(402, 8)" kind="Lean.cdotTk">
                                      <OtherNode start="(402, 7)" end="(402, 8)" kind="patternIgnore">
                                        <OtherNode start="(402, 7)" end="(402, 8)" kind="token.«· »">
                                          <AtomNode start="(402, 7)" end="(402, 8)" leading="" trailing=" " val="·"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <TacticTacticseqNode start="(402, 9)" end="(402, 12)">
                                      <TacticTacticseq1IndentedNode start="(402, 9)" end="(402, 12)">
                                        <NullNode start="(402, 9)" end="(402, 12)">
                                          <OtherNode start="(402, 9)" end="(402, 12)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case intro.intro.refine_2.e_l.x.mk.mk.refl.right&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a✝ : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a✝ :: l).zipIdx).Nodup&#10;m₁ : (a✝, 0) ∈ (a✝ :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h✝ : (a✝ :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a✝, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a✝, 0) :: l₂)&#10;p : l₁ ++ (a✝, 0) :: l₂ ~ (a✝ :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;a : α&#10;i : Nat&#10;b : α&#10;ha : (a, i) ∈ l.zipIdx 1&#10;ab : decide (le a b = true) = true&#10;ba : le b a = true&#10;hb : (b, i) ∈ l.zipIdx 1&#10;h h' : i ≤ i&#10;⊢ i = i" state_after="no goals" tactic="rfl">
                                            <AtomNode start="(402, 9)" end="(402, 12)" leading="" trailing="&#10;    " val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(403, 5)" end="(403, 78)" kind="Lean.cdot" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((l.zipIdx 1).mergeSort (zipIdxLE le))&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" state_after="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" tactic="· exact sorted_mergeSort (zipIdxLE_trans trans) (zipIdxLE_total total) ..">
                            <OtherNode start="(403, 5)" end="(403, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(403, 5)" end="(403, 6)" kind="patternIgnore">
                                <OtherNode start="(403, 5)" end="(403, 6)" kind="token.«· »">
                                  <AtomNode start="(403, 5)" end="(403, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(403, 7)" end="(403, 78)">
                              <TacticTacticseq1IndentedNode start="(403, 7)" end="(403, 78)">
                                <NullNode start="(403, 7)" end="(403, 78)">
                                  <OtherNode start="(403, 7)" end="(403, 78)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) ((l.zipIdx 1).mergeSort (zipIdxLE le))" state_after="no goals" tactic="exact sorted_mergeSort (zipIdxLE_trans trans) (zipIdxLE_total total) ..">
                                    <AtomNode start="(403, 7)" end="(403, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(403, 13)" end="(403, 78)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(403, 13)" end="(403, 29)" leading="" trailing=" " raw_val="sorted_mergeSort" val="sorted_mergeSort" full_name="List.sorted_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(296, 9)" def_end="(296, 25)"/>
                                      <NullNode start="(403, 30)" end="(403, 78)">
                                        <OtherNode start="(403, 30)" end="(403, 52)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(403, 30)" end="(403, 31)" leading="" trailing="" val="("/>
                                          <OtherNode start="(403, 31)" end="(403, 51)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(403, 31)" end="(403, 45)" leading="" trailing=" " raw_val="zipIdxLE_trans" val="zipIdxLE_trans" full_name="List.zipIdxLE_trans" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(100, 9)" def_end="(100, 23)"/>
                                            <NullNode start="(403, 46)" end="(403, 51)">
                                              <IdentNode start="(403, 46)" end="(403, 51)" leading="" trailing="" raw_val="trans" val="trans"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(403, 51)" end="(403, 52)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <OtherNode start="(403, 53)" end="(403, 75)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(403, 53)" end="(403, 54)" leading="" trailing="" val="("/>
                                          <OtherNode start="(403, 54)" end="(403, 74)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(403, 54)" end="(403, 68)" leading="" trailing=" " raw_val="zipIdxLE_total" val="zipIdxLE_total" full_name="List.zipIdxLE_total" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(128, 9)" def_end="(128, 23)"/>
                                            <NullNode start="(403, 69)" end="(403, 74)">
                                              <IdentNode start="(403, 69)" end="(403, 74)" leading="" trailing="" raw_val="total" val="total"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(403, 74)" end="(403, 75)" leading="" trailing=" " val=")"/>
                                        </OtherNode>
                                        <OtherNode start="(403, 76)" end="(403, 78)" kind="Lean.Parser.Term.ellipsis">
                                          <AtomNode start="(403, 76)" end="(403, 78)" leading="" trailing="&#10;    " val=".."/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(404, 5)" end="(404, 69)" kind="Lean.cdot" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)&#10;&#10;case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" state_after="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" tactic="· exact s.sublist ((sublist_cons_self (a, 0) l₂).append_left l₁)">
                            <OtherNode start="(404, 5)" end="(404, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(404, 5)" end="(404, 6)" kind="patternIgnore">
                                <OtherNode start="(404, 5)" end="(404, 6)" kind="token.«· »">
                                  <AtomNode start="(404, 5)" end="(404, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(404, 7)" end="(404, 69)">
                              <TacticTacticseq1IndentedNode start="(404, 7)" end="(404, 69)">
                                <NullNode start="(404, 7)" end="(404, 69)">
                                  <OtherNode start="(404, 7)" end="(404, 69)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ l₂)" state_after="no goals" tactic="exact s.sublist ((sublist_cons_self (a, 0) l₂).append_left l₁)">
                                    <AtomNode start="(404, 7)" end="(404, 12)" leading="" trailing=" " val="exact"/>
                                    <OtherNode start="(404, 13)" end="(404, 69)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(404, 13)" end="(404, 22)" leading="" trailing=" " raw_val="s.sublist" val="s.sublist"/>
                                      <NullNode start="(404, 23)" end="(404, 69)">
                                        <OtherNode start="(404, 23)" end="(404, 69)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(404, 23)" end="(404, 24)" leading="" trailing="" val="("/>
                                          <OtherNode start="(404, 24)" end="(404, 68)" kind="Lean.Parser.Term.app">
                                            <OtherNode start="(404, 24)" end="(404, 65)" kind="Lean.Parser.Term.proj">
                                              <OtherNode start="(404, 24)" end="(404, 53)" kind="Lean.Parser.Term.paren">
                                                <AtomNode start="(404, 24)" end="(404, 25)" leading="" trailing="" val="("/>
                                                <OtherNode start="(404, 25)" end="(404, 52)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(404, 25)" end="(404, 42)" leading="" trailing=" " raw_val="sublist_cons_self" val="sublist_cons_self" full_name="List.sublist_cons_self" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                  <NullNode start="(404, 43)" end="(404, 52)">
                                                    <OtherNode start="(404, 43)" end="(404, 49)" kind="Lean.Parser.Term.tuple">
                                                      <AtomNode start="(404, 43)" end="(404, 44)" leading="" trailing="" val="("/>
                                                      <NullNode start="(404, 44)" end="(404, 48)">
                                                        <IdentNode start="(404, 44)" end="(404, 45)" leading="" trailing="" raw_val="a" val="a"/>
                                                        <AtomNode start="(404, 45)" end="(404, 46)" leading="" trailing=" " val=","/>
                                                        <NullNode start="(404, 47)" end="(404, 48)">
                                                          <OtherNode start="(404, 47)" end="(404, 48)" kind="num">
                                                            <AtomNode start="(404, 47)" end="(404, 48)" leading="" trailing="" val="0"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </NullNode>
                                                      <AtomNode start="(404, 48)" end="(404, 49)" leading="" trailing=" " val=")"/>
                                                    </OtherNode>
                                                    <IdentNode start="(404, 50)" end="(404, 52)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                                  </NullNode>
                                                </OtherNode>
                                                <AtomNode start="(404, 52)" end="(404, 53)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                              <AtomNode start="(404, 53)" end="(404, 54)" leading="" trailing="" val="."/>
                                              <IdentNode start="(404, 54)" end="(404, 65)" leading="" trailing=" " raw_val="append_left" val="append_left" full_name="List.Sublist.append_left" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                            </OtherNode>
                                            <NullNode start="(404, 66)" end="(404, 68)">
                                              <IdentNode start="(404, 66)" end="(404, 68)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(404, 68)" end="(404, 69)" leading="" trailing="&#10;    " val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(405, 5)" end="(405, 14)" kind="Lean.cdot" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" state_after="no goals" tactic="· exact q">
                            <OtherNode start="(405, 5)" end="(405, 6)" kind="Lean.cdotTk">
                              <OtherNode start="(405, 5)" end="(405, 6)" kind="patternIgnore">
                                <OtherNode start="(405, 5)" end="(405, 6)" kind="token.«· »">
                                  <AtomNode start="(405, 5)" end="(405, 6)" leading="" trailing=" " val="·"/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <TacticTacticseqNode start="(405, 7)" end="(405, 14)">
                              <TacticTacticseq1IndentedNode start="(405, 7)" end="(405, 14)">
                                <NullNode start="(405, 7)" end="(405, 14)">
                                  <OtherNode start="(405, 7)" end="(405, 14)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro.refine_2.e_l.x&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;q : (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂&#10;⊢ (l.zipIdx 1).mergeSort (zipIdxLE le) ~ l₁ ++ l₂" state_after="no goals" tactic="exact q">
                                    <AtomNode start="(405, 7)" end="(405, 12)" leading="" trailing=" " val="exact"/>
                                    <IdentNode start="(405, 13)" end="(405, 14)" leading="" trailing="&#10;  " raw_val="q" val="q"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(406, 3)" end="(416, 24)" kind="Lean.cdot" state_before="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" state_after="no goals" tactic="· intro b m&#10;  simp only [mem_map, Prod.exists] at m&#10;  obtain ⟨j, _, m, rfl⟩ := m&#10;  replace p := p.map (·.2)&#10;  have nd' := nd.perm p.symm&#10;  rw [map_append] at nd'&#10;  have j0 := nd'.rel_of_mem_append&#10;    (mem_map_of_mem m) (mem_map_of_mem mem_cons_self)&#10;  simp only [ne_eq] at j0&#10;  have r := s.rel_of_mem_append m mem_cons_self&#10;  simp_all [zipIdxLE]">
                    <OtherNode start="(406, 3)" end="(406, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(406, 3)" end="(406, 4)" kind="patternIgnore">
                        <OtherNode start="(406, 3)" end="(406, 4)" kind="token.«· »">
                          <AtomNode start="(406, 3)" end="(406, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(406, 5)" end="(416, 24)">
                      <TacticTacticseq1IndentedNode start="(406, 5)" end="(416, 24)">
                        <NullNode start="(406, 5)" end="(416, 24)">
                          <OtherNode start="(406, 5)" end="(406, 14)" kind="Lean.Parser.Tactic.intro" state_before="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;⊢ ∀ (b : α), b ∈ map (fun x =&amp;gt; x.fst) l₁ → (!le a b) = true" state_after="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;b : α&#10;m : b ∈ map (fun x =&amp;gt; x.fst) l₁&#10;⊢ (!le a b) = true" tactic="intro b m">
                            <AtomNode start="(406, 5)" end="(406, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(406, 11)" end="(406, 14)">
                              <IdentNode start="(406, 11)" end="(406, 12)" leading="" trailing=" " raw_val="b" val="b"/>
                              <IdentNode start="(406, 13)" end="(406, 14)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(407, 5)" end="(407, 42)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;b : α&#10;m : b ∈ map (fun x =&amp;gt; x.fst) l₁&#10;⊢ (!le a b) = true" state_after="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;b : α&#10;m : ∃ a b_1, (a, b_1) ∈ l₁ ∧ a = b&#10;⊢ (!le a b) = true" tactic="simp only [mem_map, Prod.exists] at m">
                            <AtomNode start="(407, 5)" end="(407, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(407, 10)" end="(407, 14)">
                              <AtomNode start="(407, 10)" end="(407, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(407, 15)" end="(407, 37)">
                              <AtomNode start="(407, 15)" end="(407, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(407, 16)" end="(407, 36)">
                                <OtherNode start="(407, 16)" end="(407, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(407, 16)" end="(407, 23)" leading="" trailing="" raw_val="mem_map" val="mem_map" full_name="List.mem_map" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(407, 23)" end="(407, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(407, 25)" end="(407, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(407, 25)" end="(407, 36)" leading="" trailing="" raw_val="Prod.exists" val="Prod.exists" full_name="Prod.exists" mod_name="Init.Data.Prod" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Prod.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(407, 36)" end="(407, 37)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(407, 38)" end="(407, 42)">
                              <OtherNode start="(407, 38)" end="(407, 42)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(407, 38)" end="(407, 40)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(407, 41)" end="(407, 42)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(407, 41)" end="(407, 42)">
                                    <IdentNode start="(407, 41)" end="(407, 42)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(408, 5)" end="(408, 31)" kind="Lean.Parser.Tactic.obtain" state_before="case intro.intro.refine_3&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;b : α&#10;m : ∃ a b_1, (a, b_1) ∈ l₁ ∧ a = b&#10;⊢ (!le a b) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;⊢ (!le a j) = true" tactic="obtain ⟨j, _, m, rfl⟩ := m">
                            <AtomNode start="(408, 5)" end="(408, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(408, 12)" end="(408, 26)">
                              <OtherNode start="(408, 12)" end="(408, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(408, 12)" end="(408, 26)">
                                  <OtherNode start="(408, 12)" end="(408, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(408, 12)" end="(408, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(408, 13)" end="(408, 25)">
                                      <OtherNode start="(408, 13)" end="(408, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(408, 13)" end="(408, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(408, 13)" end="(408, 14)">
                                            <OtherNode start="(408, 13)" end="(408, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(408, 13)" end="(408, 14)" leading="" trailing="" raw_val="j" val="j"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(408, 14)" end="(408, 15)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(408, 16)" end="(408, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(408, 16)" end="(408, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(408, 16)" end="(408, 17)">
                                            <OtherNode start="(408, 16)" end="(408, 17)" kind="Lean.Parser.Tactic.rcasesPat.ignore">
                                              <AtomNode start="(408, 16)" end="(408, 17)" leading="" trailing="" val="_"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(408, 17)" end="(408, 18)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(408, 19)" end="(408, 20)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(408, 19)" end="(408, 20)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(408, 19)" end="(408, 20)">
                                            <OtherNode start="(408, 19)" end="(408, 20)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(408, 19)" end="(408, 20)" leading="" trailing="" raw_val="m" val="m"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(408, 20)" end="(408, 21)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(408, 22)" end="(408, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(408, 22)" end="(408, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(408, 22)" end="(408, 25)">
                                            <OtherNode start="(408, 22)" end="(408, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(408, 22)" end="(408, 25)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(408, 25)" end="(408, 26)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(408, 27)" end="(408, 31)">
                              <AtomNode start="(408, 27)" end="(408, 29)" leading="" trailing=" " val=":="/>
                              <NullNode start="(408, 30)" end="(408, 31)">
                                <IdentNode start="(408, 30)" end="(408, 31)" leading="" trailing="&#10;    " raw_val="m" val="m"/>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(409, 5)" end="(409, 29)" kind="Lean.Parser.Tactic.replace" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;p : l₁ ++ (a, 0) :: l₂ ~ (a :: l).zipIdx&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;⊢ (!le a j) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;⊢ (!le a j) = true" tactic="replace p := p.map (·.2)">
                            <AtomNode start="(409, 5)" end="(409, 12)" leading="" trailing=" " val="replace"/>
                            <OtherNode start="(409, 13)" end="(409, 29)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(409, 13)" end="(409, 29)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(409, 13)" end="(409, 14)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(409, 13)" end="(409, 14)" leading="" trailing=" " raw_val="p" val="p"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(409, 15)" end="(409, 17)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(409, 18)" end="(409, 29)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(409, 18)" end="(409, 23)" leading="" trailing=" " raw_val="p.map" val="p.map"/>
                                  <NullNode start="(409, 24)" end="(409, 29)">
                                    <OtherNode start="(409, 24)" end="(409, 29)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(409, 24)" end="(409, 25)" leading="" trailing="" val="("/>
                                      <OtherNode start="(409, 25)" end="(409, 28)" kind="Lean.Parser.Term.proj">
                                        <OtherNode start="(409, 25)" end="(409, 26)" kind="Lean.Parser.Term.cdot">
                                          <AtomNode start="(409, 25)" end="(409, 26)" leading="" trailing="" val="·"/>
                                        </OtherNode>
                                        <AtomNode start="(409, 26)" end="(409, 27)" leading="" trailing="" val="."/>
                                        <OtherNode start="(409, 27)" end="(409, 28)" kind="fieldIdx">
                                          <AtomNode start="(409, 27)" end="(409, 28)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(409, 28)" end="(409, 29)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(410, 5)" end="(410, 31)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;⊢ (!le a j) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂)).Nodup&#10;⊢ (!le a j) = true" tactic="have nd' := nd.perm p.symm">
                            <AtomNode start="(410, 5)" end="(410, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(410, 10)" end="(410, 31)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(410, 10)" end="(410, 31)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(410, 10)" end="(410, 13)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(410, 10)" end="(410, 13)" leading="" trailing=" " raw_val="nd'" val="nd'"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(410, 14)" end="(410, 16)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(410, 17)" end="(410, 31)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(410, 17)" end="(410, 24)" leading="" trailing=" " raw_val="nd.perm" val="nd.perm"/>
                                  <NullNode start="(410, 25)" end="(410, 31)">
                                    <IdentNode start="(410, 25)" end="(410, 31)" leading="" trailing="&#10;    " raw_val="p.symm" val="p.symm"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(411, 5)" end="(411, 27)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂)).Nodup&#10;⊢ (!le a j) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;⊢ (!le a j) = true" tactic="rw [map_append] at nd'">
                            <AtomNode start="(411, 5)" end="(411, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(411, 8)" end="(411, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(411, 8)" end="(411, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(411, 9)" end="(411, 19)">
                                <OtherNode start="(411, 9)" end="(411, 19)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(411, 9)" end="(411, 19)" leading="" trailing="" raw_val="map_append" val="map_append" full_name="List.map_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(411, 19)" end="(411, 20)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(411, 21)" end="(411, 27)">
                              <OtherNode start="(411, 21)" end="(411, 27)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(411, 21)" end="(411, 23)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(411, 24)" end="(411, 27)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(411, 24)" end="(411, 27)">
                                    <IdentNode start="(411, 24)" end="(411, 27)" leading="" trailing="&#10;    " raw_val="nd'" val="nd'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(412, 5)" end="(413, 56)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;⊢ (!le a j) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;j0 : (j, w✝).snd ≠ (a, 0).snd&#10;⊢ (!le a j) = true" tactic="have j0 := nd'.rel_of_mem_append&#10;  (mem_map_of_mem m) (mem_map_of_mem mem_cons_self)">
                            <AtomNode start="(412, 5)" end="(412, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(412, 10)" end="(413, 56)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(412, 10)" end="(413, 56)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(412, 10)" end="(412, 12)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(412, 10)" end="(412, 12)" leading="" trailing=" " raw_val="j0" val="j0"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(412, 13)" end="(412, 15)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(412, 16)" end="(413, 56)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(412, 16)" end="(412, 37)" leading="" trailing="&#10;      " raw_val="nd'.rel_of_mem_append" val="nd'.rel_of_mem_append"/>
                                  <NullNode start="(413, 7)" end="(413, 56)">
                                    <OtherNode start="(413, 7)" end="(413, 25)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(413, 7)" end="(413, 8)" leading="" trailing="" val="("/>
                                      <OtherNode start="(413, 8)" end="(413, 24)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(413, 8)" end="(413, 22)" leading="" trailing=" " raw_val="mem_map_of_mem" val="mem_map_of_mem" full_name="List.mem_map_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        <NullNode start="(413, 23)" end="(413, 24)">
                                          <IdentNode start="(413, 23)" end="(413, 24)" leading="" trailing="" raw_val="m" val="m"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(413, 24)" end="(413, 25)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <OtherNode start="(413, 26)" end="(413, 56)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(413, 26)" end="(413, 27)" leading="" trailing="" val="("/>
                                      <OtherNode start="(413, 27)" end="(413, 55)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(413, 27)" end="(413, 41)" leading="" trailing=" " raw_val="mem_map_of_mem" val="mem_map_of_mem" full_name="List.mem_map_of_mem" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        <NullNode start="(413, 42)" end="(413, 55)">
                                          <IdentNode start="(413, 42)" end="(413, 55)" leading="" trailing="" raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(413, 55)" end="(413, 56)" leading="" trailing="&#10;    " val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(414, 5)" end="(414, 28)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;j0 : (j, w✝).snd ≠ (a, 0).snd&#10;⊢ (!le a j) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;j0 : ¬w✝ = 0&#10;⊢ (!le a j) = true" tactic="simp only [ne_eq] at j0">
                            <AtomNode start="(414, 5)" end="(414, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(414, 10)" end="(414, 14)">
                              <AtomNode start="(414, 10)" end="(414, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(414, 15)" end="(414, 22)">
                              <AtomNode start="(414, 15)" end="(414, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(414, 16)" end="(414, 21)">
                                <OtherNode start="(414, 16)" end="(414, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(414, 16)" end="(414, 21)" leading="" trailing="" raw_val="ne_eq" val="ne_eq" full_name="ne_eq" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(414, 21)" end="(414, 22)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(414, 23)" end="(414, 28)">
                              <OtherNode start="(414, 23)" end="(414, 28)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(414, 23)" end="(414, 25)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(414, 26)" end="(414, 28)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(414, 26)" end="(414, 28)">
                                    <IdentNode start="(414, 26)" end="(414, 28)" leading="" trailing="&#10;    " raw_val="j0" val="j0"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(415, 5)" end="(415, 50)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;j0 : ¬w✝ = 0&#10;⊢ (!le a j) = true" state_after="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;j0 : ¬w✝ = 0&#10;r : zipIdxLE le (j, w✝) (a, 0) = true&#10;⊢ (!le a j) = true" tactic="have r := s.rel_of_mem_append m mem_cons_self">
                            <AtomNode start="(415, 5)" end="(415, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(415, 10)" end="(415, 50)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(415, 10)" end="(415, 50)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(415, 10)" end="(415, 11)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(415, 10)" end="(415, 11)" leading="" trailing=" " raw_val="r" val="r"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(415, 12)" end="(415, 14)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(415, 15)" end="(415, 50)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(415, 15)" end="(415, 34)" leading="" trailing=" " raw_val="s.rel_of_mem_append" val="s.rel_of_mem_append"/>
                                  <NullNode start="(415, 35)" end="(415, 50)">
                                    <IdentNode start="(415, 35)" end="(415, 36)" leading="" trailing=" " raw_val="m" val="m"/>
                                    <IdentNode start="(415, 37)" end="(415, 50)" leading="" trailing="&#10;    " raw_val="mem_cons_self" val="mem_cons_self" full_name="List.mem_cons_self" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(416, 5)" end="(416, 24)" kind="Lean.Parser.Tactic.simpAll" state_before="case intro.intro.refine_3.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l : List α&#10;nd : (map (fun x =&amp;gt; x.snd) (a :: l).zipIdx).Nodup&#10;m₁ : (a, 0) ∈ (a :: l).zipIdx.mergeSort (zipIdxLE le)&#10;l₁ l₂ : List (α × Nat)&#10;h : (a :: l).zipIdx.mergeSort (zipIdxLE le) = l₁ ++ (a, 0) :: l₂&#10;s : Pairwise (fun a b =&amp;gt; zipIdxLE le a b = true) (l₁ ++ (a, 0) :: l₂)&#10;j : α&#10;w✝ : Nat&#10;m : (j, w✝) ∈ l₁&#10;p : map (fun x =&amp;gt; x.snd) (l₁ ++ (a, 0) :: l₂) ~ map (fun x =&amp;gt; x.snd) (a :: l).zipIdx&#10;nd' : (map (fun x =&amp;gt; x.snd) l₁ ++ map (fun x =&amp;gt; x.snd) ((a, 0) :: l₂)).Nodup&#10;j0 : ¬w✝ = 0&#10;r : zipIdxLE le (j, w✝) (a, 0) = true&#10;⊢ (!le a j) = true" state_after="no goals" tactic="simp_all [zipIdxLE]">
                            <AtomNode start="(416, 5)" end="(416, 13)" leading="" trailing=" " val="simp_all"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(416, 14)" end="(416, 24)">
                              <AtomNode start="(416, 14)" end="(416, 15)" leading="" trailing="" val="["/>
                              <NullNode start="(416, 15)" end="(416, 23)">
                                <OtherNode start="(416, 15)" end="(416, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(416, 15)" end="(416, 23)" leading="" trailing="" raw_val="zipIdxLE" val="zipIdxLE" full_name="List.zipIdxLE" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(416, 23)" end="(416, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(418, 1)" end="(445, 91)" name="sublist_mergeSort" full_name="List.sublist_mergeSort">
      <CommandDeclmodifiersNode start="(418, 1)" end="(422, 3)">
        <NullNode start="(418, 1)" end="(422, 3)">
          <CommandDoccommentNode start="(418, 1)" end="(422, 3)" comment="Another statement of stability of merge sort.&#10;If `c` is a sorted sublist of `l`,&#10;then `c` is still a sublist of `mergeSort le l`.&#10;-/">
            <AtomNode start="(418, 1)" end="(418, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(419, 1)" end="(422, 3)" leading="" trailing="&#10;" val="Another statement of stability of merge sort.&#10;If `c` is a sorted sublist of `l`,&#10;then `c` is still a sublist of `mergeSort le l`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(423, 1)" end="(445, 91)" name="sublist_mergeSort" full_name="List.sublist_mergeSort" _is_private_decl="False">
        <AtomNode start="(423, 1)" end="(423, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(423, 9)" end="(423, 26)">
          <IdentNode start="(423, 9)" end="(423, 26)" leading="" trailing="&#10;    " raw_val="sublist_mergeSort" val="sublist_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(424, 5)" end="(427, 26)">
          <NullNode start="(424, 5)" end="(425, 44)">
            <TermExplicitbinderNode start="(424, 5)" end="(424, 54)">
              <AtomNode start="(424, 5)" end="(424, 6)" leading="" trailing="" val="("/>
              <NullNode start="(424, 6)" end="(424, 11)">
                <IdentNode start="(424, 6)" end="(424, 11)" leading="" trailing=" " raw_val="trans" val="trans"/>
              </NullNode>
              <NullNode start="(424, 12)" end="(424, 53)">
                <AtomNode start="(424, 12)" end="(424, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(424, 14)" end="(424, 53)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(424, 14)" end="(424, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(424, 16)" end="(424, 27)">
                    <TermExplicitbinderNode start="(424, 16)" end="(424, 27)">
                      <AtomNode start="(424, 16)" end="(424, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(424, 17)" end="(424, 22)">
                        <IdentNode start="(424, 17)" end="(424, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(424, 19)" end="(424, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(424, 21)" end="(424, 22)" leading="" trailing=" " raw_val="c" val="c"/>
                      </NullNode>
                      <NullNode start="(424, 23)" end="(424, 26)">
                        <AtomNode start="(424, 23)" end="(424, 24)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(424, 25)" end="(424, 26)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(424, 26)" end="(424, 27)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(424, 27)" end="(424, 28)" leading="" trailing=" " val=","/>
                  <OtherNode start="(424, 29)" end="(424, 53)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(424, 29)" end="(424, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(424, 29)" end="(424, 31)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(424, 32)" end="(424, 35)">
                        <IdentNode start="(424, 32)" end="(424, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(424, 34)" end="(424, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(424, 36)" end="(424, 37)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(424, 38)" end="(424, 53)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(424, 38)" end="(424, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(424, 38)" end="(424, 40)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(424, 41)" end="(424, 44)">
                          <IdentNode start="(424, 41)" end="(424, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(424, 43)" end="(424, 44)" leading="" trailing=" " raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(424, 45)" end="(424, 46)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(424, 47)" end="(424, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(424, 47)" end="(424, 49)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(424, 50)" end="(424, 53)">
                          <IdentNode start="(424, 50)" end="(424, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(424, 52)" end="(424, 53)" leading="" trailing="" raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(424, 53)" end="(424, 54)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(425, 5)" end="(425, 44)">
              <AtomNode start="(425, 5)" end="(425, 6)" leading="" trailing="" val="("/>
              <NullNode start="(425, 6)" end="(425, 11)">
                <IdentNode start="(425, 6)" end="(425, 11)" leading="" trailing=" " raw_val="total" val="total"/>
              </NullNode>
              <NullNode start="(425, 12)" end="(425, 43)">
                <AtomNode start="(425, 12)" end="(425, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(425, 14)" end="(425, 43)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(425, 14)" end="(425, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(425, 16)" end="(425, 25)">
                    <TermExplicitbinderNode start="(425, 16)" end="(425, 25)">
                      <AtomNode start="(425, 16)" end="(425, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(425, 17)" end="(425, 20)">
                        <IdentNode start="(425, 17)" end="(425, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(425, 19)" end="(425, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode start="(425, 21)" end="(425, 24)">
                        <AtomNode start="(425, 21)" end="(425, 22)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(425, 23)" end="(425, 24)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(425, 24)" end="(425, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(425, 25)" end="(425, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(425, 27)" end="(425, 43)" kind="«term_||_»">
                    <OtherNode start="(425, 27)" end="(425, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(425, 27)" end="(425, 29)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(425, 30)" end="(425, 33)">
                        <IdentNode start="(425, 30)" end="(425, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(425, 32)" end="(425, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(425, 34)" end="(425, 36)" leading="" trailing=" " val="||"/>
                    <OtherNode start="(425, 37)" end="(425, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(425, 37)" end="(425, 39)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(425, 40)" end="(425, 43)">
                        <IdentNode start="(425, 40)" end="(425, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(425, 42)" end="(425, 43)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(425, 43)" end="(425, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(425, 45)" end="(427, 26)">
            <AtomNode start="(425, 45)" end="(425, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(426, 5)" end="(427, 26)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(426, 5)" end="(426, 6)" leading="" trailing=" " val="∀"/>
              <NullNode start="(426, 7)" end="(426, 56)">
                <OtherNode start="(426, 7)" end="(426, 20)" kind="Lean.Parser.Term.implicitBinder">
                  <AtomNode start="(426, 7)" end="(426, 8)" leading="" trailing="" val="{"/>
                  <NullNode start="(426, 8)" end="(426, 10)">
                    <IdentNode start="(426, 8)" end="(426, 10)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  </NullNode>
                  <NullNode start="(426, 11)" end="(426, 19)">
                    <AtomNode start="(426, 11)" end="(426, 12)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(426, 13)" end="(426, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(426, 13)" end="(426, 17)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(426, 18)" end="(426, 19)">
                        <IdentNode start="(426, 18)" end="(426, 19)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(426, 19)" end="(426, 20)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <TermExplicitbinderNode start="(426, 21)" end="(426, 41)">
                  <AtomNode start="(426, 21)" end="(426, 22)" leading="" trailing="" val="("/>
                  <NullNode start="(426, 22)" end="(426, 23)">
                    <TermHoleNode start="(426, 22)" end="(426, 23)">
                      <AtomNode start="(426, 22)" end="(426, 23)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(426, 24)" end="(426, 40)">
                    <AtomNode start="(426, 24)" end="(426, 25)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(426, 26)" end="(426, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(426, 26)" end="(426, 37)" leading="" trailing=" " raw_val="ys.Pairwise" val="ys.Pairwise"/>
                      <NullNode start="(426, 38)" end="(426, 40)">
                        <IdentNode start="(426, 38)" end="(426, 40)" leading="" trailing="" raw_val="le" val="le"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(426, 40)" end="(426, 41)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <TermExplicitbinderNode start="(426, 42)" end="(426, 56)">
                  <AtomNode start="(426, 42)" end="(426, 43)" leading="" trailing="" val="("/>
                  <NullNode start="(426, 43)" end="(426, 44)">
                    <TermHoleNode start="(426, 43)" end="(426, 44)">
                      <AtomNode start="(426, 43)" end="(426, 44)" leading="" trailing=" " val="_"/>
                    </TermHoleNode>
                  </NullNode>
                  <NullNode start="(426, 45)" end="(426, 55)">
                    <AtomNode start="(426, 45)" end="(426, 46)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(426, 47)" end="(426, 55)" kind="List.«term_&amp;lt;+_»">
                      <IdentNode start="(426, 47)" end="(426, 49)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      <AtomNode start="(426, 50)" end="(426, 52)" leading="" trailing=" " val="&amp;lt;+"/>
                      <IdentNode start="(426, 53)" end="(426, 55)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(426, 55)" end="(426, 56)" leading="" trailing="" val=")"/>
                </TermExplicitbinderNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(426, 56)" end="(426, 57)" leading="" trailing="&#10;    " val=","/>
              <OtherNode start="(427, 5)" end="(427, 26)" kind="List.«term_&amp;lt;+_»">
                <IdentNode start="(427, 5)" end="(427, 7)" leading="" trailing=" " raw_val="ys" val="ys"/>
                <AtomNode start="(427, 8)" end="(427, 10)" leading="" trailing=" " val="&amp;lt;+"/>
                <OtherNode start="(427, 11)" end="(427, 26)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(427, 11)" end="(427, 20)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(427, 21)" end="(427, 26)">
                    <IdentNode start="(427, 21)" end="(427, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <IdentNode start="(427, 24)" end="(427, 26)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(428, 3)" end="(445, 91)">
          <OtherNode start="(428, 3)" end="(445, 91)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(428, 3)" end="(445, 91)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(428, 3)" end="(445, 91)">
                <OtherNode start="(428, 3)" end="(428, 34)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(428, 3)" end="(428, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(428, 5)" end="(428, 17)">
                    <NullNode start="(428, 5)" end="(428, 17)">
                      <TermHoleNode start="(428, 5)" end="(428, 6)">
                        <AtomNode start="(428, 5)" end="(428, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(428, 6)" end="(428, 7)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(428, 8)" end="(428, 9)">
                        <AtomNode start="(428, 8)" end="(428, 9)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(428, 9)" end="(428, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(428, 11)" end="(428, 17)" kind="Lean.Parser.Term.dotIdent">
                        <AtomNode start="(428, 11)" end="(428, 12)" leading="" trailing="" val="."/>
                        <IdentNode start="(428, 12)" end="(428, 17)" leading="" trailing=" " raw_val="slnil" val="slnil"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(428, 18)" end="(428, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                  <OtherNode start="(428, 21)" end="(428, 34)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(428, 21)" end="(428, 32)" leading="" trailing=" " raw_val="nil_sublist" val="nil_sublist" full_name="List.nil_sublist" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                    <NullNode start="(428, 33)" end="(428, 34)">
                      <TermHoleNode start="(428, 33)" end="(428, 34)">
                        <AtomNode start="(428, 33)" end="(428, 34)" leading="" trailing="&#10;  " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(429, 3)" end="(434, 22)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(429, 3)" end="(429, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(429, 5)" end="(429, 36)">
                    <NullNode start="(429, 5)" end="(429, 36)">
                      <IdentNode start="(429, 5)" end="(429, 7)" leading="" trailing="" raw_val="ys" val="ys"/>
                      <AtomNode start="(429, 7)" end="(429, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(429, 9)" end="(429, 11)" leading="" trailing="" raw_val="hc" val="hc"/>
                      <AtomNode start="(429, 11)" end="(429, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(429, 13)" end="(429, 36)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(429, 13)" end="(429, 26)" kind="Lean.Parser.Term.explicit">
                          <AtomNode start="(429, 13)" end="(429, 14)" leading="" trailing="" val="@"/>
                          <IdentNode start="(429, 14)" end="(429, 26)" leading="" trailing=" " raw_val="Sublist.cons" val="Sublist.cons" full_name="List.Sublist.cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <NullNode start="(429, 27)" end="(429, 36)">
                          <TermHoleNode start="(429, 27)" end="(429, 28)">
                            <AtomNode start="(429, 27)" end="(429, 28)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <TermHoleNode start="(429, 29)" end="(429, 30)">
                            <AtomNode start="(429, 29)" end="(429, 30)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <IdentNode start="(429, 31)" end="(429, 32)" leading="" trailing=" " raw_val="l" val="l"/>
                          <IdentNode start="(429, 33)" end="(429, 34)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(429, 35)" end="(429, 36)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(429, 37)" end="(429, 39)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(429, 40)" end="(434, 22)">
                    <AtomNode start="(429, 40)" end="(429, 42)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(430, 5)" end="(434, 22)">
                      <TacticTacticseq1IndentedNode start="(430, 5)" end="(434, 22)">
                        <NullNode start="(430, 5)" end="(434, 22)">
                          <OtherNode start="(430, 5)" end="(430, 65)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;⊢ ys &amp;lt;+ (a :: l).mergeSort le" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;⊢ ys &amp;lt;+ (a :: l).mergeSort le" tactic="obtain ⟨l₁, l₂, h₁, h₂, -⟩ := mergeSort_cons trans total a l">
                            <AtomNode start="(430, 5)" end="(430, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(430, 12)" end="(430, 31)">
                              <OtherNode start="(430, 12)" end="(430, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(430, 12)" end="(430, 31)">
                                  <OtherNode start="(430, 12)" end="(430, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(430, 12)" end="(430, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(430, 13)" end="(430, 30)">
                                      <OtherNode start="(430, 13)" end="(430, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(430, 13)" end="(430, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(430, 13)" end="(430, 15)">
                                            <OtherNode start="(430, 13)" end="(430, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(430, 13)" end="(430, 15)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(430, 15)" end="(430, 16)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 17)" end="(430, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(430, 17)" end="(430, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(430, 17)" end="(430, 19)">
                                            <OtherNode start="(430, 17)" end="(430, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(430, 17)" end="(430, 19)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(430, 19)" end="(430, 20)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 21)" end="(430, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(430, 21)" end="(430, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(430, 21)" end="(430, 23)">
                                            <OtherNode start="(430, 21)" end="(430, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(430, 21)" end="(430, 23)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(430, 23)" end="(430, 24)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 25)" end="(430, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(430, 25)" end="(430, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(430, 25)" end="(430, 27)">
                                            <OtherNode start="(430, 25)" end="(430, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(430, 25)" end="(430, 27)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(430, 27)" end="(430, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(430, 29)" end="(430, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(430, 29)" end="(430, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(430, 29)" end="(430, 30)">
                                            <OtherNode start="(430, 29)" end="(430, 30)" kind="Lean.Parser.Tactic.rcasesPat.clear">
                                              <AtomNode start="(430, 29)" end="(430, 30)" leading="" trailing="" val="-"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(430, 30)" end="(430, 31)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(430, 32)" end="(430, 65)">
                              <AtomNode start="(430, 32)" end="(430, 34)" leading="" trailing=" " val=":="/>
                              <NullNode start="(430, 35)" end="(430, 65)">
                                <OtherNode start="(430, 35)" end="(430, 65)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(430, 35)" end="(430, 49)" leading="" trailing=" " raw_val="mergeSort_cons" val="mergeSort_cons" full_name="List.mergeSort_cons" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(364, 9)" def_end="(364, 23)"/>
                                  <NullNode start="(430, 50)" end="(430, 65)">
                                    <IdentNode start="(430, 50)" end="(430, 55)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                    <IdentNode start="(430, 56)" end="(430, 61)" leading="" trailing=" " raw_val="total" val="total"/>
                                    <IdentNode start="(430, 62)" end="(430, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(430, 64)" end="(430, 65)" leading="" trailing="&#10;    " raw_val="l" val="l"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(431, 5)" end="(431, 12)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;⊢ ys &amp;lt;+ (a :: l).mergeSort le" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;⊢ ys &amp;lt;+ l₁ ++ a :: l₂" tactic="rw [h₁]">
                            <AtomNode start="(431, 5)" end="(431, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(431, 8)" end="(431, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(431, 8)" end="(431, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(431, 9)" end="(431, 11)">
                                <OtherNode start="(431, 9)" end="(431, 11)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(431, 9)" end="(431, 11)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(431, 11)" end="(431, 12)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(432, 5)" end="(432, 50)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;⊢ ys &amp;lt;+ l₁ ++ a :: l₂" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;h' : ys &amp;lt;+ l.mergeSort le&#10;⊢ ys &amp;lt;+ l₁ ++ a :: l₂" tactic="have h' := sublist_mergeSort trans total hc h">
                            <AtomNode start="(432, 5)" end="(432, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(432, 10)" end="(432, 50)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(432, 10)" end="(432, 50)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(432, 10)" end="(432, 12)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(432, 10)" end="(432, 12)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(432, 13)" end="(432, 15)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(432, 16)" end="(432, 50)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(432, 16)" end="(432, 33)" leading="" trailing=" " raw_val="sublist_mergeSort" val="sublist_mergeSort"/>
                                  <NullNode start="(432, 34)" end="(432, 50)">
                                    <IdentNode start="(432, 34)" end="(432, 39)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                    <IdentNode start="(432, 40)" end="(432, 45)" leading="" trailing=" " raw_val="total" val="total"/>
                                    <IdentNode start="(432, 46)" end="(432, 48)" leading="" trailing=" " raw_val="hc" val="hc"/>
                                    <IdentNode start="(432, 49)" end="(432, 50)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(433, 5)" end="(433, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;h' : ys &amp;lt;+ l.mergeSort le&#10;⊢ ys &amp;lt;+ l₁ ++ a :: l₂" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;h' : ys &amp;lt;+ l₁ ++ l₂&#10;⊢ ys &amp;lt;+ l₁ ++ a :: l₂" tactic="rw [h₂] at h'">
                            <AtomNode start="(433, 5)" end="(433, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(433, 8)" end="(433, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(433, 8)" end="(433, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(433, 9)" end="(433, 11)">
                                <OtherNode start="(433, 9)" end="(433, 11)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(433, 9)" end="(433, 11)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(433, 11)" end="(433, 12)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(433, 13)" end="(433, 18)">
                              <OtherNode start="(433, 13)" end="(433, 18)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(433, 13)" end="(433, 15)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(433, 16)" end="(433, 18)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(433, 16)" end="(433, 18)">
                                    <IdentNode start="(433, 16)" end="(433, 18)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(434, 5)" end="(434, 22)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;ys : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) ys&#10;l : List α&#10;a : α&#10;h : ys &amp;lt;+ l&#10;l₁ l₂ : List α&#10;h₁ : (a :: l).mergeSort le = l₁ ++ a :: l₂&#10;h₂ : l.mergeSort le = l₁ ++ l₂&#10;h' : ys &amp;lt;+ l₁ ++ l₂&#10;⊢ ys &amp;lt;+ l₁ ++ a :: l₂" state_after="no goals" tactic="exact h'.middle a">
                            <AtomNode start="(434, 5)" end="(434, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(434, 11)" end="(434, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(434, 11)" end="(434, 20)" leading="" trailing=" " raw_val="h'.middle" val="h'.middle"/>
                              <NullNode start="(434, 21)" end="(434, 22)">
                                <IdentNode start="(434, 21)" end="(434, 22)" leading="" trailing="&#10;  " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(435, 3)" end="(445, 91)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(435, 3)" end="(435, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(435, 5)" end="(435, 37)">
                    <NullNode start="(435, 5)" end="(435, 37)">
                      <TermHoleNode start="(435, 5)" end="(435, 6)">
                        <AtomNode start="(435, 5)" end="(435, 6)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(435, 6)" end="(435, 7)" leading="" trailing=" " val=","/>
                      <TermHoleNode start="(435, 8)" end="(435, 9)">
                        <AtomNode start="(435, 8)" end="(435, 9)" leading="" trailing="" val="_"/>
                      </TermHoleNode>
                      <AtomNode start="(435, 9)" end="(435, 10)" leading="" trailing=" " val=","/>
                      <OtherNode start="(435, 11)" end="(435, 37)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(435, 11)" end="(435, 25)" kind="Lean.Parser.Term.explicit">
                          <AtomNode start="(435, 11)" end="(435, 12)" leading="" trailing="" val="@"/>
                          <IdentNode start="(435, 12)" end="(435, 25)" leading="" trailing=" " raw_val="Sublist.cons₂" val="Sublist.cons₂" full_name="List.Sublist.cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <NullNode start="(435, 26)" end="(435, 37)">
                          <TermHoleNode start="(435, 26)" end="(435, 27)">
                            <AtomNode start="(435, 26)" end="(435, 27)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                          <IdentNode start="(435, 28)" end="(435, 30)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                          <IdentNode start="(435, 31)" end="(435, 33)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                          <IdentNode start="(435, 34)" end="(435, 35)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(435, 36)" end="(435, 37)" leading="" trailing=" " raw_val="h" val="h"/>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(435, 38)" end="(435, 40)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(435, 41)" end="(445, 91)">
                    <AtomNode start="(435, 41)" end="(435, 43)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(436, 5)" end="(445, 91)">
                      <TacticTacticseq1IndentedNode start="(436, 5)" end="(445, 91)">
                        <NullNode start="(436, 5)" end="(445, 91)">
                          <OtherNode start="(436, 5)" end="(436, 16)" kind="Lean.Parser.Tactic.renameI" state_before="α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;x✝ : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ a :: l₁ &amp;lt;+ (a :: l₂).mergeSort le" state_after="α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ a :: l₁ &amp;lt;+ (a :: l₂).mergeSort le" tactic="rename_i hc">
                            <AtomNode start="(436, 5)" end="(436, 13)" leading="" trailing=" " val="rename_i"/>
                            <NullNode start="(436, 14)" end="(436, 16)">
                              <LeanBinderidentNode start="(436, 14)" end="(436, 16)">
                                <IdentNode start="(436, 14)" end="(436, 16)" leading="" trailing="&#10;    " raw_val="hc" val="hc"/>
                              </LeanBinderidentNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(437, 5)" end="(437, 67)" kind="Lean.Parser.Tactic.obtain" state_before="α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;⊢ a :: l₁ &amp;lt;+ (a :: l₂).mergeSort le" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;⊢ a :: l₁ &amp;lt;+ (a :: l₂).mergeSort le" tactic="obtain ⟨l₃, l₄, h₁, h₂, h₃⟩ := mergeSort_cons trans total a l₂">
                            <AtomNode start="(437, 5)" end="(437, 11)" leading="" trailing=" " val="obtain"/>
                            <NullNode start="(437, 12)" end="(437, 32)">
                              <OtherNode start="(437, 12)" end="(437, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                <NullNode start="(437, 12)" end="(437, 32)">
                                  <OtherNode start="(437, 12)" end="(437, 32)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                    <AtomNode start="(437, 12)" end="(437, 13)" leading="" trailing="" val="⟨"/>
                                    <NullNode start="(437, 13)" end="(437, 31)">
                                      <OtherNode start="(437, 13)" end="(437, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(437, 13)" end="(437, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(437, 13)" end="(437, 15)">
                                            <OtherNode start="(437, 13)" end="(437, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(437, 13)" end="(437, 15)" leading="" trailing="" raw_val="l₃" val="l₃"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(437, 15)" end="(437, 16)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(437, 17)" end="(437, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(437, 17)" end="(437, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(437, 17)" end="(437, 19)">
                                            <OtherNode start="(437, 17)" end="(437, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(437, 17)" end="(437, 19)" leading="" trailing="" raw_val="l₄" val="l₄"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(437, 19)" end="(437, 20)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(437, 21)" end="(437, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(437, 21)" end="(437, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(437, 21)" end="(437, 23)">
                                            <OtherNode start="(437, 21)" end="(437, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(437, 21)" end="(437, 23)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(437, 23)" end="(437, 24)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(437, 25)" end="(437, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(437, 25)" end="(437, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(437, 25)" end="(437, 27)">
                                            <OtherNode start="(437, 25)" end="(437, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(437, 25)" end="(437, 27)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(437, 27)" end="(437, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(437, 29)" end="(437, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                        <OtherNode start="(437, 29)" end="(437, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                          <NullNode start="(437, 29)" end="(437, 31)">
                                            <OtherNode start="(437, 29)" end="(437, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                              <IdentNode start="(437, 29)" end="(437, 31)" leading="" trailing="" raw_val="h₃" val="h₃"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(437, 31)" end="(437, 32)" leading="" trailing=" " val="⟩"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(437, 33)" end="(437, 67)">
                              <AtomNode start="(437, 33)" end="(437, 35)" leading="" trailing=" " val=":="/>
                              <NullNode start="(437, 36)" end="(437, 67)">
                                <OtherNode start="(437, 36)" end="(437, 67)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(437, 36)" end="(437, 50)" leading="" trailing=" " raw_val="mergeSort_cons" val="mergeSort_cons" full_name="List.mergeSort_cons" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(364, 9)" def_end="(364, 23)"/>
                                  <NullNode start="(437, 51)" end="(437, 67)">
                                    <IdentNode start="(437, 51)" end="(437, 56)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                    <IdentNode start="(437, 57)" end="(437, 62)" leading="" trailing=" " raw_val="total" val="total"/>
                                    <IdentNode start="(437, 63)" end="(437, 64)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <IdentNode start="(437, 65)" end="(437, 67)" leading="" trailing="&#10;    " raw_val="l₂" val="l₂"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(438, 5)" end="(438, 12)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;⊢ a :: l₁ &amp;lt;+ (a :: l₂).mergeSort le" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" tactic="rw [h₁]">
                            <AtomNode start="(438, 5)" end="(438, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(438, 8)" end="(438, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(438, 8)" end="(438, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(438, 9)" end="(438, 11)">
                                <OtherNode start="(438, 9)" end="(438, 11)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(438, 9)" end="(438, 11)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(438, 11)" end="(438, 12)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(439, 5)" end="(439, 55)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;h' : (a :: l₁).tail &amp;lt;+ l₂.mergeSort le&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" tactic="have h' := sublist_mergeSort trans total hc.tail h">
                            <AtomNode start="(439, 5)" end="(439, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(439, 10)" end="(439, 55)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(439, 10)" end="(439, 55)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(439, 10)" end="(439, 12)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(439, 10)" end="(439, 12)" leading="" trailing=" " raw_val="h'" val="h'"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <AtomNode start="(439, 13)" end="(439, 15)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(439, 16)" end="(439, 55)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(439, 16)" end="(439, 33)" leading="" trailing=" " raw_val="sublist_mergeSort" val="sublist_mergeSort"/>
                                  <NullNode start="(439, 34)" end="(439, 55)">
                                    <IdentNode start="(439, 34)" end="(439, 39)" leading="" trailing=" " raw_val="trans" val="trans"/>
                                    <IdentNode start="(439, 40)" end="(439, 45)" leading="" trailing=" " raw_val="total" val="total"/>
                                    <IdentNode start="(439, 46)" end="(439, 53)" leading="" trailing=" " raw_val="hc.tail" val="hc.tail"/>
                                    <IdentNode start="(439, 54)" end="(439, 55)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(440, 5)" end="(440, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;h' : (a :: l₁).tail &amp;lt;+ l₂.mergeSort le&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;h' : (a :: l₁).tail &amp;lt;+ l₃ ++ l₄&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" tactic="rw [h₂] at h'">
                            <AtomNode start="(440, 5)" end="(440, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(440, 8)" end="(440, 12)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(440, 8)" end="(440, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(440, 9)" end="(440, 11)">
                                <OtherNode start="(440, 9)" end="(440, 11)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(440, 9)" end="(440, 11)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(440, 11)" end="(440, 12)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(440, 13)" end="(440, 18)">
                              <OtherNode start="(440, 13)" end="(440, 18)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(440, 13)" end="(440, 15)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(440, 16)" end="(440, 18)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(440, 16)" end="(440, 18)">
                                    <IdentNode start="(440, 16)" end="(440, 18)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(441, 5)" end="(441, 54)" kind="Lean.Parser.Tactic.simp" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → (!le a b) = true&#10;h' : (a :: l₁).tail &amp;lt;+ l₃ ++ l₄&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" state_after="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h' : l₁ &amp;lt;+ l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → le a b = false&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" tactic="simp only [Bool.not_eq_true', tail_cons] at h₃ h'">
                            <AtomNode start="(441, 5)" end="(441, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(441, 10)" end="(441, 14)">
                              <AtomNode start="(441, 10)" end="(441, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(441, 15)" end="(441, 45)">
                              <AtomNode start="(441, 15)" end="(441, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(441, 16)" end="(441, 44)">
                                <OtherNode start="(441, 16)" end="(441, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(441, 16)" end="(441, 33)" leading="" trailing="" raw_val="Bool.not_eq_true'" val="Bool.not_eq_true'" full_name="Bool.not_eq_true'" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(441, 33)" end="(441, 34)" leading="" trailing=" " val=","/>
                                <OtherNode start="(441, 35)" end="(441, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(441, 35)" end="(441, 44)" leading="" trailing="" raw_val="tail_cons" val="tail_cons" full_name="List.tail_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(441, 44)" end="(441, 45)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(441, 46)" end="(441, 54)">
                              <OtherNode start="(441, 46)" end="(441, 54)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(441, 46)" end="(441, 48)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(441, 49)" end="(441, 54)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(441, 49)" end="(441, 54)">
                                    <IdentNode start="(441, 49)" end="(441, 51)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                    <IdentNode start="(441, 52)" end="(441, 54)" leading="" trailing="&#10;    " raw_val="h'" val="h'"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(442, 5)" end="(445, 91)" kind="Lean.Parser.Tactic.exact" state_before="case intro.intro.intro.intro&#10;α : Type u_1&#10;le : α → α → Bool&#10;xs : List α&#10;trans : ∀ (a b c : α), le a b = true → le b c = true → le a c = true&#10;total : ∀ (a b : α), (le a b || le b a) = true&#10;a : α&#10;l₁ : List α&#10;hc : Pairwise (fun a b =&amp;gt; le a b = true) (a :: l₁)&#10;l₂ : List α&#10;h : l₁ &amp;lt;+ l₂&#10;l₃ l₄ : List α&#10;h₁ : (a :: l₂).mergeSort le = l₃ ++ a :: l₄&#10;h₂ : l₂.mergeSort le = l₃ ++ l₄&#10;h' : l₁ &amp;lt;+ l₃ ++ l₄&#10;h₃ : ∀ (b : α), b ∈ l₃ → le a b = false&#10;⊢ a :: l₁ &amp;lt;+ l₃ ++ a :: l₄" state_after="no goals" tactic="exact&#10;  sublist_append_of_sublist_right (Sublist.cons₂ a&#10;    ((fun w =&amp;gt; Sublist.of_sublist_append_right w h') fun b m₁ m₃ =&amp;gt;&#10;      (Bool.eq_not_self true).mp ((rel_of_pairwise_cons hc m₁).symm.trans (h₃ b m₃))))">
                            <AtomNode start="(442, 5)" end="(442, 10)" leading="" trailing="&#10;      " val="exact"/>
                            <OtherNode start="(443, 7)" end="(445, 91)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(443, 7)" end="(443, 38)" leading="" trailing=" " raw_val="sublist_append_of_sublist_right" val="sublist_append_of_sublist_right" full_name="List.sublist_append_of_sublist_right" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                              <NullNode start="(443, 39)" end="(445, 91)">
                                <OtherNode start="(443, 39)" end="(445, 91)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(443, 39)" end="(443, 40)" leading="" trailing="" val="("/>
                                  <OtherNode start="(443, 40)" end="(445, 90)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(443, 40)" end="(443, 53)" leading="" trailing=" " raw_val="Sublist.cons₂" val="Sublist.cons₂" full_name="List.Sublist.cons₂" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                    <NullNode start="(443, 54)" end="(445, 90)">
                                      <IdentNode start="(443, 54)" end="(443, 55)" leading="" trailing="&#10;        " raw_val="a" val="a"/>
                                      <OtherNode start="(444, 9)" end="(445, 90)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(444, 9)" end="(444, 10)" leading="" trailing="" val="("/>
                                        <OtherNode start="(444, 10)" end="(445, 89)" kind="Lean.Parser.Term.app">
                                          <OtherNode start="(444, 10)" end="(444, 57)" kind="Lean.Parser.Term.paren">
                                            <AtomNode start="(444, 10)" end="(444, 11)" leading="" trailing="" val="("/>
                                            <OtherNode start="(444, 11)" end="(444, 56)" kind="Lean.Parser.Term.fun">
                                              <AtomNode start="(444, 11)" end="(444, 14)" leading="" trailing=" " val="fun"/>
                                              <OtherNode start="(444, 15)" end="(444, 56)" kind="Lean.Parser.Term.basicFun">
                                                <NullNode start="(444, 15)" end="(444, 16)">
                                                  <IdentNode start="(444, 15)" end="(444, 16)" leading="" trailing=" " raw_val="w" val="w"/>
                                                </NullNode>
                                                <NullNode/>
                                                <AtomNode start="(444, 17)" end="(444, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <OtherNode start="(444, 20)" end="(444, 56)" kind="Lean.Parser.Term.app">
                                                  <IdentNode start="(444, 20)" end="(444, 51)" leading="" trailing=" " raw_val="Sublist.of_sublist_append_right" val="Sublist.of_sublist_append_right" full_name="List.Sublist.of_sublist_append_right" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                  <NullNode start="(444, 52)" end="(444, 56)">
                                                    <IdentNode start="(444, 52)" end="(444, 53)" leading="" trailing=" " raw_val="w" val="w"/>
                                                    <IdentNode start="(444, 54)" end="(444, 56)" leading="" trailing="" raw_val="h'" val="h'"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(444, 56)" end="(444, 57)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                          <NullNode start="(444, 58)" end="(445, 89)">
                                            <OtherNode start="(444, 58)" end="(445, 89)" kind="Lean.Parser.Term.fun">
                                              <AtomNode start="(444, 58)" end="(444, 61)" leading="" trailing=" " val="fun"/>
                                              <OtherNode start="(444, 62)" end="(445, 89)" kind="Lean.Parser.Term.basicFun">
                                                <NullNode start="(444, 62)" end="(444, 69)">
                                                  <IdentNode start="(444, 62)" end="(444, 63)" leading="" trailing=" " raw_val="b" val="b"/>
                                                  <IdentNode start="(444, 64)" end="(444, 66)" leading="" trailing=" " raw_val="m₁" val="m₁"/>
                                                  <IdentNode start="(444, 67)" end="(444, 69)" leading="" trailing=" " raw_val="m₃" val="m₃"/>
                                                </NullNode>
                                                <NullNode/>
                                                <AtomNode start="(444, 70)" end="(444, 72)" leading="" trailing="&#10;          " val="=&amp;gt;"/>
                                                <OtherNode start="(445, 11)" end="(445, 89)" kind="Lean.Parser.Term.app">
                                                  <OtherNode start="(445, 11)" end="(445, 37)" kind="Lean.Parser.Term.proj">
                                                    <OtherNode start="(445, 11)" end="(445, 34)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(445, 11)" end="(445, 12)" leading="" trailing="" val="("/>
                                                      <OtherNode start="(445, 12)" end="(445, 33)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(445, 12)" end="(445, 28)" leading="" trailing=" " raw_val="Bool.eq_not_self" val="Bool.eq_not_self" full_name="Bool.eq_not_self" mod_name="Init.Data.Bool" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Bool.lean"/>
                                                        <NullNode start="(445, 29)" end="(445, 33)">
                                                          <IdentNode start="(445, 29)" end="(445, 33)" leading="" trailing="" raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(445, 33)" end="(445, 34)" leading="" trailing="" val=")"/>
                                                    </OtherNode>
                                                    <AtomNode start="(445, 34)" end="(445, 35)" leading="" trailing="" val="."/>
                                                    <IdentNode start="(445, 35)" end="(445, 37)" leading="" trailing=" " raw_val="mp" val="mp" full_name="Iff.mp" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                                                  </OtherNode>
                                                  <NullNode start="(445, 38)" end="(445, 89)">
                                                    <OtherNode start="(445, 38)" end="(445, 89)" kind="Lean.Parser.Term.paren">
                                                      <AtomNode start="(445, 38)" end="(445, 39)" leading="" trailing="" val="("/>
                                                      <OtherNode start="(445, 39)" end="(445, 88)" kind="Lean.Parser.Term.app">
                                                        <OtherNode start="(445, 39)" end="(445, 78)" kind="Lean.Parser.Term.proj">
                                                          <OtherNode start="(445, 39)" end="(445, 67)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(445, 39)" end="(445, 40)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(445, 40)" end="(445, 66)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(445, 40)" end="(445, 60)" leading="" trailing=" " raw_val="rel_of_pairwise_cons" val="rel_of_pairwise_cons" full_name="List.rel_of_pairwise_cons" mod_name="Init.Data.List.Pairwise" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Pairwise.lean"/>
                                                            <NullNode start="(445, 61)" end="(445, 66)">
                                                            <IdentNode start="(445, 61)" end="(445, 63)" leading="" trailing=" " raw_val="hc" val="hc"/>
                                                            <IdentNode start="(445, 64)" end="(445, 66)" leading="" trailing="" raw_val="m₁" val="m₁"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(445, 66)" end="(445, 67)" leading="" trailing="" val=")"/>
                                                          </OtherNode>
                                                          <AtomNode start="(445, 67)" end="(445, 68)" leading="" trailing="" val="."/>
                                                          <IdentNode start="(445, 68)" end="(445, 78)" leading="" trailing=" " raw_val="symm.trans" val="symm.trans"/>
                                                        </OtherNode>
                                                        <NullNode start="(445, 79)" end="(445, 88)">
                                                          <OtherNode start="(445, 79)" end="(445, 88)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(445, 79)" end="(445, 80)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(445, 80)" end="(445, 87)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(445, 80)" end="(445, 82)" leading="" trailing=" " raw_val="h₃" val="h₃"/>
                                                            <NullNode start="(445, 83)" end="(445, 87)">
                                                            <IdentNode start="(445, 83)" end="(445, 84)" leading="" trailing=" " raw_val="b" val="b"/>
                                                            <IdentNode start="(445, 85)" end="(445, 87)" leading="" trailing="" raw_val="m₃" val="m₃"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(445, 87)" end="(445, 88)" leading="" trailing="" val=")"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(445, 88)" end="(445, 89)" leading="" trailing="" val=")"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(445, 89)" end="(445, 90)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(445, 90)" end="(445, 91)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(447, 1)" end="(448, 46)" name="mergeSort_stable" full_name="List.mergeSort_stable">
      <CommandDeclmodifiersNode start="(447, 1)" end="(447, 56)">
        <NullNode/>
        <NullNode start="(447, 1)" end="(447, 56)">
          <OtherNode start="(447, 1)" end="(447, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(447, 1)" end="(447, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(447, 3)" end="(447, 55)">
              <OtherNode start="(447, 3)" end="(447, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(447, 3)" end="(447, 55)" kind="Lean.deprecated">
                  <AtomNode start="(447, 3)" end="(447, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(447, 14)" end="(447, 31)">
                    <IdentNode start="(447, 14)" end="(447, 31)" leading="" trailing=" " raw_val="sublist_mergeSort" val="sublist_mergeSort" full_name="List.sublist_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(423, 9)" def_end="(423, 26)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(447, 32)" end="(447, 55)">
                    <AtomNode start="(447, 32)" end="(447, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(447, 33)" end="(447, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(447, 39)" end="(447, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(447, 42)" end="(447, 54)" kind="str">
                      <AtomNode start="(447, 42)" end="(447, 54)" leading="" trailing="" val="&amp;quot;2024-09-02&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(447, 54)" end="(447, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(447, 55)" end="(447, 56)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(448, 1)" end="(448, 46)" name="mergeSort_stable">
        <AtomNode start="(448, 1)" end="(448, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(448, 8)" end="(448, 24)">
          <IdentNode start="(448, 8)" end="(448, 24)" leading="" trailing=" " raw_val="mergeSort_stable" val="mergeSort_stable"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(448, 25)" end="(448, 46)">
          <AtomNode start="(448, 25)" end="(448, 27)" leading="" trailing=" " val=":="/>
          <OtherNode start="(448, 28)" end="(448, 46)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(448, 28)" end="(448, 29)" leading="" trailing="" val="@"/>
            <IdentNode start="(448, 29)" end="(448, 46)" leading="" trailing="&#10;&#10;" raw_val="sublist_mergeSort" val="sublist_mergeSort" full_name="List.sublist_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(423, 9)" def_end="(423, 26)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(450, 1)" end="(459, 58)" name="pair_sublist_mergeSort" full_name="List.pair_sublist_mergeSort">
      <CommandDeclmodifiersNode start="(450, 1)" end="(454, 3)">
        <NullNode start="(450, 1)" end="(454, 3)">
          <CommandDoccommentNode start="(450, 1)" end="(454, 3)" comment="Another statement of stability of merge sort.&#10;If a pair `[a, b]` is a sublist of `l` and `le a b`,&#10;then `[a, b]` is still a sublist of `mergeSort le l`.&#10;-/">
            <AtomNode start="(450, 1)" end="(450, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(451, 1)" end="(454, 3)" leading="" trailing="&#10;" val="Another statement of stability of merge sort.&#10;If a pair `[a, b]` is a sublist of `l` and `le a b`,&#10;then `[a, b]` is still a sublist of `mergeSort le l`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(455, 1)" end="(459, 58)" name="pair_sublist_mergeSort" full_name="List.pair_sublist_mergeSort" _is_private_decl="False">
        <AtomNode start="(455, 1)" end="(455, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(455, 9)" end="(455, 31)">
          <IdentNode start="(455, 9)" end="(455, 31)" leading="" trailing="&#10;    " raw_val="pair_sublist_mergeSort" val="pair_sublist_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(456, 5)" end="(458, 64)">
          <NullNode start="(456, 5)" end="(458, 37)">
            <TermExplicitbinderNode start="(456, 5)" end="(456, 54)">
              <AtomNode start="(456, 5)" end="(456, 6)" leading="" trailing="" val="("/>
              <NullNode start="(456, 6)" end="(456, 11)">
                <IdentNode start="(456, 6)" end="(456, 11)" leading="" trailing=" " raw_val="trans" val="trans"/>
              </NullNode>
              <NullNode start="(456, 12)" end="(456, 53)">
                <AtomNode start="(456, 12)" end="(456, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(456, 14)" end="(456, 53)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(456, 14)" end="(456, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(456, 16)" end="(456, 27)">
                    <TermExplicitbinderNode start="(456, 16)" end="(456, 27)">
                      <AtomNode start="(456, 16)" end="(456, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(456, 17)" end="(456, 22)">
                        <IdentNode start="(456, 17)" end="(456, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(456, 19)" end="(456, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(456, 21)" end="(456, 22)" leading="" trailing=" " raw_val="c" val="c"/>
                      </NullNode>
                      <NullNode start="(456, 23)" end="(456, 26)">
                        <AtomNode start="(456, 23)" end="(456, 24)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(456, 25)" end="(456, 26)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(456, 26)" end="(456, 27)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(456, 27)" end="(456, 28)" leading="" trailing=" " val=","/>
                  <OtherNode start="(456, 29)" end="(456, 53)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(456, 29)" end="(456, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(456, 29)" end="(456, 31)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(456, 32)" end="(456, 35)">
                        <IdentNode start="(456, 32)" end="(456, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(456, 34)" end="(456, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(456, 36)" end="(456, 37)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(456, 38)" end="(456, 53)" kind="Lean.Parser.Term.arrow">
                      <OtherNode start="(456, 38)" end="(456, 44)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(456, 38)" end="(456, 40)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(456, 41)" end="(456, 44)">
                          <IdentNode start="(456, 41)" end="(456, 42)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(456, 43)" end="(456, 44)" leading="" trailing=" " raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(456, 45)" end="(456, 46)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(456, 47)" end="(456, 53)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(456, 47)" end="(456, 49)" leading="" trailing=" " raw_val="le" val="le"/>
                        <NullNode start="(456, 50)" end="(456, 53)">
                          <IdentNode start="(456, 50)" end="(456, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(456, 52)" end="(456, 53)" leading="" trailing="" raw_val="c" val="c"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(456, 53)" end="(456, 54)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(457, 5)" end="(457, 44)">
              <AtomNode start="(457, 5)" end="(457, 6)" leading="" trailing="" val="("/>
              <NullNode start="(457, 6)" end="(457, 11)">
                <IdentNode start="(457, 6)" end="(457, 11)" leading="" trailing=" " raw_val="total" val="total"/>
              </NullNode>
              <NullNode start="(457, 12)" end="(457, 43)">
                <AtomNode start="(457, 12)" end="(457, 13)" leading="" trailing=" " val=":"/>
                <OtherNode start="(457, 14)" end="(457, 43)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(457, 14)" end="(457, 15)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(457, 16)" end="(457, 25)">
                    <TermExplicitbinderNode start="(457, 16)" end="(457, 25)">
                      <AtomNode start="(457, 16)" end="(457, 17)" leading="" trailing="" val="("/>
                      <NullNode start="(457, 17)" end="(457, 20)">
                        <IdentNode start="(457, 17)" end="(457, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(457, 19)" end="(457, 20)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                      <NullNode start="(457, 21)" end="(457, 24)">
                        <AtomNode start="(457, 21)" end="(457, 22)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(457, 23)" end="(457, 24)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(457, 24)" end="(457, 25)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(457, 25)" end="(457, 26)" leading="" trailing=" " val=","/>
                  <OtherNode start="(457, 27)" end="(457, 43)" kind="«term_||_»">
                    <OtherNode start="(457, 27)" end="(457, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(457, 27)" end="(457, 29)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(457, 30)" end="(457, 33)">
                        <IdentNode start="(457, 30)" end="(457, 31)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(457, 32)" end="(457, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(457, 34)" end="(457, 36)" leading="" trailing=" " val="||"/>
                    <OtherNode start="(457, 37)" end="(457, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(457, 37)" end="(457, 39)" leading="" trailing=" " raw_val="le" val="le"/>
                      <NullNode start="(457, 40)" end="(457, 43)">
                        <IdentNode start="(457, 40)" end="(457, 41)" leading="" trailing=" " raw_val="b" val="b"/>
                        <IdentNode start="(457, 42)" end="(457, 43)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(457, 43)" end="(457, 44)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(458, 5)" end="(458, 19)">
              <AtomNode start="(458, 5)" end="(458, 6)" leading="" trailing="" val="("/>
              <NullNode start="(458, 6)" end="(458, 9)">
                <IdentNode start="(458, 6)" end="(458, 9)" leading="" trailing=" " raw_val="hab" val="hab"/>
              </NullNode>
              <NullNode start="(458, 10)" end="(458, 18)">
                <AtomNode start="(458, 10)" end="(458, 11)" leading="" trailing=" " val=":"/>
                <OtherNode start="(458, 12)" end="(458, 18)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(458, 12)" end="(458, 14)" leading="" trailing=" " raw_val="le" val="le"/>
                  <NullNode start="(458, 15)" end="(458, 18)">
                    <IdentNode start="(458, 15)" end="(458, 16)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(458, 17)" end="(458, 18)" leading="" trailing="" raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(458, 18)" end="(458, 19)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(458, 20)" end="(458, 37)">
              <AtomNode start="(458, 20)" end="(458, 21)" leading="" trailing="" val="("/>
              <NullNode start="(458, 21)" end="(458, 22)">
                <IdentNode start="(458, 21)" end="(458, 22)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(458, 23)" end="(458, 36)">
                <AtomNode start="(458, 23)" end="(458, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(458, 25)" end="(458, 36)" kind="List.«term_&amp;lt;+_»">
                  <OtherNode start="(458, 25)" end="(458, 31)" kind="«term[_]»">
                    <AtomNode start="(458, 25)" end="(458, 26)" leading="" trailing="" val="["/>
                    <NullNode start="(458, 26)" end="(458, 30)">
                      <IdentNode start="(458, 26)" end="(458, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(458, 27)" end="(458, 28)" leading="" trailing=" " val=","/>
                      <IdentNode start="(458, 29)" end="(458, 30)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                    <AtomNode start="(458, 30)" end="(458, 31)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                  <AtomNode start="(458, 32)" end="(458, 34)" leading="" trailing=" " val="&amp;lt;+"/>
                  <IdentNode start="(458, 35)" end="(458, 36)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(458, 36)" end="(458, 37)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(458, 38)" end="(458, 64)">
            <AtomNode start="(458, 38)" end="(458, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(458, 40)" end="(458, 64)" kind="List.«term_&amp;lt;+_»">
              <OtherNode start="(458, 40)" end="(458, 46)" kind="«term[_]»">
                <AtomNode start="(458, 40)" end="(458, 41)" leading="" trailing="" val="["/>
                <NullNode start="(458, 41)" end="(458, 45)">
                  <IdentNode start="(458, 41)" end="(458, 42)" leading="" trailing="" raw_val="a" val="a"/>
                  <AtomNode start="(458, 42)" end="(458, 43)" leading="" trailing=" " val=","/>
                  <IdentNode start="(458, 44)" end="(458, 45)" leading="" trailing="" raw_val="b" val="b"/>
                </NullNode>
                <AtomNode start="(458, 45)" end="(458, 46)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(458, 47)" end="(458, 49)" leading="" trailing=" " val="&amp;lt;+"/>
              <OtherNode start="(458, 50)" end="(458, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(458, 50)" end="(458, 59)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                <NullNode start="(458, 60)" end="(458, 64)">
                  <IdentNode start="(458, 60)" end="(458, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                  <IdentNode start="(458, 62)" end="(458, 64)" leading="" trailing=" " raw_val="le" val="le"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(458, 65)" end="(459, 58)">
          <AtomNode start="(458, 65)" end="(458, 67)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(459, 3)" end="(459, 58)" kind="Lean.Parser.Term.app">
            <IdentNode start="(459, 3)" end="(459, 20)" leading="" trailing=" " raw_val="sublist_mergeSort" val="sublist_mergeSort" full_name="List.sublist_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(423, 9)" def_end="(423, 26)"/>
            <NullNode start="(459, 21)" end="(459, 58)">
              <IdentNode start="(459, 21)" end="(459, 26)" leading="" trailing=" " raw_val="trans" val="trans"/>
              <IdentNode start="(459, 27)" end="(459, 32)" leading="" trailing=" " raw_val="total" val="total"/>
              <OtherNode start="(459, 33)" end="(459, 56)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(459, 33)" end="(459, 34)" leading="" trailing="" val="("/>
                <OtherNode start="(459, 34)" end="(459, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(459, 34)" end="(459, 51)" leading="" trailing=" " raw_val="pairwise_pair.mpr" val="pairwise_pair.mpr"/>
                  <NullNode start="(459, 52)" end="(459, 55)">
                    <IdentNode start="(459, 52)" end="(459, 55)" leading="" trailing="" raw_val="hab" val="hab"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(459, 55)" end="(459, 56)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <IdentNode start="(459, 57)" end="(459, 58)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(461, 1)" end="(462, 56)" name="mergeSort_stable_pair" full_name="List.mergeSort_stable_pair">
      <CommandDeclmodifiersNode start="(461, 1)" end="(461, 60)">
        <NullNode/>
        <NullNode start="(461, 1)" end="(461, 60)">
          <OtherNode start="(461, 1)" end="(461, 60)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(461, 1)" end="(461, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(461, 3)" end="(461, 59)">
              <OtherNode start="(461, 3)" end="(461, 59)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(461, 3)" end="(461, 59)" kind="Lean.deprecated">
                  <AtomNode start="(461, 3)" end="(461, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(461, 14)" end="(461, 36)">
                    <IdentNode start="(461, 14)" end="(461, 36)" leading="" trailing="" raw_val="pair_sublist_mergeSort" val="pair_sublist_mergeSort" full_name="List.pair_sublist_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(455, 9)" def_end="(455, 31)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(461, 36)" end="(461, 59)">
                    <AtomNode start="(461, 36)" end="(461, 37)" leading="" trailing="" val="("/>
                    <AtomNode start="(461, 37)" end="(461, 42)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(461, 43)" end="(461, 45)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(461, 46)" end="(461, 58)" kind="str">
                      <AtomNode start="(461, 46)" end="(461, 58)" leading="" trailing="" val="&amp;quot;2024-09-02&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(461, 58)" end="(461, 59)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(461, 59)" end="(461, 60)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(462, 1)" end="(462, 56)" name="mergeSort_stable_pair">
        <AtomNode start="(462, 1)" end="(462, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(462, 8)" end="(462, 29)">
          <IdentNode start="(462, 8)" end="(462, 29)" leading="" trailing=" " raw_val="mergeSort_stable_pair" val="mergeSort_stable_pair"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(462, 30)" end="(462, 56)">
          <AtomNode start="(462, 30)" end="(462, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(462, 33)" end="(462, 56)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(462, 33)" end="(462, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(462, 34)" end="(462, 56)" leading="" trailing="&#10;&#10;" raw_val="pair_sublist_mergeSort" val="pair_sublist_mergeSort" full_name="List.pair_sublist_mergeSort" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(455, 9)" def_end="(455, 31)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(464, 1)" end="(481, 29)" name="map_merge" full_name="List.map_merge">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(464, 1)" end="(481, 29)" name="map_merge" full_name="List.map_merge" _is_private_decl="False">
        <AtomNode start="(464, 1)" end="(464, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(464, 9)" end="(464, 18)">
          <IdentNode start="(464, 9)" end="(464, 18)" leading="" trailing=" " raw_val="map_merge" val="map_merge"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(464, 19)" end="(466, 56)">
          <NullNode start="(464, 19)" end="(465, 52)">
            <OtherNode start="(464, 19)" end="(464, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 19)" end="(464, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 20)" end="(464, 21)">
                <IdentNode start="(464, 20)" end="(464, 21)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(464, 22)" end="(464, 29)">
                <AtomNode start="(464, 22)" end="(464, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 24)" end="(464, 29)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(464, 24)" end="(464, 25)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(464, 26)" end="(464, 27)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(464, 28)" end="(464, 29)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 29)" end="(464, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(464, 31)" end="(464, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 31)" end="(464, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 32)" end="(464, 33)">
                <IdentNode start="(464, 32)" end="(464, 33)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(464, 34)" end="(464, 48)">
                <AtomNode start="(464, 34)" end="(464, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 36)" end="(464, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(464, 36)" end="(464, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(464, 38)" end="(464, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(464, 40)" end="(464, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(464, 40)" end="(464, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(464, 42)" end="(464, 43)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(464, 44)" end="(464, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 48)" end="(464, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(464, 50)" end="(464, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 50)" end="(464, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 51)" end="(464, 52)">
                <IdentNode start="(464, 51)" end="(464, 52)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(464, 53)" end="(464, 67)">
                <AtomNode start="(464, 53)" end="(464, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 55)" end="(464, 67)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(464, 55)" end="(464, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(464, 57)" end="(464, 58)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(464, 59)" end="(464, 67)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(464, 59)" end="(464, 60)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(464, 61)" end="(464, 62)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(464, 63)" end="(464, 67)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 67)" end="(464, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(464, 69)" end="(464, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(464, 69)" end="(464, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(464, 70)" end="(464, 74)">
                <IdentNode start="(464, 70)" end="(464, 71)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(464, 72)" end="(464, 74)" leading="" trailing=" " raw_val="l'" val="l'"/>
              </NullNode>
              <NullNode start="(464, 75)" end="(464, 83)">
                <AtomNode start="(464, 75)" end="(464, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(464, 77)" end="(464, 83)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(464, 77)" end="(464, 81)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(464, 82)" end="(464, 83)">
                    <IdentNode start="(464, 82)" end="(464, 83)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(464, 83)" end="(464, 84)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(465, 5)" end="(465, 52)">
              <AtomNode start="(465, 5)" end="(465, 6)" leading="" trailing="" val="("/>
              <NullNode start="(465, 6)" end="(465, 8)">
                <IdentNode start="(465, 6)" end="(465, 8)" leading="" trailing=" " raw_val="hl" val="hl"/>
              </NullNode>
              <NullNode start="(465, 9)" end="(465, 51)">
                <AtomNode start="(465, 9)" end="(465, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(465, 11)" end="(465, 51)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(465, 11)" end="(465, 12)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(465, 13)" end="(465, 14)">
                    <IdentNode start="(465, 13)" end="(465, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(465, 15)" end="(465, 18)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(465, 15)" end="(465, 16)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(465, 17)" end="(465, 18)" leading="" trailing="" raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(465, 18)" end="(465, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(465, 20)" end="(465, 51)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(465, 20)" end="(465, 21)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(465, 22)" end="(465, 23)">
                      <IdentNode start="(465, 22)" end="(465, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(465, 24)" end="(465, 28)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(465, 24)" end="(465, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(465, 26)" end="(465, 28)" leading="" trailing="" raw_val="l'" val="l'"/>
                    </OtherNode>
                    <AtomNode start="(465, 28)" end="(465, 29)" leading="" trailing=" " val=","/>
                    <OtherNode start="(465, 30)" end="(465, 51)" kind="«term_=_»">
                      <OtherNode start="(465, 30)" end="(465, 35)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(465, 30)" end="(465, 31)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(465, 32)" end="(465, 35)">
                          <IdentNode start="(465, 32)" end="(465, 33)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(465, 34)" end="(465, 35)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(465, 36)" end="(465, 37)" leading="" trailing=" " val="="/>
                      <OtherNode start="(465, 38)" end="(465, 51)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(465, 38)" end="(465, 39)" leading="" trailing=" " raw_val="s" val="s"/>
                        <NullNode start="(465, 40)" end="(465, 51)">
                          <OtherNode start="(465, 40)" end="(465, 45)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(465, 40)" end="(465, 41)" leading="" trailing="" val="("/>
                            <OtherNode start="(465, 41)" end="(465, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(465, 41)" end="(465, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(465, 43)" end="(465, 44)">
                                <IdentNode start="(465, 43)" end="(465, 44)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(465, 44)" end="(465, 45)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(465, 46)" end="(465, 51)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(465, 46)" end="(465, 47)" leading="" trailing="" val="("/>
                            <OtherNode start="(465, 47)" end="(465, 50)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(465, 47)" end="(465, 48)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(465, 49)" end="(465, 50)">
                                <IdentNode start="(465, 49)" end="(465, 50)" leading="" trailing="" raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(465, 50)" end="(465, 51)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(465, 51)" end="(465, 52)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(465, 53)" end="(466, 56)">
            <AtomNode start="(465, 53)" end="(465, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(466, 5)" end="(466, 56)" kind="«term_=_»">
              <OtherNode start="(466, 5)" end="(466, 25)" kind="Lean.Parser.Term.app">
                <OtherNode start="(466, 5)" end="(466, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(466, 5)" end="(466, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(466, 5)" end="(466, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(466, 6)" end="(466, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(466, 6)" end="(466, 13)" leading="" trailing=" " raw_val="l.merge" val="l.merge"/>
                      <NullNode start="(466, 14)" end="(466, 18)">
                        <IdentNode start="(466, 14)" end="(466, 16)" leading="" trailing=" " raw_val="l'" val="l'"/>
                        <IdentNode start="(466, 17)" end="(466, 18)" leading="" trailing="" raw_val="r" val="r"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(466, 18)" end="(466, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(466, 19)" end="(466, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(466, 20)" end="(466, 23)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(466, 24)" end="(466, 25)">
                  <IdentNode start="(466, 24)" end="(466, 25)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(466, 26)" end="(466, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(466, 28)" end="(466, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(466, 28)" end="(466, 43)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(466, 28)" end="(466, 37)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(466, 28)" end="(466, 29)" leading="" trailing="" val="("/>
                    <OtherNode start="(466, 29)" end="(466, 36)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(466, 29)" end="(466, 34)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(466, 35)" end="(466, 36)">
                        <IdentNode start="(466, 35)" end="(466, 36)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(466, 36)" end="(466, 37)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(466, 37)" end="(466, 38)" leading="" trailing="" val="."/>
                  <IdentNode start="(466, 38)" end="(466, 43)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                </OtherNode>
                <NullNode start="(466, 44)" end="(466, 56)">
                  <OtherNode start="(466, 44)" end="(466, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(466, 44)" end="(466, 45)" leading="" trailing="" val="("/>
                    <OtherNode start="(466, 45)" end="(466, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(466, 45)" end="(466, 51)" leading="" trailing=" " raw_val="l'.map" val="l'.map"/>
                      <NullNode start="(466, 52)" end="(466, 53)">
                        <IdentNode start="(466, 52)" end="(466, 53)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(466, 53)" end="(466, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(466, 55)" end="(466, 56)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(466, 57)" end="(481, 29)">
          <AtomNode start="(466, 57)" end="(466, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(466, 60)" end="(481, 29)">
            <AtomNode start="(466, 60)" end="(466, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(467, 3)" end="(481, 29)">
              <TacticTacticseq1IndentedNode start="(467, 3)" end="(481, 29)">
                <NullNode start="(467, 3)" end="(481, 29)">
                  <OtherNode start="(467, 3)" end="(481, 29)" kind="Lean.Parser.Tactic.match" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;hl : ∀ (a : α), a ∈ l → ∀ (b : α), b ∈ l' → r a b = s (f a) (f b)&#10;⊢ map f (l.merge l' r) = (map f l).merge (map f l') s" state_after="no goals" tactic="match l, l' with&#10;| [], _ =&amp;gt; simp&#10;| _, [] =&amp;gt; simp&#10;| _ :: _, _ :: _ =&amp;gt;&#10;  simp only [List.forall_mem_cons] at hl&#10;  simp only [forall_and] at hl&#10;  simp only [List.map, List.cons_merge_cons]&#10;  rw [← hl.1.1]&#10;  split&#10;  · rw [List.map, map_merge, List.map]&#10;    simp only [List.forall_mem_cons, forall_and]&#10;    exact ⟨hl.2.1, hl.2.2⟩&#10;  · rw [List.map, map_merge, List.map]&#10;    simp only [List.forall_mem_cons]&#10;    exact ⟨hl.1.2, hl.2.2⟩">
                    <AtomNode start="(467, 3)" end="(467, 8)" leading="" trailing=" " val="match"/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(467, 9)" end="(467, 14)">
                      <OtherNode start="(467, 9)" end="(467, 10)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(467, 9)" end="(467, 10)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(467, 10)" end="(467, 11)" leading="" trailing=" " val=","/>
                      <OtherNode start="(467, 12)" end="(467, 14)" kind="Lean.Parser.Term.matchDiscr">
                        <NullNode/>
                        <IdentNode start="(467, 12)" end="(467, 14)" leading="" trailing=" " raw_val="l'" val="l'"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(467, 15)" end="(467, 19)" leading="" trailing="&#10;  " val="with"/>
                    <OtherNode start="(468, 3)" end="(481, 29)" kind="Lean.Parser.Term.matchAlts">
                      <NullNode start="(468, 3)" end="(481, 29)">
                        <OtherNode start="(468, 3)" end="(468, 18)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(468, 3)" end="(468, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(468, 5)" end="(468, 10)">
                            <NullNode start="(468, 5)" end="(468, 10)">
                              <OtherNode start="(468, 5)" end="(468, 7)" kind="«term[_]»">
                                <AtomNode start="(468, 5)" end="(468, 6)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(468, 6)" end="(468, 7)" leading="" trailing="" val="]"/>
                              </OtherNode>
                              <AtomNode start="(468, 7)" end="(468, 8)" leading="" trailing=" " val=","/>
                              <TermHoleNode start="(468, 9)" end="(468, 10)">
                                <AtomNode start="(468, 9)" end="(468, 10)" leading="" trailing=" " val="_"/>
                              </TermHoleNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(468, 11)" end="(468, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(468, 14)" end="(468, 18)">
                            <TacticTacticseq1IndentedNode start="(468, 14)" end="(468, 18)">
                              <NullNode start="(468, 14)" end="(468, 18)">
                                <OtherNode start="(468, 14)" end="(468, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' x✝ : List α&#10;hl : ∀ (a : α), a ∈ [] → ∀ (b : α), b ∈ x✝ → r a b = s (f a) (f b)&#10;⊢ map f ([].merge x✝ r) = (map f []).merge (map f x✝) s" state_after="no goals" tactic="simp">
                                  <AtomNode start="(468, 14)" end="(468, 18)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(469, 3)" end="(469, 18)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(469, 3)" end="(469, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(469, 5)" end="(469, 10)">
                            <NullNode start="(469, 5)" end="(469, 10)">
                              <TermHoleNode start="(469, 5)" end="(469, 6)">
                                <AtomNode start="(469, 5)" end="(469, 6)" leading="" trailing="" val="_"/>
                              </TermHoleNode>
                              <AtomNode start="(469, 6)" end="(469, 7)" leading="" trailing=" " val=","/>
                              <OtherNode start="(469, 8)" end="(469, 10)" kind="«term[_]»">
                                <AtomNode start="(469, 8)" end="(469, 9)" leading="" trailing="" val="["/>
                                <NullNode/>
                                <AtomNode start="(469, 9)" end="(469, 10)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(469, 11)" end="(469, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(469, 14)" end="(469, 18)">
                            <TacticTacticseq1IndentedNode start="(469, 14)" end="(469, 18)">
                              <NullNode start="(469, 14)" end="(469, 18)">
                                <OtherNode start="(469, 14)" end="(469, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' x✝ : List α&#10;hl : ∀ (a : α), a ∈ x✝ → ∀ (b : α), b ∈ [] → r a b = s (f a) (f b)&#10;⊢ map f (x✝.merge [] r) = (map f x✝).merge (map f []) s" state_after="no goals" tactic="simp">
                                  <AtomNode start="(469, 14)" end="(469, 18)" leading="" trailing="&#10;  " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                        <OtherNode start="(470, 3)" end="(481, 29)" kind="Lean.Parser.Term.matchAlt">
                          <AtomNode start="(470, 3)" end="(470, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(470, 5)" end="(470, 19)">
                            <NullNode start="(470, 5)" end="(470, 19)">
                              <OtherNode start="(470, 5)" end="(470, 11)" kind="«term_::_»">
                                <TermHoleNode start="(470, 5)" end="(470, 6)">
                                  <AtomNode start="(470, 5)" end="(470, 6)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(470, 7)" end="(470, 9)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(470, 10)" end="(470, 11)">
                                  <AtomNode start="(470, 10)" end="(470, 11)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                              <AtomNode start="(470, 11)" end="(470, 12)" leading="" trailing=" " val=","/>
                              <OtherNode start="(470, 13)" end="(470, 19)" kind="«term_::_»">
                                <TermHoleNode start="(470, 13)" end="(470, 14)">
                                  <AtomNode start="(470, 13)" end="(470, 14)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(470, 15)" end="(470, 17)" leading="" trailing=" " val="::"/>
                                <TermHoleNode start="(470, 18)" end="(470, 19)">
                                  <AtomNode start="(470, 18)" end="(470, 19)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(470, 20)" end="(470, 22)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                          <TacticTacticseqNode start="(471, 5)" end="(481, 29)">
                            <TacticTacticseq1IndentedNode start="(471, 5)" end="(481, 29)">
                              <NullNode start="(471, 5)" end="(481, 29)">
                                <OtherNode start="(471, 5)" end="(471, 43)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl : ∀ (a : α), a ∈ head✝¹ :: tail✝¹ → ∀ (b : α), b ∈ head✝ :: tail✝ → r a b = s (f a) (f b)&#10;⊢ map f ((head✝¹ :: tail✝¹).merge (head✝ :: tail✝) r) = (map f (head✝¹ :: tail✝¹)).merge (map f (head✝ :: tail✝)) s" state_after="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    ∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝) ∧ ∀ (x_1 : α), x_1 ∈ tail✝ → r x x_1 = s (f x) (f x_1)&#10;⊢ map f ((head✝¹ :: tail✝¹).merge (head✝ :: tail✝) r) = (map f (head✝¹ :: tail✝¹)).merge (map f (head✝ :: tail✝)) s" tactic="simp only [List.forall_mem_cons] at hl">
                                  <AtomNode start="(471, 5)" end="(471, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(471, 10)" end="(471, 14)">
                                    <AtomNode start="(471, 10)" end="(471, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(471, 15)" end="(471, 37)">
                                    <AtomNode start="(471, 15)" end="(471, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(471, 16)" end="(471, 36)">
                                      <OtherNode start="(471, 16)" end="(471, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(471, 16)" end="(471, 36)" leading="" trailing="" raw_val="List.forall_mem_cons" val="List.forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(471, 36)" end="(471, 37)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(471, 38)" end="(471, 43)">
                                    <OtherNode start="(471, 38)" end="(471, 43)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(471, 38)" end="(471, 40)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(471, 41)" end="(471, 43)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(471, 41)" end="(471, 43)">
                                          <IdentNode start="(471, 41)" end="(471, 43)" leading="" trailing="&#10;    " raw_val="hl" val="hl"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(472, 5)" end="(472, 33)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    ∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝) ∧ ∀ (x_1 : α), x_1 ∈ tail✝ → r x x_1 = s (f x) (f x_1)&#10;⊢ map f ((head✝¹ :: tail✝¹).merge (head✝ :: tail✝) r) = (map f (head✝¹ :: tail✝¹)).merge (map f (head✝ :: tail✝)) s" state_after="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;⊢ map f ((head✝¹ :: tail✝¹).merge (head✝ :: tail✝) r) = (map f (head✝¹ :: tail✝¹)).merge (map f (head✝ :: tail✝)) s" tactic="simp only [forall_and] at hl">
                                  <AtomNode start="(472, 5)" end="(472, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(472, 10)" end="(472, 14)">
                                    <AtomNode start="(472, 10)" end="(472, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(472, 15)" end="(472, 27)">
                                    <AtomNode start="(472, 15)" end="(472, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(472, 16)" end="(472, 26)">
                                      <OtherNode start="(472, 16)" end="(472, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(472, 16)" end="(472, 26)" leading="" trailing="" raw_val="forall_and" val="forall_and" full_name="forall_and" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(472, 26)" end="(472, 27)" leading="" trailing=" " val="]"/>
                                  </NullNode>
                                  <NullNode start="(472, 28)" end="(472, 33)">
                                    <OtherNode start="(472, 28)" end="(472, 33)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(472, 28)" end="(472, 30)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(472, 31)" end="(472, 33)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(472, 31)" end="(472, 33)">
                                          <IdentNode start="(472, 31)" end="(472, 33)" leading="" trailing="&#10;    " raw_val="hl" val="hl"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(473, 5)" end="(473, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;⊢ map f ((head✝¹ :: tail✝¹).merge (head✝ :: tail✝) r) = (map f (head✝¹ :: tail✝¹)).merge (map f (head✝ :: tail✝)) s" state_after="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;⊢ map f&#10;      (if r head✝¹ head✝ = true then head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r&#10;      else head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) =&#10;    if s (f head✝¹) (f head✝) = true then f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s&#10;    else f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" tactic="simp only [List.map, List.cons_merge_cons]">
                                  <AtomNode start="(473, 5)" end="(473, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(473, 10)" end="(473, 14)">
                                    <AtomNode start="(473, 10)" end="(473, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(473, 15)" end="(473, 47)">
                                    <AtomNode start="(473, 15)" end="(473, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(473, 16)" end="(473, 46)">
                                      <OtherNode start="(473, 16)" end="(473, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(473, 16)" end="(473, 24)" leading="" trailing="" raw_val="List.map" val="List.map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(473, 24)" end="(473, 25)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(473, 26)" end="(473, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(473, 26)" end="(473, 46)" leading="" trailing="" raw_val="List.cons_merge_cons" val="List.cons_merge_cons" full_name="List.cons_merge_cons" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(140, 9)" def_end="(140, 24)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(473, 46)" end="(473, 47)" leading="" trailing="&#10;    " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(474, 5)" end="(474, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;⊢ map f&#10;      (if r head✝¹ head✝ = true then head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r&#10;      else head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) =&#10;    if s (f head✝¹) (f head✝) = true then f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s&#10;    else f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" state_after="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;⊢ map f&#10;      (if r head✝¹ head✝ = true then head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r&#10;      else head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) =&#10;    if r head✝¹ head✝ = true then f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s&#10;    else f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" tactic="rw [← hl.1.1]">
                                  <AtomNode start="(474, 5)" end="(474, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(474, 8)" end="(474, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(474, 8)" end="(474, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(474, 9)" end="(474, 17)">
                                      <OtherNode start="(474, 9)" end="(474, 17)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode start="(474, 9)" end="(474, 10)">
                                          <OtherNode start="(474, 9)" end="(474, 10)" kind="patternIgnore">
                                            <OtherNode start="(474, 9)" end="(474, 10)" kind="token.«← »">
                                              <AtomNode start="(474, 9)" end="(474, 10)" leading="" trailing=" " val="←"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <OtherNode start="(474, 11)" end="(474, 17)" kind="Lean.Parser.Term.proj">
                                          <OtherNode start="(474, 11)" end="(474, 15)" kind="Lean.Parser.Term.proj">
                                            <IdentNode start="(474, 11)" end="(474, 13)" leading="" trailing="" raw_val="hl" val="hl"/>
                                            <AtomNode start="(474, 13)" end="(474, 14)" leading="" trailing="" val="."/>
                                            <OtherNode start="(474, 14)" end="(474, 15)" kind="fieldIdx">
                                              <AtomNode start="(474, 14)" end="(474, 15)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(474, 15)" end="(474, 16)" leading="" trailing="" val="."/>
                                          <OtherNode start="(474, 16)" end="(474, 17)" kind="fieldIdx">
                                            <AtomNode start="(474, 16)" end="(474, 17)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(474, 17)" end="(474, 18)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(475, 5)" end="(475, 10)" kind="Lean.Parser.Tactic.split" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;⊢ map f&#10;      (if r head✝¹ head✝ = true then head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r&#10;      else head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) =&#10;    if r head✝¹ head✝ = true then f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s&#10;    else f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" state_after="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ map f (head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r) = f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s&#10;&#10;case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ map f (head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) = f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" tactic="split">
                                  <AtomNode start="(475, 5)" end="(475, 10)" leading="" trailing="&#10;    " val="split"/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(476, 5)" end="(478, 29)" kind="Lean.cdot" state_before="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ map f (head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r) = f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s&#10;&#10;case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ map f (head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) = f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" state_after="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ map f (head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) = f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" tactic="· rw [List.map, map_merge, List.map]&#10;  simp only [List.forall_mem_cons, forall_and]&#10;  exact ⟨hl.2.1, hl.2.2⟩">
                                  <OtherNode start="(476, 5)" end="(476, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(476, 5)" end="(476, 6)" kind="patternIgnore">
                                      <OtherNode start="(476, 5)" end="(476, 6)" kind="token.«· »">
                                        <AtomNode start="(476, 5)" end="(476, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(476, 7)" end="(478, 29)">
                                    <TacticTacticseq1IndentedNode start="(476, 7)" end="(478, 29)">
                                      <NullNode start="(476, 7)" end="(478, 29)">
                                        <OtherNode start="(476, 7)" end="(476, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ map f (head✝¹ :: tail✝¹.merge (head✝ :: tail✝) r) = f head✝¹ :: (map f tail✝¹).merge (f head✝ :: map f tail✝) s" state_after="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ ∀ (a : α), a ∈ tail✝¹ → ∀ (b : α), b ∈ head✝ :: tail✝ → r a b = s (f a) (f b)" tactic="rw [List.map, map_merge, List.map]">
                                          <AtomNode start="(476, 7)" end="(476, 9)" leading="" trailing=" " val="rw"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <OtherNode start="(476, 10)" end="(476, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                            <AtomNode start="(476, 10)" end="(476, 11)" leading="" trailing="" val="["/>
                                            <NullNode start="(476, 11)" end="(476, 40)">
                                              <OtherNode start="(476, 11)" end="(476, 19)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(476, 11)" end="(476, 19)" leading="" trailing="" raw_val="List.map" val="List.map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                              </OtherNode>
                                              <AtomNode start="(476, 19)" end="(476, 20)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(476, 21)" end="(476, 30)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(476, 21)" end="(476, 30)" leading="" trailing="" raw_val="map_merge" val="map_merge" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </OtherNode>
                                              <AtomNode start="(476, 30)" end="(476, 31)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(476, 32)" end="(476, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(476, 32)" end="(476, 40)" leading="" trailing="" raw_val="List.map" val="List.map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(476, 40)" end="(476, 41)" leading="" trailing="&#10;      " val="]"/>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(477, 7)" end="(477, 51)" kind="Lean.Parser.Tactic.simp" state_before="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ ∀ (a : α), a ∈ tail✝¹ → ∀ (b : α), b ∈ head✝ :: tail✝ → r a b = s (f a) (f b)" state_after="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;    ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)" tactic="simp only [List.forall_mem_cons, forall_and]">
                                          <AtomNode start="(477, 7)" end="(477, 11)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(477, 12)" end="(477, 16)">
                                            <AtomNode start="(477, 12)" end="(477, 16)" leading="" trailing=" " val="only"/>
                                          </NullNode>
                                          <NullNode start="(477, 17)" end="(477, 51)">
                                            <AtomNode start="(477, 17)" end="(477, 18)" leading="" trailing="" val="["/>
                                            <NullNode start="(477, 18)" end="(477, 50)">
                                              <OtherNode start="(477, 18)" end="(477, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(477, 18)" end="(477, 38)" leading="" trailing="" raw_val="List.forall_mem_cons" val="List.forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              </OtherNode>
                                              <AtomNode start="(477, 38)" end="(477, 39)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(477, 40)" end="(477, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(477, 40)" end="(477, 50)" leading="" trailing="" raw_val="forall_and" val="forall_and" full_name="forall_and" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(477, 50)" end="(477, 51)" leading="" trailing="&#10;      " val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(478, 7)" end="(478, 29)" kind="Lean.Parser.Tactic.exact" state_before="case isTrue&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : r head✝¹ head✝ = true&#10;⊢ (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;    ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)" state_after="no goals" tactic="exact ⟨hl.2.1, hl.2.2⟩">
                                          <AtomNode start="(478, 7)" end="(478, 12)" leading="" trailing=" " val="exact"/>
                                          <OtherNode start="(478, 13)" end="(478, 29)" kind="Lean.Parser.Term.anonymousCtor">
                                            <AtomNode start="(478, 13)" end="(478, 14)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(478, 14)" end="(478, 28)">
                                              <OtherNode start="(478, 14)" end="(478, 20)" kind="Lean.Parser.Term.proj">
                                                <OtherNode start="(478, 14)" end="(478, 18)" kind="Lean.Parser.Term.proj">
                                                  <IdentNode start="(478, 14)" end="(478, 16)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                  <AtomNode start="(478, 16)" end="(478, 17)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(478, 17)" end="(478, 18)" kind="fieldIdx">
                                                    <AtomNode start="(478, 17)" end="(478, 18)" leading="" trailing="" val="2"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(478, 18)" end="(478, 19)" leading="" trailing="" val="."/>
                                                <OtherNode start="(478, 19)" end="(478, 20)" kind="fieldIdx">
                                                  <AtomNode start="(478, 19)" end="(478, 20)" leading="" trailing="" val="1"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(478, 20)" end="(478, 21)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(478, 22)" end="(478, 28)" kind="Lean.Parser.Term.proj">
                                                <OtherNode start="(478, 22)" end="(478, 26)" kind="Lean.Parser.Term.proj">
                                                  <IdentNode start="(478, 22)" end="(478, 24)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                  <AtomNode start="(478, 24)" end="(478, 25)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(478, 25)" end="(478, 26)" kind="fieldIdx">
                                                    <AtomNode start="(478, 25)" end="(478, 26)" leading="" trailing="" val="2"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(478, 26)" end="(478, 27)" leading="" trailing="" val="."/>
                                                <OtherNode start="(478, 27)" end="(478, 28)" kind="fieldIdx">
                                                  <AtomNode start="(478, 27)" end="(478, 28)" leading="" trailing="" val="2"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(478, 28)" end="(478, 29)" leading="" trailing="&#10;    " val="⟩"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(479, 5)" end="(481, 29)" kind="Lean.cdot" state_before="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ map f (head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) = f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" state_after="no goals" tactic="· rw [List.map, map_merge, List.map]&#10;  simp only [List.forall_mem_cons]&#10;  exact ⟨hl.1.2, hl.2.2⟩">
                                  <OtherNode start="(479, 5)" end="(479, 6)" kind="Lean.cdotTk">
                                    <OtherNode start="(479, 5)" end="(479, 6)" kind="patternIgnore">
                                      <OtherNode start="(479, 5)" end="(479, 6)" kind="token.«· »">
                                        <AtomNode start="(479, 5)" end="(479, 6)" leading="" trailing=" " val="·"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <TacticTacticseqNode start="(479, 7)" end="(481, 29)">
                                    <TacticTacticseq1IndentedNode start="(479, 7)" end="(481, 29)">
                                      <NullNode start="(479, 7)" end="(481, 29)">
                                        <OtherNode start="(479, 7)" end="(479, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ map f (head✝ :: (head✝¹ :: tail✝¹).merge tail✝ r) = f head✝ :: (f head✝¹ :: map f tail✝¹).merge (map f tail✝) s" state_after="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ ∀ (a : α), a ∈ head✝¹ :: tail✝¹ → ∀ (b : α), b ∈ tail✝ → r a b = s (f a) (f b)" tactic="rw [List.map, map_merge, List.map]">
                                          <AtomNode start="(479, 7)" end="(479, 9)" leading="" trailing=" " val="rw"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <OtherNode start="(479, 10)" end="(479, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                            <AtomNode start="(479, 10)" end="(479, 11)" leading="" trailing="" val="["/>
                                            <NullNode start="(479, 11)" end="(479, 40)">
                                              <OtherNode start="(479, 11)" end="(479, 19)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(479, 11)" end="(479, 19)" leading="" trailing="" raw_val="List.map" val="List.map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                              </OtherNode>
                                              <AtomNode start="(479, 19)" end="(479, 20)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(479, 21)" end="(479, 30)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(479, 21)" end="(479, 30)" leading="" trailing="" raw_val="map_merge" val="map_merge" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </OtherNode>
                                              <AtomNode start="(479, 30)" end="(479, 31)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(479, 32)" end="(479, 40)" kind="Lean.Parser.Tactic.rwRule">
                                                <NullNode/>
                                                <IdentNode start="(479, 32)" end="(479, 40)" leading="" trailing="" raw_val="List.map" val="List.map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(479, 40)" end="(479, 41)" leading="" trailing="&#10;      " val="]"/>
                                          </OtherNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(480, 7)" end="(480, 39)" kind="Lean.Parser.Tactic.simp" state_before="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ ∀ (a : α), a ∈ head✝¹ :: tail✝¹ → ∀ (b : α), b ∈ tail✝ → r a b = s (f a) (f b)" state_after="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ (∀ (b : α), b ∈ tail✝ → r head✝¹ b = s (f head✝¹) (f b)) ∧&#10;    ∀ (x : α), x ∈ tail✝¹ → ∀ (b : α), b ∈ tail✝ → r x b = s (f x) (f b)" tactic="simp only [List.forall_mem_cons]">
                                          <AtomNode start="(480, 7)" end="(480, 11)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(480, 12)" end="(480, 16)">
                                            <AtomNode start="(480, 12)" end="(480, 16)" leading="" trailing=" " val="only"/>
                                          </NullNode>
                                          <NullNode start="(480, 17)" end="(480, 39)">
                                            <AtomNode start="(480, 17)" end="(480, 18)" leading="" trailing="" val="["/>
                                            <NullNode start="(480, 18)" end="(480, 38)">
                                              <OtherNode start="(480, 18)" end="(480, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(480, 18)" end="(480, 38)" leading="" trailing="" raw_val="List.forall_mem_cons" val="List.forall_mem_cons" full_name="List.forall_mem_cons" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(480, 38)" end="(480, 39)" leading="" trailing="&#10;      " val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <OtherNode start="(481, 7)" end="(481, 29)" kind="Lean.Parser.Tactic.exact" state_before="case isFalse&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;l l' : List α&#10;head✝¹ : α&#10;tail✝¹ : List α&#10;head✝ : α&#10;tail✝ : List α&#10;hl :&#10;  (r head✝¹ head✝ = s (f head✝¹) (f head✝) ∧ ∀ (x : α), x ∈ tail✝ → r head✝¹ x = s (f head✝¹) (f x)) ∧&#10;    (∀ (x : α), x ∈ tail✝¹ → r x head✝ = s (f x) (f head✝)) ∧&#10;      ∀ (x : α), x ∈ tail✝¹ → ∀ (x_2 : α), x_2 ∈ tail✝ → r x x_2 = s (f x) (f x_2)&#10;h✝ : ¬r head✝¹ head✝ = true&#10;⊢ (∀ (b : α), b ∈ tail✝ → r head✝¹ b = s (f head✝¹) (f b)) ∧&#10;    ∀ (x : α), x ∈ tail✝¹ → ∀ (b : α), b ∈ tail✝ → r x b = s (f x) (f b)" state_after="no goals" tactic="exact ⟨hl.1.2, hl.2.2⟩">
                                          <AtomNode start="(481, 7)" end="(481, 12)" leading="" trailing=" " val="exact"/>
                                          <OtherNode start="(481, 13)" end="(481, 29)" kind="Lean.Parser.Term.anonymousCtor">
                                            <AtomNode start="(481, 13)" end="(481, 14)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(481, 14)" end="(481, 28)">
                                              <OtherNode start="(481, 14)" end="(481, 20)" kind="Lean.Parser.Term.proj">
                                                <OtherNode start="(481, 14)" end="(481, 18)" kind="Lean.Parser.Term.proj">
                                                  <IdentNode start="(481, 14)" end="(481, 16)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                  <AtomNode start="(481, 16)" end="(481, 17)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(481, 17)" end="(481, 18)" kind="fieldIdx">
                                                    <AtomNode start="(481, 17)" end="(481, 18)" leading="" trailing="" val="1"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(481, 18)" end="(481, 19)" leading="" trailing="" val="."/>
                                                <OtherNode start="(481, 19)" end="(481, 20)" kind="fieldIdx">
                                                  <AtomNode start="(481, 19)" end="(481, 20)" leading="" trailing="" val="2"/>
                                                </OtherNode>
                                              </OtherNode>
                                              <AtomNode start="(481, 20)" end="(481, 21)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(481, 22)" end="(481, 28)" kind="Lean.Parser.Term.proj">
                                                <OtherNode start="(481, 22)" end="(481, 26)" kind="Lean.Parser.Term.proj">
                                                  <IdentNode start="(481, 22)" end="(481, 24)" leading="" trailing="" raw_val="hl" val="hl"/>
                                                  <AtomNode start="(481, 24)" end="(481, 25)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(481, 25)" end="(481, 26)" kind="fieldIdx">
                                                    <AtomNode start="(481, 25)" end="(481, 26)" leading="" trailing="" val="2"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <AtomNode start="(481, 26)" end="(481, 27)" leading="" trailing="" val="."/>
                                                <OtherNode start="(481, 27)" end="(481, 28)" kind="fieldIdx">
                                                  <AtomNode start="(481, 27)" end="(481, 28)" leading="" trailing="" val="2"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(481, 28)" end="(481, 29)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(483, 1)" end="(499, 26)" name="map_mergeSort" full_name="List.map_mergeSort">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(483, 1)" end="(499, 26)" name="map_mergeSort" full_name="List.map_mergeSort" _is_private_decl="False">
        <AtomNode start="(483, 1)" end="(483, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(483, 9)" end="(483, 22)">
          <IdentNode start="(483, 9)" end="(483, 22)" leading="" trailing=" " raw_val="map_mergeSort" val="map_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(483, 23)" end="(485, 50)">
          <NullNode start="(483, 23)" end="(484, 51)">
            <OtherNode start="(483, 23)" end="(483, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 23)" end="(483, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 24)" end="(483, 25)">
                <IdentNode start="(483, 24)" end="(483, 25)" leading="" trailing=" " raw_val="r" val="r"/>
              </NullNode>
              <NullNode start="(483, 26)" end="(483, 40)">
                <AtomNode start="(483, 26)" end="(483, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(483, 28)" end="(483, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(483, 28)" end="(483, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(483, 30)" end="(483, 31)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(483, 32)" end="(483, 40)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(483, 32)" end="(483, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(483, 34)" end="(483, 35)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(483, 36)" end="(483, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(483, 40)" end="(483, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(483, 42)" end="(483, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 42)" end="(483, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 43)" end="(483, 44)">
                <IdentNode start="(483, 43)" end="(483, 44)" leading="" trailing=" " raw_val="s" val="s"/>
              </NullNode>
              <NullNode start="(483, 45)" end="(483, 59)">
                <AtomNode start="(483, 45)" end="(483, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(483, 47)" end="(483, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(483, 47)" end="(483, 48)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(483, 49)" end="(483, 50)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(483, 51)" end="(483, 59)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(483, 51)" end="(483, 52)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(483, 53)" end="(483, 54)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(483, 55)" end="(483, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(483, 59)" end="(483, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(483, 61)" end="(483, 72)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 61)" end="(483, 62)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 62)" end="(483, 63)">
                <IdentNode start="(483, 62)" end="(483, 63)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(483, 64)" end="(483, 71)">
                <AtomNode start="(483, 64)" end="(483, 65)" leading="" trailing=" " val=":"/>
                <OtherNode start="(483, 66)" end="(483, 71)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(483, 66)" end="(483, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(483, 68)" end="(483, 69)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(483, 70)" end="(483, 71)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(483, 71)" end="(483, 72)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(483, 73)" end="(483, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(483, 73)" end="(483, 74)" leading="" trailing="" val="{"/>
              <NullNode start="(483, 74)" end="(483, 75)">
                <IdentNode start="(483, 74)" end="(483, 75)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(483, 76)" end="(483, 84)">
                <AtomNode start="(483, 76)" end="(483, 77)" leading="" trailing=" " val=":"/>
                <OtherNode start="(483, 78)" end="(483, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(483, 78)" end="(483, 82)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(483, 83)" end="(483, 84)">
                    <IdentNode start="(483, 83)" end="(483, 84)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(483, 84)" end="(483, 85)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(484, 5)" end="(484, 51)">
              <AtomNode start="(484, 5)" end="(484, 6)" leading="" trailing="" val="("/>
              <NullNode start="(484, 6)" end="(484, 8)">
                <IdentNode start="(484, 6)" end="(484, 8)" leading="" trailing=" " raw_val="hl" val="hl"/>
              </NullNode>
              <NullNode start="(484, 9)" end="(484, 50)">
                <AtomNode start="(484, 9)" end="(484, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(484, 11)" end="(484, 50)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(484, 11)" end="(484, 12)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(484, 13)" end="(484, 14)">
                    <IdentNode start="(484, 13)" end="(484, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(484, 15)" end="(484, 18)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(484, 15)" end="(484, 16)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(484, 17)" end="(484, 18)" leading="" trailing="" raw_val="l" val="l"/>
                  </OtherNode>
                  <AtomNode start="(484, 18)" end="(484, 19)" leading="" trailing=" " val=","/>
                  <OtherNode start="(484, 20)" end="(484, 50)" kind="Lean.«term∀__,_»">
                    <AtomNode start="(484, 20)" end="(484, 21)" leading="" trailing=" " val="∀"/>
                    <LeanBinderidentNode start="(484, 22)" end="(484, 23)">
                      <IdentNode start="(484, 22)" end="(484, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                    </LeanBinderidentNode>
                    <OtherNode start="(484, 24)" end="(484, 27)" kind="Lean.«binderTerm∈_»">
                      <AtomNode start="(484, 24)" end="(484, 25)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(484, 26)" end="(484, 27)" leading="" trailing="" raw_val="l" val="l"/>
                    </OtherNode>
                    <AtomNode start="(484, 27)" end="(484, 28)" leading="" trailing=" " val=","/>
                    <OtherNode start="(484, 29)" end="(484, 50)" kind="«term_=_»">
                      <OtherNode start="(484, 29)" end="(484, 34)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(484, 29)" end="(484, 30)" leading="" trailing=" " raw_val="r" val="r"/>
                        <NullNode start="(484, 31)" end="(484, 34)">
                          <IdentNode start="(484, 31)" end="(484, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(484, 33)" end="(484, 34)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(484, 35)" end="(484, 36)" leading="" trailing=" " val="="/>
                      <OtherNode start="(484, 37)" end="(484, 50)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(484, 37)" end="(484, 38)" leading="" trailing=" " raw_val="s" val="s"/>
                        <NullNode start="(484, 39)" end="(484, 50)">
                          <OtherNode start="(484, 39)" end="(484, 44)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(484, 39)" end="(484, 40)" leading="" trailing="" val="("/>
                            <OtherNode start="(484, 40)" end="(484, 43)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(484, 40)" end="(484, 41)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(484, 42)" end="(484, 43)">
                                <IdentNode start="(484, 42)" end="(484, 43)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(484, 43)" end="(484, 44)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                          <OtherNode start="(484, 45)" end="(484, 50)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(484, 45)" end="(484, 46)" leading="" trailing="" val="("/>
                            <OtherNode start="(484, 46)" end="(484, 49)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(484, 46)" end="(484, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(484, 48)" end="(484, 49)">
                                <IdentNode start="(484, 48)" end="(484, 49)" leading="" trailing="" raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(484, 49)" end="(484, 50)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(484, 50)" end="(484, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(484, 52)" end="(485, 50)">
            <AtomNode start="(484, 52)" end="(484, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(485, 5)" end="(485, 50)" kind="«term_=_»">
              <OtherNode start="(485, 5)" end="(485, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(485, 5)" end="(485, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(485, 5)" end="(485, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(485, 5)" end="(485, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(485, 6)" end="(485, 19)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(485, 6)" end="(485, 17)" leading="" trailing=" " raw_val="l.mergeSort" val="l.mergeSort"/>
                      <NullNode start="(485, 18)" end="(485, 19)">
                        <IdentNode start="(485, 18)" end="(485, 19)" leading="" trailing="" raw_val="r" val="r"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(485, 19)" end="(485, 20)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(485, 20)" end="(485, 21)" leading="" trailing="" val="."/>
                  <IdentNode start="(485, 21)" end="(485, 24)" leading="" trailing=" " raw_val="map" val="map" full_name="List.map" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(485, 25)" end="(485, 26)">
                  <IdentNode start="(485, 25)" end="(485, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(485, 27)" end="(485, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(485, 29)" end="(485, 50)" kind="Lean.Parser.Term.app">
                <OtherNode start="(485, 29)" end="(485, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(485, 29)" end="(485, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(485, 29)" end="(485, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(485, 30)" end="(485, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(485, 30)" end="(485, 35)" leading="" trailing=" " raw_val="l.map" val="l.map"/>
                      <NullNode start="(485, 36)" end="(485, 37)">
                        <IdentNode start="(485, 36)" end="(485, 37)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(485, 37)" end="(485, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(485, 38)" end="(485, 39)" leading="" trailing="" val="."/>
                  <IdentNode start="(485, 39)" end="(485, 48)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                </OtherNode>
                <NullNode start="(485, 49)" end="(485, 50)">
                  <IdentNode start="(485, 49)" end="(485, 50)" leading="" trailing=" " raw_val="s" val="s"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(485, 51)" end="(499, 26)">
          <AtomNode start="(485, 51)" end="(485, 53)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(486, 3)" end="(498, 9)" kind="Lean.Parser.Term.match">
            <AtomNode start="(486, 3)" end="(486, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(486, 9)" end="(486, 10)">
              <OtherNode start="(486, 9)" end="(486, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(486, 9)" end="(486, 10)" leading="" trailing=" " raw_val="l" val="l"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(486, 11)" end="(486, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(487, 3)" end="(498, 9)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(487, 3)" end="(498, 9)">
                <OtherNode start="(487, 3)" end="(487, 18)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(487, 3)" end="(487, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(487, 5)" end="(487, 7)">
                    <NullNode start="(487, 5)" end="(487, 7)">
                      <OtherNode start="(487, 5)" end="(487, 7)" kind="«term[_]»">
                        <AtomNode start="(487, 5)" end="(487, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(487, 6)" end="(487, 7)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(487, 8)" end="(487, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(487, 11)" end="(487, 18)">
                    <AtomNode start="(487, 11)" end="(487, 13)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(487, 14)" end="(487, 18)">
                      <TacticTacticseq1IndentedNode start="(487, 14)" end="(487, 18)">
                        <NullNode start="(487, 14)" end="(487, 18)">
                          <OtherNode start="(487, 14)" end="(487, 18)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l : List α&#10;hl : ∀ (a : α), a ∈ [] → ∀ (b : α), b ∈ [] → r a b = s (f a) (f b)&#10;⊢ map f ([].mergeSort r) = (map f []).mergeSort s" state_after="no goals" tactic="simp">
                            <AtomNode start="(487, 14)" end="(487, 18)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(488, 3)" end="(488, 19)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(488, 3)" end="(488, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(488, 5)" end="(488, 8)">
                    <NullNode start="(488, 5)" end="(488, 8)">
                      <OtherNode start="(488, 5)" end="(488, 8)" kind="«term[_]»">
                        <AtomNode start="(488, 5)" end="(488, 6)" leading="" trailing="" val="["/>
                        <NullNode start="(488, 6)" end="(488, 7)">
                          <IdentNode start="(488, 6)" end="(488, 7)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                        <AtomNode start="(488, 7)" end="(488, 8)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(488, 9)" end="(488, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(488, 12)" end="(488, 19)">
                    <AtomNode start="(488, 12)" end="(488, 14)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(488, 15)" end="(488, 19)">
                      <TacticTacticseq1IndentedNode start="(488, 15)" end="(488, 19)">
                        <NullNode start="(488, 15)" end="(488, 19)">
                          <OtherNode start="(488, 15)" end="(488, 19)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l : List α&#10;x : α&#10;hl : ∀ (a : α), a ∈ [x] → ∀ (b : α), b ∈ [x] → r a b = s (f a) (f b)&#10;⊢ map f ([x].mergeSort r) = (map f [x]).mergeSort s" state_after="no goals" tactic="simp">
                            <AtomNode start="(488, 15)" end="(488, 19)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(489, 3)" end="(498, 9)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(489, 3)" end="(489, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(489, 5)" end="(489, 16)">
                    <NullNode start="(489, 5)" end="(489, 16)">
                      <OtherNode start="(489, 5)" end="(489, 16)" kind="«term_::_»">
                        <IdentNode start="(489, 5)" end="(489, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(489, 7)" end="(489, 9)" leading="" trailing=" " val="::"/>
                        <OtherNode start="(489, 10)" end="(489, 16)" kind="«term_::_»">
                          <IdentNode start="(489, 10)" end="(489, 11)" leading="" trailing=" " raw_val="b" val="b"/>
                          <AtomNode start="(489, 12)" end="(489, 14)" leading="" trailing=" " val="::"/>
                          <IdentNode start="(489, 15)" end="(489, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(489, 17)" end="(489, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(489, 20)" end="(498, 9)">
                    <AtomNode start="(489, 20)" end="(489, 22)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(490, 5)" end="(498, 9)">
                      <TacticTacticseq1IndentedNode start="(490, 5)" end="(498, 9)">
                        <NullNode start="(490, 5)" end="(498, 9)">
                          <OtherNode start="(490, 5)" end="(490, 68)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ map f ((a :: b :: l).mergeSort r) = (map f (a :: b :: l)).mergeSort s" state_after="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ map f&#10;      (((take (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r).merge&#10;        ((drop (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r) r) =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" tactic="simp only [mergeSort, splitInTwo_fst, splitInTwo_snd, map_cons]">
                            <AtomNode start="(490, 5)" end="(490, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(490, 10)" end="(490, 14)">
                              <AtomNode start="(490, 10)" end="(490, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(490, 15)" end="(490, 68)">
                              <AtomNode start="(490, 15)" end="(490, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(490, 16)" end="(490, 67)">
                                <OtherNode start="(490, 16)" end="(490, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(490, 16)" end="(490, 25)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(490, 25)" end="(490, 26)" leading="" trailing=" " val=","/>
                                <OtherNode start="(490, 27)" end="(490, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(490, 27)" end="(490, 41)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(35, 17)" def_end="(35, 31)"/>
                                </OtherNode>
                                <AtomNode start="(490, 41)" end="(490, 42)" leading="" trailing=" " val=","/>
                                <OtherNode start="(490, 43)" end="(490, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(490, 43)" end="(490, 57)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(39, 17)" def_end="(39, 31)"/>
                                </OtherNode>
                                <AtomNode start="(490, 57)" end="(490, 58)" leading="" trailing=" " val=","/>
                                <OtherNode start="(490, 59)" end="(490, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(490, 59)" end="(490, 67)" leading="" trailing="" raw_val="map_cons" val="map_cons" full_name="List.map_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(490, 67)" end="(490, 68)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(491, 5)" end="(492, 48)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ map f&#10;      (((take (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r).merge&#10;        ((drop (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r) r) =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" state_after="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ (map f ((take (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r)).merge&#10;      (map f ((drop (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r)) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" tactic="rw [map_merge (fun a am b bm =&amp;gt; hl a (mem_of_mem_take (by simpa using am))&#10;  b (mem_of_mem_drop (by simpa using bm)))]">
                            <AtomNode start="(491, 5)" end="(491, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(491, 8)" end="(492, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(491, 8)" end="(491, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(491, 9)" end="(492, 47)">
                                <OtherNode start="(491, 9)" end="(492, 47)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(491, 9)" end="(492, 47)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(491, 9)" end="(491, 18)" leading="" trailing=" " raw_val="map_merge" val="map_merge" full_name="List.map_merge" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean" def_start="(464, 9)" def_end="(464, 18)"/>
                                    <NullNode start="(491, 19)" end="(492, 47)">
                                      <OtherNode start="(491, 19)" end="(492, 47)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(491, 19)" end="(491, 20)" leading="" trailing="" val="("/>
                                        <OtherNode start="(491, 20)" end="(492, 46)" kind="Lean.Parser.Term.fun">
                                          <AtomNode start="(491, 20)" end="(491, 23)" leading="" trailing=" " val="fun"/>
                                          <OtherNode start="(491, 24)" end="(492, 46)" kind="Lean.Parser.Term.basicFun">
                                            <NullNode start="(491, 24)" end="(491, 33)">
                                              <IdentNode start="(491, 24)" end="(491, 25)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(491, 26)" end="(491, 28)" leading="" trailing=" " raw_val="am" val="am"/>
                                              <IdentNode start="(491, 29)" end="(491, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                                              <IdentNode start="(491, 31)" end="(491, 33)" leading="" trailing=" " raw_val="bm" val="bm"/>
                                            </NullNode>
                                            <NullNode/>
                                            <AtomNode start="(491, 34)" end="(491, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <OtherNode start="(491, 37)" end="(492, 46)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(491, 37)" end="(491, 39)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                              <NullNode start="(491, 40)" end="(492, 46)">
                                                <IdentNode start="(491, 40)" end="(491, 41)" leading="" trailing=" " raw_val="a" val="a"/>
                                                <OtherNode start="(491, 42)" end="(491, 79)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(491, 42)" end="(491, 43)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(491, 43)" end="(491, 78)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(491, 43)" end="(491, 58)" leading="" trailing=" " raw_val="mem_of_mem_take" val="mem_of_mem_take" full_name="List.mem_of_mem_take" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                    <NullNode start="(491, 59)" end="(491, 78)">
                                                      <OtherNode start="(491, 59)" end="(491, 78)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(491, 59)" end="(491, 60)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(491, 60)" end="(491, 77)">
                                                          <AtomNode start="(491, 60)" end="(491, 62)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(491, 63)" end="(491, 77)">
                                                            <TacticTacticseq1IndentedNode start="(491, 63)" end="(491, 77)">
                                                            <NullNode start="(491, 63)" end="(491, 77)">
                                                            <OtherNode start="(491, 63)" end="(491, 77)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a✝ b✝ : α&#10;l : List α&#10;hl : ∀ (a : α), a ∈ a✝ :: b✝ :: l → ∀ (b : α), b ∈ a✝ :: b✝ :: l → r a b = s (f a) (f b)&#10;a : α&#10;am : a ∈ (take (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)).mergeSort r&#10;b : α&#10;bm : b ∈ (drop (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)).mergeSort r&#10;⊢ a ∈ take (?m.149507 a am b bm) (a✝ :: b✝ :: l)" state_after="no goals" tactic="simpa using am">
                                                            <AtomNode start="(491, 63)" end="(491, 68)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(491, 69)" end="(491, 77)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(491, 69)" end="(491, 77)">
                                                            <AtomNode start="(491, 69)" end="(491, 74)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(491, 75)" end="(491, 77)" leading="" trailing="" raw_val="am" val="am"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(491, 77)" end="(491, 78)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(491, 78)" end="(491, 79)" leading="" trailing="&#10;      " val=")"/>
                                                </OtherNode>
                                                <IdentNode start="(492, 7)" end="(492, 8)" leading="" trailing=" " raw_val="b" val="b"/>
                                                <OtherNode start="(492, 9)" end="(492, 46)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(492, 9)" end="(492, 10)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(492, 10)" end="(492, 45)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(492, 10)" end="(492, 25)" leading="" trailing=" " raw_val="mem_of_mem_drop" val="mem_of_mem_drop" full_name="List.mem_of_mem_drop" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                    <NullNode start="(492, 26)" end="(492, 45)">
                                                      <OtherNode start="(492, 26)" end="(492, 45)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(492, 26)" end="(492, 27)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(492, 27)" end="(492, 44)">
                                                          <AtomNode start="(492, 27)" end="(492, 29)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(492, 30)" end="(492, 44)">
                                                            <TacticTacticseq1IndentedNode start="(492, 30)" end="(492, 44)">
                                                            <NullNode start="(492, 30)" end="(492, 44)">
                                                            <OtherNode start="(492, 30)" end="(492, 44)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a✝ b✝ : α&#10;l : List α&#10;hl : ∀ (a : α), a ∈ a✝ :: b✝ :: l → ∀ (b : α), b ∈ a✝ :: b✝ :: l → r a b = s (f a) (f b)&#10;a : α&#10;am : a ∈ (take (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)).mergeSort r&#10;b : α&#10;bm : b ∈ (drop (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)).mergeSort r&#10;⊢ b ∈ drop (?m.149509 a am b bm) (a✝ :: b✝ :: l)" state_after="no goals" tactic="simpa using bm">
                                                            <AtomNode start="(492, 30)" end="(492, 35)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(492, 36)" end="(492, 44)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(492, 36)" end="(492, 44)">
                                                            <AtomNode start="(492, 36)" end="(492, 41)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(492, 42)" end="(492, 44)" leading="" trailing="" raw_val="bm" val="bm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(492, 44)" end="(492, 45)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(492, 45)" end="(492, 46)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(492, 46)" end="(492, 47)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(492, 47)" end="(492, 48)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(493, 5)" end="(494, 48)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ (map f ((take (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r)).merge&#10;      (map f ((drop (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r)) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" state_after="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ ((map f (take (((a :: b :: l).length + 1) / 2) (a :: b :: l))).mergeSort s).merge&#10;      (map f ((drop (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r)) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" tactic="rw [map_mergeSort (s := s) (fun a am b bm =&amp;gt; hl a (mem_of_mem_take (by simpa using am))&#10;  b (mem_of_mem_take (by simpa using bm)))]">
                            <AtomNode start="(493, 5)" end="(493, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(493, 8)" end="(494, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(493, 8)" end="(493, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(493, 9)" end="(494, 47)">
                                <OtherNode start="(493, 9)" end="(494, 47)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(493, 9)" end="(494, 47)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(493, 9)" end="(493, 22)" leading="" trailing=" " raw_val="map_mergeSort" val="map_mergeSort"/>
                                    <NullNode start="(493, 23)" end="(494, 47)">
                                      <OtherNode start="(493, 23)" end="(493, 31)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(493, 23)" end="(493, 24)" leading="" trailing="" val="("/>
                                        <IdentNode start="(493, 24)" end="(493, 25)" leading="" trailing=" " raw_val="s" val="s"/>
                                        <AtomNode start="(493, 26)" end="(493, 28)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(493, 29)" end="(493, 30)" leading="" trailing="" raw_val="s" val="s"/>
                                        <AtomNode start="(493, 30)" end="(493, 31)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <OtherNode start="(493, 32)" end="(494, 47)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(493, 32)" end="(493, 33)" leading="" trailing="" val="("/>
                                        <OtherNode start="(493, 33)" end="(494, 46)" kind="Lean.Parser.Term.fun">
                                          <AtomNode start="(493, 33)" end="(493, 36)" leading="" trailing=" " val="fun"/>
                                          <OtherNode start="(493, 37)" end="(494, 46)" kind="Lean.Parser.Term.basicFun">
                                            <NullNode start="(493, 37)" end="(493, 46)">
                                              <IdentNode start="(493, 37)" end="(493, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(493, 39)" end="(493, 41)" leading="" trailing=" " raw_val="am" val="am"/>
                                              <IdentNode start="(493, 42)" end="(493, 43)" leading="" trailing=" " raw_val="b" val="b"/>
                                              <IdentNode start="(493, 44)" end="(493, 46)" leading="" trailing=" " raw_val="bm" val="bm"/>
                                            </NullNode>
                                            <NullNode/>
                                            <AtomNode start="(493, 47)" end="(493, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <OtherNode start="(493, 50)" end="(494, 46)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(493, 50)" end="(493, 52)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                              <NullNode start="(493, 53)" end="(494, 46)">
                                                <IdentNode start="(493, 53)" end="(493, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                                                <OtherNode start="(493, 55)" end="(493, 92)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(493, 55)" end="(493, 56)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(493, 56)" end="(493, 91)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(493, 56)" end="(493, 71)" leading="" trailing=" " raw_val="mem_of_mem_take" val="mem_of_mem_take" full_name="List.mem_of_mem_take" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                    <NullNode start="(493, 72)" end="(493, 91)">
                                                      <OtherNode start="(493, 72)" end="(493, 91)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(493, 72)" end="(493, 73)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(493, 73)" end="(493, 90)">
                                                          <AtomNode start="(493, 73)" end="(493, 75)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(493, 76)" end="(493, 90)">
                                                            <TacticTacticseq1IndentedNode start="(493, 76)" end="(493, 90)">
                                                            <NullNode start="(493, 76)" end="(493, 90)">
                                                            <OtherNode start="(493, 76)" end="(493, 90)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a✝ b✝ : α&#10;l : List α&#10;hl : ∀ (a : α), a ∈ a✝ :: b✝ :: l → ∀ (b : α), b ∈ a✝ :: b✝ :: l → r a b = s (f a) (f b)&#10;a : α&#10;am : a ∈ take (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;b : α&#10;bm : b ∈ take (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;⊢ a ∈ take (?m.149854 a am b bm) (a✝ :: b✝ :: l)" state_after="no goals" tactic="simpa using am">
                                                            <AtomNode start="(493, 76)" end="(493, 81)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(493, 82)" end="(493, 90)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(493, 82)" end="(493, 90)">
                                                            <AtomNode start="(493, 82)" end="(493, 87)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(493, 88)" end="(493, 90)" leading="" trailing="" raw_val="am" val="am"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(493, 90)" end="(493, 91)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(493, 91)" end="(493, 92)" leading="" trailing="&#10;      " val=")"/>
                                                </OtherNode>
                                                <IdentNode start="(494, 7)" end="(494, 8)" leading="" trailing=" " raw_val="b" val="b"/>
                                                <OtherNode start="(494, 9)" end="(494, 46)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(494, 9)" end="(494, 10)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(494, 10)" end="(494, 45)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(494, 10)" end="(494, 25)" leading="" trailing=" " raw_val="mem_of_mem_take" val="mem_of_mem_take" full_name="List.mem_of_mem_take" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                    <NullNode start="(494, 26)" end="(494, 45)">
                                                      <OtherNode start="(494, 26)" end="(494, 45)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(494, 26)" end="(494, 27)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(494, 27)" end="(494, 44)">
                                                          <AtomNode start="(494, 27)" end="(494, 29)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(494, 30)" end="(494, 44)">
                                                            <TacticTacticseq1IndentedNode start="(494, 30)" end="(494, 44)">
                                                            <NullNode start="(494, 30)" end="(494, 44)">
                                                            <OtherNode start="(494, 30)" end="(494, 44)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a✝ b✝ : α&#10;l : List α&#10;hl : ∀ (a : α), a ∈ a✝ :: b✝ :: l → ∀ (b : α), b ∈ a✝ :: b✝ :: l → r a b = s (f a) (f b)&#10;a : α&#10;am : a ∈ take (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;b : α&#10;bm : b ∈ take (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;⊢ b ∈ take (?m.149856 a am b bm) (a✝ :: b✝ :: l)" state_after="no goals" tactic="simpa using bm">
                                                            <AtomNode start="(494, 30)" end="(494, 35)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(494, 36)" end="(494, 44)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(494, 36)" end="(494, 44)">
                                                            <AtomNode start="(494, 36)" end="(494, 41)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(494, 42)" end="(494, 44)" leading="" trailing="" raw_val="bm" val="bm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(494, 44)" end="(494, 45)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(494, 45)" end="(494, 46)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(494, 46)" end="(494, 47)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(494, 47)" end="(494, 48)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(495, 5)" end="(496, 48)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ ((map f (take (((a :: b :: l).length + 1) / 2) (a :: b :: l))).mergeSort s).merge&#10;      (map f ((drop (((a :: b :: l).length + 1) / 2) (a :: b :: l)).mergeSort r)) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" state_after="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ ((map f (take (((a :: b :: l).length + 1) / 2) (a :: b :: l))).mergeSort s).merge&#10;      ((map f (drop (((a :: b :: l).length + 1) / 2) (a :: b :: l))).mergeSort s) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" tactic="rw [map_mergeSort (s := s) (fun a am b bm =&amp;gt; hl a (mem_of_mem_drop (by simpa using am))&#10;  b (mem_of_mem_drop (by simpa using bm)))]">
                            <AtomNode start="(495, 5)" end="(495, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(495, 8)" end="(496, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(495, 8)" end="(495, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(495, 9)" end="(496, 47)">
                                <OtherNode start="(495, 9)" end="(496, 47)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <OtherNode start="(495, 9)" end="(496, 47)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(495, 9)" end="(495, 22)" leading="" trailing=" " raw_val="map_mergeSort" val="map_mergeSort"/>
                                    <NullNode start="(495, 23)" end="(496, 47)">
                                      <OtherNode start="(495, 23)" end="(495, 31)" kind="Lean.Parser.Term.namedArgument">
                                        <AtomNode start="(495, 23)" end="(495, 24)" leading="" trailing="" val="("/>
                                        <IdentNode start="(495, 24)" end="(495, 25)" leading="" trailing=" " raw_val="s" val="s"/>
                                        <AtomNode start="(495, 26)" end="(495, 28)" leading="" trailing=" " val=":="/>
                                        <IdentNode start="(495, 29)" end="(495, 30)" leading="" trailing="" raw_val="s" val="s"/>
                                        <AtomNode start="(495, 30)" end="(495, 31)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <OtherNode start="(495, 32)" end="(496, 47)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(495, 32)" end="(495, 33)" leading="" trailing="" val="("/>
                                        <OtherNode start="(495, 33)" end="(496, 46)" kind="Lean.Parser.Term.fun">
                                          <AtomNode start="(495, 33)" end="(495, 36)" leading="" trailing=" " val="fun"/>
                                          <OtherNode start="(495, 37)" end="(496, 46)" kind="Lean.Parser.Term.basicFun">
                                            <NullNode start="(495, 37)" end="(495, 46)">
                                              <IdentNode start="(495, 37)" end="(495, 38)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(495, 39)" end="(495, 41)" leading="" trailing=" " raw_val="am" val="am"/>
                                              <IdentNode start="(495, 42)" end="(495, 43)" leading="" trailing=" " raw_val="b" val="b"/>
                                              <IdentNode start="(495, 44)" end="(495, 46)" leading="" trailing=" " raw_val="bm" val="bm"/>
                                            </NullNode>
                                            <NullNode/>
                                            <AtomNode start="(495, 47)" end="(495, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <OtherNode start="(495, 50)" end="(496, 46)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(495, 50)" end="(495, 52)" leading="" trailing=" " raw_val="hl" val="hl"/>
                                              <NullNode start="(495, 53)" end="(496, 46)">
                                                <IdentNode start="(495, 53)" end="(495, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                                                <OtherNode start="(495, 55)" end="(495, 92)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(495, 55)" end="(495, 56)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(495, 56)" end="(495, 91)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(495, 56)" end="(495, 71)" leading="" trailing=" " raw_val="mem_of_mem_drop" val="mem_of_mem_drop" full_name="List.mem_of_mem_drop" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                    <NullNode start="(495, 72)" end="(495, 91)">
                                                      <OtherNode start="(495, 72)" end="(495, 91)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(495, 72)" end="(495, 73)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(495, 73)" end="(495, 90)">
                                                          <AtomNode start="(495, 73)" end="(495, 75)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(495, 76)" end="(495, 90)">
                                                            <TacticTacticseq1IndentedNode start="(495, 76)" end="(495, 90)">
                                                            <NullNode start="(495, 76)" end="(495, 90)">
                                                            <OtherNode start="(495, 76)" end="(495, 90)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a✝ b✝ : α&#10;l : List α&#10;hl : ∀ (a : α), a ∈ a✝ :: b✝ :: l → ∀ (b : α), b ∈ a✝ :: b✝ :: l → r a b = s (f a) (f b)&#10;a : α&#10;am : a ∈ drop (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;b : α&#10;bm : b ∈ drop (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;⊢ a ∈ drop (?m.150115 a am b bm) (a✝ :: b✝ :: l)" state_after="no goals" tactic="simpa using am">
                                                            <AtomNode start="(495, 76)" end="(495, 81)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(495, 82)" end="(495, 90)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(495, 82)" end="(495, 90)">
                                                            <AtomNode start="(495, 82)" end="(495, 87)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(495, 88)" end="(495, 90)" leading="" trailing="" raw_val="am" val="am"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(495, 90)" end="(495, 91)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(495, 91)" end="(495, 92)" leading="" trailing="&#10;      " val=")"/>
                                                </OtherNode>
                                                <IdentNode start="(496, 7)" end="(496, 8)" leading="" trailing=" " raw_val="b" val="b"/>
                                                <OtherNode start="(496, 9)" end="(496, 46)" kind="Lean.Parser.Term.paren">
                                                  <AtomNode start="(496, 9)" end="(496, 10)" leading="" trailing="" val="("/>
                                                  <OtherNode start="(496, 10)" end="(496, 45)" kind="Lean.Parser.Term.app">
                                                    <IdentNode start="(496, 10)" end="(496, 25)" leading="" trailing=" " raw_val="mem_of_mem_drop" val="mem_of_mem_drop" full_name="List.mem_of_mem_drop" mod_name="Init.Data.List.Sublist" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sublist.lean"/>
                                                    <NullNode start="(496, 26)" end="(496, 45)">
                                                      <OtherNode start="(496, 26)" end="(496, 45)" kind="Lean.Parser.Term.paren">
                                                        <AtomNode start="(496, 26)" end="(496, 27)" leading="" trailing="" val="("/>
                                                        <TermBytacticNode start="(496, 27)" end="(496, 44)">
                                                          <AtomNode start="(496, 27)" end="(496, 29)" leading="" trailing=" " val="by"/>
                                                          <TacticTacticseqNode start="(496, 30)" end="(496, 44)">
                                                            <TacticTacticseq1IndentedNode start="(496, 30)" end="(496, 44)">
                                                            <NullNode start="(496, 30)" end="(496, 44)">
                                                            <OtherNode start="(496, 30)" end="(496, 44)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a✝ b✝ : α&#10;l : List α&#10;hl : ∀ (a : α), a ∈ a✝ :: b✝ :: l → ∀ (b : α), b ∈ a✝ :: b✝ :: l → r a b = s (f a) (f b)&#10;a : α&#10;am : a ∈ drop (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;b : α&#10;bm : b ∈ drop (((a✝ :: b✝ :: l).length + 1) / 2) (a✝ :: b✝ :: l)&#10;⊢ b ∈ drop (?m.150117 a am b bm) (a✝ :: b✝ :: l)" state_after="no goals" tactic="simpa using bm">
                                                            <AtomNode start="(496, 30)" end="(496, 35)" leading="" trailing=" " val="simpa"/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <OtherNode start="(496, 36)" end="(496, 44)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(496, 36)" end="(496, 44)">
                                                            <AtomNode start="(496, 36)" end="(496, 41)" leading="" trailing=" " val="using"/>
                                                            <IdentNode start="(496, 42)" end="(496, 44)" leading="" trailing="" raw_val="bm" val="bm"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                          </TacticTacticseqNode>
                                                        </TermBytacticNode>
                                                        <AtomNode start="(496, 44)" end="(496, 45)" leading="" trailing="" val=")"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                  <AtomNode start="(496, 45)" end="(496, 46)" leading="" trailing="" val=")"/>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </OtherNode>
                                        <AtomNode start="(496, 46)" end="(496, 47)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(496, 47)" end="(496, 48)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(497, 5)" end="(497, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ ((map f (take (((a :: b :: l).length + 1) / 2) (a :: b :: l))).mergeSort s).merge&#10;      ((map f (drop (((a :: b :: l).length + 1) / 2) (a :: b :: l))).mergeSort s) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" state_after="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ ((take (((a :: b :: l).length + 1) / 2) (map f (a :: b :: l))).mergeSort s).merge&#10;      ((drop (((a :: b :: l).length + 1) / 2) (map f (a :: b :: l))).mergeSort s) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" tactic="rw [map_take, map_drop]">
                            <AtomNode start="(497, 5)" end="(497, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(497, 8)" end="(497, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(497, 8)" end="(497, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(497, 9)" end="(497, 27)">
                                <OtherNode start="(497, 9)" end="(497, 17)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(497, 9)" end="(497, 17)" leading="" trailing="" raw_val="map_take" val="map_take" full_name="List.map_take" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                </OtherNode>
                                <AtomNode start="(497, 17)" end="(497, 18)" leading="" trailing=" " val=","/>
                                <OtherNode start="(497, 19)" end="(497, 27)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(497, 19)" end="(497, 27)" leading="" trailing="" raw_val="map_drop" val="map_drop" full_name="List.map_drop" mod_name="Init.Data.List.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/TakeDrop.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(497, 27)" end="(497, 28)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(498, 5)" end="(498, 9)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;r : α → α → Bool&#10;s : β → β → Bool&#10;f : α → β&#10;l✝ : List α&#10;a b : α&#10;l : List α&#10;hl : ∀ (a_1 : α), a_1 ∈ a :: b :: l → ∀ (b_1 : α), b_1 ∈ a :: b :: l → r a_1 b_1 = s (f a_1) (f b_1)&#10;⊢ ((take (((a :: b :: l).length + 1) / 2) (map f (a :: b :: l))).mergeSort s).merge&#10;      ((drop (((a :: b :: l).length + 1) / 2) (map f (a :: b :: l))).mergeSort s) s =&#10;    ((take (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s).merge&#10;      ((drop (((f a :: f b :: map f l).length + 1) / 2) (f a :: f b :: map f l)).mergeSort s) s" state_after="no goals" tactic="simp">
                            <AtomNode start="(498, 5)" end="(498, 9)" leading="" trailing="&#10;  " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(499, 3)" end="(499, 26)" kind="Lean.Parser.Termination.suffix">
            <NullNode start="(499, 3)" end="(499, 26)">
              <OtherNode start="(499, 3)" end="(499, 26)" kind="Lean.Parser.Termination.terminationBy">
                <AtomNode start="(499, 3)" end="(499, 17)" leading="" trailing=" " val="termination_by"/>
                <NullNode/>
                <NullNode/>
                <OtherNode start="(499, 18)" end="(499, 26)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(499, 18)" end="(499, 24)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(499, 25)" end="(499, 26)">
                    <IdentNode start="(499, 25)" end="(499, 26)" leading="" trailing="&#10;" raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 1)" end="(24, 3)" text="# Basic properties of `mergeSort`.&#10;&#10;* `sorted_mergeSort`: `mergeSort` produces a sorted list.&#10;* `mergeSort_perm`: `mergeSort` is a permutation of the input list.&#10;* `mergeSort_of_sorted`: `mergeSort` does not change a sorted list.&#10;* `mergeSort_cons`: proves `mergeSort le (x :: xs) = l₁ ++ x :: l₂` for some `l₁, l₂`&#10;  so that `mergeSort le xs = l₁ ++ l₂`, and no `a ∈ l₁` satisfies `le a x`.&#10;* `sublist_mergeSort`: if `c` is a sorted sublist of `l`, then `c` is still a sublist of `mergeSort le l`.&#10;&#10;-/"/>
    <Comment start="(26, 38)" end="(27, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(27, 39)" end="(29, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(31, 1)" end="(31, 22)" text="### splitInTwo -/"/>
    <Comment start="(96, 1)" end="(96, 20)" text="### zipIdxLE -/"/>
    <Comment start="(138, 1)" end="(138, 17)" text="### merge -/"/>
    <Comment start="(163, 1)" end="(165, 3)" text="The elements of `merge le xs ys` are exactly the elements of `xs` and `ys`.&#10;-/"/>
    <Comment start="(166, 1)" end="(167, 1)" text="-- We subsequently prove that `mergeSort_perm : merge le xs ys ~ xs ++ ys`.&#10;"/>
    <Comment start="(202, 1)" end="(203, 1)" text="-- We enable this instance locally so we can write `Pairwise le` instead of `Pairwise (le · ·)` everywhere.&#10;"/>
    <Comment start="(205, 1)" end="(208, 3)" text="If the ordering relation `le` is transitive and total (i.e. `le a b || le b a` for all `a, b`)&#10;then the `merge` of two sorted lists is sorted.&#10;-/"/>
    <Comment start="(265, 1)" end="(265, 21)" text="### mergeSort -/"/>
    <Comment start="(289, 1)" end="(295, 3)" text="The result of `mergeSort` is sorted,&#10;as long as the comparison function is transitive (`le a b → le b c → le a c`)&#10;and total in the sense that `le a b || le b a`.&#10;&#10;The comparison function need not be irreflexive, i.e. `le a b` and `le b a` is allowed even when `a ≠ b`.&#10;-/"/>
    <Comment start="(311, 1)" end="(313, 3)" text="If the input list is already sorted, then `mergeSort` does not change the list.&#10;-/"/>
    <Comment start="(327, 1)" end="(338, 3)" text="This merge sort algorithm is stable,&#10;in the sense that breaking ties in the ordering function using the position in the list&#10;has no effect on the output.&#10;&#10;That is, elements which are equal with respect to the ordering function will remain&#10;in the same order in the output list as they were in the input list.&#10;&#10;See also:&#10;* `sublist_mergeSort`: if `c &lt;+ l` and `c.Pairwise le`, then `c &lt;+ mergeSort le l`.&#10;* `pair_sublist_mergeSort`: if `[a, b] &lt;+ l` and `le a b`, then `[a, b] &lt;+ mergeSort le l`)&#10;-/"/>
    <Comment start="(418, 1)" end="(422, 3)" text="Another statement of stability of merge sort.&#10;If `c` is a sorted sublist of `l`,&#10;then `c` is still a sublist of `mergeSort le l`.&#10;-/"/>
    <Comment start="(450, 1)" end="(454, 3)" text="Another statement of stability of merge sort.&#10;If a pair `[a, b]` is a sublist of `l` and `le a b`,&#10;then `[a, b]` is still a sublist of `mergeSort le l`.&#10;-/"/>
  </Comments>
</TracedFile>
