<TracedFile path="src/lean/Init/Data/List/Sort/Impl.lean" md5="7e0d930427f6cfca8ddc7f1cbdda6571">
  <FileNode start="(1, 1)" end="(240, 28)">
    <ModuleHeaderNode start="(6, 1)" end="(9, 34)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(9, 34)">
        <ModuleImportNode start="(9, 1)" end="(9, 34)" module="Init.Data.List.Sort.Lemmas" path="src/lean/Init/Data/List/Sort/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 34)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.List.Sort.Lemmas" val="Init.Data.List.Sort.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(11, 1)" end="(34, 3)" comment="# Replacing `merge` and `mergeSort` at runtime with tail-recursive and faster versions.&#10;&#10;We replace `merge` with `mergeTR` using a `@[csimp]` lemma.&#10;&#10;We replace `mergeSort` in two steps:&#10;* first with `mergeSortTR`, which while not tail-recursive itself (it can't be),&#10;  uses `mergeTR` internally.&#10;* second with `mergeSortTR₂`, which achieves an ~20% speed-up over `mergeSortTR`&#10;  by avoiding some unnecessary list reversals.&#10;&#10;There is no public API in this file; it solely exists to implement the `@[csimp]` lemmas&#10;affecting runtime behaviour.&#10;&#10;## Future work&#10;The current runtime implementation could be further improved in a number of ways, e.g.:&#10;* only walking the list once during splitting,&#10;* using insertion sort for small chunks rather than splitting all the way down to singletons,&#10;* identifying already sorted or reverse sorted chunks and skipping them.&#10;&#10;Because the theory developed for `mergeSort` is independent of the runtime implementation,&#10;as long as such improvements are carefully validated by benchmarking,&#10;they can be done without changing the theory, as long as a `@[csimp]` lemma is provided.&#10;-/">
      <AtomNode start="(11, 1)" end="(11, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(12, 1)" end="(34, 3)" leading="" trailing="&#10;&#10;" val="# Replacing `merge` and `mergeSort` at runtime with tail-recursive and faster versions.&#10;&#10;We replace `merge` with `mergeTR` using a `@[csimp]` lemma.&#10;&#10;We replace `mergeSort` in two steps:&#10;* first with `mergeSortTR`, which while not tail-recursive itself (it can't be),&#10;  uses `mergeTR` internally.&#10;* second with `mergeSortTR₂`, which achieves an ~20% speed-up over `mergeSortTR`&#10;  by avoiding some unnecessary list reversals.&#10;&#10;There is no public API in this file; it solely exists to implement the `@[csimp]` lemmas&#10;affecting runtime behaviour.&#10;&#10;## Future work&#10;The current runtime implementation could be further improved in a number of ways, e.g.:&#10;* only walking the list once during splitting,&#10;* using insertion sort for small chunks rather than splitting all the way down to singletons,&#10;* identifying already sorted or reverse sorted chunks and skipping them.&#10;&#10;Because the theory developed for `mergeSort` is independent of the runtime implementation,&#10;as long as such improvements are carefully validated by benchmarking,&#10;they can be done without changing the theory, as long as a `@[csimp]` lemma is provided.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(36, 1)" end="(36, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(36, 1)" end="(36, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(36, 12)" end="(36, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(36, 33)" end="(36, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(37, 1)" end="(37, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(37, 1)" end="(37, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(37, 12)" end="(37, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(37, 34)" end="(37, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandOpenNode start="(39, 1)" end="(39, 10)">
      <AtomNode start="(39, 1)" end="(39, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(39, 6)" end="(39, 10)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(39, 6)" end="(39, 10)">
          <IdentNode start="(39, 6)" end="(39, 10)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandNamespaceNode start="(41, 1)" end="(41, 34)" name="List.MergeSort.Internal">
      <AtomNode start="(41, 1)" end="(41, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(41, 11)" end="(41, 34)" leading="" trailing="&#10;&#10;" raw_val="List.MergeSort.Internal" val="List.MergeSort.Internal"/>
    </CommandNamespaceNode>
    <CommandDeclarationNode start="(43, 1)" end="(55, 33)" name="mergeTR" full_name="List.MergeSort.Internal.mergeTR">
      <CommandDeclmodifiersNode start="(43, 1)" end="(45, 3)">
        <NullNode start="(43, 1)" end="(45, 3)">
          <CommandDoccommentNode start="(43, 1)" end="(45, 3)" comment="`O(|l₁| + |l₂|)`. Merge two lists using `le` as a switch.&#10;-/">
            <AtomNode start="(43, 1)" end="(43, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(44, 1)" end="(45, 3)" leading="" trailing="&#10;" val="`O(|l₁| + |l₂|)`. Merge two lists using `le` as a switch.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(46, 1)" end="(55, 33)" name="mergeTR">
        <AtomNode start="(46, 1)" end="(46, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(46, 5)" end="(46, 12)">
          <IdentNode start="(46, 5)" end="(46, 12)" leading="" trailing=" " raw_val="mergeTR" val="mergeTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(46, 13)" end="(46, 58)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(46, 13)" end="(46, 49)">
            <TermExplicitbinderNode start="(46, 13)" end="(46, 29)">
              <AtomNode start="(46, 13)" end="(46, 14)" leading="" trailing="" val="("/>
              <NullNode start="(46, 14)" end="(46, 19)">
                <IdentNode start="(46, 14)" end="(46, 16)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                <IdentNode start="(46, 17)" end="(46, 19)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              </NullNode>
              <NullNode start="(46, 20)" end="(46, 28)">
                <AtomNode start="(46, 20)" end="(46, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(46, 22)" end="(46, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(46, 22)" end="(46, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(46, 27)" end="(46, 28)">
                    <IdentNode start="(46, 27)" end="(46, 28)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(46, 28)" end="(46, 29)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(46, 30)" end="(46, 49)">
              <AtomNode start="(46, 30)" end="(46, 31)" leading="" trailing="" val="("/>
              <NullNode start="(46, 31)" end="(46, 33)">
                <IdentNode start="(46, 31)" end="(46, 33)" leading="" trailing=" " raw_val="le" val="le"/>
              </NullNode>
              <NullNode start="(46, 34)" end="(46, 48)">
                <AtomNode start="(46, 34)" end="(46, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(46, 36)" end="(46, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(46, 36)" end="(46, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(46, 38)" end="(46, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(46, 40)" end="(46, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(46, 40)" end="(46, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(46, 42)" end="(46, 43)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(46, 44)" end="(46, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(46, 48)" end="(46, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(46, 50)" end="(46, 58)">
            <TermTypespecNode start="(46, 50)" end="(46, 58)">
              <AtomNode start="(46, 50)" end="(46, 51)" leading="" trailing=" " val=":"/>
              <OtherNode start="(46, 52)" end="(46, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(46, 52)" end="(46, 56)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(46, 57)" end="(46, 58)">
                  <IdentNode start="(46, 57)" end="(46, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(46, 59)" end="(55, 33)">
          <AtomNode start="(46, 59)" end="(46, 61)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(47, 3)" end="(47, 14)" kind="Lean.Parser.Term.app">
            <IdentNode start="(47, 3)" end="(47, 5)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(47, 6)" end="(47, 14)">
              <IdentNode start="(47, 6)" end="(47, 8)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
              <IdentNode start="(47, 9)" end="(47, 11)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
              <OtherNode start="(47, 12)" end="(47, 14)" kind="«term[_]»">
                <AtomNode start="(47, 12)" end="(47, 13)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(47, 13)" end="(47, 14)" leading="" trailing="&#10;" val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(48, 1)" end="(55, 33)">
            <OtherNode start="(48, 1)" end="(55, 33)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(48, 1)" end="(48, 6)" leading="" trailing=" " val="where"/>
              <NullNode start="(48, 7)" end="(55, 33)">
                <OtherNode start="(48, 7)" end="(55, 33)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(48, 7)" end="(55, 33)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(48, 7)" end="(55, 33)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(48, 7)" end="(48, 9)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(48, 10)" end="(48, 45)">
                        <TermTypespecNode start="(48, 10)" end="(48, 45)">
                          <AtomNode start="(48, 10)" end="(48, 11)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(48, 12)" end="(48, 45)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(48, 12)" end="(48, 18)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(48, 12)" end="(48, 16)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(48, 17)" end="(48, 18)">
                                <IdentNode start="(48, 17)" end="(48, 18)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(48, 19)" end="(48, 20)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(48, 21)" end="(48, 45)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(48, 21)" end="(48, 27)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(48, 21)" end="(48, 25)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(48, 26)" end="(48, 27)">
                                  <IdentNode start="(48, 26)" end="(48, 27)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(48, 28)" end="(48, 29)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(48, 30)" end="(48, 45)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(48, 30)" end="(48, 36)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(48, 30)" end="(48, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(48, 35)" end="(48, 36)">
                                    <IdentNode start="(48, 35)" end="(48, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(48, 37)" end="(48, 38)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(48, 39)" end="(48, 45)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(48, 39)" end="(48, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(48, 44)" end="(48, 45)">
                                    <IdentNode start="(48, 44)" end="(48, 45)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(49, 3)" end="(55, 33)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(49, 3)" end="(55, 33)">
                          <OtherNode start="(49, 3)" end="(49, 37)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(49, 3)" end="(49, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(49, 5)" end="(49, 16)">
                              <NullNode start="(49, 5)" end="(49, 16)">
                                <OtherNode start="(49, 5)" end="(49, 7)" kind="«term[_]»">
                                  <AtomNode start="(49, 5)" end="(49, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(49, 6)" end="(49, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(49, 7)" end="(49, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(49, 9)" end="(49, 11)" leading="" trailing="" raw_val="l₂" val="l₂"/>
                                <AtomNode start="(49, 11)" end="(49, 12)" leading="" trailing=" " val=","/>
                                <IdentNode start="(49, 13)" end="(49, 16)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(49, 17)" end="(49, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(49, 20)" end="(49, 37)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(49, 20)" end="(49, 30)" leading="" trailing=" " raw_val="reverseAux" val="reverseAux" full_name="List.reverseAux" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              <NullNode start="(49, 31)" end="(49, 37)">
                                <IdentNode start="(49, 31)" end="(49, 34)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                <IdentNode start="(49, 35)" end="(49, 37)" leading="" trailing="&#10;  " raw_val="l₂" val="l₂"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(50, 3)" end="(50, 37)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(50, 3)" end="(50, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(50, 5)" end="(50, 16)">
                              <NullNode start="(50, 5)" end="(50, 16)">
                                <IdentNode start="(50, 5)" end="(50, 7)" leading="" trailing="" raw_val="l₁" val="l₁"/>
                                <AtomNode start="(50, 7)" end="(50, 8)" leading="" trailing=" " val=","/>
                                <OtherNode start="(50, 9)" end="(50, 11)" kind="«term[_]»">
                                  <AtomNode start="(50, 9)" end="(50, 10)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(50, 10)" end="(50, 11)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(50, 11)" end="(50, 12)" leading="" trailing=" " val=","/>
                                <IdentNode start="(50, 13)" end="(50, 16)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(50, 17)" end="(50, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(50, 20)" end="(50, 37)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(50, 20)" end="(50, 30)" leading="" trailing=" " raw_val="reverseAux" val="reverseAux" full_name="List.reverseAux" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              <NullNode start="(50, 31)" end="(50, 37)">
                                <IdentNode start="(50, 31)" end="(50, 34)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                <IdentNode start="(50, 35)" end="(50, 37)" leading="" trailing="&#10;  " raw_val="l₁" val="l₁"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(51, 3)" end="(55, 33)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(51, 3)" end="(51, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(51, 5)" end="(51, 26)">
                              <NullNode start="(51, 5)" end="(51, 26)">
                                <OtherNode start="(51, 5)" end="(51, 12)" kind="«term_::_»">
                                  <IdentNode start="(51, 5)" end="(51, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <AtomNode start="(51, 7)" end="(51, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(51, 10)" end="(51, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(51, 12)" end="(51, 13)" leading="" trailing=" " val=","/>
                                <OtherNode start="(51, 14)" end="(51, 21)" kind="«term_::_»">
                                  <IdentNode start="(51, 14)" end="(51, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                                  <AtomNode start="(51, 16)" end="(51, 18)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(51, 19)" end="(51, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                </OtherNode>
                                <AtomNode start="(51, 21)" end="(51, 22)" leading="" trailing=" " val=","/>
                                <IdentNode start="(51, 23)" end="(51, 26)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(51, 27)" end="(51, 29)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <OtherNode start="(52, 5)" end="(55, 33)" kind="termIfThenElse">
                              <AtomNode start="(52, 5)" end="(52, 7)" leading="" trailing=" " val="if"/>
                              <OtherNode start="(52, 8)" end="(52, 14)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(52, 8)" end="(52, 10)" leading="" trailing=" " raw_val="le" val="le"/>
                                <NullNode start="(52, 11)" end="(52, 14)">
                                  <IdentNode start="(52, 11)" end="(52, 12)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(52, 13)" end="(52, 14)" leading="" trailing=" " raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(52, 15)" end="(52, 19)" leading="" trailing="&#10;      " val="then"/>
                              <OtherNode start="(53, 7)" end="(53, 33)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(53, 7)" end="(53, 9)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(53, 10)" end="(53, 33)">
                                  <IdentNode start="(53, 10)" end="(53, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <OtherNode start="(53, 13)" end="(53, 22)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(53, 13)" end="(53, 14)" leading="" trailing="" val="("/>
                                    <OtherNode start="(53, 14)" end="(53, 21)" kind="«term_::_»">
                                      <IdentNode start="(53, 14)" end="(53, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                                      <AtomNode start="(53, 16)" end="(53, 18)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(53, 19)" end="(53, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                    </OtherNode>
                                    <AtomNode start="(53, 21)" end="(53, 22)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <OtherNode start="(53, 23)" end="(53, 33)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(53, 23)" end="(53, 24)" leading="" trailing="" val="("/>
                                    <OtherNode start="(53, 24)" end="(53, 32)" kind="«term_::_»">
                                      <IdentNode start="(53, 24)" end="(53, 25)" leading="" trailing=" " raw_val="x" val="x"/>
                                      <AtomNode start="(53, 26)" end="(53, 28)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(53, 29)" end="(53, 32)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </OtherNode>
                                    <AtomNode start="(53, 32)" end="(53, 33)" leading="" trailing="&#10;    " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(54, 5)" end="(54, 9)" leading="" trailing="&#10;      " val="else"/>
                              <OtherNode start="(55, 7)" end="(55, 33)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(55, 7)" end="(55, 9)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(55, 10)" end="(55, 33)">
                                  <OtherNode start="(55, 10)" end="(55, 19)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(55, 10)" end="(55, 11)" leading="" trailing="" val="("/>
                                    <OtherNode start="(55, 11)" end="(55, 18)" kind="«term_::_»">
                                      <IdentNode start="(55, 11)" end="(55, 12)" leading="" trailing=" " raw_val="x" val="x"/>
                                      <AtomNode start="(55, 13)" end="(55, 15)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(55, 16)" end="(55, 18)" leading="" trailing="" raw_val="xs" val="xs"/>
                                    </OtherNode>
                                    <AtomNode start="(55, 18)" end="(55, 19)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(55, 20)" end="(55, 22)" leading="" trailing=" " raw_val="ys" val="ys"/>
                                  <OtherNode start="(55, 23)" end="(55, 33)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(55, 23)" end="(55, 24)" leading="" trailing="" val="("/>
                                    <OtherNode start="(55, 24)" end="(55, 32)" kind="«term_::_»">
                                      <IdentNode start="(55, 24)" end="(55, 25)" leading="" trailing=" " raw_val="y" val="y"/>
                                      <AtomNode start="(55, 26)" end="(55, 28)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(55, 29)" end="(55, 32)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </OtherNode>
                                    <AtomNode start="(55, 32)" end="(55, 33)" leading="" trailing="&#10;&#10;" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(57, 1)" end="(65, 32)" name="mergeTR_go_eq" full_name="List.MergeSort.Internal.mergeTR_go_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(57, 1)" end="(65, 32)" name="mergeTR_go_eq" full_name="List.MergeSort.Internal.mergeTR_go_eq" _is_private_decl="False">
        <AtomNode start="(57, 1)" end="(57, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(57, 9)" end="(57, 22)">
          <IdentNode start="(57, 9)" end="(57, 22)" leading="" trailing=" " raw_val="mergeTR_go_eq" val="mergeTR_go_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(57, 23)" end="(57, 80)">
          <NullNode/>
          <TermTypespecNode start="(57, 23)" end="(57, 80)">
            <AtomNode start="(57, 23)" end="(57, 24)" leading="" trailing=" " val=":"/>
            <OtherNode start="(57, 25)" end="(57, 80)" kind="«term_=_»">
              <OtherNode start="(57, 25)" end="(57, 48)" kind="Lean.Parser.Term.app">
                <IdentNode start="(57, 25)" end="(57, 35)" leading="" trailing=" " raw_val="mergeTR.go" val="mergeTR.go" full_name="List.MergeSort.Internal.mergeTR.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(48, 7)" def_end="(48, 9)"/>
                <NullNode start="(57, 36)" end="(57, 48)">
                  <IdentNode start="(57, 36)" end="(57, 38)" leading="" trailing=" " raw_val="le" val="le"/>
                  <IdentNode start="(57, 39)" end="(57, 41)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                  <IdentNode start="(57, 42)" end="(57, 44)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                  <IdentNode start="(57, 45)" end="(57, 48)" leading="" trailing=" " raw_val="acc" val="acc"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(57, 49)" end="(57, 50)" leading="" trailing=" " val="="/>
              <OtherNode start="(57, 51)" end="(57, 80)" kind="«term_++_»">
                <IdentNode start="(57, 51)" end="(57, 62)" leading="" trailing=" " raw_val="acc.reverse" val="acc.reverse"/>
                <AtomNode start="(57, 63)" end="(57, 65)" leading="" trailing=" " val="++"/>
                <OtherNode start="(57, 66)" end="(57, 80)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(57, 66)" end="(57, 71)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                  <NullNode start="(57, 72)" end="(57, 80)">
                    <IdentNode start="(57, 72)" end="(57, 74)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                    <IdentNode start="(57, 75)" end="(57, 77)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                    <IdentNode start="(57, 78)" end="(57, 80)" leading="" trailing=" " raw_val="le" val="le"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(57, 81)" end="(65, 32)">
          <AtomNode start="(57, 81)" end="(57, 83)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(57, 84)" end="(65, 32)">
            <AtomNode start="(57, 84)" end="(57, 86)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(58, 3)" end="(65, 32)">
              <TacticTacticseq1IndentedNode start="(58, 3)" end="(65, 32)">
                <NullNode start="(58, 3)" end="(65, 32)">
                  <OtherNode start="(58, 3)" end="(65, 32)" kind="Lean.Parser.Tactic.induction" state_before="α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;l₁ l₂ acc : List α✝&#10;⊢ mergeTR.go le l₁ l₂ acc = acc.reverse ++ l₁.merge l₂ le" state_after="no goals" tactic="induction l₁ generalizing l₂ acc with&#10;| nil =&amp;gt; simp [mergeTR.go, merge, reverseAux_eq]&#10;| cons x l₁ ih₁ =&amp;gt;&#10;  induction l₂ generalizing acc with&#10;  | nil =&amp;gt; simp [mergeTR.go, merge, reverseAux_eq]&#10;  | cons y l₂ ih₂ =&amp;gt;&#10;    simp [mergeTR.go, merge]&#10;    split &amp;lt;;&amp;gt; simp [ih₁, ih₂]">
                    <AtomNode start="(58, 3)" end="(58, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(58, 13)" end="(58, 15)">
                      <OtherNode start="(58, 13)" end="(58, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(58, 13)" end="(58, 15)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(58, 16)" end="(58, 35)">
                      <AtomNode start="(58, 16)" end="(58, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(58, 29)" end="(58, 35)">
                        <IdentNode start="(58, 29)" end="(58, 31)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                        <IdentNode start="(58, 32)" end="(58, 35)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(58, 36)" end="(65, 32)">
                      <OtherNode start="(58, 36)" end="(65, 32)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(58, 36)" end="(58, 40)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(59, 3)" end="(65, 32)">
                          <OtherNode start="(59, 3)" end="(59, 51)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(59, 3)" end="(59, 8)">
                              <OtherNode start="(59, 3)" end="(59, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(59, 3)" end="(59, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(59, 5)" end="(59, 8)">
                                  <NullNode/>
                                  <IdentNode start="(59, 5)" end="(59, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(59, 9)" end="(59, 51)">
                              <AtomNode start="(59, 9)" end="(59, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(59, 12)" end="(59, 51)">
                                <TacticTacticseq1IndentedNode start="(59, 12)" end="(59, 51)">
                                  <NullNode start="(59, 12)" end="(59, 51)">
                                    <OtherNode start="(59, 12)" end="(59, 51)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;l₂ acc : List α✝&#10;⊢ mergeTR.go le [] l₂ acc = acc.reverse ++ [].merge l₂ le" state_after="no goals" tactic="simp [mergeTR.go, merge, reverseAux_eq]">
                                      <AtomNode start="(59, 12)" end="(59, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(59, 17)" end="(59, 51)">
                                        <AtomNode start="(59, 17)" end="(59, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(59, 18)" end="(59, 50)">
                                          <OtherNode start="(59, 18)" end="(59, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(59, 18)" end="(59, 28)" leading="" trailing="" raw_val="mergeTR.go" val="mergeTR.go" full_name="List.MergeSort.Internal.mergeTR.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(48, 7)" def_end="(48, 9)"/>
                                          </OtherNode>
                                          <AtomNode start="(59, 28)" end="(59, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(59, 30)" end="(59, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(59, 30)" end="(59, 35)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(59, 35)" end="(59, 36)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(59, 37)" end="(59, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(59, 37)" end="(59, 50)" leading="" trailing="" raw_val="reverseAux_eq" val="reverseAux_eq" full_name="List.reverseAux_eq" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(59, 50)" end="(59, 51)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(60, 3)" end="(65, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(60, 3)" end="(60, 18)">
                              <OtherNode start="(60, 3)" end="(60, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(60, 3)" end="(60, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(60, 5)" end="(60, 9)">
                                  <NullNode/>
                                  <IdentNode start="(60, 5)" end="(60, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(60, 10)" end="(60, 18)">
                                  <IdentNode start="(60, 10)" end="(60, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(60, 12)" end="(60, 14)" leading="" trailing=" " raw_val="l₁" val="l₁"/>
                                  <IdentNode start="(60, 15)" end="(60, 18)" leading="" trailing=" " raw_val="ih₁" val="ih₁"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(60, 19)" end="(65, 32)">
                              <AtomNode start="(60, 19)" end="(60, 21)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(61, 5)" end="(65, 32)">
                                <TacticTacticseq1IndentedNode start="(61, 5)" end="(65, 32)">
                                  <NullNode start="(61, 5)" end="(65, 32)">
                                    <OtherNode start="(61, 5)" end="(65, 32)" kind="Lean.Parser.Tactic.induction" state_before="case cons&#10;α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;x : α✝&#10;l₁ : List α✝&#10;ih₁ : ∀ {l₂ acc : List α✝}, mergeTR.go le l₁ l₂ acc = acc.reverse ++ l₁.merge l₂ le&#10;l₂ acc : List α✝&#10;⊢ mergeTR.go le (x :: l₁) l₂ acc = acc.reverse ++ (x :: l₁).merge l₂ le" state_after="no goals" tactic="induction l₂ generalizing acc with&#10;| nil =&amp;gt; simp [mergeTR.go, merge, reverseAux_eq]&#10;| cons y l₂ ih₂ =&amp;gt;&#10;  simp [mergeTR.go, merge]&#10;  split &amp;lt;;&amp;gt; simp [ih₁, ih₂]">
                                      <AtomNode start="(61, 5)" end="(61, 14)" leading="" trailing=" " val="induction"/>
                                      <NullNode start="(61, 15)" end="(61, 17)">
                                        <OtherNode start="(61, 15)" end="(61, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(61, 15)" end="(61, 17)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(61, 18)" end="(61, 34)">
                                        <AtomNode start="(61, 18)" end="(61, 30)" leading="" trailing=" " val="generalizing"/>
                                        <NullNode start="(61, 31)" end="(61, 34)">
                                          <IdentNode start="(61, 31)" end="(61, 34)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                        </NullNode>
                                      </NullNode>
                                      <NullNode start="(61, 35)" end="(65, 32)">
                                        <OtherNode start="(61, 35)" end="(65, 32)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(61, 35)" end="(61, 39)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(62, 5)" end="(65, 32)">
                                            <OtherNode start="(62, 5)" end="(62, 53)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(62, 5)" end="(62, 10)">
                                                <OtherNode start="(62, 5)" end="(62, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(62, 5)" end="(62, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(62, 7)" end="(62, 10)">
                                                    <NullNode/>
                                                    <IdentNode start="(62, 7)" end="(62, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(62, 11)" end="(62, 53)">
                                                <AtomNode start="(62, 11)" end="(62, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(62, 14)" end="(62, 53)">
                                                  <TacticTacticseq1IndentedNode start="(62, 14)" end="(62, 53)">
                                                    <NullNode start="(62, 14)" end="(62, 53)">
                                                      <OtherNode start="(62, 14)" end="(62, 53)" kind="Lean.Parser.Tactic.simp" state_before="case cons.nil&#10;α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;x : α✝&#10;l₁ : List α✝&#10;ih₁ : ∀ {l₂ acc : List α✝}, mergeTR.go le l₁ l₂ acc = acc.reverse ++ l₁.merge l₂ le&#10;acc : List α✝&#10;⊢ mergeTR.go le (x :: l₁) [] acc = acc.reverse ++ (x :: l₁).merge [] le" state_after="no goals" tactic="simp [mergeTR.go, merge, reverseAux_eq]">
                                                        <AtomNode start="(62, 14)" end="(62, 18)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(62, 19)" end="(62, 53)">
                                                          <AtomNode start="(62, 19)" end="(62, 20)" leading="" trailing="" val="["/>
                                                          <NullNode start="(62, 20)" end="(62, 52)">
                                                            <OtherNode start="(62, 20)" end="(62, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(62, 20)" end="(62, 30)" leading="" trailing="" raw_val="mergeTR.go" val="mergeTR.go" full_name="List.MergeSort.Internal.mergeTR.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(48, 7)" def_end="(48, 9)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(62, 30)" end="(62, 31)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(62, 32)" end="(62, 37)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(62, 32)" end="(62, 37)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(62, 37)" end="(62, 38)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(62, 39)" end="(62, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(62, 39)" end="(62, 52)" leading="" trailing="" raw_val="reverseAux_eq" val="reverseAux_eq" full_name="List.reverseAux_eq" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(62, 52)" end="(62, 53)" leading="" trailing="&#10;    " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(63, 5)" end="(65, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(63, 5)" end="(63, 20)">
                                                <OtherNode start="(63, 5)" end="(63, 20)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(63, 5)" end="(63, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(63, 7)" end="(63, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(63, 7)" end="(63, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </GroupNode>
                                                  <NullNode start="(63, 12)" end="(63, 20)">
                                                    <IdentNode start="(63, 12)" end="(63, 13)" leading="" trailing=" " raw_val="y" val="y"/>
                                                    <IdentNode start="(63, 14)" end="(63, 16)" leading="" trailing=" " raw_val="l₂" val="l₂"/>
                                                    <IdentNode start="(63, 17)" end="(63, 20)" leading="" trailing=" " raw_val="ih₂" val="ih₂"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(63, 21)" end="(65, 32)">
                                                <AtomNode start="(63, 21)" end="(63, 23)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(64, 7)" end="(65, 32)">
                                                  <TacticTacticseq1IndentedNode start="(64, 7)" end="(65, 32)">
                                                    <NullNode start="(64, 7)" end="(65, 32)">
                                                      <OtherNode start="(64, 7)" end="(64, 31)" kind="Lean.Parser.Tactic.simp" state_before="case cons.cons&#10;α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;x : α✝&#10;l₁ : List α✝&#10;ih₁ : ∀ {l₂ acc : List α✝}, mergeTR.go le l₁ l₂ acc = acc.reverse ++ l₁.merge l₂ le&#10;y : α✝&#10;l₂ : List α✝&#10;ih₂ : ∀ {acc : List α✝}, mergeTR.go le (x :: l₁) l₂ acc = acc.reverse ++ (x :: l₁).merge l₂ le&#10;acc : List α✝&#10;⊢ mergeTR.go le (x :: l₁) (y :: l₂) acc = acc.reverse ++ (x :: l₁).merge (y :: l₂) le" state_after="case cons.cons&#10;α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;x : α✝&#10;l₁ : List α✝&#10;ih₁ : ∀ {l₂ acc : List α✝}, mergeTR.go le l₁ l₂ acc = acc.reverse ++ l₁.merge l₂ le&#10;y : α✝&#10;l₂ : List α✝&#10;ih₂ : ∀ {acc : List α✝}, mergeTR.go le (x :: l₁) l₂ acc = acc.reverse ++ (x :: l₁).merge l₂ le&#10;acc : List α✝&#10;⊢ (if le x y = true then mergeTR.go le l₁ (y :: l₂) (x :: acc) else mergeTR.go le (x :: l₁) l₂ (y :: acc)) =&#10;    acc.reverse ++ if le x y = true then x :: l₁.merge (y :: l₂) le else y :: (x :: l₁).merge l₂ le" tactic="simp [mergeTR.go, merge]">
                                                        <AtomNode start="(64, 7)" end="(64, 11)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(64, 12)" end="(64, 31)">
                                                          <AtomNode start="(64, 12)" end="(64, 13)" leading="" trailing="" val="["/>
                                                          <NullNode start="(64, 13)" end="(64, 30)">
                                                            <OtherNode start="(64, 13)" end="(64, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(64, 13)" end="(64, 23)" leading="" trailing="" raw_val="mergeTR.go" val="mergeTR.go" full_name="List.MergeSort.Internal.mergeTR.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(48, 7)" def_end="(48, 9)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(64, 23)" end="(64, 24)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(64, 25)" end="(64, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(64, 25)" end="(64, 30)" leading="" trailing="" raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(64, 30)" end="(64, 31)" leading="" trailing="&#10;      " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <OtherNode start="(65, 7)" end="(65, 32)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons.cons&#10;α✝ : Type u_1&#10;le : α✝ → α✝ → Bool&#10;x : α✝&#10;l₁ : List α✝&#10;ih₁ : ∀ {l₂ acc : List α✝}, mergeTR.go le l₁ l₂ acc = acc.reverse ++ l₁.merge l₂ le&#10;y : α✝&#10;l₂ : List α✝&#10;ih₂ : ∀ {acc : List α✝}, mergeTR.go le (x :: l₁) l₂ acc = acc.reverse ++ (x :: l₁).merge l₂ le&#10;acc : List α✝&#10;⊢ (if le x y = true then mergeTR.go le l₁ (y :: l₂) (x :: acc) else mergeTR.go le (x :: l₁) l₂ (y :: acc)) =&#10;    acc.reverse ++ if le x y = true then x :: l₁.merge (y :: l₂) le else y :: (x :: l₁).merge l₂ le" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [ih₁, ih₂]">
                                                        <OtherNode start="(65, 7)" end="(65, 12)" kind="Lean.Parser.Tactic.split">
                                                          <AtomNode start="(65, 7)" end="(65, 12)" leading="" trailing=" " val="split"/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(65, 13)" end="(65, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(65, 17)" end="(65, 32)" kind="Lean.Parser.Tactic.simp">
                                                          <AtomNode start="(65, 17)" end="(65, 21)" leading="" trailing=" " val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode start="(65, 22)" end="(65, 32)">
                                                            <AtomNode start="(65, 22)" end="(65, 23)" leading="" trailing="" val="["/>
                                                            <NullNode start="(65, 23)" end="(65, 31)">
                                                            <OtherNode start="(65, 23)" end="(65, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(65, 23)" end="(65, 26)" leading="" trailing="" raw_val="ih₁" val="ih₁"/>
                                                            </OtherNode>
                                                            <AtomNode start="(65, 26)" end="(65, 27)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(65, 28)" end="(65, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(65, 28)" end="(65, 31)" leading="" trailing="" raw_val="ih₂" val="ih₂"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(65, 31)" end="(65, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                                                          </NullNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(67, 1)" end="(69, 32)" name="merge_eq_mergeTR" full_name="List.MergeSort.Internal.merge_eq_mergeTR">
      <CommandDeclmodifiersNode start="(67, 1)" end="(67, 9)">
        <NullNode/>
        <NullNode start="(67, 1)" end="(67, 9)">
          <OtherNode start="(67, 1)" end="(67, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(67, 1)" end="(67, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(67, 3)" end="(67, 8)">
              <OtherNode start="(67, 3)" end="(67, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(67, 3)" end="(67, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(67, 3)" end="(67, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(67, 8)" end="(67, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(67, 10)" end="(69, 32)" name="merge_eq_mergeTR" full_name="List.MergeSort.Internal.merge_eq_mergeTR" _is_private_decl="False">
        <AtomNode start="(67, 10)" end="(67, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(67, 18)" end="(67, 34)">
          <IdentNode start="(67, 18)" end="(67, 34)" leading="" trailing=" " raw_val="merge_eq_mergeTR" val="merge_eq_mergeTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(67, 35)" end="(67, 54)">
          <NullNode/>
          <TermTypespecNode start="(67, 35)" end="(67, 54)">
            <AtomNode start="(67, 35)" end="(67, 36)" leading="" trailing=" " val=":"/>
            <OtherNode start="(67, 37)" end="(67, 54)" kind="«term_=_»">
              <OtherNode start="(67, 37)" end="(67, 43)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(67, 37)" end="(67, 38)" leading="" trailing="" val="@"/>
                <IdentNode start="(67, 38)" end="(67, 43)" leading="" trailing=" " raw_val="merge" val="merge" full_name="List.merge" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(67, 44)" end="(67, 45)" leading="" trailing=" " val="="/>
              <OtherNode start="(67, 46)" end="(67, 54)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(67, 46)" end="(67, 47)" leading="" trailing="" val="@"/>
                <IdentNode start="(67, 47)" end="(67, 54)" leading="" trailing=" " raw_val="mergeTR" val="mergeTR" full_name="List.MergeSort.Internal.mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(46, 5)" def_end="(46, 12)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(67, 55)" end="(69, 32)">
          <AtomNode start="(67, 55)" end="(67, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(67, 58)" end="(69, 32)">
            <AtomNode start="(67, 58)" end="(67, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(68, 3)" end="(69, 32)">
              <TacticTacticseq1IndentedNode start="(68, 3)" end="(69, 32)">
                <NullNode start="(68, 3)" end="(69, 32)">
                  <OtherNode start="(68, 3)" end="(68, 9)" kind="tacticFunext___" state_before="⊢ @merge = @mergeTR" state_after="case h.h.h.h&#10;x✝³ : Type u_1&#10;x✝² x✝¹ : List x✝³&#10;x✝ : autoParam (x✝³ → x✝³ → Bool) _auto✝&#10;⊢ x✝².merge x✝¹ x✝ = mergeTR x✝² x✝¹ x✝" tactic="funext">
                    <AtomNode start="(68, 3)" end="(68, 9)" leading="" trailing="&#10;  " val="funext"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(69, 3)" end="(69, 32)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h&#10;x✝³ : Type u_1&#10;x✝² x✝¹ : List x✝³&#10;x✝ : autoParam (x✝³ → x✝³ → Bool) _auto✝&#10;⊢ x✝².merge x✝¹ x✝ = mergeTR x✝² x✝¹ x✝" state_after="no goals" tactic="simp [mergeTR, mergeTR_go_eq]">
                    <AtomNode start="(69, 3)" end="(69, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(69, 8)" end="(69, 32)">
                      <AtomNode start="(69, 8)" end="(69, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(69, 9)" end="(69, 31)">
                        <OtherNode start="(69, 9)" end="(69, 16)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(69, 9)" end="(69, 16)" leading="" trailing="" raw_val="mergeTR" val="mergeTR" full_name="List.MergeSort.Internal.mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(46, 5)" def_end="(46, 12)"/>
                        </OtherNode>
                        <AtomNode start="(69, 16)" end="(69, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(69, 18)" end="(69, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(69, 18)" end="(69, 31)" leading="" trailing="" raw_val="mergeTR_go_eq" val="mergeTR_go_eq" full_name="List.MergeSort.Internal.mergeTR_go_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(57, 9)" def_end="(57, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(69, 31)" end="(69, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(71, 1)" end="(82, 28)" name="splitRevAt" full_name="List.MergeSort.Internal.splitRevAt">
      <CommandDeclmodifiersNode start="(71, 1)" end="(77, 3)">
        <NullNode start="(71, 1)" end="(77, 3)">
          <CommandDoccommentNode start="(71, 1)" end="(77, 3)" comment="Variant of `splitAt`, that does not reverse the first list, i.e&#10;`splitRevAt n l = ((l.take n).reverse, l.drop n)`.&#10;&#10;This exists solely as an optimization for `mergeSortTR` and `mergeSortTR₂`,&#10;and should not be used elsewhere.&#10;-/">
            <AtomNode start="(71, 1)" end="(71, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(72, 1)" end="(77, 3)" leading="" trailing="&#10;" val="Variant of `splitAt`, that does not reverse the first list, i.e&#10;`splitRevAt n l = ((l.take n).reverse, l.drop n)`.&#10;&#10;This exists solely as an optimization for `mergeSortTR` and `mergeSortTR₂`,&#10;and should not be used elsewhere.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(78, 1)" end="(82, 28)" name="splitRevAt">
        <AtomNode start="(78, 1)" end="(78, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(78, 5)" end="(78, 15)">
          <IdentNode start="(78, 5)" end="(78, 15)" leading="" trailing=" " raw_val="splitRevAt" val="splitRevAt"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(78, 16)" end="(78, 56)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(78, 16)" end="(78, 38)">
            <TermExplicitbinderNode start="(78, 16)" end="(78, 25)">
              <AtomNode start="(78, 16)" end="(78, 17)" leading="" trailing="" val="("/>
              <NullNode start="(78, 17)" end="(78, 18)">
                <IdentNode start="(78, 17)" end="(78, 18)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(78, 19)" end="(78, 24)">
                <AtomNode start="(78, 19)" end="(78, 20)" leading="" trailing=" " val=":"/>
                <IdentNode start="(78, 21)" end="(78, 24)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 24)" end="(78, 25)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(78, 26)" end="(78, 38)">
              <AtomNode start="(78, 26)" end="(78, 27)" leading="" trailing="" val="("/>
              <NullNode start="(78, 27)" end="(78, 28)">
                <IdentNode start="(78, 27)" end="(78, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(78, 29)" end="(78, 37)">
                <AtomNode start="(78, 29)" end="(78, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(78, 31)" end="(78, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 31)" end="(78, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 36)" end="(78, 37)">
                    <IdentNode start="(78, 36)" end="(78, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(78, 37)" end="(78, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(78, 39)" end="(78, 56)">
            <TermTypespecNode start="(78, 39)" end="(78, 56)">
              <AtomNode start="(78, 39)" end="(78, 40)" leading="" trailing=" " val=":"/>
              <OtherNode start="(78, 41)" end="(78, 56)" kind="«term_×_»">
                <OtherNode start="(78, 41)" end="(78, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 41)" end="(78, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 46)" end="(78, 47)">
                    <IdentNode start="(78, 46)" end="(78, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(78, 48)" end="(78, 49)" leading="" trailing=" " val="×"/>
                <OtherNode start="(78, 50)" end="(78, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(78, 50)" end="(78, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(78, 55)" end="(78, 56)">
                    <IdentNode start="(78, 55)" end="(78, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(78, 57)" end="(82, 28)">
          <AtomNode start="(78, 57)" end="(78, 59)" leading="" trailing=" " val=":="/>
          <OtherNode start="(78, 60)" end="(78, 69)" kind="Lean.Parser.Term.app">
            <IdentNode start="(78, 60)" end="(78, 62)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(78, 63)" end="(78, 69)">
              <IdentNode start="(78, 63)" end="(78, 64)" leading="" trailing=" " raw_val="l" val="l"/>
              <IdentNode start="(78, 65)" end="(78, 66)" leading="" trailing=" " raw_val="n" val="n"/>
              <OtherNode start="(78, 67)" end="(78, 69)" kind="«term[_]»">
                <AtomNode start="(78, 67)" end="(78, 68)" leading="" trailing="" val="["/>
                <NullNode/>
                <AtomNode start="(78, 68)" end="(78, 69)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(78, 70)" end="(82, 28)">
            <OtherNode start="(78, 70)" end="(82, 28)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(78, 70)" end="(78, 75)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(79, 3)" end="(82, 28)">
                <OtherNode start="(79, 3)" end="(82, 28)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(79, 3)" end="(79, 105)">
                    <CommandDoccommentNode start="(79, 3)" end="(79, 105)" comment="Auxiliary for `splitAtRev`: `splitAtRev.go xs n acc = ((take n xs).reverse ++ acc, drop n xs)`. -/">
                      <AtomNode start="(79, 3)" end="(79, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(79, 7)" end="(79, 105)" leading="" trailing="&#10;  " val="Auxiliary for `splitAtRev`: `splitAtRev.go xs n acc = ((take n xs).reverse ++ acc, drop n xs)`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(80, 3)" end="(82, 28)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(80, 3)" end="(82, 28)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(80, 3)" end="(80, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(80, 6)" end="(80, 47)">
                        <TermTypespecNode start="(80, 6)" end="(80, 47)">
                          <AtomNode start="(80, 6)" end="(80, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(80, 8)" end="(80, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(80, 8)" end="(80, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(80, 8)" end="(80, 12)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(80, 13)" end="(80, 14)">
                                <IdentNode start="(80, 13)" end="(80, 14)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(80, 15)" end="(80, 16)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(80, 17)" end="(80, 47)" kind="Lean.Parser.Term.arrow">
                              <IdentNode start="(80, 17)" end="(80, 20)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(80, 21)" end="(80, 22)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(80, 23)" end="(80, 47)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(80, 23)" end="(80, 29)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(80, 23)" end="(80, 27)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(80, 28)" end="(80, 29)">
                                    <IdentNode start="(80, 28)" end="(80, 29)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(80, 30)" end="(80, 31)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(80, 32)" end="(80, 47)" kind="«term_×_»">
                                  <OtherNode start="(80, 32)" end="(80, 38)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(80, 32)" end="(80, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(80, 37)" end="(80, 38)">
                                      <IdentNode start="(80, 37)" end="(80, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(80, 39)" end="(80, 40)" leading="" trailing=" " val="×"/>
                                  <OtherNode start="(80, 41)" end="(80, 47)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(80, 41)" end="(80, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(80, 46)" end="(80, 47)">
                                      <IdentNode start="(80, 46)" end="(80, 47)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(81, 3)" end="(82, 28)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(81, 3)" end="(82, 28)">
                          <OtherNode start="(81, 3)" end="(81, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(81, 3)" end="(81, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(81, 5)" end="(81, 22)">
                              <NullNode start="(81, 5)" end="(81, 22)">
                                <OtherNode start="(81, 5)" end="(81, 12)" kind="«term_::_»">
                                  <IdentNode start="(81, 5)" end="(81, 6)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <AtomNode start="(81, 7)" end="(81, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(81, 10)" end="(81, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(81, 12)" end="(81, 13)" leading="" trailing=" " val=","/>
                                <OtherNode start="(81, 14)" end="(81, 17)" kind="«term_+_»">
                                  <IdentNode start="(81, 14)" end="(81, 15)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(81, 15)" end="(81, 16)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(81, 16)" end="(81, 17)" kind="num">
                                    <AtomNode start="(81, 16)" end="(81, 17)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(81, 17)" end="(81, 18)" leading="" trailing=" " val=","/>
                                <IdentNode start="(81, 19)" end="(81, 22)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(81, 23)" end="(81, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(81, 26)" end="(81, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(81, 26)" end="(81, 28)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(81, 29)" end="(81, 44)">
                                <IdentNode start="(81, 29)" end="(81, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(81, 32)" end="(81, 33)" leading="" trailing=" " raw_val="n" val="n"/>
                                <OtherNode start="(81, 34)" end="(81, 44)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(81, 34)" end="(81, 35)" leading="" trailing="" val="("/>
                                  <OtherNode start="(81, 35)" end="(81, 43)" kind="«term_::_»">
                                    <IdentNode start="(81, 35)" end="(81, 36)" leading="" trailing=" " raw_val="x" val="x"/>
                                    <AtomNode start="(81, 37)" end="(81, 39)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(81, 40)" end="(81, 43)" leading="" trailing="" raw_val="acc" val="acc"/>
                                  </OtherNode>
                                  <AtomNode start="(81, 43)" end="(81, 44)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(82, 3)" end="(82, 28)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(82, 3)" end="(82, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(82, 5)" end="(82, 15)">
                              <NullNode start="(82, 5)" end="(82, 15)">
                                <IdentNode start="(82, 5)" end="(82, 7)" leading="" trailing="" raw_val="xs" val="xs"/>
                                <AtomNode start="(82, 7)" end="(82, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(82, 9)" end="(82, 10)">
                                  <AtomNode start="(82, 9)" end="(82, 10)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(82, 10)" end="(82, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(82, 12)" end="(82, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(82, 16)" end="(82, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(82, 19)" end="(82, 28)" kind="Lean.Parser.Term.tuple">
                              <AtomNode start="(82, 19)" end="(82, 20)" leading="" trailing="" val="("/>
                              <NullNode start="(82, 20)" end="(82, 27)">
                                <IdentNode start="(82, 20)" end="(82, 23)" leading="" trailing="" raw_val="acc" val="acc"/>
                                <AtomNode start="(82, 23)" end="(82, 24)" leading="" trailing=" " val=","/>
                                <NullNode start="(82, 25)" end="(82, 27)">
                                  <IdentNode start="(82, 25)" end="(82, 27)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(82, 27)" end="(82, 28)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(84, 1)" end="(93, 40)" name="splitRevAt_go" full_name="List.MergeSort.Internal.splitRevAt_go">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(84, 1)" end="(93, 40)" name="splitRevAt_go" full_name="List.MergeSort.Internal.splitRevAt_go" _is_private_decl="False">
        <AtomNode start="(84, 1)" end="(84, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(84, 9)" end="(84, 22)">
          <IdentNode start="(84, 9)" end="(84, 22)" leading="" trailing=" " raw_val="splitRevAt_go" val="splitRevAt_go"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(84, 23)" end="(85, 69)">
          <NullNode start="(84, 23)" end="(84, 61)">
            <TermExplicitbinderNode start="(84, 23)" end="(84, 36)">
              <AtomNode start="(84, 23)" end="(84, 24)" leading="" trailing="" val="("/>
              <NullNode start="(84, 24)" end="(84, 26)">
                <IdentNode start="(84, 24)" end="(84, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(84, 27)" end="(84, 35)">
                <AtomNode start="(84, 27)" end="(84, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 29)" end="(84, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(84, 29)" end="(84, 33)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(84, 34)" end="(84, 35)">
                    <IdentNode start="(84, 34)" end="(84, 35)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(84, 35)" end="(84, 36)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(84, 37)" end="(84, 46)">
              <AtomNode start="(84, 37)" end="(84, 38)" leading="" trailing="" val="("/>
              <NullNode start="(84, 38)" end="(84, 39)">
                <IdentNode start="(84, 38)" end="(84, 39)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(84, 40)" end="(84, 45)">
                <AtomNode start="(84, 40)" end="(84, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(84, 42)" end="(84, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(84, 45)" end="(84, 46)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(84, 47)" end="(84, 61)">
              <AtomNode start="(84, 47)" end="(84, 48)" leading="" trailing="" val="("/>
              <NullNode start="(84, 48)" end="(84, 51)">
                <IdentNode start="(84, 48)" end="(84, 51)" leading="" trailing=" " raw_val="acc" val="acc"/>
              </NullNode>
              <NullNode start="(84, 52)" end="(84, 60)">
                <AtomNode start="(84, 52)" end="(84, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 54)" end="(84, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(84, 54)" end="(84, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(84, 59)" end="(84, 60)">
                    <IdentNode start="(84, 59)" end="(84, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(84, 60)" end="(84, 61)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(84, 62)" end="(85, 69)">
            <AtomNode start="(84, 62)" end="(84, 63)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(85, 5)" end="(85, 69)" kind="«term_=_»">
              <OtherNode start="(85, 5)" end="(85, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(85, 5)" end="(85, 18)" leading="" trailing=" " raw_val="splitRevAt.go" val="splitRevAt.go" full_name="List.MergeSort.Internal.splitRevAt.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(80, 3)" def_end="(80, 5)"/>
                <NullNode start="(85, 19)" end="(85, 27)">
                  <IdentNode start="(85, 19)" end="(85, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(85, 22)" end="(85, 23)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(85, 24)" end="(85, 27)" leading="" trailing=" " raw_val="acc" val="acc"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(85, 28)" end="(85, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(85, 30)" end="(85, 69)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(85, 30)" end="(85, 31)" leading="" trailing="" val="("/>
                <NullNode start="(85, 31)" end="(85, 68)">
                  <OtherNode start="(85, 31)" end="(85, 57)" kind="«term_++_»">
                    <OtherNode start="(85, 31)" end="(85, 50)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(85, 31)" end="(85, 42)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(85, 31)" end="(85, 32)" leading="" trailing="" val="("/>
                        <OtherNode start="(85, 32)" end="(85, 41)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(85, 32)" end="(85, 36)" leading="" trailing=" " raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          <NullNode start="(85, 37)" end="(85, 41)">
                            <IdentNode start="(85, 37)" end="(85, 38)" leading="" trailing=" " raw_val="i" val="i"/>
                            <IdentNode start="(85, 39)" end="(85, 41)" leading="" trailing="" raw_val="xs" val="xs"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(85, 41)" end="(85, 42)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(85, 42)" end="(85, 43)" leading="" trailing="" val="."/>
                      <IdentNode start="(85, 43)" end="(85, 50)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    </OtherNode>
                    <AtomNode start="(85, 51)" end="(85, 53)" leading="" trailing=" " val="++"/>
                    <IdentNode start="(85, 54)" end="(85, 57)" leading="" trailing="" raw_val="acc" val="acc"/>
                  </OtherNode>
                  <AtomNode start="(85, 57)" end="(85, 58)" leading="" trailing=" " val=","/>
                  <NullNode start="(85, 59)" end="(85, 68)">
                    <OtherNode start="(85, 59)" end="(85, 68)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(85, 59)" end="(85, 63)" leading="" trailing=" " raw_val="drop" val="drop" full_name="List.drop" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                      <NullNode start="(85, 64)" end="(85, 68)">
                        <IdentNode start="(85, 64)" end="(85, 65)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(85, 66)" end="(85, 68)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(85, 68)" end="(85, 69)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(85, 70)" end="(93, 40)">
          <AtomNode start="(85, 70)" end="(85, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(85, 73)" end="(93, 40)">
            <AtomNode start="(85, 73)" end="(85, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(86, 3)" end="(93, 40)">
              <TacticTacticseq1IndentedNode start="(86, 3)" end="(93, 40)">
                <NullNode start="(86, 3)" end="(93, 40)">
                  <OtherNode start="(86, 3)" end="(93, 40)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;xs : List α&#10;i : Nat&#10;acc : List α&#10;⊢ splitRevAt.go xs i acc = ((take i xs).reverse ++ acc, drop i xs)" state_after="no goals" tactic="induction xs generalizing i acc with&#10;| nil =&amp;gt; simp [splitRevAt.go]&#10;| cons x xs ih =&amp;gt;&#10;  cases i with&#10;  | zero =&amp;gt; simp [splitRevAt.go]&#10;  | succ i =&amp;gt;&#10;    rw [splitRevAt.go, ih i (x :: acc), take_succ_cons, reverse_cons, drop_succ_cons,&#10;      append_assoc, singleton_append]">
                    <AtomNode start="(86, 3)" end="(86, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(86, 13)" end="(86, 15)">
                      <OtherNode start="(86, 13)" end="(86, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(86, 13)" end="(86, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(86, 16)" end="(86, 34)">
                      <AtomNode start="(86, 16)" end="(86, 28)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(86, 29)" end="(86, 34)">
                        <IdentNode start="(86, 29)" end="(86, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(86, 31)" end="(86, 34)" leading="" trailing=" " raw_val="acc" val="acc"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(86, 35)" end="(93, 40)">
                      <OtherNode start="(86, 35)" end="(93, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(86, 35)" end="(86, 39)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(87, 3)" end="(93, 40)">
                          <OtherNode start="(87, 3)" end="(87, 32)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(87, 3)" end="(87, 8)">
                              <OtherNode start="(87, 3)" end="(87, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(87, 3)" end="(87, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(87, 5)" end="(87, 8)">
                                  <NullNode/>
                                  <IdentNode start="(87, 5)" end="(87, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(87, 9)" end="(87, 32)">
                              <AtomNode start="(87, 9)" end="(87, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(87, 12)" end="(87, 32)">
                                <TacticTacticseq1IndentedNode start="(87, 12)" end="(87, 32)">
                                  <NullNode start="(87, 12)" end="(87, 32)">
                                    <OtherNode start="(87, 12)" end="(87, 32)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;i : Nat&#10;acc : List α&#10;⊢ splitRevAt.go [] i acc = ((take i []).reverse ++ acc, drop i [])" state_after="no goals" tactic="simp [splitRevAt.go]">
                                      <AtomNode start="(87, 12)" end="(87, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(87, 17)" end="(87, 32)">
                                        <AtomNode start="(87, 17)" end="(87, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(87, 18)" end="(87, 31)">
                                          <OtherNode start="(87, 18)" end="(87, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(87, 18)" end="(87, 31)" leading="" trailing="" raw_val="splitRevAt.go" val="splitRevAt.go" full_name="List.MergeSort.Internal.splitRevAt.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(80, 3)" def_end="(80, 5)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(87, 31)" end="(87, 32)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(88, 3)" end="(93, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(88, 3)" end="(88, 17)">
                              <OtherNode start="(88, 3)" end="(88, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(88, 3)" end="(88, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(88, 5)" end="(88, 9)">
                                  <NullNode/>
                                  <IdentNode start="(88, 5)" end="(88, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(88, 10)" end="(88, 17)">
                                  <IdentNode start="(88, 10)" end="(88, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(88, 12)" end="(88, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(88, 15)" end="(88, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(88, 18)" end="(93, 40)">
                              <AtomNode start="(88, 18)" end="(88, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(89, 5)" end="(93, 40)">
                                <TacticTacticseq1IndentedNode start="(89, 5)" end="(93, 40)">
                                  <NullNode start="(89, 5)" end="(93, 40)">
                                    <OtherNode start="(89, 5)" end="(93, 40)" kind="Lean.Parser.Tactic.cases" state_before="case cons&#10;α : Type u_1&#10;x : α&#10;xs : List α&#10;ih : ∀ (i : Nat) (acc : List α), splitRevAt.go xs i acc = ((take i xs).reverse ++ acc, drop i xs)&#10;i : Nat&#10;acc : List α&#10;⊢ splitRevAt.go (x :: xs) i acc = ((take i (x :: xs)).reverse ++ acc, drop i (x :: xs))" state_after="no goals" tactic="cases i with&#10;| zero =&amp;gt; simp [splitRevAt.go]&#10;| succ i =&amp;gt;&#10;  rw [splitRevAt.go, ih i (x :: acc), take_succ_cons, reverse_cons, drop_succ_cons,&#10;    append_assoc, singleton_append]">
                                      <AtomNode start="(89, 5)" end="(89, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(89, 11)" end="(89, 12)">
                                        <OtherNode start="(89, 11)" end="(89, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(89, 11)" end="(89, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(89, 13)" end="(93, 40)">
                                        <OtherNode start="(89, 13)" end="(93, 40)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(89, 13)" end="(89, 17)" leading="" trailing="&#10;    " val="with"/>
                                          <NullNode/>
                                          <NullNode start="(90, 5)" end="(93, 40)">
                                            <OtherNode start="(90, 5)" end="(90, 35)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(90, 5)" end="(90, 11)">
                                                <OtherNode start="(90, 5)" end="(90, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(90, 5)" end="(90, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(90, 7)" end="(90, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(90, 7)" end="(90, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(90, 12)" end="(90, 35)">
                                                <AtomNode start="(90, 12)" end="(90, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(90, 15)" end="(90, 35)">
                                                  <TacticTacticseq1IndentedNode start="(90, 15)" end="(90, 35)">
                                                    <NullNode start="(90, 15)" end="(90, 35)">
                                                      <OtherNode start="(90, 15)" end="(90, 35)" kind="Lean.Parser.Tactic.simp" state_before="case cons.zero&#10;α : Type u_1&#10;x : α&#10;xs : List α&#10;ih : ∀ (i : Nat) (acc : List α), splitRevAt.go xs i acc = ((take i xs).reverse ++ acc, drop i xs)&#10;acc : List α&#10;⊢ splitRevAt.go (x :: xs) 0 acc = ((take 0 (x :: xs)).reverse ++ acc, drop 0 (x :: xs))" state_after="no goals" tactic="simp [splitRevAt.go]">
                                                        <AtomNode start="(90, 15)" end="(90, 19)" leading="" trailing=" " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode start="(90, 20)" end="(90, 35)">
                                                          <AtomNode start="(90, 20)" end="(90, 21)" leading="" trailing="" val="["/>
                                                          <NullNode start="(90, 21)" end="(90, 34)">
                                                            <OtherNode start="(90, 21)" end="(90, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(90, 21)" end="(90, 34)" leading="" trailing="" raw_val="splitRevAt.go" val="splitRevAt.go" full_name="List.MergeSort.Internal.splitRevAt.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(80, 3)" def_end="(80, 5)"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(90, 34)" end="(90, 35)" leading="" trailing="&#10;    " val="]"/>
                                                        </NullNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(91, 5)" end="(93, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(91, 5)" end="(91, 13)">
                                                <OtherNode start="(91, 5)" end="(91, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(91, 5)" end="(91, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(91, 7)" end="(91, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(91, 7)" end="(91, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(91, 12)" end="(91, 13)">
                                                    <IdentNode start="(91, 12)" end="(91, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(91, 14)" end="(93, 40)">
                                                <AtomNode start="(91, 14)" end="(91, 16)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(92, 7)" end="(93, 40)">
                                                  <TacticTacticseq1IndentedNode start="(92, 7)" end="(93, 40)">
                                                    <NullNode start="(92, 7)" end="(93, 40)">
                                                      <OtherNode start="(92, 7)" end="(93, 40)" kind="Lean.Parser.Tactic.rwSeq" state_before="case cons.succ&#10;α : Type u_1&#10;x : α&#10;xs : List α&#10;ih : ∀ (i : Nat) (acc : List α), splitRevAt.go xs i acc = ((take i xs).reverse ++ acc, drop i xs)&#10;acc : List α&#10;i : Nat&#10;⊢ splitRevAt.go (x :: xs) (i + 1) acc = ((take (i + 1) (x :: xs)).reverse ++ acc, drop (i + 1) (x :: xs))" state_after="no goals" tactic="rw [splitRevAt.go, ih i (x :: acc), take_succ_cons, reverse_cons, drop_succ_cons,&#10;  append_assoc, singleton_append]">
                                                        <AtomNode start="(92, 7)" end="(92, 9)" leading="" trailing=" " val="rw"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <OtherNode start="(92, 10)" end="(93, 40)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                          <AtomNode start="(92, 10)" end="(92, 11)" leading="" trailing="" val="["/>
                                                          <NullNode start="(92, 11)" end="(93, 39)">
                                                            <OtherNode start="(92, 11)" end="(92, 24)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(92, 11)" end="(92, 24)" leading="" trailing="" raw_val="splitRevAt.go" val="splitRevAt.go" full_name="List.MergeSort.Internal.splitRevAt.go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(80, 3)" def_end="(80, 5)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 24)" end="(92, 25)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(92, 26)" end="(92, 41)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(92, 26)" end="(92, 41)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(92, 26)" end="(92, 28)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                                            <NullNode start="(92, 29)" end="(92, 41)">
                                                            <IdentNode start="(92, 29)" end="(92, 30)" leading="" trailing=" " raw_val="i" val="i"/>
                                                            <OtherNode start="(92, 31)" end="(92, 41)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(92, 31)" end="(92, 32)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(92, 32)" end="(92, 40)" kind="«term_::_»">
                                                            <IdentNode start="(92, 32)" end="(92, 33)" leading="" trailing=" " raw_val="x" val="x"/>
                                                            <AtomNode start="(92, 34)" end="(92, 36)" leading="" trailing=" " val="::"/>
                                                            <IdentNode start="(92, 37)" end="(92, 40)" leading="" trailing="" raw_val="acc" val="acc"/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 40)" end="(92, 41)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 41)" end="(92, 42)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(92, 43)" end="(92, 57)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(92, 43)" end="(92, 57)" leading="" trailing="" raw_val="take_succ_cons" val="take_succ_cons" full_name="List.take_succ_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 57)" end="(92, 58)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(92, 59)" end="(92, 71)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(92, 59)" end="(92, 71)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 71)" end="(92, 72)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(92, 73)" end="(92, 87)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(92, 73)" end="(92, 87)" leading="" trailing="" raw_val="drop_succ_cons" val="drop_succ_cons" full_name="List.drop_succ_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(92, 87)" end="(92, 88)" leading="" trailing="&#10;        " val=","/>
                                                            <OtherNode start="(93, 9)" end="(93, 21)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(93, 9)" end="(93, 21)" leading="" trailing="" raw_val="append_assoc" val="append_assoc" full_name="List.append_assoc" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(93, 21)" end="(93, 22)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(93, 23)" end="(93, 39)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(93, 23)" end="(93, 39)" leading="" trailing="" raw_val="singleton_append" val="singleton_append" full_name="List.singleton_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                          <AtomNode start="(93, 39)" end="(93, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(95, 1)" end="(96, 45)" name="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(95, 1)" end="(96, 45)" name="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" _is_private_decl="False">
        <AtomNode start="(95, 1)" end="(95, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(95, 9)" end="(95, 22)">
          <IdentNode start="(95, 9)" end="(95, 22)" leading="" trailing=" " raw_val="splitRevAt_eq" val="splitRevAt_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(95, 23)" end="(95, 95)">
          <NullNode start="(95, 23)" end="(95, 45)">
            <TermExplicitbinderNode start="(95, 23)" end="(95, 32)">
              <AtomNode start="(95, 23)" end="(95, 24)" leading="" trailing="" val="("/>
              <NullNode start="(95, 24)" end="(95, 25)">
                <IdentNode start="(95, 24)" end="(95, 25)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(95, 26)" end="(95, 31)">
                <AtomNode start="(95, 26)" end="(95, 27)" leading="" trailing=" " val=":"/>
                <IdentNode start="(95, 28)" end="(95, 31)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(95, 31)" end="(95, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(95, 33)" end="(95, 45)">
              <AtomNode start="(95, 33)" end="(95, 34)" leading="" trailing="" val="("/>
              <NullNode start="(95, 34)" end="(95, 35)">
                <IdentNode start="(95, 34)" end="(95, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(95, 36)" end="(95, 44)">
                <AtomNode start="(95, 36)" end="(95, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(95, 38)" end="(95, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(95, 38)" end="(95, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(95, 43)" end="(95, 44)">
                    <IdentNode start="(95, 43)" end="(95, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(95, 44)" end="(95, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(95, 46)" end="(95, 95)">
            <AtomNode start="(95, 46)" end="(95, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(95, 48)" end="(95, 95)" kind="«term_=_»">
              <OtherNode start="(95, 48)" end="(95, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(95, 48)" end="(95, 58)" leading="" trailing=" " raw_val="splitRevAt" val="splitRevAt" full_name="List.MergeSort.Internal.splitRevAt" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(78, 5)" def_end="(78, 15)"/>
                <NullNode start="(95, 59)" end="(95, 62)">
                  <IdentNode start="(95, 59)" end="(95, 60)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(95, 61)" end="(95, 62)" leading="" trailing=" " raw_val="l" val="l"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(95, 63)" end="(95, 64)" leading="" trailing=" " val="="/>
              <OtherNode start="(95, 65)" end="(95, 95)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(95, 65)" end="(95, 66)" leading="" trailing="" val="("/>
                <NullNode start="(95, 66)" end="(95, 94)">
                  <OtherNode start="(95, 66)" end="(95, 84)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(95, 66)" end="(95, 76)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(95, 66)" end="(95, 67)" leading="" trailing="" val="("/>
                      <OtherNode start="(95, 67)" end="(95, 75)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(95, 67)" end="(95, 73)" leading="" trailing=" " raw_val="l.take" val="l.take"/>
                        <NullNode start="(95, 74)" end="(95, 75)">
                          <IdentNode start="(95, 74)" end="(95, 75)" leading="" trailing="" raw_val="i" val="i"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(95, 75)" end="(95, 76)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(95, 76)" end="(95, 77)" leading="" trailing="" val="."/>
                    <IdentNode start="(95, 77)" end="(95, 84)" leading="" trailing="" raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <AtomNode start="(95, 84)" end="(95, 85)" leading="" trailing=" " val=","/>
                  <NullNode start="(95, 86)" end="(95, 94)">
                    <OtherNode start="(95, 86)" end="(95, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(95, 86)" end="(95, 92)" leading="" trailing=" " raw_val="l.drop" val="l.drop"/>
                      <NullNode start="(95, 93)" end="(95, 94)">
                        <IdentNode start="(95, 93)" end="(95, 94)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(95, 94)" end="(95, 95)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(95, 96)" end="(96, 45)">
          <AtomNode start="(95, 96)" end="(95, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(95, 99)" end="(96, 45)">
            <AtomNode start="(95, 99)" end="(95, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(96, 3)" end="(96, 45)">
              <TacticTacticseq1IndentedNode start="(96, 3)" end="(96, 45)">
                <NullNode start="(96, 3)" end="(96, 45)">
                  <OtherNode start="(96, 3)" end="(96, 45)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ splitRevAt i l = ((take i l).reverse, drop i l)" state_after="no goals" tactic="rw [splitRevAt, splitRevAt_go, append_nil]">
                    <AtomNode start="(96, 3)" end="(96, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(96, 6)" end="(96, 45)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(96, 6)" end="(96, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(96, 7)" end="(96, 44)">
                        <OtherNode start="(96, 7)" end="(96, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(96, 7)" end="(96, 17)" leading="" trailing="" raw_val="splitRevAt" val="splitRevAt" full_name="List.MergeSort.Internal.splitRevAt" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(78, 5)" def_end="(78, 15)"/>
                        </OtherNode>
                        <AtomNode start="(96, 17)" end="(96, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(96, 19)" end="(96, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(96, 19)" end="(96, 32)" leading="" trailing="" raw_val="splitRevAt_go" val="splitRevAt_go" full_name="List.MergeSort.Internal.splitRevAt_go" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(84, 9)" def_end="(84, 22)"/>
                        </OtherNode>
                        <AtomNode start="(96, 32)" end="(96, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(96, 34)" end="(96, 44)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(96, 34)" end="(96, 44)" leading="" trailing="" raw_val="append_nil" val="append_nil" full_name="List.append_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(96, 44)" end="(96, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(98, 1)" end="(112, 31)" name="mergeSortTR" full_name="List.MergeSort.Internal.mergeSortTR">
      <CommandDeclmodifiersNode start="(98, 1)" end="(104, 3)">
        <NullNode start="(98, 1)" end="(104, 3)">
          <CommandDoccommentNode start="(98, 1)" end="(104, 3)" comment="An intermediate speed-up for `mergeSort`.&#10;This version uses the tail-recurive `mergeTR` function as a subroutine.&#10;&#10;This is not the final version we use at runtime, as `mergeSortTR₂` is faster.&#10;This definition is useful as an intermediate step in proving the `@[csimp]` lemma for `mergeSortTR₂`.&#10;-/">
            <AtomNode start="(98, 1)" end="(98, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(99, 1)" end="(104, 3)" leading="" trailing="&#10;" val="An intermediate speed-up for `mergeSort`.&#10;This version uses the tail-recurive `mergeTR` function as a subroutine.&#10;&#10;This is not the final version we use at runtime, as `mergeSortTR₂` is faster.&#10;This definition is useful as an intermediate step in proving the `@[csimp]` lemma for `mergeSortTR₂`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(105, 1)" end="(112, 31)" name="mergeSortTR">
        <AtomNode start="(105, 1)" end="(105, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(105, 5)" end="(105, 16)">
          <IdentNode start="(105, 5)" end="(105, 16)" leading="" trailing=" " raw_val="mergeSortTR" val="mergeSortTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(105, 17)" end="(105, 87)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(105, 17)" end="(105, 78)">
            <TermExplicitbinderNode start="(105, 17)" end="(105, 29)">
              <AtomNode start="(105, 17)" end="(105, 18)" leading="" trailing="" val="("/>
              <NullNode start="(105, 18)" end="(105, 19)">
                <IdentNode start="(105, 18)" end="(105, 19)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(105, 20)" end="(105, 28)">
                <AtomNode start="(105, 20)" end="(105, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(105, 22)" end="(105, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(105, 22)" end="(105, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(105, 27)" end="(105, 28)">
                    <IdentNode start="(105, 27)" end="(105, 28)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(105, 28)" end="(105, 29)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(105, 30)" end="(105, 78)">
              <AtomNode start="(105, 30)" end="(105, 31)" leading="" trailing="" val="("/>
              <NullNode start="(105, 31)" end="(105, 33)">
                <IdentNode start="(105, 31)" end="(105, 33)" leading="" trailing=" " raw_val="le" val="le"/>
              </NullNode>
              <NullNode start="(105, 34)" end="(105, 48)">
                <AtomNode start="(105, 34)" end="(105, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(105, 36)" end="(105, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(105, 36)" end="(105, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(105, 38)" end="(105, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(105, 40)" end="(105, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(105, 40)" end="(105, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(105, 42)" end="(105, 43)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(105, 44)" end="(105, 48)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode start="(105, 49)" end="(105, 77)">
                <OtherNode start="(105, 49)" end="(105, 77)" kind="Lean.Parser.Term.binderTactic">
                  <AtomNode start="(105, 49)" end="(105, 51)" leading="" trailing=" " val=":="/>
                  <AtomNode start="(105, 52)" end="(105, 54)" leading="" trailing=" " val="by"/>
                  <TacticTacticseqNode start="(105, 55)" end="(105, 77)">
                    <TacticTacticseq1IndentedNode start="(105, 55)" end="(105, 77)">
                      <NullNode start="(105, 55)" end="(105, 77)">
                        <OtherNode start="(105, 55)" end="(105, 77)" kind="Lean.Parser.Tactic.exact">
                          <AtomNode start="(105, 55)" end="(105, 60)" leading="" trailing=" " val="exact"/>
                          <OtherNode start="(105, 61)" end="(105, 77)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(105, 61)" end="(105, 64)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(105, 65)" end="(105, 77)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(105, 65)" end="(105, 68)">
                                <IdentNode start="(105, 65)" end="(105, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(105, 67)" end="(105, 68)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(105, 69)" end="(105, 71)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(105, 72)" end="(105, 77)" kind="«term_≤_»">
                                <IdentNode start="(105, 72)" end="(105, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(105, 74)" end="(105, 75)" leading="" trailing=" " val="≤"/>
                                <IdentNode start="(105, 76)" end="(105, 77)" leading="" trailing="" raw_val="b" val="b"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(105, 77)" end="(105, 78)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(105, 79)" end="(105, 87)">
            <TermTypespecNode start="(105, 79)" end="(105, 87)">
              <AtomNode start="(105, 79)" end="(105, 80)" leading="" trailing=" " val=":"/>
              <OtherNode start="(105, 81)" end="(105, 87)" kind="Lean.Parser.Term.app">
                <IdentNode start="(105, 81)" end="(105, 85)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(105, 86)" end="(105, 87)">
                  <IdentNode start="(105, 86)" end="(105, 87)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(105, 88)" end="(112, 31)">
          <AtomNode start="(105, 88)" end="(105, 90)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(106, 3)" end="(106, 15)" kind="Lean.Parser.Term.app">
            <IdentNode start="(106, 3)" end="(106, 6)" leading="" trailing=" " raw_val="run" val="run"/>
            <NullNode start="(106, 7)" end="(106, 15)">
              <OtherNode start="(106, 7)" end="(106, 15)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(106, 7)" end="(106, 8)" leading="" trailing="" val="⟨"/>
                <NullNode start="(106, 8)" end="(106, 14)">
                  <IdentNode start="(106, 8)" end="(106, 9)" leading="" trailing="" raw_val="l" val="l"/>
                  <AtomNode start="(106, 9)" end="(106, 10)" leading="" trailing=" " val=","/>
                  <IdentNode start="(106, 11)" end="(106, 14)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
                <AtomNode start="(106, 14)" end="(106, 15)" leading="" trailing="&#10;" val="⟩"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(107, 1)" end="(112, 31)">
            <OtherNode start="(107, 1)" end="(112, 31)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(107, 1)" end="(107, 6)" leading="" trailing=" " val="where"/>
              <NullNode start="(107, 7)" end="(112, 31)">
                <OtherNode start="(107, 7)" end="(112, 31)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(107, 7)" end="(112, 31)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(107, 7)" end="(112, 31)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(107, 7)" end="(107, 10)" leading="" trailing=" " raw_val="run" val="run"/>
                      <NullNode/>
                      <NullNode start="(107, 11)" end="(107, 64)">
                        <TermTypespecNode start="(107, 11)" end="(107, 64)">
                          <AtomNode start="(107, 11)" end="(107, 12)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(107, 13)" end="(107, 64)" kind="Lean.Parser.Term.depArrow">
                            <OtherNode start="(107, 13)" end="(107, 22)" kind="Lean.Parser.Term.implicitBinder">
                              <AtomNode start="(107, 13)" end="(107, 14)" leading="" trailing="" val="{"/>
                              <NullNode start="(107, 14)" end="(107, 15)">
                                <IdentNode start="(107, 14)" end="(107, 15)" leading="" trailing=" " raw_val="n" val="n"/>
                              </NullNode>
                              <NullNode start="(107, 16)" end="(107, 21)">
                                <AtomNode start="(107, 16)" end="(107, 17)" leading="" trailing=" " val=":"/>
                                <IdentNode start="(107, 18)" end="(107, 21)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(107, 21)" end="(107, 22)" leading="" trailing=" " val="}"/>
                            </OtherNode>
                            <AtomNode start="(107, 23)" end="(107, 24)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(107, 25)" end="(107, 64)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(107, 25)" end="(107, 55)" kind="«term{_:_//_}»">
                                <AtomNode start="(107, 25)" end="(107, 26)" leading="" trailing=" " val="{"/>
                                <IdentNode start="(107, 27)" end="(107, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                                <NullNode start="(107, 29)" end="(107, 37)">
                                  <AtomNode start="(107, 29)" end="(107, 30)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(107, 31)" end="(107, 37)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(107, 31)" end="(107, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(107, 36)" end="(107, 37)">
                                      <IdentNode start="(107, 36)" end="(107, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(107, 38)" end="(107, 40)" leading="" trailing=" " val="//"/>
                                <OtherNode start="(107, 41)" end="(107, 53)" kind="«term_=_»">
                                  <IdentNode start="(107, 41)" end="(107, 49)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                  <AtomNode start="(107, 50)" end="(107, 51)" leading="" trailing=" " val="="/>
                                  <IdentNode start="(107, 52)" end="(107, 53)" leading="" trailing=" " raw_val="n" val="n"/>
                                </OtherNode>
                                <AtomNode start="(107, 54)" end="(107, 55)" leading="" trailing=" " val="}"/>
                              </OtherNode>
                              <AtomNode start="(107, 56)" end="(107, 57)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(107, 58)" end="(107, 64)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(107, 58)" end="(107, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(107, 63)" end="(107, 64)">
                                  <IdentNode start="(107, 63)" end="(107, 64)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(108, 3)" end="(112, 31)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(108, 3)" end="(112, 31)">
                          <OtherNode start="(108, 3)" end="(108, 21)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(108, 3)" end="(108, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(108, 5)" end="(108, 15)">
                              <NullNode start="(108, 5)" end="(108, 15)">
                                <OtherNode start="(108, 5)" end="(108, 6)" kind="num">
                                  <AtomNode start="(108, 5)" end="(108, 6)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(108, 6)" end="(108, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(108, 8)" end="(108, 15)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(108, 8)" end="(108, 9)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(108, 9)" end="(108, 14)">
                                    <OtherNode start="(108, 9)" end="(108, 11)" kind="«term[_]»">
                                      <AtomNode start="(108, 9)" end="(108, 10)" leading="" trailing="" val="["/>
                                      <NullNode/>
                                      <AtomNode start="(108, 10)" end="(108, 11)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(108, 11)" end="(108, 12)" leading="" trailing=" " val=","/>
                                    <TermHoleNode start="(108, 13)" end="(108, 14)">
                                      <AtomNode start="(108, 13)" end="(108, 14)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(108, 14)" end="(108, 15)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(108, 16)" end="(108, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(108, 19)" end="(108, 21)" kind="«term[_]»">
                              <AtomNode start="(108, 19)" end="(108, 20)" leading="" trailing="" val="["/>
                              <NullNode/>
                              <AtomNode start="(108, 20)" end="(108, 21)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(109, 3)" end="(109, 23)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(109, 3)" end="(109, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(109, 5)" end="(109, 16)">
                              <NullNode start="(109, 5)" end="(109, 16)">
                                <OtherNode start="(109, 5)" end="(109, 6)" kind="num">
                                  <AtomNode start="(109, 5)" end="(109, 6)" leading="" trailing="" val="1"/>
                                </OtherNode>
                                <AtomNode start="(109, 6)" end="(109, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(109, 8)" end="(109, 16)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(109, 8)" end="(109, 9)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(109, 9)" end="(109, 15)">
                                    <OtherNode start="(109, 9)" end="(109, 12)" kind="«term[_]»">
                                      <AtomNode start="(109, 9)" end="(109, 10)" leading="" trailing="" val="["/>
                                      <NullNode start="(109, 10)" end="(109, 11)">
                                        <IdentNode start="(109, 10)" end="(109, 11)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                      <AtomNode start="(109, 11)" end="(109, 12)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(109, 12)" end="(109, 13)" leading="" trailing=" " val=","/>
                                    <TermHoleNode start="(109, 14)" end="(109, 15)">
                                      <AtomNode start="(109, 14)" end="(109, 15)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(109, 15)" end="(109, 16)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(109, 17)" end="(109, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(109, 20)" end="(109, 23)" kind="«term[_]»">
                              <AtomNode start="(109, 20)" end="(109, 21)" leading="" trailing="" val="["/>
                              <NullNode start="(109, 21)" end="(109, 22)">
                                <IdentNode start="(109, 21)" end="(109, 22)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                              <AtomNode start="(109, 22)" end="(109, 23)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(110, 3)" end="(112, 31)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(110, 3)" end="(110, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(110, 5)" end="(110, 12)">
                              <NullNode start="(110, 5)" end="(110, 12)">
                                <OtherNode start="(110, 5)" end="(110, 8)" kind="«term_+_»">
                                  <TermHoleNode start="(110, 5)" end="(110, 6)">
                                    <AtomNode start="(110, 5)" end="(110, 6)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(110, 6)" end="(110, 7)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(110, 7)" end="(110, 8)" kind="num">
                                    <AtomNode start="(110, 7)" end="(110, 8)" leading="" trailing="" val="2"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing=" " val=","/>
                                <IdentNode start="(110, 10)" end="(110, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(110, 13)" end="(110, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <OtherNode start="(111, 5)" end="(112, 31)" kind="Lean.Parser.Term.let">
                              <AtomNode start="(111, 5)" end="(111, 8)" leading="" trailing=" " val="let"/>
                              <OtherNode start="(111, 9)" end="(111, 32)" kind="Lean.Parser.Term.letDecl">
                                <OtherNode start="(111, 9)" end="(111, 32)" kind="Lean.Parser.Term.letPatDecl">
                                  <OtherNode start="(111, 9)" end="(111, 15)" kind="Lean.Parser.Term.tuple">
                                    <AtomNode start="(111, 9)" end="(111, 10)" leading="" trailing="" val="("/>
                                    <NullNode start="(111, 10)" end="(111, 14)">
                                      <IdentNode start="(111, 10)" end="(111, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(111, 11)" end="(111, 12)" leading="" trailing=" " val=","/>
                                      <NullNode start="(111, 13)" end="(111, 14)">
                                        <IdentNode start="(111, 13)" end="(111, 14)" leading="" trailing="" raw_val="r" val="r"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(111, 14)" end="(111, 15)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(111, 16)" end="(111, 18)" leading="" trailing=" " val=":="/>
                                  <OtherNode start="(111, 19)" end="(111, 32)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(111, 19)" end="(111, 29)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                    <NullNode start="(111, 30)" end="(111, 32)">
                                      <IdentNode start="(111, 30)" end="(111, 32)" leading="" trailing="&#10;    " raw_val="xs" val="xs"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(112, 5)" end="(112, 31)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(112, 5)" end="(112, 12)" leading="" trailing=" " raw_val="mergeTR" val="mergeTR" full_name="List.MergeSort.Internal.mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(46, 5)" def_end="(46, 12)"/>
                                <NullNode start="(112, 13)" end="(112, 31)">
                                  <OtherNode start="(112, 13)" end="(112, 20)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(112, 13)" end="(112, 14)" leading="" trailing="" val="("/>
                                    <OtherNode start="(112, 14)" end="(112, 19)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(112, 14)" end="(112, 17)" leading="" trailing=" " raw_val="run" val="run"/>
                                      <NullNode start="(112, 18)" end="(112, 19)">
                                        <IdentNode start="(112, 18)" end="(112, 19)" leading="" trailing="" raw_val="l" val="l"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(112, 19)" end="(112, 20)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <OtherNode start="(112, 21)" end="(112, 28)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(112, 21)" end="(112, 22)" leading="" trailing="" val="("/>
                                    <OtherNode start="(112, 22)" end="(112, 27)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(112, 22)" end="(112, 25)" leading="" trailing=" " raw_val="run" val="run"/>
                                      <NullNode start="(112, 26)" end="(112, 27)">
                                        <IdentNode start="(112, 26)" end="(112, 27)" leading="" trailing="" raw_val="r" val="r"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(112, 27)" end="(112, 28)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(112, 29)" end="(112, 31)" leading="" trailing="&#10;&#10;" raw_val="le" val="le"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(114, 1)" end="(121, 97)" name="splitRevInTwo" full_name="List.MergeSort.Internal.splitRevInTwo">
      <CommandDeclmodifiersNode start="(114, 1)" end="(117, 3)">
        <NullNode start="(114, 1)" end="(117, 3)">
          <CommandDoccommentNode start="(114, 1)" end="(117, 3)" comment="Split a list in two equal parts, reversing the first part.&#10;If the length is odd, the first part will be one element longer.&#10;-/">
            <AtomNode start="(114, 1)" end="(114, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(115, 1)" end="(117, 3)" leading="" trailing="&#10;" val="Split a list in two equal parts, reversing the first part.&#10;If the length is odd, the first part will be one element longer.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(118, 1)" end="(121, 97)" name="splitRevInTwo">
        <AtomNode start="(118, 1)" end="(118, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(118, 5)" end="(118, 18)">
          <IdentNode start="(118, 5)" end="(118, 18)" leading="" trailing=" " raw_val="splitRevInTwo" val="splitRevInTwo"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(118, 19)" end="(119, 76)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(118, 19)" end="(118, 55)">
            <TermExplicitbinderNode start="(118, 19)" end="(118, 55)">
              <AtomNode start="(118, 19)" end="(118, 20)" leading="" trailing="" val="("/>
              <NullNode start="(118, 20)" end="(118, 21)">
                <IdentNode start="(118, 20)" end="(118, 21)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(118, 22)" end="(118, 54)">
                <AtomNode start="(118, 22)" end="(118, 23)" leading="" trailing=" " val=":"/>
                <OtherNode start="(118, 24)" end="(118, 54)" kind="«term{_:_//_}»">
                  <AtomNode start="(118, 24)" end="(118, 25)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(118, 26)" end="(118, 27)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(118, 28)" end="(118, 36)">
                    <AtomNode start="(118, 28)" end="(118, 29)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(118, 30)" end="(118, 36)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(118, 30)" end="(118, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(118, 35)" end="(118, 36)">
                        <IdentNode start="(118, 35)" end="(118, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(118, 37)" end="(118, 39)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(118, 40)" end="(118, 52)" kind="«term_=_»">
                    <IdentNode start="(118, 40)" end="(118, 48)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(118, 49)" end="(118, 50)" leading="" trailing=" " val="="/>
                    <IdentNode start="(118, 51)" end="(118, 52)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(118, 53)" end="(118, 54)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(118, 54)" end="(118, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(118, 56)" end="(119, 76)">
            <TermTypespecNode start="(118, 56)" end="(119, 76)">
              <AtomNode start="(118, 56)" end="(118, 57)" leading="" trailing="&#10;    " val=":"/>
              <OtherNode start="(119, 5)" end="(119, 76)" kind="«term_×_»">
                <OtherNode start="(119, 5)" end="(119, 41)" kind="«term{_:_//_}»">
                  <AtomNode start="(119, 5)" end="(119, 6)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(119, 7)" end="(119, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(119, 9)" end="(119, 17)">
                    <AtomNode start="(119, 9)" end="(119, 10)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(119, 11)" end="(119, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(119, 11)" end="(119, 15)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(119, 16)" end="(119, 17)">
                        <IdentNode start="(119, 16)" end="(119, 17)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(119, 18)" end="(119, 20)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(119, 21)" end="(119, 39)" kind="«term_=_»">
                    <IdentNode start="(119, 21)" end="(119, 29)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(119, 30)" end="(119, 31)" leading="" trailing=" " val="="/>
                    <OtherNode start="(119, 32)" end="(119, 39)" kind="«term_/_»">
                      <OtherNode start="(119, 32)" end="(119, 37)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(119, 32)" end="(119, 33)" leading="" trailing="" val="("/>
                        <OtherNode start="(119, 33)" end="(119, 36)" kind="«term_+_»">
                          <IdentNode start="(119, 33)" end="(119, 34)" leading="" trailing="" raw_val="n" val="n"/>
                          <AtomNode start="(119, 34)" end="(119, 35)" leading="" trailing="" val="+"/>
                          <OtherNode start="(119, 35)" end="(119, 36)" kind="num">
                            <AtomNode start="(119, 35)" end="(119, 36)" leading="" trailing="" val="1"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(119, 36)" end="(119, 37)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(119, 37)" end="(119, 38)" leading="" trailing="" val="/"/>
                      <OtherNode start="(119, 38)" end="(119, 39)" kind="num">
                        <AtomNode start="(119, 38)" end="(119, 39)" leading="" trailing=" " val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(119, 40)" end="(119, 41)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <AtomNode start="(119, 42)" end="(119, 43)" leading="" trailing=" " val="×"/>
                <OtherNode start="(119, 44)" end="(119, 76)" kind="«term{_:_//_}»">
                  <AtomNode start="(119, 44)" end="(119, 45)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(119, 46)" end="(119, 47)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(119, 48)" end="(119, 56)">
                    <AtomNode start="(119, 48)" end="(119, 49)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(119, 50)" end="(119, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(119, 50)" end="(119, 54)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(119, 55)" end="(119, 56)">
                        <IdentNode start="(119, 55)" end="(119, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(119, 57)" end="(119, 59)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(119, 60)" end="(119, 74)" kind="«term_=_»">
                    <IdentNode start="(119, 60)" end="(119, 68)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(119, 69)" end="(119, 70)" leading="" trailing=" " val="="/>
                    <OtherNode start="(119, 71)" end="(119, 74)" kind="«term_/_»">
                      <IdentNode start="(119, 71)" end="(119, 72)" leading="" trailing="" raw_val="n" val="n"/>
                      <AtomNode start="(119, 72)" end="(119, 73)" leading="" trailing="" val="/"/>
                      <OtherNode start="(119, 73)" end="(119, 74)" kind="num">
                        <AtomNode start="(119, 73)" end="(119, 74)" leading="" trailing=" " val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(119, 75)" end="(119, 76)" leading="" trailing=" " val="}"/>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(119, 77)" end="(121, 97)">
          <AtomNode start="(119, 77)" end="(119, 79)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(120, 3)" end="(121, 97)" kind="Lean.Parser.Term.let">
            <AtomNode start="(120, 3)" end="(120, 6)" leading="" trailing=" " val="let"/>
            <OtherNode start="(120, 7)" end="(120, 36)" kind="Lean.Parser.Term.letDecl">
              <OtherNode start="(120, 7)" end="(120, 36)" kind="Lean.Parser.Term.letIdDecl">
                <IdentNode start="(120, 7)" end="(120, 8)" leading="" trailing=" " raw_val="r" val="r"/>
                <NullNode/>
                <NullNode/>
                <AtomNode start="(120, 9)" end="(120, 11)" leading="" trailing=" " val=":="/>
                <OtherNode start="(120, 12)" end="(120, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(120, 12)" end="(120, 22)" leading="" trailing=" " raw_val="splitRevAt" val="splitRevAt" full_name="List.MergeSort.Internal.splitRevAt" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(78, 5)" def_end="(78, 15)"/>
                  <NullNode start="(120, 23)" end="(120, 36)">
                    <OtherNode start="(120, 23)" end="(120, 32)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(120, 23)" end="(120, 24)" leading="" trailing="" val="("/>
                      <OtherNode start="(120, 24)" end="(120, 31)" kind="«term_/_»">
                        <OtherNode start="(120, 24)" end="(120, 29)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(120, 24)" end="(120, 25)" leading="" trailing="" val="("/>
                          <OtherNode start="(120, 25)" end="(120, 28)" kind="«term_+_»">
                            <IdentNode start="(120, 25)" end="(120, 26)" leading="" trailing="" raw_val="n" val="n"/>
                            <AtomNode start="(120, 26)" end="(120, 27)" leading="" trailing="" val="+"/>
                            <OtherNode start="(120, 27)" end="(120, 28)" kind="num">
                              <AtomNode start="(120, 27)" end="(120, 28)" leading="" trailing="" val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(120, 28)" end="(120, 29)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(120, 29)" end="(120, 30)" leading="" trailing="" val="/"/>
                        <OtherNode start="(120, 30)" end="(120, 31)" kind="num">
                          <AtomNode start="(120, 30)" end="(120, 31)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(120, 31)" end="(120, 32)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(120, 33)" end="(120, 36)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(120, 33)" end="(120, 34)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(120, 34)" end="(120, 35)" leading="" trailing="" val="."/>
                      <OtherNode start="(120, 35)" end="(120, 36)" kind="fieldIdx">
                        <AtomNode start="(120, 35)" end="(120, 36)" leading="" trailing="&#10;  " val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(121, 3)" end="(121, 97)" kind="Lean.Parser.Term.tuple">
              <AtomNode start="(121, 3)" end="(121, 4)" leading="" trailing="" val="("/>
              <NullNode start="(121, 4)" end="(121, 96)">
                <OtherNode start="(121, 4)" end="(121, 49)" kind="Lean.Parser.Term.anonymousCtor">
                  <AtomNode start="(121, 4)" end="(121, 5)" leading="" trailing="" val="⟨"/>
                  <NullNode start="(121, 5)" end="(121, 48)">
                    <OtherNode start="(121, 5)" end="(121, 8)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(121, 5)" end="(121, 6)" leading="" trailing="" raw_val="r" val="r"/>
                      <AtomNode start="(121, 6)" end="(121, 7)" leading="" trailing="" val="."/>
                      <OtherNode start="(121, 7)" end="(121, 8)" kind="fieldIdx">
                        <AtomNode start="(121, 7)" end="(121, 8)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(121, 8)" end="(121, 9)" leading="" trailing=" " val=","/>
                    <TermBytacticNode start="(121, 10)" end="(121, 48)">
                      <AtomNode start="(121, 10)" end="(121, 12)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(121, 13)" end="(121, 48)">
                        <TacticTacticseq1IndentedNode start="(121, 13)" end="(121, 48)">
                          <NullNode start="(121, 13)" end="(121, 48)">
                            <OtherNode start="(121, 13)" end="(121, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.33686&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt ((n + 1) / 2) l.val&#10;⊢ r.fst.length = (n + 1) / 2" state_after="α : Type ?u.33686&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt ((n + 1) / 2) l.val&#10;⊢ min ((n + 1) / 2) n = (n + 1) / 2" tactic="simp [r, splitRevAt_eq, l.2]">
                              <AtomNode start="(121, 13)" end="(121, 17)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(121, 18)" end="(121, 41)">
                                <AtomNode start="(121, 18)" end="(121, 19)" leading="" trailing="" val="["/>
                                <NullNode start="(121, 19)" end="(121, 40)">
                                  <OtherNode start="(121, 19)" end="(121, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(121, 19)" end="(121, 20)" leading="" trailing="" raw_val="r" val="r"/>
                                  </OtherNode>
                                  <AtomNode start="(121, 20)" end="(121, 21)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(121, 22)" end="(121, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(121, 22)" end="(121, 35)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                                  </OtherNode>
                                  <AtomNode start="(121, 35)" end="(121, 36)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(121, 37)" end="(121, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(121, 37)" end="(121, 40)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(121, 37)" end="(121, 38)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(121, 38)" end="(121, 39)" leading="" trailing="" val="."/>
                                      <OtherNode start="(121, 39)" end="(121, 40)" kind="fieldIdx">
                                        <AtomNode start="(121, 39)" end="(121, 40)" leading="" trailing="" val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(121, 40)" end="(121, 41)" leading="" trailing="" val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(121, 41)" end="(121, 42)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(121, 43)" end="(121, 48)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.33686&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt ((n + 1) / 2) l.val&#10;⊢ min ((n + 1) / 2) n = (n + 1) / 2" state_after="no goals" tactic="omega">
                              <AtomNode start="(121, 43)" end="(121, 48)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </NullNode>
                  <AtomNode start="(121, 48)" end="(121, 49)" leading="" trailing="" val="⟩"/>
                </OtherNode>
                <AtomNode start="(121, 49)" end="(121, 50)" leading="" trailing=" " val=","/>
                <NullNode start="(121, 51)" end="(121, 96)">
                  <OtherNode start="(121, 51)" end="(121, 96)" kind="Lean.Parser.Term.anonymousCtor">
                    <AtomNode start="(121, 51)" end="(121, 52)" leading="" trailing="" val="⟨"/>
                    <NullNode start="(121, 52)" end="(121, 95)">
                      <OtherNode start="(121, 52)" end="(121, 55)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(121, 52)" end="(121, 53)" leading="" trailing="" raw_val="r" val="r"/>
                        <AtomNode start="(121, 53)" end="(121, 54)" leading="" trailing="" val="."/>
                        <OtherNode start="(121, 54)" end="(121, 55)" kind="fieldIdx">
                          <AtomNode start="(121, 54)" end="(121, 55)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(121, 55)" end="(121, 56)" leading="" trailing=" " val=","/>
                      <TermBytacticNode start="(121, 57)" end="(121, 95)">
                        <AtomNode start="(121, 57)" end="(121, 59)" leading="" trailing=" " val="by"/>
                        <TacticTacticseqNode start="(121, 60)" end="(121, 95)">
                          <TacticTacticseq1IndentedNode start="(121, 60)" end="(121, 95)">
                            <NullNode start="(121, 60)" end="(121, 95)">
                              <OtherNode start="(121, 60)" end="(121, 88)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.33686&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt ((n + 1) / 2) l.val&#10;⊢ r.snd.length = n / 2" state_after="α : Type ?u.33686&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt ((n + 1) / 2) l.val&#10;⊢ n - (n + 1) / 2 = n / 2" tactic="simp [r, splitRevAt_eq, l.2]">
                                <AtomNode start="(121, 60)" end="(121, 64)" leading="" trailing=" " val="simp"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(121, 65)" end="(121, 88)">
                                  <AtomNode start="(121, 65)" end="(121, 66)" leading="" trailing="" val="["/>
                                  <NullNode start="(121, 66)" end="(121, 87)">
                                    <OtherNode start="(121, 66)" end="(121, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(121, 66)" end="(121, 67)" leading="" trailing="" raw_val="r" val="r"/>
                                    </OtherNode>
                                    <AtomNode start="(121, 67)" end="(121, 68)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(121, 69)" end="(121, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(121, 69)" end="(121, 82)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                                    </OtherNode>
                                    <AtomNode start="(121, 82)" end="(121, 83)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(121, 84)" end="(121, 87)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <OtherNode start="(121, 84)" end="(121, 87)" kind="Lean.Parser.Term.proj">
                                        <IdentNode start="(121, 84)" end="(121, 85)" leading="" trailing="" raw_val="l" val="l"/>
                                        <AtomNode start="(121, 85)" end="(121, 86)" leading="" trailing="" val="."/>
                                        <OtherNode start="(121, 86)" end="(121, 87)" kind="fieldIdx">
                                          <AtomNode start="(121, 86)" end="(121, 87)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(121, 87)" end="(121, 88)" leading="" trailing="" val="]"/>
                                </NullNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(121, 88)" end="(121, 89)" leading="" trailing=" " val=";"/>
                              <OtherNode start="(121, 90)" end="(121, 95)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.33686&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt ((n + 1) / 2) l.val&#10;⊢ n - (n + 1) / 2 = n / 2" state_after="no goals" tactic="omega">
                                <AtomNode start="(121, 90)" end="(121, 95)" leading="" trailing="" val="omega"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </TermBytacticNode>
                    </NullNode>
                    <AtomNode start="(121, 95)" end="(121, 96)" leading="" trailing="" val="⟩"/>
                  </OtherNode>
                </NullNode>
              </NullNode>
              <AtomNode start="(121, 96)" end="(121, 97)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(123, 1)" end="(130, 97)" name="splitRevInTwo'" full_name="List.MergeSort.Internal.splitRevInTwo'">
      <CommandDeclmodifiersNode start="(123, 1)" end="(126, 3)">
        <NullNode start="(123, 1)" end="(126, 3)">
          <CommandDoccommentNode start="(123, 1)" end="(126, 3)" comment="Split a list in two equal parts, reversing the first part.&#10;If the length is odd, the second part will be one element longer.&#10;-/">
            <AtomNode start="(123, 1)" end="(123, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(124, 1)" end="(126, 3)" leading="" trailing="&#10;" val="Split a list in two equal parts, reversing the first part.&#10;If the length is odd, the second part will be one element longer.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(127, 1)" end="(130, 97)" name="splitRevInTwo'">
        <AtomNode start="(127, 1)" end="(127, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(127, 5)" end="(127, 19)">
          <IdentNode start="(127, 5)" end="(127, 19)" leading="" trailing=" " raw_val="splitRevInTwo'" val="splitRevInTwo'"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(127, 20)" end="(128, 76)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(127, 20)" end="(127, 56)">
            <TermExplicitbinderNode start="(127, 20)" end="(127, 56)">
              <AtomNode start="(127, 20)" end="(127, 21)" leading="" trailing="" val="("/>
              <NullNode start="(127, 21)" end="(127, 22)">
                <IdentNode start="(127, 21)" end="(127, 22)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(127, 23)" end="(127, 55)">
                <AtomNode start="(127, 23)" end="(127, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(127, 25)" end="(127, 55)" kind="«term{_:_//_}»">
                  <AtomNode start="(127, 25)" end="(127, 26)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(127, 27)" end="(127, 28)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(127, 29)" end="(127, 37)">
                    <AtomNode start="(127, 29)" end="(127, 30)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(127, 31)" end="(127, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(127, 31)" end="(127, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(127, 36)" end="(127, 37)">
                        <IdentNode start="(127, 36)" end="(127, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(127, 38)" end="(127, 40)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(127, 41)" end="(127, 53)" kind="«term_=_»">
                    <IdentNode start="(127, 41)" end="(127, 49)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(127, 50)" end="(127, 51)" leading="" trailing=" " val="="/>
                    <IdentNode start="(127, 52)" end="(127, 53)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(127, 54)" end="(127, 55)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(127, 55)" end="(127, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(127, 57)" end="(128, 76)">
            <TermTypespecNode start="(127, 57)" end="(128, 76)">
              <AtomNode start="(127, 57)" end="(127, 58)" leading="" trailing="&#10;    " val=":"/>
              <OtherNode start="(128, 5)" end="(128, 76)" kind="«term_×_»">
                <OtherNode start="(128, 5)" end="(128, 37)" kind="«term{_:_//_}»">
                  <AtomNode start="(128, 5)" end="(128, 6)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(128, 7)" end="(128, 8)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(128, 9)" end="(128, 17)">
                    <AtomNode start="(128, 9)" end="(128, 10)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(128, 11)" end="(128, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(128, 11)" end="(128, 15)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(128, 16)" end="(128, 17)">
                        <IdentNode start="(128, 16)" end="(128, 17)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(128, 18)" end="(128, 20)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(128, 21)" end="(128, 35)" kind="«term_=_»">
                    <IdentNode start="(128, 21)" end="(128, 29)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(128, 30)" end="(128, 31)" leading="" trailing=" " val="="/>
                    <OtherNode start="(128, 32)" end="(128, 35)" kind="«term_/_»">
                      <IdentNode start="(128, 32)" end="(128, 33)" leading="" trailing="" raw_val="n" val="n"/>
                      <AtomNode start="(128, 33)" end="(128, 34)" leading="" trailing="" val="/"/>
                      <OtherNode start="(128, 34)" end="(128, 35)" kind="num">
                        <AtomNode start="(128, 34)" end="(128, 35)" leading="" trailing=" " val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(128, 36)" end="(128, 37)" leading="" trailing=" " val="}"/>
                </OtherNode>
                <AtomNode start="(128, 38)" end="(128, 39)" leading="" trailing=" " val="×"/>
                <OtherNode start="(128, 40)" end="(128, 76)" kind="«term{_:_//_}»">
                  <AtomNode start="(128, 40)" end="(128, 41)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(128, 42)" end="(128, 43)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(128, 44)" end="(128, 52)">
                    <AtomNode start="(128, 44)" end="(128, 45)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(128, 46)" end="(128, 52)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(128, 46)" end="(128, 50)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(128, 51)" end="(128, 52)">
                        <IdentNode start="(128, 51)" end="(128, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(128, 53)" end="(128, 55)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(128, 56)" end="(128, 74)" kind="«term_=_»">
                    <IdentNode start="(128, 56)" end="(128, 64)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(128, 65)" end="(128, 66)" leading="" trailing=" " val="="/>
                    <OtherNode start="(128, 67)" end="(128, 74)" kind="«term_/_»">
                      <OtherNode start="(128, 67)" end="(128, 72)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(128, 67)" end="(128, 68)" leading="" trailing="" val="("/>
                        <OtherNode start="(128, 68)" end="(128, 71)" kind="«term_+_»">
                          <IdentNode start="(128, 68)" end="(128, 69)" leading="" trailing="" raw_val="n" val="n"/>
                          <AtomNode start="(128, 69)" end="(128, 70)" leading="" trailing="" val="+"/>
                          <OtherNode start="(128, 70)" end="(128, 71)" kind="num">
                            <AtomNode start="(128, 70)" end="(128, 71)" leading="" trailing="" val="1"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(128, 71)" end="(128, 72)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(128, 72)" end="(128, 73)" leading="" trailing="" val="/"/>
                      <OtherNode start="(128, 73)" end="(128, 74)" kind="num">
                        <AtomNode start="(128, 73)" end="(128, 74)" leading="" trailing=" " val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(128, 75)" end="(128, 76)" leading="" trailing=" " val="}"/>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(128, 77)" end="(130, 97)">
          <AtomNode start="(128, 77)" end="(128, 79)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(129, 3)" end="(130, 97)" kind="Lean.Parser.Term.let">
            <AtomNode start="(129, 3)" end="(129, 6)" leading="" trailing=" " val="let"/>
            <OtherNode start="(129, 7)" end="(129, 32)" kind="Lean.Parser.Term.letDecl">
              <OtherNode start="(129, 7)" end="(129, 32)" kind="Lean.Parser.Term.letIdDecl">
                <IdentNode start="(129, 7)" end="(129, 8)" leading="" trailing=" " raw_val="r" val="r"/>
                <NullNode/>
                <NullNode/>
                <AtomNode start="(129, 9)" end="(129, 11)" leading="" trailing=" " val=":="/>
                <OtherNode start="(129, 12)" end="(129, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(129, 12)" end="(129, 22)" leading="" trailing=" " raw_val="splitRevAt" val="splitRevAt" full_name="List.MergeSort.Internal.splitRevAt" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(78, 5)" def_end="(78, 15)"/>
                  <NullNode start="(129, 23)" end="(129, 32)">
                    <OtherNode start="(129, 23)" end="(129, 28)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(129, 23)" end="(129, 24)" leading="" trailing="" val="("/>
                      <OtherNode start="(129, 24)" end="(129, 27)" kind="«term_/_»">
                        <IdentNode start="(129, 24)" end="(129, 25)" leading="" trailing="" raw_val="n" val="n"/>
                        <AtomNode start="(129, 25)" end="(129, 26)" leading="" trailing="" val="/"/>
                        <OtherNode start="(129, 26)" end="(129, 27)" kind="num">
                          <AtomNode start="(129, 26)" end="(129, 27)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(129, 27)" end="(129, 28)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(129, 29)" end="(129, 32)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(129, 29)" end="(129, 30)" leading="" trailing="" raw_val="l" val="l"/>
                      <AtomNode start="(129, 30)" end="(129, 31)" leading="" trailing="" val="."/>
                      <OtherNode start="(129, 31)" end="(129, 32)" kind="fieldIdx">
                        <AtomNode start="(129, 31)" end="(129, 32)" leading="" trailing="&#10;  " val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(130, 3)" end="(130, 97)" kind="Lean.Parser.Term.tuple">
              <AtomNode start="(130, 3)" end="(130, 4)" leading="" trailing="" val="("/>
              <NullNode start="(130, 4)" end="(130, 96)">
                <OtherNode start="(130, 4)" end="(130, 49)" kind="Lean.Parser.Term.anonymousCtor">
                  <AtomNode start="(130, 4)" end="(130, 5)" leading="" trailing="" val="⟨"/>
                  <NullNode start="(130, 5)" end="(130, 48)">
                    <OtherNode start="(130, 5)" end="(130, 8)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(130, 5)" end="(130, 6)" leading="" trailing="" raw_val="r" val="r"/>
                      <AtomNode start="(130, 6)" end="(130, 7)" leading="" trailing="" val="."/>
                      <OtherNode start="(130, 7)" end="(130, 8)" kind="fieldIdx">
                        <AtomNode start="(130, 7)" end="(130, 8)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(130, 8)" end="(130, 9)" leading="" trailing=" " val=","/>
                    <TermBytacticNode start="(130, 10)" end="(130, 48)">
                      <AtomNode start="(130, 10)" end="(130, 12)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(130, 13)" end="(130, 48)">
                        <TacticTacticseq1IndentedNode start="(130, 13)" end="(130, 48)">
                          <NullNode start="(130, 13)" end="(130, 48)">
                            <OtherNode start="(130, 13)" end="(130, 41)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.36299&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt (n / 2) l.val&#10;⊢ r.fst.length = n / 2" state_after="α : Type ?u.36299&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt (n / 2) l.val&#10;⊢ min (n / 2) n = n / 2" tactic="simp [r, splitRevAt_eq, l.2]">
                              <AtomNode start="(130, 13)" end="(130, 17)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(130, 18)" end="(130, 41)">
                                <AtomNode start="(130, 18)" end="(130, 19)" leading="" trailing="" val="["/>
                                <NullNode start="(130, 19)" end="(130, 40)">
                                  <OtherNode start="(130, 19)" end="(130, 20)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(130, 19)" end="(130, 20)" leading="" trailing="" raw_val="r" val="r"/>
                                  </OtherNode>
                                  <AtomNode start="(130, 20)" end="(130, 21)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(130, 22)" end="(130, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(130, 22)" end="(130, 35)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                                  </OtherNode>
                                  <AtomNode start="(130, 35)" end="(130, 36)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(130, 37)" end="(130, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <OtherNode start="(130, 37)" end="(130, 40)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(130, 37)" end="(130, 38)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(130, 38)" end="(130, 39)" leading="" trailing="" val="."/>
                                      <OtherNode start="(130, 39)" end="(130, 40)" kind="fieldIdx">
                                        <AtomNode start="(130, 39)" end="(130, 40)" leading="" trailing="" val="2"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(130, 40)" end="(130, 41)" leading="" trailing="" val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(130, 41)" end="(130, 42)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(130, 43)" end="(130, 48)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.36299&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt (n / 2) l.val&#10;⊢ min (n / 2) n = n / 2" state_after="no goals" tactic="omega">
                              <AtomNode start="(130, 43)" end="(130, 48)" leading="" trailing="" val="omega"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                  </NullNode>
                  <AtomNode start="(130, 48)" end="(130, 49)" leading="" trailing="" val="⟩"/>
                </OtherNode>
                <AtomNode start="(130, 49)" end="(130, 50)" leading="" trailing=" " val=","/>
                <NullNode start="(130, 51)" end="(130, 96)">
                  <OtherNode start="(130, 51)" end="(130, 96)" kind="Lean.Parser.Term.anonymousCtor">
                    <AtomNode start="(130, 51)" end="(130, 52)" leading="" trailing="" val="⟨"/>
                    <NullNode start="(130, 52)" end="(130, 95)">
                      <OtherNode start="(130, 52)" end="(130, 55)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(130, 52)" end="(130, 53)" leading="" trailing="" raw_val="r" val="r"/>
                        <AtomNode start="(130, 53)" end="(130, 54)" leading="" trailing="" val="."/>
                        <OtherNode start="(130, 54)" end="(130, 55)" kind="fieldIdx">
                          <AtomNode start="(130, 54)" end="(130, 55)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(130, 55)" end="(130, 56)" leading="" trailing=" " val=","/>
                      <TermBytacticNode start="(130, 57)" end="(130, 95)">
                        <AtomNode start="(130, 57)" end="(130, 59)" leading="" trailing=" " val="by"/>
                        <TacticTacticseqNode start="(130, 60)" end="(130, 95)">
                          <TacticTacticseq1IndentedNode start="(130, 60)" end="(130, 95)">
                            <NullNode start="(130, 60)" end="(130, 95)">
                              <OtherNode start="(130, 60)" end="(130, 88)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.36299&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt (n / 2) l.val&#10;⊢ r.snd.length = (n + 1) / 2" state_after="α : Type ?u.36299&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt (n / 2) l.val&#10;⊢ n - n / 2 = (n + 1) / 2" tactic="simp [r, splitRevAt_eq, l.2]">
                                <AtomNode start="(130, 60)" end="(130, 64)" leading="" trailing=" " val="simp"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(130, 65)" end="(130, 88)">
                                  <AtomNode start="(130, 65)" end="(130, 66)" leading="" trailing="" val="["/>
                                  <NullNode start="(130, 66)" end="(130, 87)">
                                    <OtherNode start="(130, 66)" end="(130, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(130, 66)" end="(130, 67)" leading="" trailing="" raw_val="r" val="r"/>
                                    </OtherNode>
                                    <AtomNode start="(130, 67)" end="(130, 68)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(130, 69)" end="(130, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(130, 69)" end="(130, 82)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                                    </OtherNode>
                                    <AtomNode start="(130, 82)" end="(130, 83)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(130, 84)" end="(130, 87)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <OtherNode start="(130, 84)" end="(130, 87)" kind="Lean.Parser.Term.proj">
                                        <IdentNode start="(130, 84)" end="(130, 85)" leading="" trailing="" raw_val="l" val="l"/>
                                        <AtomNode start="(130, 85)" end="(130, 86)" leading="" trailing="" val="."/>
                                        <OtherNode start="(130, 86)" end="(130, 87)" kind="fieldIdx">
                                          <AtomNode start="(130, 86)" end="(130, 87)" leading="" trailing="" val="2"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(130, 87)" end="(130, 88)" leading="" trailing="" val="]"/>
                                </NullNode>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(130, 88)" end="(130, 89)" leading="" trailing=" " val=";"/>
                              <OtherNode start="(130, 90)" end="(130, 95)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.36299&#10;n : Nat&#10;l : { l // l.length = n }&#10;r : List α × List α := splitRevAt (n / 2) l.val&#10;⊢ n - n / 2 = (n + 1) / 2" state_after="no goals" tactic="omega">
                                <AtomNode start="(130, 90)" end="(130, 95)" leading="" trailing="" val="omega"/>
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </TermBytacticNode>
                    </NullNode>
                    <AtomNode start="(130, 95)" end="(130, 96)" leading="" trailing="" val="⟩"/>
                  </OtherNode>
                </NullNode>
              </NullNode>
              <AtomNode start="(130, 96)" end="(130, 97)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(132, 1)" end="(152, 32)" name="mergeSortTR₂" full_name="List.MergeSort.Internal.mergeSortTR₂">
      <CommandDeclmodifiersNode start="(132, 1)" end="(134, 3)">
        <NullNode start="(132, 1)" end="(134, 3)">
          <CommandDoccommentNode start="(132, 1)" end="(134, 3)" comment="Faster version of `mergeSortTR`, which avoids unnecessary list reversals.&#10;-/">
            <AtomNode start="(132, 1)" end="(132, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(133, 1)" end="(134, 3)" leading="" trailing="&#10;-- Per the benchmark in `tests/bench/mergeSort/`&#10;-- (which averages over 4 use cases: already sorted lists, reverse sorted lists, almost sorted lists, and random lists),&#10;-- for lists of length 10^6, `mergeSortTR₂` is about 20% faster than `mergeSortTR`.&#10;" val="Faster version of `mergeSortTR`, which avoids unnecessary list reversals.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(138, 1)" end="(152, 32)" name="mergeSortTR₂">
        <AtomNode start="(138, 1)" end="(138, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(138, 5)" end="(138, 17)">
          <IdentNode start="(138, 5)" end="(138, 17)" leading="" trailing=" " raw_val="mergeSortTR₂" val="mergeSortTR₂"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(138, 18)" end="(138, 88)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(138, 18)" end="(138, 79)">
            <TermExplicitbinderNode start="(138, 18)" end="(138, 30)">
              <AtomNode start="(138, 18)" end="(138, 19)" leading="" trailing="" val="("/>
              <NullNode start="(138, 19)" end="(138, 20)">
                <IdentNode start="(138, 19)" end="(138, 20)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(138, 21)" end="(138, 29)">
                <AtomNode start="(138, 21)" end="(138, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(138, 23)" end="(138, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(138, 23)" end="(138, 27)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(138, 28)" end="(138, 29)">
                    <IdentNode start="(138, 28)" end="(138, 29)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(138, 29)" end="(138, 30)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(138, 31)" end="(138, 79)">
              <AtomNode start="(138, 31)" end="(138, 32)" leading="" trailing="" val="("/>
              <NullNode start="(138, 32)" end="(138, 34)">
                <IdentNode start="(138, 32)" end="(138, 34)" leading="" trailing=" " raw_val="le" val="le"/>
              </NullNode>
              <NullNode start="(138, 35)" end="(138, 49)">
                <AtomNode start="(138, 35)" end="(138, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(138, 37)" end="(138, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(138, 37)" end="(138, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(138, 39)" end="(138, 40)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(138, 41)" end="(138, 49)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(138, 41)" end="(138, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(138, 43)" end="(138, 44)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(138, 45)" end="(138, 49)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode start="(138, 50)" end="(138, 78)">
                <OtherNode start="(138, 50)" end="(138, 78)" kind="Lean.Parser.Term.binderTactic">
                  <AtomNode start="(138, 50)" end="(138, 52)" leading="" trailing=" " val=":="/>
                  <AtomNode start="(138, 53)" end="(138, 55)" leading="" trailing=" " val="by"/>
                  <TacticTacticseqNode start="(138, 56)" end="(138, 78)">
                    <TacticTacticseq1IndentedNode start="(138, 56)" end="(138, 78)">
                      <NullNode start="(138, 56)" end="(138, 78)">
                        <OtherNode start="(138, 56)" end="(138, 78)" kind="Lean.Parser.Tactic.exact">
                          <AtomNode start="(138, 56)" end="(138, 61)" leading="" trailing=" " val="exact"/>
                          <OtherNode start="(138, 62)" end="(138, 78)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(138, 62)" end="(138, 65)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(138, 66)" end="(138, 78)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(138, 66)" end="(138, 69)">
                                <IdentNode start="(138, 66)" end="(138, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(138, 68)" end="(138, 69)" leading="" trailing=" " raw_val="b" val="b"/>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(138, 70)" end="(138, 72)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(138, 73)" end="(138, 78)" kind="«term_≤_»">
                                <IdentNode start="(138, 73)" end="(138, 74)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(138, 75)" end="(138, 76)" leading="" trailing=" " val="≤"/>
                                <IdentNode start="(138, 77)" end="(138, 78)" leading="" trailing="" raw_val="b" val="b"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(138, 78)" end="(138, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(138, 80)" end="(138, 88)">
            <TermTypespecNode start="(138, 80)" end="(138, 88)">
              <AtomNode start="(138, 80)" end="(138, 81)" leading="" trailing=" " val=":"/>
              <OtherNode start="(138, 82)" end="(138, 88)" kind="Lean.Parser.Term.app">
                <IdentNode start="(138, 82)" end="(138, 86)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(138, 87)" end="(138, 88)">
                  <IdentNode start="(138, 87)" end="(138, 88)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(138, 89)" end="(152, 32)">
          <AtomNode start="(138, 89)" end="(138, 91)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(139, 3)" end="(139, 15)" kind="Lean.Parser.Term.app">
            <IdentNode start="(139, 3)" end="(139, 6)" leading="" trailing=" " raw_val="run" val="run"/>
            <NullNode start="(139, 7)" end="(139, 15)">
              <OtherNode start="(139, 7)" end="(139, 15)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(139, 7)" end="(139, 8)" leading="" trailing="" val="⟨"/>
                <NullNode start="(139, 8)" end="(139, 14)">
                  <IdentNode start="(139, 8)" end="(139, 9)" leading="" trailing="" raw_val="l" val="l"/>
                  <AtomNode start="(139, 9)" end="(139, 10)" leading="" trailing=" " val=","/>
                  <IdentNode start="(139, 11)" end="(139, 14)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
                <AtomNode start="(139, 14)" end="(139, 15)" leading="" trailing="&#10;" val="⟩"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(140, 1)" end="(152, 32)">
            <OtherNode start="(140, 1)" end="(152, 32)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(140, 1)" end="(140, 6)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(141, 3)" end="(152, 32)">
                <OtherNode start="(141, 3)" end="(146, 32)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(141, 3)" end="(146, 32)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(141, 3)" end="(146, 32)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(141, 3)" end="(141, 6)" leading="" trailing=" " raw_val="run" val="run"/>
                      <NullNode/>
                      <NullNode start="(141, 7)" end="(141, 60)">
                        <TermTypespecNode start="(141, 7)" end="(141, 60)">
                          <AtomNode start="(141, 7)" end="(141, 8)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(141, 9)" end="(141, 60)" kind="Lean.Parser.Term.depArrow">
                            <OtherNode start="(141, 9)" end="(141, 18)" kind="Lean.Parser.Term.implicitBinder">
                              <AtomNode start="(141, 9)" end="(141, 10)" leading="" trailing="" val="{"/>
                              <NullNode start="(141, 10)" end="(141, 11)">
                                <IdentNode start="(141, 10)" end="(141, 11)" leading="" trailing=" " raw_val="n" val="n"/>
                              </NullNode>
                              <NullNode start="(141, 12)" end="(141, 17)">
                                <AtomNode start="(141, 12)" end="(141, 13)" leading="" trailing=" " val=":"/>
                                <IdentNode start="(141, 14)" end="(141, 17)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(141, 17)" end="(141, 18)" leading="" trailing=" " val="}"/>
                            </OtherNode>
                            <AtomNode start="(141, 19)" end="(141, 20)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(141, 21)" end="(141, 60)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(141, 21)" end="(141, 51)" kind="«term{_:_//_}»">
                                <AtomNode start="(141, 21)" end="(141, 22)" leading="" trailing=" " val="{"/>
                                <IdentNode start="(141, 23)" end="(141, 24)" leading="" trailing=" " raw_val="l" val="l"/>
                                <NullNode start="(141, 25)" end="(141, 33)">
                                  <AtomNode start="(141, 25)" end="(141, 26)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(141, 27)" end="(141, 33)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(141, 27)" end="(141, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(141, 32)" end="(141, 33)">
                                      <IdentNode start="(141, 32)" end="(141, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(141, 34)" end="(141, 36)" leading="" trailing=" " val="//"/>
                                <OtherNode start="(141, 37)" end="(141, 49)" kind="«term_=_»">
                                  <IdentNode start="(141, 37)" end="(141, 45)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                  <AtomNode start="(141, 46)" end="(141, 47)" leading="" trailing=" " val="="/>
                                  <IdentNode start="(141, 48)" end="(141, 49)" leading="" trailing=" " raw_val="n" val="n"/>
                                </OtherNode>
                                <AtomNode start="(141, 50)" end="(141, 51)" leading="" trailing=" " val="}"/>
                              </OtherNode>
                              <AtomNode start="(141, 52)" end="(141, 53)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(141, 54)" end="(141, 60)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(141, 54)" end="(141, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(141, 59)" end="(141, 60)">
                                  <IdentNode start="(141, 59)" end="(141, 60)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(142, 3)" end="(146, 32)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(142, 3)" end="(146, 32)">
                          <OtherNode start="(142, 3)" end="(142, 21)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(142, 3)" end="(142, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(142, 5)" end="(142, 15)">
                              <NullNode start="(142, 5)" end="(142, 15)">
                                <OtherNode start="(142, 5)" end="(142, 6)" kind="num">
                                  <AtomNode start="(142, 5)" end="(142, 6)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(142, 6)" end="(142, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(142, 8)" end="(142, 15)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(142, 8)" end="(142, 9)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(142, 9)" end="(142, 14)">
                                    <OtherNode start="(142, 9)" end="(142, 11)" kind="«term[_]»">
                                      <AtomNode start="(142, 9)" end="(142, 10)" leading="" trailing="" val="["/>
                                      <NullNode/>
                                      <AtomNode start="(142, 10)" end="(142, 11)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(142, 11)" end="(142, 12)" leading="" trailing=" " val=","/>
                                    <TermHoleNode start="(142, 13)" end="(142, 14)">
                                      <AtomNode start="(142, 13)" end="(142, 14)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(142, 14)" end="(142, 15)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(142, 16)" end="(142, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(142, 19)" end="(142, 21)" kind="«term[_]»">
                              <AtomNode start="(142, 19)" end="(142, 20)" leading="" trailing="" val="["/>
                              <NullNode/>
                              <AtomNode start="(142, 20)" end="(142, 21)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(143, 3)" end="(143, 23)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(143, 3)" end="(143, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(143, 5)" end="(143, 16)">
                              <NullNode start="(143, 5)" end="(143, 16)">
                                <OtherNode start="(143, 5)" end="(143, 6)" kind="num">
                                  <AtomNode start="(143, 5)" end="(143, 6)" leading="" trailing="" val="1"/>
                                </OtherNode>
                                <AtomNode start="(143, 6)" end="(143, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(143, 8)" end="(143, 16)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(143, 8)" end="(143, 9)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(143, 9)" end="(143, 15)">
                                    <OtherNode start="(143, 9)" end="(143, 12)" kind="«term[_]»">
                                      <AtomNode start="(143, 9)" end="(143, 10)" leading="" trailing="" val="["/>
                                      <NullNode start="(143, 10)" end="(143, 11)">
                                        <IdentNode start="(143, 10)" end="(143, 11)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                      <AtomNode start="(143, 11)" end="(143, 12)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(143, 12)" end="(143, 13)" leading="" trailing=" " val=","/>
                                    <TermHoleNode start="(143, 14)" end="(143, 15)">
                                      <AtomNode start="(143, 14)" end="(143, 15)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(143, 15)" end="(143, 16)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(143, 17)" end="(143, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(143, 20)" end="(143, 23)" kind="«term[_]»">
                              <AtomNode start="(143, 20)" end="(143, 21)" leading="" trailing="" val="["/>
                              <NullNode start="(143, 21)" end="(143, 22)">
                                <IdentNode start="(143, 21)" end="(143, 22)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                              <AtomNode start="(143, 22)" end="(143, 23)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(144, 3)" end="(146, 32)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(144, 3)" end="(144, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(144, 5)" end="(144, 12)">
                              <NullNode start="(144, 5)" end="(144, 12)">
                                <OtherNode start="(144, 5)" end="(144, 8)" kind="«term_+_»">
                                  <TermHoleNode start="(144, 5)" end="(144, 6)">
                                    <AtomNode start="(144, 5)" end="(144, 6)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(144, 6)" end="(144, 7)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(144, 7)" end="(144, 8)" kind="num">
                                    <AtomNode start="(144, 7)" end="(144, 8)" leading="" trailing="" val="2"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(144, 8)" end="(144, 9)" leading="" trailing=" " val=","/>
                                <IdentNode start="(144, 10)" end="(144, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(144, 13)" end="(144, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <OtherNode start="(145, 5)" end="(146, 32)" kind="Lean.Parser.Term.let">
                              <AtomNode start="(145, 5)" end="(145, 8)" leading="" trailing=" " val="let"/>
                              <OtherNode start="(145, 9)" end="(145, 35)" kind="Lean.Parser.Term.letDecl">
                                <OtherNode start="(145, 9)" end="(145, 35)" kind="Lean.Parser.Term.letPatDecl">
                                  <OtherNode start="(145, 9)" end="(145, 15)" kind="Lean.Parser.Term.tuple">
                                    <AtomNode start="(145, 9)" end="(145, 10)" leading="" trailing="" val="("/>
                                    <NullNode start="(145, 10)" end="(145, 14)">
                                      <IdentNode start="(145, 10)" end="(145, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(145, 11)" end="(145, 12)" leading="" trailing=" " val=","/>
                                      <NullNode start="(145, 13)" end="(145, 14)">
                                        <IdentNode start="(145, 13)" end="(145, 14)" leading="" trailing="" raw_val="r" val="r"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(145, 14)" end="(145, 15)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(145, 16)" end="(145, 18)" leading="" trailing=" " val=":="/>
                                  <OtherNode start="(145, 19)" end="(145, 35)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(145, 19)" end="(145, 32)" leading="" trailing=" " raw_val="splitRevInTwo" val="splitRevInTwo" full_name="List.MergeSort.Internal.splitRevInTwo" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(118, 5)" def_end="(118, 18)"/>
                                    <NullNode start="(145, 33)" end="(145, 35)">
                                      <IdentNode start="(145, 33)" end="(145, 35)" leading="" trailing="&#10;    " raw_val="xs" val="xs"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(146, 5)" end="(146, 32)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(146, 5)" end="(146, 12)" leading="" trailing=" " raw_val="mergeTR" val="mergeTR" full_name="List.MergeSort.Internal.mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(46, 5)" def_end="(46, 12)"/>
                                <NullNode start="(146, 13)" end="(146, 32)">
                                  <OtherNode start="(146, 13)" end="(146, 21)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(146, 13)" end="(146, 14)" leading="" trailing="" val="("/>
                                    <OtherNode start="(146, 14)" end="(146, 20)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(146, 14)" end="(146, 18)" leading="" trailing=" " raw_val="run'" val="run'"/>
                                      <NullNode start="(146, 19)" end="(146, 20)">
                                        <IdentNode start="(146, 19)" end="(146, 20)" leading="" trailing="" raw_val="l" val="l"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(146, 20)" end="(146, 21)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <OtherNode start="(146, 22)" end="(146, 29)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(146, 22)" end="(146, 23)" leading="" trailing="" val="("/>
                                    <OtherNode start="(146, 23)" end="(146, 28)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(146, 23)" end="(146, 26)" leading="" trailing=" " raw_val="run" val="run"/>
                                      <NullNode start="(146, 27)" end="(146, 28)">
                                        <IdentNode start="(146, 27)" end="(146, 28)" leading="" trailing="" raw_val="r" val="r"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(146, 28)" end="(146, 29)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(146, 30)" end="(146, 32)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <NullNode/>
                <OtherNode start="(147, 3)" end="(152, 32)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode/>
                  <NullNode/>
                  <OtherNode start="(147, 3)" end="(152, 32)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(147, 3)" end="(152, 32)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(147, 3)" end="(147, 7)" leading="" trailing=" " raw_val="run'" val="run'"/>
                      <NullNode/>
                      <NullNode start="(147, 8)" end="(147, 61)">
                        <TermTypespecNode start="(147, 8)" end="(147, 61)">
                          <AtomNode start="(147, 8)" end="(147, 9)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(147, 10)" end="(147, 61)" kind="Lean.Parser.Term.depArrow">
                            <OtherNode start="(147, 10)" end="(147, 19)" kind="Lean.Parser.Term.implicitBinder">
                              <AtomNode start="(147, 10)" end="(147, 11)" leading="" trailing="" val="{"/>
                              <NullNode start="(147, 11)" end="(147, 12)">
                                <IdentNode start="(147, 11)" end="(147, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                              </NullNode>
                              <NullNode start="(147, 13)" end="(147, 18)">
                                <AtomNode start="(147, 13)" end="(147, 14)" leading="" trailing=" " val=":"/>
                                <IdentNode start="(147, 15)" end="(147, 18)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              </NullNode>
                              <AtomNode start="(147, 18)" end="(147, 19)" leading="" trailing=" " val="}"/>
                            </OtherNode>
                            <AtomNode start="(147, 20)" end="(147, 21)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(147, 22)" end="(147, 61)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(147, 22)" end="(147, 52)" kind="«term{_:_//_}»">
                                <AtomNode start="(147, 22)" end="(147, 23)" leading="" trailing=" " val="{"/>
                                <IdentNode start="(147, 24)" end="(147, 25)" leading="" trailing=" " raw_val="l" val="l"/>
                                <NullNode start="(147, 26)" end="(147, 34)">
                                  <AtomNode start="(147, 26)" end="(147, 27)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(147, 28)" end="(147, 34)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(147, 28)" end="(147, 32)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(147, 33)" end="(147, 34)">
                                      <IdentNode start="(147, 33)" end="(147, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                                    </NullNode>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(147, 35)" end="(147, 37)" leading="" trailing=" " val="//"/>
                                <OtherNode start="(147, 38)" end="(147, 50)" kind="«term_=_»">
                                  <IdentNode start="(147, 38)" end="(147, 46)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                                  <AtomNode start="(147, 47)" end="(147, 48)" leading="" trailing=" " val="="/>
                                  <IdentNode start="(147, 49)" end="(147, 50)" leading="" trailing=" " raw_val="n" val="n"/>
                                </OtherNode>
                                <AtomNode start="(147, 51)" end="(147, 52)" leading="" trailing=" " val="}"/>
                              </OtherNode>
                              <AtomNode start="(147, 53)" end="(147, 54)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(147, 55)" end="(147, 61)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(147, 55)" end="(147, 59)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(147, 60)" end="(147, 61)">
                                  <IdentNode start="(147, 60)" end="(147, 61)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(148, 3)" end="(152, 32)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(148, 3)" end="(152, 32)">
                          <OtherNode start="(148, 3)" end="(148, 21)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(148, 3)" end="(148, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(148, 5)" end="(148, 15)">
                              <NullNode start="(148, 5)" end="(148, 15)">
                                <OtherNode start="(148, 5)" end="(148, 6)" kind="num">
                                  <AtomNode start="(148, 5)" end="(148, 6)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(148, 6)" end="(148, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(148, 8)" end="(148, 15)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(148, 8)" end="(148, 9)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(148, 9)" end="(148, 14)">
                                    <OtherNode start="(148, 9)" end="(148, 11)" kind="«term[_]»">
                                      <AtomNode start="(148, 9)" end="(148, 10)" leading="" trailing="" val="["/>
                                      <NullNode/>
                                      <AtomNode start="(148, 10)" end="(148, 11)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(148, 11)" end="(148, 12)" leading="" trailing=" " val=","/>
                                    <TermHoleNode start="(148, 13)" end="(148, 14)">
                                      <AtomNode start="(148, 13)" end="(148, 14)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(148, 14)" end="(148, 15)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(148, 16)" end="(148, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(148, 19)" end="(148, 21)" kind="«term[_]»">
                              <AtomNode start="(148, 19)" end="(148, 20)" leading="" trailing="" val="["/>
                              <NullNode/>
                              <AtomNode start="(148, 20)" end="(148, 21)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(149, 3)" end="(149, 23)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(149, 3)" end="(149, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(149, 5)" end="(149, 16)">
                              <NullNode start="(149, 5)" end="(149, 16)">
                                <OtherNode start="(149, 5)" end="(149, 6)" kind="num">
                                  <AtomNode start="(149, 5)" end="(149, 6)" leading="" trailing="" val="1"/>
                                </OtherNode>
                                <AtomNode start="(149, 6)" end="(149, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(149, 8)" end="(149, 16)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(149, 8)" end="(149, 9)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(149, 9)" end="(149, 15)">
                                    <OtherNode start="(149, 9)" end="(149, 12)" kind="«term[_]»">
                                      <AtomNode start="(149, 9)" end="(149, 10)" leading="" trailing="" val="["/>
                                      <NullNode start="(149, 10)" end="(149, 11)">
                                        <IdentNode start="(149, 10)" end="(149, 11)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                      <AtomNode start="(149, 11)" end="(149, 12)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(149, 12)" end="(149, 13)" leading="" trailing=" " val=","/>
                                    <TermHoleNode start="(149, 14)" end="(149, 15)">
                                      <AtomNode start="(149, 14)" end="(149, 15)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(149, 15)" end="(149, 16)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(149, 17)" end="(149, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(149, 20)" end="(149, 23)" kind="«term[_]»">
                              <AtomNode start="(149, 20)" end="(149, 21)" leading="" trailing="" val="["/>
                              <NullNode start="(149, 21)" end="(149, 22)">
                                <IdentNode start="(149, 21)" end="(149, 22)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                              <AtomNode start="(149, 22)" end="(149, 23)" leading="" trailing="&#10;  " val="]"/>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(150, 3)" end="(152, 32)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(150, 3)" end="(150, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(150, 5)" end="(150, 12)">
                              <NullNode start="(150, 5)" end="(150, 12)">
                                <OtherNode start="(150, 5)" end="(150, 8)" kind="«term_+_»">
                                  <TermHoleNode start="(150, 5)" end="(150, 6)">
                                    <AtomNode start="(150, 5)" end="(150, 6)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(150, 6)" end="(150, 7)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(150, 7)" end="(150, 8)" kind="num">
                                    <AtomNode start="(150, 7)" end="(150, 8)" leading="" trailing="" val="2"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(150, 8)" end="(150, 9)" leading="" trailing=" " val=","/>
                                <IdentNode start="(150, 10)" end="(150, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(150, 13)" end="(150, 15)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <OtherNode start="(151, 5)" end="(152, 32)" kind="Lean.Parser.Term.let">
                              <AtomNode start="(151, 5)" end="(151, 8)" leading="" trailing=" " val="let"/>
                              <OtherNode start="(151, 9)" end="(151, 36)" kind="Lean.Parser.Term.letDecl">
                                <OtherNode start="(151, 9)" end="(151, 36)" kind="Lean.Parser.Term.letPatDecl">
                                  <OtherNode start="(151, 9)" end="(151, 15)" kind="Lean.Parser.Term.tuple">
                                    <AtomNode start="(151, 9)" end="(151, 10)" leading="" trailing="" val="("/>
                                    <NullNode start="(151, 10)" end="(151, 14)">
                                      <IdentNode start="(151, 10)" end="(151, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(151, 11)" end="(151, 12)" leading="" trailing=" " val=","/>
                                      <NullNode start="(151, 13)" end="(151, 14)">
                                        <IdentNode start="(151, 13)" end="(151, 14)" leading="" trailing="" raw_val="r" val="r"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(151, 14)" end="(151, 15)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(151, 16)" end="(151, 18)" leading="" trailing=" " val=":="/>
                                  <OtherNode start="(151, 19)" end="(151, 36)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(151, 19)" end="(151, 33)" leading="" trailing=" " raw_val="splitRevInTwo'" val="splitRevInTwo'" full_name="List.MergeSort.Internal.splitRevInTwo'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(127, 5)" def_end="(127, 19)"/>
                                    <NullNode start="(151, 34)" end="(151, 36)">
                                      <IdentNode start="(151, 34)" end="(151, 36)" leading="" trailing="&#10;    " raw_val="xs" val="xs"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                              <NullNode/>
                              <OtherNode start="(152, 5)" end="(152, 32)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(152, 5)" end="(152, 12)" leading="" trailing=" " raw_val="mergeTR" val="mergeTR" full_name="List.MergeSort.Internal.mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(46, 5)" def_end="(46, 12)"/>
                                <NullNode start="(152, 13)" end="(152, 32)">
                                  <OtherNode start="(152, 13)" end="(152, 21)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(152, 13)" end="(152, 14)" leading="" trailing="" val="("/>
                                    <OtherNode start="(152, 14)" end="(152, 20)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(152, 14)" end="(152, 18)" leading="" trailing=" " raw_val="run'" val="run'"/>
                                      <NullNode start="(152, 19)" end="(152, 20)">
                                        <IdentNode start="(152, 19)" end="(152, 20)" leading="" trailing="" raw_val="r" val="r"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(152, 20)" end="(152, 21)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <OtherNode start="(152, 22)" end="(152, 29)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(152, 22)" end="(152, 23)" leading="" trailing="" val="("/>
                                    <OtherNode start="(152, 23)" end="(152, 28)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(152, 23)" end="(152, 26)" leading="" trailing=" " raw_val="run" val="run"/>
                                      <NullNode start="(152, 27)" end="(152, 28)">
                                        <IdentNode start="(152, 27)" end="(152, 28)" leading="" trailing="" raw_val="l" val="l"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(152, 28)" end="(152, 29)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <IdentNode start="(152, 30)" end="(152, 32)" leading="" trailing="&#10;&#10;" raw_val="le" val="le"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(154, 1)" end="(158, 8)" name="splitRevInTwo'_fst" full_name="List.MergeSort.Internal.splitRevInTwo'_fst">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(154, 1)" end="(158, 8)" name="splitRevInTwo'_fst" full_name="List.MergeSort.Internal.splitRevInTwo'_fst" _is_private_decl="False">
        <AtomNode start="(154, 1)" end="(154, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(154, 9)" end="(154, 27)">
          <IdentNode start="(154, 9)" end="(154, 27)" leading="" trailing=" " raw_val="splitRevInTwo'_fst" val="splitRevInTwo'_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(154, 28)" end="(155, 96)">
          <NullNode start="(154, 28)" end="(154, 64)">
            <TermExplicitbinderNode start="(154, 28)" end="(154, 64)">
              <AtomNode start="(154, 28)" end="(154, 29)" leading="" trailing="" val="("/>
              <NullNode start="(154, 29)" end="(154, 30)">
                <IdentNode start="(154, 29)" end="(154, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(154, 31)" end="(154, 63)">
                <AtomNode start="(154, 31)" end="(154, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(154, 33)" end="(154, 63)" kind="«term{_:_//_}»">
                  <AtomNode start="(154, 33)" end="(154, 34)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(154, 35)" end="(154, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(154, 37)" end="(154, 45)">
                    <AtomNode start="(154, 37)" end="(154, 38)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(154, 39)" end="(154, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(154, 39)" end="(154, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(154, 44)" end="(154, 45)">
                        <IdentNode start="(154, 44)" end="(154, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(154, 46)" end="(154, 48)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(154, 49)" end="(154, 61)" kind="«term_=_»">
                    <IdentNode start="(154, 49)" end="(154, 57)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(154, 58)" end="(154, 59)" leading="" trailing=" " val="="/>
                    <IdentNode start="(154, 60)" end="(154, 61)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(154, 62)" end="(154, 63)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(154, 63)" end="(154, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(154, 65)" end="(155, 96)">
            <AtomNode start="(154, 65)" end="(154, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(155, 5)" end="(155, 96)" kind="«term_=_»">
              <OtherNode start="(155, 5)" end="(155, 25)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(155, 5)" end="(155, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(155, 5)" end="(155, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(155, 6)" end="(155, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(155, 6)" end="(155, 20)" leading="" trailing=" " raw_val="splitRevInTwo'" val="splitRevInTwo'" full_name="List.MergeSort.Internal.splitRevInTwo'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(127, 5)" def_end="(127, 19)"/>
                    <NullNode start="(155, 21)" end="(155, 22)">
                      <IdentNode start="(155, 21)" end="(155, 22)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(155, 22)" end="(155, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(155, 23)" end="(155, 24)" leading="" trailing="" val="."/>
                <OtherNode start="(155, 24)" end="(155, 25)" kind="fieldIdx">
                  <AtomNode start="(155, 24)" end="(155, 25)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(155, 26)" end="(155, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(155, 28)" end="(155, 96)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(155, 28)" end="(155, 29)" leading="" trailing="" val="⟨"/>
                <NullNode start="(155, 29)" end="(155, 95)">
                  <OtherNode start="(155, 29)" end="(155, 79)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(155, 29)" end="(155, 77)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(155, 29)" end="(155, 75)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(155, 29)" end="(155, 30)" leading="" trailing="" val="("/>
                        <OtherNode start="(155, 30)" end="(155, 74)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(155, 30)" end="(155, 40)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                          <NullNode start="(155, 41)" end="(155, 74)">
                            <OtherNode start="(155, 41)" end="(155, 74)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(155, 41)" end="(155, 42)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(155, 42)" end="(155, 73)">
                                <OtherNode start="(155, 42)" end="(155, 53)" kind="Lean.Parser.Term.proj">
                                  <OtherNode start="(155, 42)" end="(155, 45)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(155, 42)" end="(155, 43)" leading="" trailing="" raw_val="l" val="l"/>
                                    <AtomNode start="(155, 43)" end="(155, 44)" leading="" trailing="" val="."/>
                                    <OtherNode start="(155, 44)" end="(155, 45)" kind="fieldIdx">
                                      <AtomNode start="(155, 44)" end="(155, 45)" leading="" trailing="" val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(155, 45)" end="(155, 46)" leading="" trailing="" val="."/>
                                  <IdentNode start="(155, 46)" end="(155, 53)" leading="" trailing="" raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(155, 53)" end="(155, 54)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(155, 55)" end="(155, 73)">
                                  <AtomNode start="(155, 55)" end="(155, 57)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(155, 58)" end="(155, 73)">
                                    <TacticTacticseq1IndentedNode start="(155, 58)" end="(155, 73)">
                                      <NullNode start="(155, 58)" end="(155, 73)">
                                        <OtherNode start="(155, 58)" end="(155, 73)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.69569&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.reverse.length = ?m.69618" state_after="no goals" tactic="simpa using l.2">
                                          <AtomNode start="(155, 58)" end="(155, 63)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(155, 64)" end="(155, 73)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(155, 64)" end="(155, 73)">
                                              <AtomNode start="(155, 64)" end="(155, 69)" leading="" trailing=" " val="using"/>
                                              <OtherNode start="(155, 70)" end="(155, 73)" kind="Lean.Parser.Term.proj">
                                                <IdentNode start="(155, 70)" end="(155, 71)" leading="" trailing="" raw_val="l" val="l"/>
                                                <AtomNode start="(155, 71)" end="(155, 72)" leading="" trailing="" val="."/>
                                                <OtherNode start="(155, 72)" end="(155, 73)" kind="fieldIdx">
                                                  <AtomNode start="(155, 72)" end="(155, 73)" leading="" trailing="" val="2"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(155, 73)" end="(155, 74)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(155, 74)" end="(155, 75)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(155, 75)" end="(155, 76)" leading="" trailing="" val="."/>
                      <OtherNode start="(155, 76)" end="(155, 77)" kind="fieldIdx">
                        <AtomNode start="(155, 76)" end="(155, 77)" leading="" trailing="" val="2"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(155, 77)" end="(155, 78)" leading="" trailing="" val="."/>
                    <OtherNode start="(155, 78)" end="(155, 79)" kind="fieldIdx">
                      <AtomNode start="(155, 78)" end="(155, 79)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(155, 79)" end="(155, 80)" leading="" trailing=" " val=","/>
                  <TermBytacticNode start="(155, 81)" end="(155, 95)">
                    <AtomNode start="(155, 81)" end="(155, 83)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(155, 84)" end="(155, 95)">
                      <TacticTacticseq1IndentedNode start="(155, 84)" end="(155, 95)">
                        <NullNode start="(155, 84)" end="(155, 95)">
                          <OtherNode start="(155, 84)" end="(155, 88)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.69569&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo ⟨l.val.reverse, ⋯⟩).snd.val.length = n / 2" state_after="α : Type ?u.69569&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.length - (n + 1) / 2 = n / 2" tactic="simp">
                            <AtomNode start="(155, 84)" end="(155, 88)" leading="" trailing="" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(155, 88)" end="(155, 89)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(155, 90)" end="(155, 95)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.69569&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.length - (n + 1) / 2 = n / 2" state_after="no goals" tactic="omega">
                            <AtomNode start="(155, 90)" end="(155, 95)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </NullNode>
                <AtomNode start="(155, 95)" end="(155, 96)" leading="" trailing=" " val="⟩"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(155, 97)" end="(158, 8)">
          <AtomNode start="(155, 97)" end="(155, 99)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(155, 100)" end="(158, 8)">
            <AtomNode start="(155, 100)" end="(155, 102)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(156, 3)" end="(158, 8)">
              <TacticTacticseq1IndentedNode start="(156, 3)" end="(158, 8)">
                <NullNode start="(156, 3)" end="(158, 8)">
                  <OtherNode start="(156, 3)" end="(156, 74)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitRevInTwo' l).fst = ⟨(splitInTwo ⟨l.val.reverse, ⋯⟩).snd.val, ⋯⟩" state_after="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ ⟨drop (l.val.length - n / 2) l.val.reverse, ⋯⟩ = ⟨drop ((n + 1) / 2) l.val.reverse, ⋯⟩" tactic="simp only [splitRevInTwo', splitRevAt_eq, reverse_take, splitInTwo_snd]">
                    <AtomNode start="(156, 3)" end="(156, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(156, 8)" end="(156, 12)">
                      <AtomNode start="(156, 8)" end="(156, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(156, 13)" end="(156, 74)">
                      <AtomNode start="(156, 13)" end="(156, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(156, 14)" end="(156, 73)">
                        <OtherNode start="(156, 14)" end="(156, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(156, 14)" end="(156, 28)" leading="" trailing="" raw_val="splitRevInTwo'" val="splitRevInTwo'" full_name="List.MergeSort.Internal.splitRevInTwo'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(127, 5)" def_end="(127, 19)"/>
                        </OtherNode>
                        <AtomNode start="(156, 28)" end="(156, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(156, 30)" end="(156, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(156, 30)" end="(156, 43)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                        <AtomNode start="(156, 43)" end="(156, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(156, 45)" end="(156, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(156, 45)" end="(156, 57)" leading="" trailing="" raw_val="reverse_take" val="reverse_take" full_name="List.reverse_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(156, 57)" end="(156, 58)" leading="" trailing=" " val=","/>
                        <OtherNode start="(156, 59)" end="(156, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(156, 59)" end="(156, 73)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(156, 73)" end="(156, 74)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(157, 3)" end="(157, 8)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ ⟨drop (l.val.length - n / 2) l.val.reverse, ⋯⟩ = ⟨drop ((n + 1) / 2) l.val.reverse, ⋯⟩" state_after="case e_val.e_n&#10;α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.length - n / 2 = (n + 1) / 2" tactic="congr">
                    <AtomNode start="(157, 3)" end="(157, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(158, 3)" end="(158, 8)" kind="Lean.Parser.Tactic.omega" state_before="case e_val.e_n&#10;α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.length - n / 2 = (n + 1) / 2" state_after="no goals" tactic="omega">
                    <AtomNode start="(158, 3)" end="(158, 8)" leading="" trailing="&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(159, 1)" end="(164, 8)" name="splitRevInTwo'_snd" full_name="List.MergeSort.Internal.splitRevInTwo'_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(159, 1)" end="(164, 8)" name="splitRevInTwo'_snd" full_name="List.MergeSort.Internal.splitRevInTwo'_snd" _is_private_decl="False">
        <AtomNode start="(159, 1)" end="(159, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(159, 9)" end="(159, 27)">
          <IdentNode start="(159, 9)" end="(159, 27)" leading="" trailing=" " raw_val="splitRevInTwo'_snd" val="splitRevInTwo'_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(159, 28)" end="(160, 104)">
          <NullNode start="(159, 28)" end="(159, 64)">
            <TermExplicitbinderNode start="(159, 28)" end="(159, 64)">
              <AtomNode start="(159, 28)" end="(159, 29)" leading="" trailing="" val="("/>
              <NullNode start="(159, 29)" end="(159, 30)">
                <IdentNode start="(159, 29)" end="(159, 30)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(159, 31)" end="(159, 63)">
                <AtomNode start="(159, 31)" end="(159, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(159, 33)" end="(159, 63)" kind="«term{_:_//_}»">
                  <AtomNode start="(159, 33)" end="(159, 34)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(159, 35)" end="(159, 36)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(159, 37)" end="(159, 45)">
                    <AtomNode start="(159, 37)" end="(159, 38)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(159, 39)" end="(159, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(159, 39)" end="(159, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(159, 44)" end="(159, 45)">
                        <IdentNode start="(159, 44)" end="(159, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(159, 46)" end="(159, 48)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(159, 49)" end="(159, 61)" kind="«term_=_»">
                    <IdentNode start="(159, 49)" end="(159, 57)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(159, 58)" end="(159, 59)" leading="" trailing=" " val="="/>
                    <IdentNode start="(159, 60)" end="(159, 61)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(159, 62)" end="(159, 63)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(159, 63)" end="(159, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(159, 65)" end="(160, 104)">
            <AtomNode start="(159, 65)" end="(159, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(160, 5)" end="(160, 104)" kind="«term_=_»">
              <OtherNode start="(160, 5)" end="(160, 25)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(160, 5)" end="(160, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(160, 5)" end="(160, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(160, 6)" end="(160, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(160, 6)" end="(160, 20)" leading="" trailing=" " raw_val="splitRevInTwo'" val="splitRevInTwo'" full_name="List.MergeSort.Internal.splitRevInTwo'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(127, 5)" def_end="(127, 19)"/>
                    <NullNode start="(160, 21)" end="(160, 22)">
                      <IdentNode start="(160, 21)" end="(160, 22)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(160, 22)" end="(160, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(160, 23)" end="(160, 24)" leading="" trailing="" val="."/>
                <OtherNode start="(160, 24)" end="(160, 25)" kind="fieldIdx">
                  <AtomNode start="(160, 24)" end="(160, 25)" leading="" trailing=" " val="2"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(160, 26)" end="(160, 27)" leading="" trailing=" " val="="/>
              <OtherNode start="(160, 28)" end="(160, 104)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(160, 28)" end="(160, 29)" leading="" trailing="" val="⟨"/>
                <NullNode start="(160, 29)" end="(160, 103)">
                  <OtherNode start="(160, 29)" end="(160, 87)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(160, 29)" end="(160, 79)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(160, 29)" end="(160, 77)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(160, 29)" end="(160, 75)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(160, 29)" end="(160, 30)" leading="" trailing="" val="("/>
                          <OtherNode start="(160, 30)" end="(160, 74)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(160, 30)" end="(160, 40)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                            <NullNode start="(160, 41)" end="(160, 74)">
                              <OtherNode start="(160, 41)" end="(160, 74)" kind="Lean.Parser.Term.anonymousCtor">
                                <AtomNode start="(160, 41)" end="(160, 42)" leading="" trailing="" val="⟨"/>
                                <NullNode start="(160, 42)" end="(160, 73)">
                                  <OtherNode start="(160, 42)" end="(160, 53)" kind="Lean.Parser.Term.proj">
                                    <OtherNode start="(160, 42)" end="(160, 45)" kind="Lean.Parser.Term.proj">
                                      <IdentNode start="(160, 42)" end="(160, 43)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(160, 43)" end="(160, 44)" leading="" trailing="" val="."/>
                                      <OtherNode start="(160, 44)" end="(160, 45)" kind="fieldIdx">
                                        <AtomNode start="(160, 44)" end="(160, 45)" leading="" trailing="" val="1"/>
                                      </OtherNode>
                                    </OtherNode>
                                    <AtomNode start="(160, 45)" end="(160, 46)" leading="" trailing="" val="."/>
                                    <IdentNode start="(160, 46)" end="(160, 53)" leading="" trailing="" raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  </OtherNode>
                                  <AtomNode start="(160, 53)" end="(160, 54)" leading="" trailing=" " val=","/>
                                  <TermBytacticNode start="(160, 55)" end="(160, 73)">
                                    <AtomNode start="(160, 55)" end="(160, 57)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(160, 58)" end="(160, 73)">
                                      <TacticTacticseq1IndentedNode start="(160, 58)" end="(160, 73)">
                                        <NullNode start="(160, 58)" end="(160, 73)">
                                          <OtherNode start="(160, 58)" end="(160, 73)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type ?u.73064&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.reverse.length = ?m.73113" state_after="no goals" tactic="simpa using l.2">
                                            <AtomNode start="(160, 58)" end="(160, 63)" leading="" trailing=" " val="simpa"/>
                                            <NullNode/>
                                            <NullNode/>
                                            <OtherNode start="(160, 64)" end="(160, 73)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(160, 64)" end="(160, 73)">
                                                <AtomNode start="(160, 64)" end="(160, 69)" leading="" trailing=" " val="using"/>
                                                <OtherNode start="(160, 70)" end="(160, 73)" kind="Lean.Parser.Term.proj">
                                                  <IdentNode start="(160, 70)" end="(160, 71)" leading="" trailing="" raw_val="l" val="l"/>
                                                  <AtomNode start="(160, 71)" end="(160, 72)" leading="" trailing="" val="."/>
                                                  <OtherNode start="(160, 72)" end="(160, 73)" kind="fieldIdx">
                                                    <AtomNode start="(160, 72)" end="(160, 73)" leading="" trailing="" val="2"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                </NullNode>
                                <AtomNode start="(160, 73)" end="(160, 74)" leading="" trailing="" val="⟩"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(160, 74)" end="(160, 75)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(160, 75)" end="(160, 76)" leading="" trailing="" val="."/>
                        <OtherNode start="(160, 76)" end="(160, 77)" kind="fieldIdx">
                          <AtomNode start="(160, 76)" end="(160, 77)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(160, 77)" end="(160, 78)" leading="" trailing="" val="."/>
                      <OtherNode start="(160, 78)" end="(160, 79)" kind="fieldIdx">
                        <AtomNode start="(160, 78)" end="(160, 79)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(160, 79)" end="(160, 80)" leading="" trailing="" val="."/>
                    <IdentNode start="(160, 80)" end="(160, 87)" leading="" trailing="" raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <AtomNode start="(160, 87)" end="(160, 88)" leading="" trailing=" " val=","/>
                  <TermBytacticNode start="(160, 89)" end="(160, 103)">
                    <AtomNode start="(160, 89)" end="(160, 91)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(160, 92)" end="(160, 103)">
                      <TacticTacticseq1IndentedNode start="(160, 92)" end="(160, 103)">
                        <NullNode start="(160, 92)" end="(160, 103)">
                          <OtherNode start="(160, 92)" end="(160, 96)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.73064&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo ⟨l.val.reverse, ⋯⟩).fst.val.reverse.length = (n + 1) / 2" state_after="α : Type ?u.73064&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ min ((n + 1) / 2) l.val.length = (n + 1) / 2" tactic="simp">
                            <AtomNode start="(160, 92)" end="(160, 96)" leading="" trailing="" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(160, 96)" end="(160, 97)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(160, 98)" end="(160, 103)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.73064&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ min ((n + 1) / 2) l.val.length = (n + 1) / 2" state_after="no goals" tactic="omega">
                            <AtomNode start="(160, 98)" end="(160, 103)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </NullNode>
                <AtomNode start="(160, 103)" end="(160, 104)" leading="" trailing=" " val="⟩"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(160, 105)" end="(164, 8)">
          <AtomNode start="(160, 105)" end="(160, 107)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(160, 108)" end="(164, 8)">
            <AtomNode start="(160, 108)" end="(160, 110)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(161, 3)" end="(164, 8)">
              <TacticTacticseq1IndentedNode start="(161, 3)" end="(164, 8)">
                <NullNode start="(161, 3)" end="(164, 8)">
                  <OtherNode start="(161, 3)" end="(161, 91)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitRevInTwo' l).snd = ⟨(splitInTwo ⟨l.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩" state_after="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ ⟨drop (n / 2) l.val, ⋯⟩ = ⟨drop (l.val.reverse.length - (n + 1) / 2) l.val, ⋯⟩" tactic="simp only [splitRevInTwo', splitRevAt_eq, reverse_take, splitInTwo_fst, reverse_reverse]">
                    <AtomNode start="(161, 3)" end="(161, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(161, 8)" end="(161, 12)">
                      <AtomNode start="(161, 8)" end="(161, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(161, 13)" end="(161, 91)">
                      <AtomNode start="(161, 13)" end="(161, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(161, 14)" end="(161, 90)">
                        <OtherNode start="(161, 14)" end="(161, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(161, 14)" end="(161, 28)" leading="" trailing="" raw_val="splitRevInTwo'" val="splitRevInTwo'" full_name="List.MergeSort.Internal.splitRevInTwo'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(127, 5)" def_end="(127, 19)"/>
                        </OtherNode>
                        <AtomNode start="(161, 28)" end="(161, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(161, 30)" end="(161, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(161, 30)" end="(161, 43)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                        <AtomNode start="(161, 43)" end="(161, 44)" leading="" trailing=" " val=","/>
                        <OtherNode start="(161, 45)" end="(161, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(161, 45)" end="(161, 57)" leading="" trailing="" raw_val="reverse_take" val="reverse_take" full_name="List.reverse_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(161, 57)" end="(161, 58)" leading="" trailing=" " val=","/>
                        <OtherNode start="(161, 59)" end="(161, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(161, 59)" end="(161, 73)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(161, 73)" end="(161, 74)" leading="" trailing=" " val=","/>
                        <OtherNode start="(161, 75)" end="(161, 90)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(161, 75)" end="(161, 90)" leading="" trailing="" raw_val="reverse_reverse" val="reverse_reverse" full_name="List.reverse_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(161, 90)" end="(161, 91)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(162, 3)" end="(162, 10)" kind="Lean.Parser.Tactic.congr" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ ⟨drop (n / 2) l.val, ⋯⟩ = ⟨drop (l.val.reverse.length - (n + 1) / 2) l.val, ⋯⟩" state_after="case e_val.e_n&#10;α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ n / 2 = l.val.reverse.length - (n + 1) / 2" tactic="congr 2">
                    <AtomNode start="(162, 3)" end="(162, 8)" leading="" trailing=" " val="congr"/>
                    <NullNode start="(162, 9)" end="(162, 10)">
                      <OtherNode start="(162, 9)" end="(162, 10)" kind="num">
                        <AtomNode start="(162, 9)" end="(162, 10)" leading="" trailing="&#10;  " val="2"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(163, 3)" end="(163, 7)" kind="Lean.Parser.Tactic.simp" state_before="case e_val.e_n&#10;α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ n / 2 = l.val.reverse.length - (n + 1) / 2" state_after="case e_val.e_n&#10;α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ n / 2 = l.val.length - (n + 1) / 2" tactic="simp">
                    <AtomNode start="(163, 3)" end="(163, 7)" leading="" trailing="&#10;  " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(164, 3)" end="(164, 8)" kind="Lean.Parser.Tactic.omega" state_before="case e_val.e_n&#10;α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ n / 2 = l.val.length - (n + 1) / 2" state_after="no goals" tactic="omega">
                    <AtomNode start="(164, 3)" end="(164, 8)" leading="" trailing="&#10;" val="omega"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(165, 1)" end="(167, 73)" name="splitRevInTwo_fst" full_name="List.MergeSort.Internal.splitRevInTwo_fst">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(165, 1)" end="(167, 73)" name="splitRevInTwo_fst" full_name="List.MergeSort.Internal.splitRevInTwo_fst" _is_private_decl="False">
        <AtomNode start="(165, 1)" end="(165, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(165, 9)" end="(165, 26)">
          <IdentNode start="(165, 9)" end="(165, 26)" leading="" trailing=" " raw_val="splitRevInTwo_fst" val="splitRevInTwo_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(165, 27)" end="(166, 71)">
          <NullNode start="(165, 27)" end="(165, 63)">
            <TermExplicitbinderNode start="(165, 27)" end="(165, 63)">
              <AtomNode start="(165, 27)" end="(165, 28)" leading="" trailing="" val="("/>
              <NullNode start="(165, 28)" end="(165, 29)">
                <IdentNode start="(165, 28)" end="(165, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(165, 30)" end="(165, 62)">
                <AtomNode start="(165, 30)" end="(165, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(165, 32)" end="(165, 62)" kind="«term{_:_//_}»">
                  <AtomNode start="(165, 32)" end="(165, 33)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(165, 34)" end="(165, 35)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(165, 36)" end="(165, 44)">
                    <AtomNode start="(165, 36)" end="(165, 37)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(165, 38)" end="(165, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(165, 38)" end="(165, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(165, 43)" end="(165, 44)">
                        <IdentNode start="(165, 43)" end="(165, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(165, 45)" end="(165, 47)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(165, 48)" end="(165, 60)" kind="«term_=_»">
                    <IdentNode start="(165, 48)" end="(165, 56)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(165, 57)" end="(165, 58)" leading="" trailing=" " val="="/>
                    <IdentNode start="(165, 59)" end="(165, 60)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(165, 61)" end="(165, 62)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(165, 62)" end="(165, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(165, 64)" end="(166, 71)">
            <AtomNode start="(165, 64)" end="(165, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(166, 5)" end="(166, 71)" kind="«term_=_»">
              <OtherNode start="(166, 5)" end="(166, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(166, 5)" end="(166, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(166, 5)" end="(166, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(166, 6)" end="(166, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(166, 6)" end="(166, 19)" leading="" trailing=" " raw_val="splitRevInTwo" val="splitRevInTwo" full_name="List.MergeSort.Internal.splitRevInTwo" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(118, 5)" def_end="(118, 18)"/>
                    <NullNode start="(166, 20)" end="(166, 21)">
                      <IdentNode start="(166, 20)" end="(166, 21)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(166, 21)" end="(166, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(166, 22)" end="(166, 23)" leading="" trailing="" val="."/>
                <OtherNode start="(166, 23)" end="(166, 24)" kind="fieldIdx">
                  <AtomNode start="(166, 23)" end="(166, 24)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(166, 25)" end="(166, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(166, 27)" end="(166, 71)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(166, 27)" end="(166, 28)" leading="" trailing="" val="⟨"/>
                <NullNode start="(166, 28)" end="(166, 70)">
                  <OtherNode start="(166, 28)" end="(166, 54)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(166, 28)" end="(166, 46)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(166, 28)" end="(166, 44)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(166, 28)" end="(166, 42)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(166, 28)" end="(166, 29)" leading="" trailing="" val="("/>
                          <OtherNode start="(166, 29)" end="(166, 41)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(166, 29)" end="(166, 39)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                            <NullNode start="(166, 40)" end="(166, 41)">
                              <IdentNode start="(166, 40)" end="(166, 41)" leading="" trailing="" raw_val="l" val="l"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(166, 41)" end="(166, 42)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(166, 42)" end="(166, 43)" leading="" trailing="" val="."/>
                        <OtherNode start="(166, 43)" end="(166, 44)" kind="fieldIdx">
                          <AtomNode start="(166, 43)" end="(166, 44)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(166, 44)" end="(166, 45)" leading="" trailing="" val="."/>
                      <OtherNode start="(166, 45)" end="(166, 46)" kind="fieldIdx">
                        <AtomNode start="(166, 45)" end="(166, 46)" leading="" trailing="" val="1"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(166, 46)" end="(166, 47)" leading="" trailing="" val="."/>
                    <IdentNode start="(166, 47)" end="(166, 54)" leading="" trailing="" raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                  </OtherNode>
                  <AtomNode start="(166, 54)" end="(166, 55)" leading="" trailing=" " val=","/>
                  <TermBytacticNode start="(166, 56)" end="(166, 70)">
                    <AtomNode start="(166, 56)" end="(166, 58)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(166, 59)" end="(166, 70)">
                      <TacticTacticseq1IndentedNode start="(166, 59)" end="(166, 70)">
                        <NullNode start="(166, 59)" end="(166, 70)">
                          <OtherNode start="(166, 59)" end="(166, 63)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.75897&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo l).fst.val.reverse.length = (n + 1) / 2" state_after="α : Type ?u.75897&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ min ((n + 1) / 2) l.val.length = (n + 1) / 2" tactic="simp">
                            <AtomNode start="(166, 59)" end="(166, 63)" leading="" trailing="" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(166, 63)" end="(166, 64)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(166, 65)" end="(166, 70)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.75897&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ min ((n + 1) / 2) l.val.length = (n + 1) / 2" state_after="no goals" tactic="omega">
                            <AtomNode start="(166, 65)" end="(166, 70)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </NullNode>
                <AtomNode start="(166, 70)" end="(166, 71)" leading="" trailing=" " val="⟩"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(166, 72)" end="(167, 73)">
          <AtomNode start="(166, 72)" end="(166, 74)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(166, 75)" end="(167, 73)">
            <AtomNode start="(166, 75)" end="(166, 77)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(167, 3)" end="(167, 73)">
              <TacticTacticseq1IndentedNode start="(167, 3)" end="(167, 73)">
                <NullNode start="(167, 3)" end="(167, 73)">
                  <OtherNode start="(167, 3)" end="(167, 73)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitRevInTwo l).fst = ⟨(splitInTwo l).fst.val.reverse, ⋯⟩" state_after="no goals" tactic="simp only [splitRevInTwo, splitRevAt_eq, reverse_take, splitInTwo_fst]">
                    <AtomNode start="(167, 3)" end="(167, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(167, 8)" end="(167, 12)">
                      <AtomNode start="(167, 8)" end="(167, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(167, 13)" end="(167, 73)">
                      <AtomNode start="(167, 13)" end="(167, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(167, 14)" end="(167, 72)">
                        <OtherNode start="(167, 14)" end="(167, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(167, 14)" end="(167, 27)" leading="" trailing="" raw_val="splitRevInTwo" val="splitRevInTwo" full_name="List.MergeSort.Internal.splitRevInTwo" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(118, 5)" def_end="(118, 18)"/>
                        </OtherNode>
                        <AtomNode start="(167, 27)" end="(167, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(167, 29)" end="(167, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(167, 29)" end="(167, 42)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                        <AtomNode start="(167, 42)" end="(167, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(167, 44)" end="(167, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(167, 44)" end="(167, 56)" leading="" trailing="" raw_val="reverse_take" val="reverse_take" full_name="List.reverse_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(167, 56)" end="(167, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(167, 58)" end="(167, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(167, 58)" end="(167, 72)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(167, 72)" end="(167, 73)" leading="" trailing="&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(168, 1)" end="(170, 73)" name="splitRevInTwo_snd" full_name="List.MergeSort.Internal.splitRevInTwo_snd">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(168, 1)" end="(170, 73)" name="splitRevInTwo_snd" full_name="List.MergeSort.Internal.splitRevInTwo_snd" _is_private_decl="False">
        <AtomNode start="(168, 1)" end="(168, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(168, 9)" end="(168, 26)">
          <IdentNode start="(168, 9)" end="(168, 26)" leading="" trailing=" " raw_val="splitRevInTwo_snd" val="splitRevInTwo_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(168, 27)" end="(169, 63)">
          <NullNode start="(168, 27)" end="(168, 63)">
            <TermExplicitbinderNode start="(168, 27)" end="(168, 63)">
              <AtomNode start="(168, 27)" end="(168, 28)" leading="" trailing="" val="("/>
              <NullNode start="(168, 28)" end="(168, 29)">
                <IdentNode start="(168, 28)" end="(168, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(168, 30)" end="(168, 62)">
                <AtomNode start="(168, 30)" end="(168, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 32)" end="(168, 62)" kind="«term{_:_//_}»">
                  <AtomNode start="(168, 32)" end="(168, 33)" leading="" trailing=" " val="{"/>
                  <IdentNode start="(168, 34)" end="(168, 35)" leading="" trailing=" " raw_val="l" val="l"/>
                  <NullNode start="(168, 36)" end="(168, 44)">
                    <AtomNode start="(168, 36)" end="(168, 37)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(168, 38)" end="(168, 44)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(168, 38)" end="(168, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(168, 43)" end="(168, 44)">
                        <IdentNode start="(168, 43)" end="(168, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(168, 45)" end="(168, 47)" leading="" trailing=" " val="//"/>
                  <OtherNode start="(168, 48)" end="(168, 60)" kind="«term_=_»">
                    <IdentNode start="(168, 48)" end="(168, 56)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                    <AtomNode start="(168, 57)" end="(168, 58)" leading="" trailing=" " val="="/>
                    <IdentNode start="(168, 59)" end="(168, 60)" leading="" trailing=" " raw_val="n" val="n"/>
                  </OtherNode>
                  <AtomNode start="(168, 61)" end="(168, 62)" leading="" trailing="" val="}"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(168, 62)" end="(168, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(168, 64)" end="(169, 63)">
            <AtomNode start="(168, 64)" end="(168, 65)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(169, 5)" end="(169, 63)" kind="«term_=_»">
              <OtherNode start="(169, 5)" end="(169, 24)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(169, 5)" end="(169, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(169, 5)" end="(169, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(169, 6)" end="(169, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(169, 6)" end="(169, 19)" leading="" trailing=" " raw_val="splitRevInTwo" val="splitRevInTwo" full_name="List.MergeSort.Internal.splitRevInTwo" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(118, 5)" def_end="(118, 18)"/>
                    <NullNode start="(169, 20)" end="(169, 21)">
                      <IdentNode start="(169, 20)" end="(169, 21)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(169, 21)" end="(169, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(169, 22)" end="(169, 23)" leading="" trailing="" val="."/>
                <OtherNode start="(169, 23)" end="(169, 24)" kind="fieldIdx">
                  <AtomNode start="(169, 23)" end="(169, 24)" leading="" trailing=" " val="2"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(169, 25)" end="(169, 26)" leading="" trailing=" " val="="/>
              <OtherNode start="(169, 27)" end="(169, 63)" kind="Lean.Parser.Term.anonymousCtor">
                <AtomNode start="(169, 27)" end="(169, 28)" leading="" trailing="" val="⟨"/>
                <NullNode start="(169, 28)" end="(169, 62)">
                  <OtherNode start="(169, 28)" end="(169, 46)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(169, 28)" end="(169, 44)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(169, 28)" end="(169, 42)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(169, 28)" end="(169, 29)" leading="" trailing="" val="("/>
                        <OtherNode start="(169, 29)" end="(169, 41)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(169, 29)" end="(169, 39)" leading="" trailing=" " raw_val="splitInTwo" val="splitInTwo" full_name="List.MergeSort.Internal.splitInTwo" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                          <NullNode start="(169, 40)" end="(169, 41)">
                            <IdentNode start="(169, 40)" end="(169, 41)" leading="" trailing="" raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(169, 41)" end="(169, 42)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(169, 42)" end="(169, 43)" leading="" trailing="" val="."/>
                      <OtherNode start="(169, 43)" end="(169, 44)" kind="fieldIdx">
                        <AtomNode start="(169, 43)" end="(169, 44)" leading="" trailing="" val="2"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(169, 44)" end="(169, 45)" leading="" trailing="" val="."/>
                    <OtherNode start="(169, 45)" end="(169, 46)" kind="fieldIdx">
                      <AtomNode start="(169, 45)" end="(169, 46)" leading="" trailing="" val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(169, 46)" end="(169, 47)" leading="" trailing=" " val=","/>
                  <TermBytacticNode start="(169, 48)" end="(169, 62)">
                    <AtomNode start="(169, 48)" end="(169, 50)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(169, 51)" end="(169, 62)">
                      <TacticTacticseq1IndentedNode start="(169, 51)" end="(169, 62)">
                        <NullNode start="(169, 51)" end="(169, 62)">
                          <OtherNode start="(169, 51)" end="(169, 55)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.77122&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitInTwo l).snd.val.length = n / 2" state_after="α : Type ?u.77122&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.length - (n + 1) / 2 = n / 2" tactic="simp">
                            <AtomNode start="(169, 51)" end="(169, 55)" leading="" trailing="" val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(169, 55)" end="(169, 56)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(169, 57)" end="(169, 62)" kind="Lean.Parser.Tactic.omega" state_before="α : Type ?u.77122&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ l.val.length - (n + 1) / 2 = n / 2" state_after="no goals" tactic="omega">
                            <AtomNode start="(169, 57)" end="(169, 62)" leading="" trailing="" val="omega"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </NullNode>
                <AtomNode start="(169, 62)" end="(169, 63)" leading="" trailing=" " val="⟩"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(169, 64)" end="(170, 73)">
          <AtomNode start="(169, 64)" end="(169, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(169, 67)" end="(170, 73)">
            <AtomNode start="(169, 67)" end="(169, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(170, 3)" end="(170, 73)">
              <TacticTacticseq1IndentedNode start="(170, 3)" end="(170, 73)">
                <NullNode start="(170, 3)" end="(170, 73)">
                  <OtherNode start="(170, 3)" end="(170, 73)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;l : { l // l.length = n }&#10;⊢ (splitRevInTwo l).snd = ⟨(splitInTwo l).snd.val, ⋯⟩" state_after="no goals" tactic="simp only [splitRevInTwo, splitRevAt_eq, reverse_take, splitInTwo_snd]">
                    <AtomNode start="(170, 3)" end="(170, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(170, 8)" end="(170, 12)">
                      <AtomNode start="(170, 8)" end="(170, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(170, 13)" end="(170, 73)">
                      <AtomNode start="(170, 13)" end="(170, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(170, 14)" end="(170, 72)">
                        <OtherNode start="(170, 14)" end="(170, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(170, 14)" end="(170, 27)" leading="" trailing="" raw_val="splitRevInTwo" val="splitRevInTwo" full_name="List.MergeSort.Internal.splitRevInTwo" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(118, 5)" def_end="(118, 18)"/>
                        </OtherNode>
                        <AtomNode start="(170, 27)" end="(170, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(170, 29)" end="(170, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(170, 29)" end="(170, 42)" leading="" trailing="" raw_val="splitRevAt_eq" val="splitRevAt_eq" full_name="List.MergeSort.Internal.splitRevAt_eq" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(95, 9)" def_end="(95, 22)"/>
                        </OtherNode>
                        <AtomNode start="(170, 42)" end="(170, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(170, 44)" end="(170, 56)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(170, 44)" end="(170, 56)" leading="" trailing="" raw_val="reverse_take" val="reverse_take" full_name="List.reverse_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                        </OtherNode>
                        <AtomNode start="(170, 56)" end="(170, 57)" leading="" trailing=" " val=","/>
                        <OtherNode start="(170, 58)" end="(170, 72)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(170, 58)" end="(170, 72)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(170, 72)" end="(170, 73)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(172, 1)" end="(179, 68)" name="mergeSortTR_run_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR_run_eq_mergeSort">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(172, 1)" end="(179, 68)" name="mergeSortTR_run_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR_run_eq_mergeSort" _is_private_decl="False">
        <AtomNode start="(172, 1)" end="(172, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(172, 9)" end="(172, 37)">
          <IdentNode start="(172, 9)" end="(172, 37)" leading="" trailing=" " raw_val="mergeSortTR_run_eq_mergeSort" val="mergeSortTR_run_eq_mergeSort"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(172, 38)" end="(172, 130)">
          <NullNode/>
          <TermTypespecNode start="(172, 38)" end="(172, 130)">
            <AtomNode start="(172, 38)" end="(172, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(172, 40)" end="(172, 130)" kind="Lean.Parser.Term.depArrow">
              <OtherNode start="(172, 40)" end="(172, 49)" kind="Lean.Parser.Term.implicitBinder">
                <AtomNode start="(172, 40)" end="(172, 41)" leading="" trailing="" val="{"/>
                <NullNode start="(172, 41)" end="(172, 42)">
                  <IdentNode start="(172, 41)" end="(172, 42)" leading="" trailing=" " raw_val="n" val="n"/>
                </NullNode>
                <NullNode start="(172, 43)" end="(172, 48)">
                  <AtomNode start="(172, 43)" end="(172, 44)" leading="" trailing=" " val=":"/>
                  <IdentNode start="(172, 45)" end="(172, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
                <AtomNode start="(172, 48)" end="(172, 49)" leading="" trailing=" " val="}"/>
              </OtherNode>
              <AtomNode start="(172, 50)" end="(172, 51)" leading="" trailing=" " val="→"/>
              <OtherNode start="(172, 52)" end="(172, 130)" kind="Lean.Parser.Term.depArrow">
                <TermExplicitbinderNode start="(172, 52)" end="(172, 88)">
                  <AtomNode start="(172, 52)" end="(172, 53)" leading="" trailing="" val="("/>
                  <NullNode start="(172, 53)" end="(172, 54)">
                    <IdentNode start="(172, 53)" end="(172, 54)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                  <NullNode start="(172, 55)" end="(172, 87)">
                    <AtomNode start="(172, 55)" end="(172, 56)" leading="" trailing=" " val=":"/>
                    <OtherNode start="(172, 57)" end="(172, 87)" kind="«term{_:_//_}»">
                      <AtomNode start="(172, 57)" end="(172, 58)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(172, 59)" end="(172, 60)" leading="" trailing=" " raw_val="l" val="l"/>
                      <NullNode start="(172, 61)" end="(172, 69)">
                        <AtomNode start="(172, 61)" end="(172, 62)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(172, 63)" end="(172, 69)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(172, 63)" end="(172, 67)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode start="(172, 68)" end="(172, 69)">
                            <IdentNode start="(172, 68)" end="(172, 69)" leading="" trailing=" " raw_val="α" val="α"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(172, 70)" end="(172, 72)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(172, 73)" end="(172, 85)" kind="«term_=_»">
                        <IdentNode start="(172, 73)" end="(172, 81)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                        <AtomNode start="(172, 82)" end="(172, 83)" leading="" trailing=" " val="="/>
                        <IdentNode start="(172, 84)" end="(172, 85)" leading="" trailing=" " raw_val="n" val="n"/>
                      </OtherNode>
                      <AtomNode start="(172, 86)" end="(172, 87)" leading="" trailing="" val="}"/>
                    </OtherNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(172, 87)" end="(172, 88)" leading="" trailing=" " val=")"/>
                </TermExplicitbinderNode>
                <AtomNode start="(172, 89)" end="(172, 90)" leading="" trailing=" " val="→"/>
                <OtherNode start="(172, 91)" end="(172, 130)" kind="«term_=_»">
                  <OtherNode start="(172, 91)" end="(172, 111)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(172, 91)" end="(172, 106)" leading="" trailing=" " raw_val="mergeSortTR.run" val="mergeSortTR.run" full_name="List.MergeSort.Internal.mergeSortTR.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(107, 7)" def_end="(107, 10)"/>
                    <NullNode start="(172, 107)" end="(172, 111)">
                      <IdentNode start="(172, 107)" end="(172, 109)" leading="" trailing=" " raw_val="le" val="le"/>
                      <IdentNode start="(172, 110)" end="(172, 111)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(172, 112)" end="(172, 113)" leading="" trailing=" " val="="/>
                  <OtherNode start="(172, 114)" end="(172, 130)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(172, 114)" end="(172, 123)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                    <NullNode start="(172, 124)" end="(172, 130)">
                      <OtherNode start="(172, 124)" end="(172, 127)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(172, 124)" end="(172, 125)" leading="" trailing="" raw_val="l" val="l"/>
                        <AtomNode start="(172, 125)" end="(172, 126)" leading="" trailing="" val="."/>
                        <OtherNode start="(172, 126)" end="(172, 127)" kind="fieldIdx">
                          <AtomNode start="(172, 126)" end="(172, 127)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <IdentNode start="(172, 128)" end="(172, 130)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(173, 3)" end="(179, 68)">
          <OtherNode start="(173, 3)" end="(179, 68)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(173, 3)" end="(179, 68)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(173, 3)" end="(179, 68)">
                <OtherNode start="(173, 3)" end="(174, 56)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(173, 3)" end="(173, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(173, 5)" end="(174, 16)">
                    <NullNode start="(173, 5)" end="(173, 15)">
                      <OtherNode start="(173, 5)" end="(173, 6)" kind="num">
                        <AtomNode start="(173, 5)" end="(173, 6)" leading="" trailing="" val="0"/>
                      </OtherNode>
                      <AtomNode start="(173, 6)" end="(173, 7)" leading="" trailing=" " val=","/>
                      <OtherNode start="(173, 8)" end="(173, 15)" kind="Lean.Parser.Term.anonymousCtor">
                        <AtomNode start="(173, 8)" end="(173, 9)" leading="" trailing="" val="⟨"/>
                        <NullNode start="(173, 9)" end="(173, 14)">
                          <OtherNode start="(173, 9)" end="(173, 11)" kind="«term[_]»">
                            <AtomNode start="(173, 9)" end="(173, 10)" leading="" trailing="" val="["/>
                            <NullNode/>
                            <AtomNode start="(173, 10)" end="(173, 11)" leading="" trailing="" val="]"/>
                          </OtherNode>
                          <AtomNode start="(173, 11)" end="(173, 12)" leading="" trailing=" " val=","/>
                          <TermHoleNode start="(173, 13)" end="(173, 14)">
                            <AtomNode start="(173, 13)" end="(173, 14)" leading="" trailing="" val="_"/>
                          </TermHoleNode>
                        </NullNode>
                        <AtomNode start="(173, 14)" end="(173, 15)" leading="" trailing="&#10;  " val="⟩"/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(174, 3)" end="(174, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(174, 5)" end="(174, 16)">
                      <OtherNode start="(174, 5)" end="(174, 6)" kind="num">
                        <AtomNode start="(174, 5)" end="(174, 6)" leading="" trailing="" val="1"/>
                      </OtherNode>
                      <AtomNode start="(174, 6)" end="(174, 7)" leading="" trailing=" " val=","/>
                      <OtherNode start="(174, 8)" end="(174, 16)" kind="Lean.Parser.Term.anonymousCtor">
                        <AtomNode start="(174, 8)" end="(174, 9)" leading="" trailing="" val="⟨"/>
                        <NullNode start="(174, 9)" end="(174, 15)">
                          <OtherNode start="(174, 9)" end="(174, 12)" kind="«term[_]»">
                            <AtomNode start="(174, 9)" end="(174, 10)" leading="" trailing="" val="["/>
                            <NullNode start="(174, 10)" end="(174, 11)">
                              <IdentNode start="(174, 10)" end="(174, 11)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                            <AtomNode start="(174, 11)" end="(174, 12)" leading="" trailing="" val="]"/>
                          </OtherNode>
                          <AtomNode start="(174, 12)" end="(174, 13)" leading="" trailing=" " val=","/>
                          <TermHoleNode start="(174, 14)" end="(174, 15)">
                            <AtomNode start="(174, 14)" end="(174, 15)" leading="" trailing="" val="_"/>
                          </TermHoleNode>
                        </NullNode>
                        <AtomNode start="(174, 15)" end="(174, 16)" leading="" trailing=" " val="⟩"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(174, 17)" end="(174, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(174, 20)" end="(174, 56)">
                    <AtomNode start="(174, 20)" end="(174, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(174, 23)" end="(174, 56)">
                      <TacticTacticseq1IndentedNode start="(174, 23)" end="(174, 56)">
                        <NullNode start="(174, 23)" end="(174, 56)">
                          <OtherNode start="(174, 23)" end="(174, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a : α&#10;property✝ : [a].length = 1&#10;⊢ mergeSortTR.run le ⟨[a], property✝⟩ = ⟨[a], property✝⟩.val.mergeSort le" state_after="no goals" tactic="simp [mergeSortTR.run, mergeSort]">
                            <AtomNode start="(174, 23)" end="(174, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(174, 28)" end="(174, 56)">
                              <AtomNode start="(174, 28)" end="(174, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(174, 29)" end="(174, 55)">
                                <OtherNode start="(174, 29)" end="(174, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(174, 29)" end="(174, 44)" leading="" trailing="" raw_val="mergeSortTR.run" val="mergeSortTR.run" full_name="List.MergeSort.Internal.mergeSortTR.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(107, 7)" def_end="(107, 10)"/>
                                </OtherNode>
                                <AtomNode start="(174, 44)" end="(174, 45)" leading="" trailing=" " val=","/>
                                <OtherNode start="(174, 46)" end="(174, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(174, 46)" end="(174, 55)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(174, 55)" end="(174, 56)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(175, 3)" end="(179, 68)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(175, 3)" end="(175, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(175, 5)" end="(175, 26)">
                    <NullNode start="(175, 5)" end="(175, 26)">
                      <OtherNode start="(175, 5)" end="(175, 8)" kind="«term_+_»">
                        <IdentNode start="(175, 5)" end="(175, 6)" leading="" trailing="" raw_val="n" val="n"/>
                        <AtomNode start="(175, 6)" end="(175, 7)" leading="" trailing="" val="+"/>
                        <OtherNode start="(175, 7)" end="(175, 8)" kind="num">
                          <AtomNode start="(175, 7)" end="(175, 8)" leading="" trailing="" val="2"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(175, 8)" end="(175, 9)" leading="" trailing=" " val=","/>
                      <OtherNode start="(175, 10)" end="(175, 26)" kind="Lean.Parser.Term.anonymousCtor">
                        <AtomNode start="(175, 10)" end="(175, 11)" leading="" trailing="" val="⟨"/>
                        <NullNode start="(175, 11)" end="(175, 25)">
                          <OtherNode start="(175, 11)" end="(175, 22)" kind="«term_::_»">
                            <IdentNode start="(175, 11)" end="(175, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                            <AtomNode start="(175, 13)" end="(175, 15)" leading="" trailing=" " val="::"/>
                            <OtherNode start="(175, 16)" end="(175, 22)" kind="«term_::_»">
                              <IdentNode start="(175, 16)" end="(175, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                              <AtomNode start="(175, 18)" end="(175, 20)" leading="" trailing=" " val="::"/>
                              <IdentNode start="(175, 21)" end="(175, 22)" leading="" trailing="" raw_val="l" val="l"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(175, 22)" end="(175, 23)" leading="" trailing=" " val=","/>
                          <IdentNode start="(175, 24)" end="(175, 25)" leading="" trailing="" raw_val="h" val="h"/>
                        </NullNode>
                        <AtomNode start="(175, 25)" end="(175, 26)" leading="" trailing=" " val="⟩"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(175, 27)" end="(175, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(175, 30)" end="(179, 68)">
                    <AtomNode start="(175, 30)" end="(175, 32)" leading="" trailing="&#10;    " val="by"/>
                    <TacticTacticseqNode start="(176, 5)" end="(179, 68)">
                      <TacticTacticseq1IndentedNode start="(176, 5)" end="(179, 68)">
                        <NullNode start="(176, 5)" end="(179, 68)">
                          <OtherNode start="(176, 5)" end="(176, 12)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;le : α → α → Bool&#10;n : Nat&#10;a b : α&#10;l : List α&#10;h : (a :: b :: l).length = n + 2&#10;⊢ mergeSortTR.run le ⟨a :: b :: l, h⟩ = ⟨a :: b :: l, h⟩.val.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeSortTR.run le ⟨a :: b :: l, ⋯⟩ = ⟨a :: b :: l, ⋯⟩.val.mergeSort le" tactic="cases h">
                            <AtomNode start="(176, 5)" end="(176, 10)" leading="" trailing=" " val="cases"/>
                            <NullNode start="(176, 11)" end="(176, 12)">
                              <OtherNode start="(176, 11)" end="(176, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                <NullNode/>
                                <IdentNode start="(176, 11)" end="(176, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(177, 5)" end="(177, 60)" kind="Lean.Parser.Tactic.simp" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeSortTR.run le ⟨a :: b :: l, ⋯⟩ = ⟨a :: b :: l, ⋯⟩.val.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).fst) (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).snd)&#10;      le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" tactic="simp only [mergeSortTR.run, mergeSortTR.run, mergeSort]">
                            <AtomNode start="(177, 5)" end="(177, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(177, 10)" end="(177, 14)">
                              <AtomNode start="(177, 10)" end="(177, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(177, 15)" end="(177, 60)">
                              <AtomNode start="(177, 15)" end="(177, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(177, 16)" end="(177, 59)">
                                <OtherNode start="(177, 16)" end="(177, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(177, 16)" end="(177, 31)" leading="" trailing="" raw_val="mergeSortTR.run" val="mergeSortTR.run" full_name="List.MergeSort.Internal.mergeSortTR.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(107, 7)" def_end="(107, 10)"/>
                                </OtherNode>
                                <AtomNode start="(177, 31)" end="(177, 32)" leading="" trailing=" " val=","/>
                                <OtherNode start="(177, 33)" end="(177, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(177, 33)" end="(177, 48)" leading="" trailing="" raw_val="mergeSortTR.run" val="mergeSortTR.run" full_name="List.MergeSort.Internal.mergeSortTR.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(107, 7)" def_end="(107, 10)"/>
                                </OtherNode>
                                <AtomNode start="(177, 48)" end="(177, 49)" leading="" trailing=" " val=","/>
                                <OtherNode start="(177, 50)" end="(177, 59)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(177, 50)" end="(177, 59)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(177, 59)" end="(177, 60)" leading="" trailing="&#10;    " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(178, 5)" end="(178, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).fst) (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).snd)&#10;      le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).fst) (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).snd)&#10;      le =&#10;    mergeTR ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le) ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" tactic="rw [merge_eq_mergeTR]">
                            <AtomNode start="(178, 5)" end="(178, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(178, 8)" end="(178, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(178, 8)" end="(178, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(178, 9)" end="(178, 25)">
                                <OtherNode start="(178, 9)" end="(178, 25)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(178, 9)" end="(178, 25)" leading="" trailing="" raw_val="merge_eq_mergeTR" val="merge_eq_mergeTR" full_name="List.MergeSort.Internal.merge_eq_mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(67, 18)" def_end="(67, 34)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(178, 25)" end="(178, 26)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(179, 5)" end="(179, 68)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).fst) (mergeSortTR.run le (splitInTwo ⟨a :: b :: l, ⋯⟩).snd)&#10;      le =&#10;    mergeTR ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le) ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" state_after="no goals" tactic="rw [mergeSortTR_run_eq_mergeSort, mergeSortTR_run_eq_mergeSort]">
                            <AtomNode start="(179, 5)" end="(179, 7)" leading="" trailing=" " val="rw"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <OtherNode start="(179, 8)" end="(179, 68)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(179, 8)" end="(179, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(179, 9)" end="(179, 67)">
                                <OtherNode start="(179, 9)" end="(179, 37)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(179, 9)" end="(179, 37)" leading="" trailing="" raw_val="mergeSortTR_run_eq_mergeSort" val="mergeSortTR_run_eq_mergeSort" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                </OtherNode>
                                <AtomNode start="(179, 37)" end="(179, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(179, 39)" end="(179, 67)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(179, 39)" end="(179, 67)" leading="" trailing="" raw_val="mergeSortTR_run_eq_mergeSort" val="mergeSortTR_run_eq_mergeSort" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(179, 67)" end="(179, 68)" leading="" trailing="&#10;&#10;-- We don't make this a `@[csimp]` lemma because `mergeSort_eq_mergeSortTR₂` is faster.&#10;" val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(182, 1)" end="(184, 49)" name="mergeSort_eq_mergeSortTR" full_name="List.MergeSort.Internal.mergeSort_eq_mergeSortTR">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(182, 1)" end="(184, 49)" name="mergeSort_eq_mergeSortTR" full_name="List.MergeSort.Internal.mergeSort_eq_mergeSortTR" _is_private_decl="False">
        <AtomNode start="(182, 1)" end="(182, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(182, 9)" end="(182, 33)">
          <IdentNode start="(182, 9)" end="(182, 33)" leading="" trailing=" " raw_val="mergeSort_eq_mergeSortTR" val="mergeSort_eq_mergeSortTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(182, 34)" end="(182, 61)">
          <NullNode/>
          <TermTypespecNode start="(182, 34)" end="(182, 61)">
            <AtomNode start="(182, 34)" end="(182, 35)" leading="" trailing=" " val=":"/>
            <OtherNode start="(182, 36)" end="(182, 61)" kind="«term_=_»">
              <OtherNode start="(182, 36)" end="(182, 46)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(182, 36)" end="(182, 37)" leading="" trailing="" val="@"/>
                <IdentNode start="(182, 37)" end="(182, 46)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(182, 47)" end="(182, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(182, 49)" end="(182, 61)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(182, 49)" end="(182, 50)" leading="" trailing="" val="@"/>
                <IdentNode start="(182, 50)" end="(182, 61)" leading="" trailing=" " raw_val="mergeSortTR" val="mergeSortTR" full_name="List.MergeSort.Internal.mergeSortTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(105, 5)" def_end="(105, 16)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(182, 62)" end="(184, 49)">
          <AtomNode start="(182, 62)" end="(182, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(182, 65)" end="(184, 49)">
            <AtomNode start="(182, 65)" end="(182, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(183, 3)" end="(184, 49)">
              <TacticTacticseq1IndentedNode start="(183, 3)" end="(184, 49)">
                <NullNode start="(183, 3)" end="(184, 49)">
                  <OtherNode start="(183, 3)" end="(183, 9)" kind="tacticFunext___" state_before="⊢ @mergeSort = @mergeSortTR" state_after="case h.h.h&#10;x✝² : Type u_1&#10;x✝¹ : List x✝²&#10;x✝ : autoParam (x✝² → x✝² → Bool) _auto✝&#10;⊢ x✝¹.mergeSort x✝ = mergeSortTR x✝¹ x✝" tactic="funext">
                    <AtomNode start="(183, 3)" end="(183, 9)" leading="" trailing="&#10;  " val="funext"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(184, 3)" end="(184, 49)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.h.h&#10;x✝² : Type u_1&#10;x✝¹ : List x✝²&#10;x✝ : autoParam (x✝² → x✝² → Bool) _auto✝&#10;⊢ x✝¹.mergeSort x✝ = mergeSortTR x✝¹ x✝" state_after="no goals" tactic="rw [mergeSortTR, mergeSortTR_run_eq_mergeSort]">
                    <AtomNode start="(184, 3)" end="(184, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(184, 6)" end="(184, 49)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(184, 6)" end="(184, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(184, 7)" end="(184, 48)">
                        <OtherNode start="(184, 7)" end="(184, 18)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(184, 7)" end="(184, 18)" leading="" trailing="" raw_val="mergeSortTR" val="mergeSortTR" full_name="List.MergeSort.Internal.mergeSortTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(105, 5)" def_end="(105, 16)"/>
                        </OtherNode>
                        <AtomNode start="(184, 18)" end="(184, 19)" leading="" trailing=" " val=","/>
                        <OtherNode start="(184, 20)" end="(184, 48)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(184, 20)" end="(184, 48)" leading="" trailing="" raw_val="mergeSortTR_run_eq_mergeSort" val="mergeSortTR_run_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR_run_eq_mergeSort" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(172, 9)" def_end="(172, 37)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(184, 48)" end="(184, 49)" leading="" trailing="&#10;&#10;-- This mutual block is unfortunately quite slow to elaborate.&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <OtherNode start="(187, 1)" end="(234, 4)" kind="Lean.Parser.Command.in">
      <OtherNode start="(187, 1)" end="(187, 32)" kind="Lean.Parser.Command.set_option">
        <AtomNode start="(187, 1)" end="(187, 11)" leading="" trailing=" " val="set_option"/>
        <IdentNode start="(187, 12)" end="(187, 25)" leading="" trailing=" " raw_val="maxHeartbeats" val="maxHeartbeats"/>
        <NullNode/>
        <OtherNode start="(187, 26)" end="(187, 32)" kind="num">
          <AtomNode start="(187, 26)" end="(187, 32)" leading="" trailing=" " val="400000"/>
        </OtherNode>
      </OtherNode>
      <AtomNode start="(187, 33)" end="(187, 35)" leading="" trailing="&#10;" val="in"/>
      <OtherNode start="(188, 1)" end="(234, 4)" kind="Lean.Parser.Command.mutual">
        <AtomNode start="(188, 1)" end="(188, 7)" leading="" trailing="&#10;" val="mutual"/>
        <NullNode start="(189, 1)" end="(232, 22)">
          <CommandDeclarationNode start="(189, 1)" end="(199, 22)" name="mergeSortTR₂_run_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR₂_run_eq_mergeSort">
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <CommandTheoremNode start="(189, 1)" end="(199, 22)" name="mergeSortTR₂_run_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR₂_run_eq_mergeSort" _is_private_decl="False">
              <AtomNode start="(189, 1)" end="(189, 8)" leading="" trailing=" " val="theorem"/>
              <CommandDeclidNode start="(189, 9)" end="(189, 38)">
                <IdentNode start="(189, 9)" end="(189, 38)" leading="" trailing=" " raw_val="mergeSortTR₂_run_eq_mergeSort" val="mergeSortTR₂_run_eq_mergeSort"/>
                <NullNode/>
              </CommandDeclidNode>
              <CommandDeclsigNode start="(189, 39)" end="(189, 132)">
                <NullNode/>
                <TermTypespecNode start="(189, 39)" end="(189, 132)">
                  <AtomNode start="(189, 39)" end="(189, 40)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(189, 41)" end="(189, 132)" kind="Lean.Parser.Term.depArrow">
                    <OtherNode start="(189, 41)" end="(189, 50)" kind="Lean.Parser.Term.implicitBinder">
                      <AtomNode start="(189, 41)" end="(189, 42)" leading="" trailing="" val="{"/>
                      <NullNode start="(189, 42)" end="(189, 43)">
                        <IdentNode start="(189, 42)" end="(189, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                      </NullNode>
                      <NullNode start="(189, 44)" end="(189, 49)">
                        <AtomNode start="(189, 44)" end="(189, 45)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(189, 46)" end="(189, 49)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <AtomNode start="(189, 49)" end="(189, 50)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <AtomNode start="(189, 51)" end="(189, 52)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(189, 53)" end="(189, 132)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(189, 53)" end="(189, 89)">
                        <AtomNode start="(189, 53)" end="(189, 54)" leading="" trailing="" val="("/>
                        <NullNode start="(189, 54)" end="(189, 55)">
                          <IdentNode start="(189, 54)" end="(189, 55)" leading="" trailing=" " raw_val="l" val="l"/>
                        </NullNode>
                        <NullNode start="(189, 56)" end="(189, 88)">
                          <AtomNode start="(189, 56)" end="(189, 57)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(189, 58)" end="(189, 88)" kind="«term{_:_//_}»">
                            <AtomNode start="(189, 58)" end="(189, 59)" leading="" trailing=" " val="{"/>
                            <IdentNode start="(189, 60)" end="(189, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                            <NullNode start="(189, 62)" end="(189, 70)">
                              <AtomNode start="(189, 62)" end="(189, 63)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(189, 64)" end="(189, 70)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(189, 64)" end="(189, 68)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(189, 69)" end="(189, 70)">
                                  <IdentNode start="(189, 69)" end="(189, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(189, 71)" end="(189, 73)" leading="" trailing=" " val="//"/>
                            <OtherNode start="(189, 74)" end="(189, 86)" kind="«term_=_»">
                              <IdentNode start="(189, 74)" end="(189, 82)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                              <AtomNode start="(189, 83)" end="(189, 84)" leading="" trailing=" " val="="/>
                              <IdentNode start="(189, 85)" end="(189, 86)" leading="" trailing=" " raw_val="n" val="n"/>
                            </OtherNode>
                            <AtomNode start="(189, 87)" end="(189, 88)" leading="" trailing="" val="}"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(189, 88)" end="(189, 89)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(189, 90)" end="(189, 91)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(189, 92)" end="(189, 132)" kind="«term_=_»">
                        <OtherNode start="(189, 92)" end="(189, 113)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(189, 92)" end="(189, 108)" leading="" trailing=" " raw_val="mergeSortTR₂.run" val="mergeSortTR₂.run" full_name="List.MergeSort.Internal.mergeSortTR₂.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(141, 3)" def_end="(141, 6)"/>
                          <NullNode start="(189, 109)" end="(189, 113)">
                            <IdentNode start="(189, 109)" end="(189, 111)" leading="" trailing=" " raw_val="le" val="le"/>
                            <IdentNode start="(189, 112)" end="(189, 113)" leading="" trailing=" " raw_val="l" val="l"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(189, 114)" end="(189, 115)" leading="" trailing=" " val="="/>
                        <OtherNode start="(189, 116)" end="(189, 132)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(189, 116)" end="(189, 125)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                          <NullNode start="(189, 126)" end="(189, 132)">
                            <OtherNode start="(189, 126)" end="(189, 129)" kind="Lean.Parser.Term.proj">
                              <IdentNode start="(189, 126)" end="(189, 127)" leading="" trailing="" raw_val="l" val="l"/>
                              <AtomNode start="(189, 127)" end="(189, 128)" leading="" trailing="" val="."/>
                              <OtherNode start="(189, 128)" end="(189, 129)" kind="fieldIdx">
                                <AtomNode start="(189, 128)" end="(189, 129)" leading="" trailing=" " val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <IdentNode start="(189, 130)" end="(189, 132)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </TermTypespecNode>
              </CommandDeclsigNode>
              <CommandDeclvaleqnsNode start="(190, 3)" end="(199, 22)">
                <OtherNode start="(190, 3)" end="(199, 22)" kind="Lean.Parser.Term.matchAltsWhereDecls">
                  <OtherNode start="(190, 3)" end="(198, 25)" kind="Lean.Parser.Term.matchAlts">
                    <NullNode start="(190, 3)" end="(198, 25)">
                      <OtherNode start="(190, 3)" end="(191, 57)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(190, 3)" end="(190, 4)" leading="" trailing=" " val="|"/>
                        <NullNode start="(190, 5)" end="(191, 16)">
                          <NullNode start="(190, 5)" end="(190, 15)">
                            <OtherNode start="(190, 5)" end="(190, 6)" kind="num">
                              <AtomNode start="(190, 5)" end="(190, 6)" leading="" trailing="" val="0"/>
                            </OtherNode>
                            <AtomNode start="(190, 6)" end="(190, 7)" leading="" trailing=" " val=","/>
                            <OtherNode start="(190, 8)" end="(190, 15)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(190, 8)" end="(190, 9)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(190, 9)" end="(190, 14)">
                                <OtherNode start="(190, 9)" end="(190, 11)" kind="«term[_]»">
                                  <AtomNode start="(190, 9)" end="(190, 10)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(190, 10)" end="(190, 11)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(190, 11)" end="(190, 12)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(190, 13)" end="(190, 14)">
                                  <AtomNode start="(190, 13)" end="(190, 14)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </NullNode>
                              <AtomNode start="(190, 14)" end="(190, 15)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(191, 3)" end="(191, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(191, 5)" end="(191, 16)">
                            <OtherNode start="(191, 5)" end="(191, 6)" kind="num">
                              <AtomNode start="(191, 5)" end="(191, 6)" leading="" trailing="" val="1"/>
                            </OtherNode>
                            <AtomNode start="(191, 6)" end="(191, 7)" leading="" trailing=" " val=","/>
                            <OtherNode start="(191, 8)" end="(191, 16)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(191, 8)" end="(191, 9)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(191, 9)" end="(191, 15)">
                                <OtherNode start="(191, 9)" end="(191, 12)" kind="«term[_]»">
                                  <AtomNode start="(191, 9)" end="(191, 10)" leading="" trailing="" val="["/>
                                  <NullNode start="(191, 10)" end="(191, 11)">
                                    <IdentNode start="(191, 10)" end="(191, 11)" leading="" trailing="" raw_val="a" val="a"/>
                                  </NullNode>
                                  <AtomNode start="(191, 11)" end="(191, 12)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(191, 12)" end="(191, 13)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(191, 14)" end="(191, 15)">
                                  <AtomNode start="(191, 14)" end="(191, 15)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </NullNode>
                              <AtomNode start="(191, 15)" end="(191, 16)" leading="" trailing=" " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(191, 17)" end="(191, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                        <TermBytacticNode start="(191, 20)" end="(191, 57)">
                          <AtomNode start="(191, 20)" end="(191, 22)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(191, 23)" end="(191, 57)">
                            <TacticTacticseq1IndentedNode start="(191, 23)" end="(191, 57)">
                              <NullNode start="(191, 23)" end="(191, 57)">
                                <OtherNode start="(191, 23)" end="(191, 57)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;le : α → α → Bool&#10;a : α&#10;property✝ : [a].length = 1&#10;⊢ mergeSortTR₂.run le ⟨[a], property✝⟩ = ⟨[a], property✝⟩.val.mergeSort le" state_after="no goals" tactic="simp [mergeSortTR₂.run, mergeSort]">
                                  <AtomNode start="(191, 23)" end="(191, 27)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(191, 28)" end="(191, 57)">
                                    <AtomNode start="(191, 28)" end="(191, 29)" leading="" trailing="" val="["/>
                                    <NullNode start="(191, 29)" end="(191, 56)">
                                      <OtherNode start="(191, 29)" end="(191, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(191, 29)" end="(191, 45)" leading="" trailing="" raw_val="mergeSortTR₂.run" val="mergeSortTR₂.run" full_name="List.MergeSort.Internal.mergeSortTR₂.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(141, 3)" def_end="(141, 6)"/>
                                      </OtherNode>
                                      <AtomNode start="(191, 45)" end="(191, 46)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(191, 47)" end="(191, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(191, 47)" end="(191, 56)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(191, 56)" end="(191, 57)" leading="" trailing="&#10;  " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                      <OtherNode start="(192, 3)" end="(198, 25)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(192, 3)" end="(192, 4)" leading="" trailing=" " val="|"/>
                        <NullNode start="(192, 5)" end="(192, 26)">
                          <NullNode start="(192, 5)" end="(192, 26)">
                            <OtherNode start="(192, 5)" end="(192, 8)" kind="«term_+_»">
                              <IdentNode start="(192, 5)" end="(192, 6)" leading="" trailing="" raw_val="n" val="n"/>
                              <AtomNode start="(192, 6)" end="(192, 7)" leading="" trailing="" val="+"/>
                              <OtherNode start="(192, 7)" end="(192, 8)" kind="num">
                                <AtomNode start="(192, 7)" end="(192, 8)" leading="" trailing="" val="2"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(192, 8)" end="(192, 9)" leading="" trailing=" " val=","/>
                            <OtherNode start="(192, 10)" end="(192, 26)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(192, 10)" end="(192, 11)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(192, 11)" end="(192, 25)">
                                <OtherNode start="(192, 11)" end="(192, 22)" kind="«term_::_»">
                                  <IdentNode start="(192, 11)" end="(192, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(192, 13)" end="(192, 15)" leading="" trailing=" " val="::"/>
                                  <OtherNode start="(192, 16)" end="(192, 22)" kind="«term_::_»">
                                    <IdentNode start="(192, 16)" end="(192, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <AtomNode start="(192, 18)" end="(192, 20)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(192, 21)" end="(192, 22)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(192, 22)" end="(192, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(192, 24)" end="(192, 25)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                              <AtomNode start="(192, 25)" end="(192, 26)" leading="" trailing=" " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(192, 27)" end="(192, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                        <TermBytacticNode start="(192, 30)" end="(198, 25)">
                          <AtomNode start="(192, 30)" end="(192, 32)" leading="" trailing="&#10;    " val="by"/>
                          <TacticTacticseqNode start="(193, 5)" end="(198, 25)">
                            <TacticTacticseq1IndentedNode start="(193, 5)" end="(198, 25)">
                              <NullNode start="(193, 5)" end="(198, 25)">
                                <OtherNode start="(193, 5)" end="(193, 12)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;le : α → α → Bool&#10;n : Nat&#10;a b : α&#10;l : List α&#10;h : (a :: b :: l).length = n + 2&#10;⊢ mergeSortTR₂.run le ⟨a :: b :: l, h⟩ = ⟨a :: b :: l, h⟩.val.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeSortTR₂.run le ⟨a :: b :: l, ⋯⟩ = ⟨a :: b :: l, ⋯⟩.val.mergeSort le" tactic="cases h">
                                  <AtomNode start="(193, 5)" end="(193, 10)" leading="" trailing=" " val="cases"/>
                                  <NullNode start="(193, 11)" end="(193, 12)">
                                    <OtherNode start="(193, 11)" end="(193, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                      <NullNode/>
                                      <IdentNode start="(193, 11)" end="(193, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(194, 5)" end="(194, 44)" kind="Lean.Parser.Tactic.simp" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeSortTR₂.run le ⟨a :: b :: l, ⋯⟩ = ⟨a :: b :: l, ⋯⟩.val.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR₂.run' le (splitRevInTwo ⟨a :: b :: l, ⋯⟩).fst)&#10;      (mergeSortTR₂.run le (splitRevInTwo ⟨a :: b :: l, ⋯⟩).snd) le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" tactic="simp only [mergeSortTR₂.run, mergeSort]">
                                  <AtomNode start="(194, 5)" end="(194, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(194, 10)" end="(194, 14)">
                                    <AtomNode start="(194, 10)" end="(194, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(194, 15)" end="(194, 44)">
                                    <AtomNode start="(194, 15)" end="(194, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(194, 16)" end="(194, 43)">
                                      <OtherNode start="(194, 16)" end="(194, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(194, 16)" end="(194, 32)" leading="" trailing="" raw_val="mergeSortTR₂.run" val="mergeSortTR₂.run" full_name="List.MergeSort.Internal.mergeSortTR₂.run" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(141, 3)" def_end="(141, 6)"/>
                                      </OtherNode>
                                      <AtomNode start="(194, 32)" end="(194, 33)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(194, 34)" end="(194, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(194, 34)" end="(194, 43)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(194, 43)" end="(194, 44)" leading="" trailing="&#10;    " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(195, 5)" end="(195, 46)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR₂.run' le (splitRevInTwo ⟨a :: b :: l, ⋯⟩).fst)&#10;      (mergeSortTR₂.run le (splitRevInTwo ⟨a :: b :: l, ⋯⟩).snd) le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR₂.run' le ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.reverse, ⋯⟩)&#10;      (mergeSortTR₂.run le ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val, ⋯⟩) le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" tactic="rw [splitRevInTwo_fst, splitRevInTwo_snd]">
                                  <AtomNode start="(195, 5)" end="(195, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(195, 8)" end="(195, 46)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(195, 8)" end="(195, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(195, 9)" end="(195, 45)">
                                      <OtherNode start="(195, 9)" end="(195, 26)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(195, 9)" end="(195, 26)" leading="" trailing="" raw_val="splitRevInTwo_fst" val="splitRevInTwo_fst" full_name="List.MergeSort.Internal.splitRevInTwo_fst" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(165, 9)" def_end="(165, 26)"/>
                                      </OtherNode>
                                      <AtomNode start="(195, 26)" end="(195, 27)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(195, 28)" end="(195, 45)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(195, 28)" end="(195, 45)" leading="" trailing="" raw_val="splitRevInTwo_snd" val="splitRevInTwo_snd" full_name="List.MergeSort.Internal.splitRevInTwo_snd" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(168, 9)" def_end="(168, 26)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(195, 45)" end="(195, 46)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(196, 5)" end="(196, 71)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSortTR₂.run' le ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.reverse, ⋯⟩)&#10;      (mergeSortTR₂.run le ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val, ⋯⟩) le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le" state_after="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSort ?m.91341 le) (⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le&#10;&#10;case refl.w&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ ?m.91341 = ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse&#10;&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ List α" tactic="rw [mergeSortTR₂_run_eq_mergeSort, mergeSortTR₂_run'_eq_mergeSort]">
                                  <AtomNode start="(196, 5)" end="(196, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(196, 8)" end="(196, 71)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(196, 8)" end="(196, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(196, 9)" end="(196, 70)">
                                      <OtherNode start="(196, 9)" end="(196, 38)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(196, 9)" end="(196, 38)" leading="" trailing="" raw_val="mergeSortTR₂_run_eq_mergeSort" val="mergeSortTR₂_run_eq_mergeSort" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(196, 38)" end="(196, 39)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(196, 40)" end="(196, 70)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(196, 40)" end="(196, 70)" leading="" trailing="" raw_val="mergeSortTR₂_run'_eq_mergeSort" val="mergeSortTR₂_run'_eq_mergeSort" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(196, 70)" end="(196, 71)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(197, 5)" end="(197, 26)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ mergeTR (mergeSort ?m.91341 le) (⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    ((splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨a :: b :: l, ⋯⟩).snd.val.mergeSort le) le&#10;&#10;case refl.w&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ ?m.91341 = ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse&#10;&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ List α" state_after="case refl.w&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ (splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val = ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse" tactic="rw [merge_eq_mergeTR]">
                                  <AtomNode start="(197, 5)" end="(197, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(197, 8)" end="(197, 26)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(197, 8)" end="(197, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(197, 9)" end="(197, 25)">
                                      <OtherNode start="(197, 9)" end="(197, 25)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(197, 9)" end="(197, 25)" leading="" trailing="" raw_val="merge_eq_mergeTR" val="merge_eq_mergeTR" full_name="List.MergeSort.Internal.merge_eq_mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(67, 18)" def_end="(67, 34)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(197, 25)" end="(197, 26)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(198, 5)" end="(198, 25)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl.w&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;⊢ (splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val = ⟨(splitInTwo ⟨a :: b :: l, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse" state_after="no goals" tactic="rw [reverse_reverse]">
                                  <AtomNode start="(198, 5)" end="(198, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(198, 8)" end="(198, 25)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(198, 8)" end="(198, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(198, 9)" end="(198, 24)">
                                      <OtherNode start="(198, 9)" end="(198, 24)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(198, 9)" end="(198, 24)" leading="" trailing="" raw_val="reverse_reverse" val="reverse_reverse" full_name="List.reverse_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(198, 24)" end="(198, 25)" leading="" trailing="&#10;" val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <OtherNode start="(199, 1)" end="(199, 22)" kind="Lean.Parser.Termination.suffix">
                    <NullNode start="(199, 1)" end="(199, 22)">
                      <OtherNode start="(199, 1)" end="(199, 22)" kind="Lean.Parser.Termination.terminationBy">
                        <AtomNode start="(199, 1)" end="(199, 15)" leading="" trailing=" " val="termination_by"/>
                        <NullNode/>
                        <NullNode start="(199, 16)" end="(199, 20)">
                          <NullNode start="(199, 16)" end="(199, 17)">
                            <IdentNode start="(199, 16)" end="(199, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          </NullNode>
                          <AtomNode start="(199, 18)" end="(199, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        </NullNode>
                        <IdentNode start="(199, 21)" end="(199, 22)" leading="" trailing="&#10;&#10;" raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                </OtherNode>
              </CommandDeclvaleqnsNode>
            </CommandTheoremNode>
          </CommandDeclarationNode>
          <CommandDeclarationNode start="(201, 1)" end="(232, 22)" name="mergeSortTR₂_run'_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR₂_run'_eq_mergeSort">
            <CommandDeclmodifiersNode>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
              <NullNode/>
            </CommandDeclmodifiersNode>
            <CommandTheoremNode start="(201, 1)" end="(232, 22)" name="mergeSortTR₂_run'_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR₂_run'_eq_mergeSort" _is_private_decl="False">
              <AtomNode start="(201, 1)" end="(201, 8)" leading="" trailing=" " val="theorem"/>
              <CommandDeclidNode start="(201, 9)" end="(201, 39)">
                <IdentNode start="(201, 9)" end="(201, 39)" leading="" trailing=" " raw_val="mergeSortTR₂_run'_eq_mergeSort" val="mergeSortTR₂_run'_eq_mergeSort"/>
                <NullNode/>
              </CommandDeclidNode>
              <CommandDeclsigNode start="(201, 40)" end="(201, 158)">
                <NullNode/>
                <TermTypespecNode start="(201, 40)" end="(201, 158)">
                  <AtomNode start="(201, 40)" end="(201, 41)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(201, 42)" end="(201, 158)" kind="Lean.Parser.Term.depArrow">
                    <OtherNode start="(201, 42)" end="(201, 51)" kind="Lean.Parser.Term.implicitBinder">
                      <AtomNode start="(201, 42)" end="(201, 43)" leading="" trailing="" val="{"/>
                      <NullNode start="(201, 43)" end="(201, 44)">
                        <IdentNode start="(201, 43)" end="(201, 44)" leading="" trailing=" " raw_val="n" val="n"/>
                      </NullNode>
                      <NullNode start="(201, 45)" end="(201, 50)">
                        <AtomNode start="(201, 45)" end="(201, 46)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(201, 47)" end="(201, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                      <AtomNode start="(201, 50)" end="(201, 51)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <AtomNode start="(201, 52)" end="(201, 53)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(201, 54)" end="(201, 158)" kind="Lean.Parser.Term.depArrow">
                      <TermExplicitbinderNode start="(201, 54)" end="(201, 90)">
                        <AtomNode start="(201, 54)" end="(201, 55)" leading="" trailing="" val="("/>
                        <NullNode start="(201, 55)" end="(201, 56)">
                          <IdentNode start="(201, 55)" end="(201, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                        </NullNode>
                        <NullNode start="(201, 57)" end="(201, 89)">
                          <AtomNode start="(201, 57)" end="(201, 58)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(201, 59)" end="(201, 89)" kind="«term{_:_//_}»">
                            <AtomNode start="(201, 59)" end="(201, 60)" leading="" trailing=" " val="{"/>
                            <IdentNode start="(201, 61)" end="(201, 62)" leading="" trailing=" " raw_val="l" val="l"/>
                            <NullNode start="(201, 63)" end="(201, 71)">
                              <AtomNode start="(201, 63)" end="(201, 64)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(201, 65)" end="(201, 71)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(201, 65)" end="(201, 69)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(201, 70)" end="(201, 71)">
                                  <IdentNode start="(201, 70)" end="(201, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <AtomNode start="(201, 72)" end="(201, 74)" leading="" trailing=" " val="//"/>
                            <OtherNode start="(201, 75)" end="(201, 87)" kind="«term_=_»">
                              <IdentNode start="(201, 75)" end="(201, 83)" leading="" trailing=" " raw_val="l.length" val="l.length"/>
                              <AtomNode start="(201, 84)" end="(201, 85)" leading="" trailing=" " val="="/>
                              <IdentNode start="(201, 86)" end="(201, 87)" leading="" trailing=" " raw_val="n" val="n"/>
                            </OtherNode>
                            <AtomNode start="(201, 88)" end="(201, 89)" leading="" trailing="" val="}"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(201, 89)" end="(201, 90)" leading="" trailing=" " val=")"/>
                      </TermExplicitbinderNode>
                      <AtomNode start="(201, 91)" end="(201, 92)" leading="" trailing=" " val="→"/>
                      <OtherNode start="(201, 93)" end="(201, 158)" kind="Lean.Parser.Term.depArrow">
                        <TermExplicitbinderNode start="(201, 93)" end="(201, 115)">
                          <AtomNode start="(201, 93)" end="(201, 94)" leading="" trailing="" val="("/>
                          <NullNode start="(201, 94)" end="(201, 95)">
                            <IdentNode start="(201, 94)" end="(201, 95)" leading="" trailing=" " raw_val="w" val="w"/>
                          </NullNode>
                          <NullNode start="(201, 96)" end="(201, 114)">
                            <AtomNode start="(201, 96)" end="(201, 97)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(201, 98)" end="(201, 114)" kind="«term_=_»">
                              <IdentNode start="(201, 98)" end="(201, 100)" leading="" trailing=" " raw_val="l'" val="l'"/>
                              <AtomNode start="(201, 101)" end="(201, 102)" leading="" trailing=" " val="="/>
                              <OtherNode start="(201, 103)" end="(201, 114)" kind="Lean.Parser.Term.proj">
                                <OtherNode start="(201, 103)" end="(201, 106)" kind="Lean.Parser.Term.proj">
                                  <IdentNode start="(201, 103)" end="(201, 104)" leading="" trailing="" raw_val="l" val="l"/>
                                  <AtomNode start="(201, 104)" end="(201, 105)" leading="" trailing="" val="."/>
                                  <OtherNode start="(201, 105)" end="(201, 106)" kind="fieldIdx">
                                    <AtomNode start="(201, 105)" end="(201, 106)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(201, 106)" end="(201, 107)" leading="" trailing="" val="."/>
                                <IdentNode start="(201, 107)" end="(201, 114)" leading="" trailing="" raw_val="reverse" val="reverse" full_name="List.reverse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(201, 114)" end="(201, 115)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <AtomNode start="(201, 116)" end="(201, 117)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(201, 118)" end="(201, 158)" kind="«term_=_»">
                          <OtherNode start="(201, 118)" end="(201, 140)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(201, 118)" end="(201, 135)" leading="" trailing=" " raw_val="mergeSortTR₂.run'" val="mergeSortTR₂.run'" full_name="List.MergeSort.Internal.mergeSortTR₂.run'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(147, 3)" def_end="(147, 7)"/>
                            <NullNode start="(201, 136)" end="(201, 140)">
                              <IdentNode start="(201, 136)" end="(201, 138)" leading="" trailing=" " raw_val="le" val="le"/>
                              <IdentNode start="(201, 139)" end="(201, 140)" leading="" trailing=" " raw_val="l" val="l"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(201, 141)" end="(201, 142)" leading="" trailing=" " val="="/>
                          <OtherNode start="(201, 143)" end="(201, 158)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(201, 143)" end="(201, 152)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                            <NullNode start="(201, 153)" end="(201, 158)">
                              <IdentNode start="(201, 153)" end="(201, 155)" leading="" trailing=" " raw_val="l'" val="l'"/>
                              <IdentNode start="(201, 156)" end="(201, 158)" leading="" trailing="&#10;  " raw_val="le" val="le"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </TermTypespecNode>
              </CommandDeclsigNode>
              <CommandDeclvaleqnsNode start="(202, 3)" end="(232, 22)">
                <OtherNode start="(202, 3)" end="(232, 22)" kind="Lean.Parser.Term.matchAltsWhereDecls">
                  <OtherNode start="(202, 3)" end="(231, 16)" kind="Lean.Parser.Term.matchAlts">
                    <NullNode start="(202, 3)" end="(231, 16)">
                      <OtherNode start="(202, 3)" end="(203, 65)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(202, 3)" end="(202, 4)" leading="" trailing=" " val="|"/>
                        <NullNode start="(202, 5)" end="(203, 19)">
                          <NullNode start="(202, 5)" end="(202, 18)">
                            <OtherNode start="(202, 5)" end="(202, 6)" kind="num">
                              <AtomNode start="(202, 5)" end="(202, 6)" leading="" trailing="" val="0"/>
                            </OtherNode>
                            <AtomNode start="(202, 6)" end="(202, 7)" leading="" trailing=" " val=","/>
                            <OtherNode start="(202, 8)" end="(202, 15)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(202, 8)" end="(202, 9)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(202, 9)" end="(202, 14)">
                                <OtherNode start="(202, 9)" end="(202, 11)" kind="«term[_]»">
                                  <AtomNode start="(202, 9)" end="(202, 10)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(202, 10)" end="(202, 11)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(202, 11)" end="(202, 12)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(202, 13)" end="(202, 14)">
                                  <AtomNode start="(202, 13)" end="(202, 14)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </NullNode>
                              <AtomNode start="(202, 14)" end="(202, 15)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                            <AtomNode start="(202, 15)" end="(202, 16)" leading="" trailing=" " val=","/>
                            <IdentNode start="(202, 17)" end="(202, 18)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                          </NullNode>
                          <AtomNode start="(203, 3)" end="(203, 4)" leading="" trailing=" " val="|"/>
                          <NullNode start="(203, 5)" end="(203, 19)">
                            <OtherNode start="(203, 5)" end="(203, 6)" kind="num">
                              <AtomNode start="(203, 5)" end="(203, 6)" leading="" trailing="" val="1"/>
                            </OtherNode>
                            <AtomNode start="(203, 6)" end="(203, 7)" leading="" trailing=" " val=","/>
                            <OtherNode start="(203, 8)" end="(203, 16)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(203, 8)" end="(203, 9)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(203, 9)" end="(203, 15)">
                                <OtherNode start="(203, 9)" end="(203, 12)" kind="«term[_]»">
                                  <AtomNode start="(203, 9)" end="(203, 10)" leading="" trailing="" val="["/>
                                  <NullNode start="(203, 10)" end="(203, 11)">
                                    <IdentNode start="(203, 10)" end="(203, 11)" leading="" trailing="" raw_val="a" val="a"/>
                                  </NullNode>
                                  <AtomNode start="(203, 11)" end="(203, 12)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(203, 12)" end="(203, 13)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(203, 14)" end="(203, 15)">
                                  <AtomNode start="(203, 14)" end="(203, 15)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                              </NullNode>
                              <AtomNode start="(203, 15)" end="(203, 16)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                            <AtomNode start="(203, 16)" end="(203, 17)" leading="" trailing=" " val=","/>
                            <IdentNode start="(203, 18)" end="(203, 19)" leading="" trailing=" " raw_val="w" val="w"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(203, 20)" end="(203, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                        <TermBytacticNode start="(203, 23)" end="(203, 65)">
                          <AtomNode start="(203, 23)" end="(203, 25)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(203, 26)" end="(203, 65)">
                            <TacticTacticseq1IndentedNode start="(203, 26)" end="(203, 65)">
                              <NullNode start="(203, 26)" end="(203, 65)">
                                <OtherNode start="(203, 26)" end="(203, 65)" kind="Lean.Parser.Tactic.simpAll" state_before="α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a : α&#10;property✝ : [a].length = 1&#10;w : l' = ⟨[a], property✝⟩.val.reverse&#10;⊢ mergeSortTR₂.run' le ⟨[a], property✝⟩ = l'.mergeSort le" state_after="no goals" tactic="simp_all [mergeSortTR₂.run', mergeSort]">
                                  <AtomNode start="(203, 26)" end="(203, 34)" leading="" trailing=" " val="simp_all"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(203, 35)" end="(203, 65)">
                                    <AtomNode start="(203, 35)" end="(203, 36)" leading="" trailing="" val="["/>
                                    <NullNode start="(203, 36)" end="(203, 64)">
                                      <OtherNode start="(203, 36)" end="(203, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(203, 36)" end="(203, 53)" leading="" trailing="" raw_val="mergeSortTR₂.run'" val="mergeSortTR₂.run'" full_name="List.MergeSort.Internal.mergeSortTR₂.run'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(147, 3)" def_end="(147, 7)"/>
                                      </OtherNode>
                                      <AtomNode start="(203, 53)" end="(203, 54)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(203, 55)" end="(203, 64)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(203, 55)" end="(203, 64)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(203, 64)" end="(203, 65)" leading="" trailing="&#10;  " val="]"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                      <OtherNode start="(204, 3)" end="(231, 16)" kind="Lean.Parser.Term.matchAlt">
                        <AtomNode start="(204, 3)" end="(204, 4)" leading="" trailing=" " val="|"/>
                        <NullNode start="(204, 5)" end="(204, 29)">
                          <NullNode start="(204, 5)" end="(204, 29)">
                            <OtherNode start="(204, 5)" end="(204, 8)" kind="«term_+_»">
                              <IdentNode start="(204, 5)" end="(204, 6)" leading="" trailing="" raw_val="n" val="n"/>
                              <AtomNode start="(204, 6)" end="(204, 7)" leading="" trailing="" val="+"/>
                              <OtherNode start="(204, 7)" end="(204, 8)" kind="num">
                                <AtomNode start="(204, 7)" end="(204, 8)" leading="" trailing="" val="2"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(204, 8)" end="(204, 9)" leading="" trailing=" " val=","/>
                            <OtherNode start="(204, 10)" end="(204, 26)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(204, 10)" end="(204, 11)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(204, 11)" end="(204, 25)">
                                <OtherNode start="(204, 11)" end="(204, 22)" kind="«term_::_»">
                                  <IdentNode start="(204, 11)" end="(204, 12)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(204, 13)" end="(204, 15)" leading="" trailing=" " val="::"/>
                                  <OtherNode start="(204, 16)" end="(204, 22)" kind="«term_::_»">
                                    <IdentNode start="(204, 16)" end="(204, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                                    <AtomNode start="(204, 18)" end="(204, 20)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(204, 21)" end="(204, 22)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(204, 22)" end="(204, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(204, 24)" end="(204, 25)" leading="" trailing="" raw_val="h" val="h"/>
                              </NullNode>
                              <AtomNode start="(204, 25)" end="(204, 26)" leading="" trailing="" val="⟩"/>
                            </OtherNode>
                            <AtomNode start="(204, 26)" end="(204, 27)" leading="" trailing=" " val=","/>
                            <IdentNode start="(204, 28)" end="(204, 29)" leading="" trailing=" " raw_val="w" val="w"/>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(204, 30)" end="(204, 32)" leading="" trailing=" " val="=&amp;gt;"/>
                        <TermBytacticNode start="(204, 33)" end="(231, 16)">
                          <AtomNode start="(204, 33)" end="(204, 35)" leading="" trailing="&#10;    " val="by"/>
                          <TacticTacticseqNode start="(205, 5)" end="(231, 16)">
                            <TacticTacticseq1IndentedNode start="(205, 5)" end="(231, 16)">
                              <NullNode start="(205, 5)" end="(231, 16)">
                                <OtherNode start="(205, 5)" end="(205, 12)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;n : Nat&#10;a b : α&#10;l : List α&#10;h : (a :: b :: l).length = n + 2&#10;w : l' = ⟨a :: b :: l, h⟩.val.reverse&#10;⊢ mergeSortTR₂.run' le ⟨a :: b :: l, h⟩ = l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeSortTR₂.run' le ⟨a :: b :: l, ⋯⟩ = l'.mergeSort le" tactic="cases h">
                                  <AtomNode start="(205, 5)" end="(205, 10)" leading="" trailing=" " val="cases"/>
                                  <NullNode start="(205, 11)" end="(205, 12)">
                                    <OtherNode start="(205, 11)" end="(205, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                      <NullNode/>
                                      <IdentNode start="(205, 11)" end="(205, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(206, 5)" end="(206, 45)" kind="Lean.Parser.Tactic.simp" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeSortTR₂.run' le ⟨a :: b :: l, ⋯⟩ = l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeTR (mergeSortTR₂.run' le (splitRevInTwo' ⟨a :: b :: l, ⋯⟩).snd)&#10;      (mergeSortTR₂.run le (splitRevInTwo' ⟨a :: b :: l, ⋯⟩).fst) le =&#10;    l'.mergeSort le" tactic="simp only [mergeSortTR₂.run', mergeSort]">
                                  <AtomNode start="(206, 5)" end="(206, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode start="(206, 10)" end="(206, 14)">
                                    <AtomNode start="(206, 10)" end="(206, 14)" leading="" trailing=" " val="only"/>
                                  </NullNode>
                                  <NullNode start="(206, 15)" end="(206, 45)">
                                    <AtomNode start="(206, 15)" end="(206, 16)" leading="" trailing="" val="["/>
                                    <NullNode start="(206, 16)" end="(206, 44)">
                                      <OtherNode start="(206, 16)" end="(206, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(206, 16)" end="(206, 33)" leading="" trailing="" raw_val="mergeSortTR₂.run'" val="mergeSortTR₂.run'" full_name="List.MergeSort.Internal.mergeSortTR₂.run'" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(147, 3)" def_end="(147, 7)"/>
                                      </OtherNode>
                                      <AtomNode start="(206, 33)" end="(206, 34)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(206, 35)" end="(206, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode/>
                                        <IdentNode start="(206, 35)" end="(206, 44)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(206, 44)" end="(206, 45)" leading="" trailing="&#10;    " val="]"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(207, 5)" end="(207, 48)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeTR (mergeSortTR₂.run' le (splitRevInTwo' ⟨a :: b :: l, ⋯⟩).snd)&#10;      (mergeSortTR₂.run le (splitRevInTwo' ⟨a :: b :: l, ⋯⟩).fst) le =&#10;    l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeTR (mergeSortTR₂.run' le ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩)&#10;      (mergeSortTR₂.run le ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩) le =&#10;    l'.mergeSort le" tactic="rw [splitRevInTwo'_fst, splitRevInTwo'_snd]">
                                  <AtomNode start="(207, 5)" end="(207, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(207, 8)" end="(207, 48)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(207, 8)" end="(207, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(207, 9)" end="(207, 47)">
                                      <OtherNode start="(207, 9)" end="(207, 27)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(207, 9)" end="(207, 27)" leading="" trailing="" raw_val="splitRevInTwo'_fst" val="splitRevInTwo'_fst" full_name="List.MergeSort.Internal.splitRevInTwo'_fst" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(154, 9)" def_end="(154, 27)"/>
                                      </OtherNode>
                                      <AtomNode start="(207, 27)" end="(207, 28)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(207, 29)" end="(207, 47)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(207, 29)" end="(207, 47)" leading="" trailing="" raw_val="splitRevInTwo'_snd" val="splitRevInTwo'_snd" full_name="List.MergeSort.Internal.splitRevInTwo'_snd" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(159, 9)" def_end="(159, 27)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(207, 47)" end="(207, 48)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(208, 5)" end="(208, 77)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeTR (mergeSortTR₂.run' le ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩)&#10;      (mergeSortTR₂.run le ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩) le =&#10;    l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeTR (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le)&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" tactic="rw [mergeSortTR₂_run_eq_mergeSort, mergeSortTR₂_run'_eq_mergeSort _ rfl]">
                                  <AtomNode start="(208, 5)" end="(208, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(208, 8)" end="(208, 77)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(208, 8)" end="(208, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(208, 9)" end="(208, 76)">
                                      <OtherNode start="(208, 9)" end="(208, 38)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <IdentNode start="(208, 9)" end="(208, 38)" leading="" trailing="" raw_val="mergeSortTR₂_run_eq_mergeSort" val="mergeSortTR₂_run_eq_mergeSort" full_name="PSigma.Lex.left" mod_name="Init.WF" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/WF.lean"/>
                                      </OtherNode>
                                      <AtomNode start="(208, 38)" end="(208, 39)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(208, 40)" end="(208, 76)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode/>
                                        <OtherNode start="(208, 40)" end="(208, 76)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(208, 40)" end="(208, 70)" leading="" trailing=" " raw_val="mergeSortTR₂_run'_eq_mergeSort" val="mergeSortTR₂_run'_eq_mergeSort"/>
                                          <NullNode start="(208, 71)" end="(208, 76)">
                                            <TermHoleNode start="(208, 71)" end="(208, 72)">
                                              <AtomNode start="(208, 71)" end="(208, 72)" leading="" trailing=" " val="_"/>
                                            </TermHoleNode>
                                            <IdentNode start="(208, 73)" end="(208, 76)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(208, 76)" end="(208, 77)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(209, 5)" end="(209, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ mergeTR (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le)&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" tactic="rw [← merge_eq_mergeTR]">
                                  <AtomNode start="(209, 5)" end="(209, 7)" leading="" trailing=" " val="rw"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(209, 8)" end="(209, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                    <AtomNode start="(209, 8)" end="(209, 9)" leading="" trailing="" val="["/>
                                    <NullNode start="(209, 9)" end="(209, 27)">
                                      <OtherNode start="(209, 9)" end="(209, 27)" kind="Lean.Parser.Tactic.rwRule">
                                        <NullNode start="(209, 9)" end="(209, 10)">
                                          <OtherNode start="(209, 9)" end="(209, 10)" kind="patternIgnore">
                                            <OtherNode start="(209, 9)" end="(209, 10)" kind="token.«← »">
                                              <AtomNode start="(209, 9)" end="(209, 10)" leading="" trailing=" " val="←"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <IdentNode start="(209, 11)" end="(209, 27)" leading="" trailing="" raw_val="merge_eq_mergeTR" val="merge_eq_mergeTR" full_name="List.MergeSort.Internal.merge_eq_mergeTR" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(67, 18)" def_end="(67, 34)"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(209, 27)" end="(209, 28)" leading="" trailing="&#10;    " val="]"/>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(210, 5)" end="(210, 33)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : l'.length = ⟨a :: b :: l, ⋯⟩.val.reverse.length&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" tactic="have w' := congrArg length w">
                                  <AtomNode start="(210, 5)" end="(210, 9)" leading="" trailing=" " val="have"/>
                                  <OtherNode start="(210, 10)" end="(210, 33)" kind="Lean.Parser.Term.haveDecl">
                                    <OtherNode start="(210, 10)" end="(210, 33)" kind="Lean.Parser.Term.haveIdDecl">
                                      <OtherNode start="(210, 10)" end="(210, 12)" kind="Lean.Parser.Term.haveId">
                                        <IdentNode start="(210, 10)" end="(210, 12)" leading="" trailing=" " raw_val="w'" val="w'"/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <AtomNode start="(210, 13)" end="(210, 15)" leading="" trailing=" " val=":="/>
                                      <OtherNode start="(210, 16)" end="(210, 33)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(210, 16)" end="(210, 24)" leading="" trailing=" " raw_val="congrArg" val="congrArg" full_name="congrArg" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                        <NullNode start="(210, 25)" end="(210, 33)">
                                          <IdentNode start="(210, 25)" end="(210, 31)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <IdentNode start="(210, 32)" end="(210, 33)" leading="" trailing="&#10;    " raw_val="w" val="w"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(211, 5)" end="(211, 15)" kind="Lean.Parser.Tactic.simp" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : l'.length = ⟨a :: b :: l, ⋯⟩.val.reverse.length&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" state_after="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : l'.length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" tactic="simp at w'">
                                  <AtomNode start="(211, 5)" end="(211, 9)" leading="" trailing=" " val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode start="(211, 10)" end="(211, 15)">
                                    <OtherNode start="(211, 10)" end="(211, 15)" kind="Lean.Parser.Tactic.location">
                                      <AtomNode start="(211, 10)" end="(211, 12)" leading="" trailing=" " val="at"/>
                                      <OtherNode start="(211, 13)" end="(211, 15)" kind="Lean.Parser.Tactic.locationHyp">
                                        <NullNode start="(211, 13)" end="(211, 15)">
                                          <IdentNode start="(211, 13)" end="(211, 15)" leading="" trailing="&#10;    " raw_val="w'" val="w'"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <OtherNode start="(212, 5)" end="(231, 16)" kind="Lean.Parser.Tactic.cases" state_before="case refl&#10;α : Type u_1&#10;l' : List α&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : l'.length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    l'.mergeSort le" state_after="no goals" tactic="cases l' with&#10;| nil =&amp;gt; simp at w'&#10;| cons x l' =&amp;gt;&#10;  cases l' with&#10;  | nil =&amp;gt; simp at w'&#10;  | cons y l' =&amp;gt;&#10;    rw [mergeSort]&#10;    congr 2&#10;    · dsimp at w&#10;      simp only [w]&#10;      simp only [splitInTwo_fst, splitInTwo_snd, reverse_take, take_reverse]&#10;      congr 1&#10;      rw [w, length_reverse]&#10;      simp&#10;    · dsimp at w&#10;      simp only [w]&#10;      simp only [reverse_cons, append_assoc, singleton_append, splitInTwo_snd, length_cons]&#10;      congr 1&#10;      simp at w'&#10;      omega">
                                  <AtomNode start="(212, 5)" end="(212, 10)" leading="" trailing=" " val="cases"/>
                                  <NullNode start="(212, 11)" end="(212, 13)">
                                    <OtherNode start="(212, 11)" end="(212, 13)" kind="Lean.Parser.Tactic.elimTarget">
                                      <NullNode/>
                                      <IdentNode start="(212, 11)" end="(212, 13)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                    </OtherNode>
                                  </NullNode>
                                  <NullNode/>
                                  <NullNode start="(212, 14)" end="(231, 16)">
                                    <OtherNode start="(212, 14)" end="(231, 16)" kind="Lean.Parser.Tactic.inductionAlts">
                                      <AtomNode start="(212, 14)" end="(212, 18)" leading="" trailing="&#10;    " val="with"/>
                                      <NullNode/>
                                      <NullNode start="(213, 5)" end="(231, 16)">
                                        <OtherNode start="(213, 5)" end="(213, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                                          <NullNode start="(213, 5)" end="(213, 10)">
                                            <OtherNode start="(213, 5)" end="(213, 10)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                              <AtomNode start="(213, 5)" end="(213, 6)" leading="" trailing=" " val="|"/>
                                              <GroupNode start="(213, 7)" end="(213, 10)">
                                                <NullNode/>
                                                <IdentNode start="(213, 7)" end="(213, 10)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </GroupNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode start="(213, 11)" end="(213, 24)">
                                            <AtomNode start="(213, 11)" end="(213, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(213, 14)" end="(213, 24)">
                                              <TacticTacticseq1IndentedNode start="(213, 14)" end="(213, 24)">
                                                <NullNode start="(213, 14)" end="(213, 24)">
                                                  <OtherNode start="(213, 14)" end="(213, 24)" kind="Lean.Parser.Tactic.simp" state_before="case refl.nil&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;w : [] = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : [].length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    [].mergeSort le" state_after="no goals" tactic="simp at w'">
                                                    <AtomNode start="(213, 14)" end="(213, 18)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(213, 19)" end="(213, 24)">
                                                      <OtherNode start="(213, 19)" end="(213, 24)" kind="Lean.Parser.Tactic.location">
                                                        <AtomNode start="(213, 19)" end="(213, 21)" leading="" trailing=" " val="at"/>
                                                        <OtherNode start="(213, 22)" end="(213, 24)" kind="Lean.Parser.Tactic.locationHyp">
                                                          <NullNode start="(213, 22)" end="(213, 24)">
                                                            <IdentNode start="(213, 22)" end="(213, 24)" leading="" trailing="&#10;    " raw_val="w'" val="w'"/>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </NullNode>
                                        </OtherNode>
                                        <OtherNode start="(214, 5)" end="(231, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                                          <NullNode start="(214, 5)" end="(214, 16)">
                                            <OtherNode start="(214, 5)" end="(214, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                              <AtomNode start="(214, 5)" end="(214, 6)" leading="" trailing=" " val="|"/>
                                              <GroupNode start="(214, 7)" end="(214, 11)">
                                                <NullNode/>
                                                <IdentNode start="(214, 7)" end="(214, 11)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                              </GroupNode>
                                              <NullNode start="(214, 12)" end="(214, 16)">
                                                <IdentNode start="(214, 12)" end="(214, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                                                <IdentNode start="(214, 14)" end="(214, 16)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode start="(214, 17)" end="(231, 16)">
                                            <AtomNode start="(214, 17)" end="(214, 19)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(215, 7)" end="(231, 16)">
                                              <TacticTacticseq1IndentedNode start="(215, 7)" end="(231, 16)">
                                                <NullNode start="(215, 7)" end="(231, 16)">
                                                  <OtherNode start="(215, 7)" end="(231, 16)" kind="Lean.Parser.Tactic.cases" state_before="case refl.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x : α&#10;l' : List α&#10;w : x :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: l').length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    (x :: l').mergeSort le" state_after="no goals" tactic="cases l' with&#10;| nil =&amp;gt; simp at w'&#10;| cons y l' =&amp;gt;&#10;  rw [mergeSort]&#10;  congr 2&#10;  · dsimp at w&#10;    simp only [w]&#10;    simp only [splitInTwo_fst, splitInTwo_snd, reverse_take, take_reverse]&#10;    congr 1&#10;    rw [w, length_reverse]&#10;    simp&#10;  · dsimp at w&#10;    simp only [w]&#10;    simp only [reverse_cons, append_assoc, singleton_append, splitInTwo_snd, length_cons]&#10;    congr 1&#10;    simp at w'&#10;    omega">
                                                    <AtomNode start="(215, 7)" end="(215, 12)" leading="" trailing=" " val="cases"/>
                                                    <NullNode start="(215, 13)" end="(215, 15)">
                                                      <OtherNode start="(215, 13)" end="(215, 15)" kind="Lean.Parser.Tactic.elimTarget">
                                                        <NullNode/>
                                                        <IdentNode start="(215, 13)" end="(215, 15)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <NullNode start="(215, 16)" end="(231, 16)">
                                                      <OtherNode start="(215, 16)" end="(231, 16)" kind="Lean.Parser.Tactic.inductionAlts">
                                                        <AtomNode start="(215, 16)" end="(215, 20)" leading="" trailing="&#10;      " val="with"/>
                                                        <NullNode/>
                                                        <NullNode start="(216, 7)" end="(231, 16)">
                                                          <OtherNode start="(216, 7)" end="(216, 26)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(216, 7)" end="(216, 12)">
                                                            <OtherNode start="(216, 7)" end="(216, 12)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(216, 7)" end="(216, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(216, 9)" end="(216, 12)">
                                                            <NullNode/>
                                                            <IdentNode start="(216, 9)" end="(216, 12)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(216, 13)" end="(216, 26)">
                                                            <AtomNode start="(216, 13)" end="(216, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(216, 16)" end="(216, 26)">
                                                            <TacticTacticseq1IndentedNode start="(216, 16)" end="(216, 26)">
                                                            <NullNode start="(216, 16)" end="(216, 26)">
                                                            <OtherNode start="(216, 16)" end="(216, 26)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.nil&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x : α&#10;w : [x] = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : [x].length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    [x].mergeSort le" state_after="no goals" tactic="simp at w'">
                                                            <AtomNode start="(216, 16)" end="(216, 20)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(216, 21)" end="(216, 26)">
                                                            <OtherNode start="(216, 21)" end="(216, 26)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(216, 21)" end="(216, 23)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(216, 24)" end="(216, 26)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(216, 24)" end="(216, 26)">
                                                            <IdentNode start="(216, 24)" end="(216, 26)" leading="" trailing="&#10;      " raw_val="w'" val="w'"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                          <OtherNode start="(217, 7)" end="(231, 16)" kind="Lean.Parser.Tactic.inductionAlt">
                                                            <NullNode start="(217, 7)" end="(217, 18)">
                                                            <OtherNode start="(217, 7)" end="(217, 18)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                            <AtomNode start="(217, 7)" end="(217, 8)" leading="" trailing=" " val="|"/>
                                                            <GroupNode start="(217, 9)" end="(217, 13)">
                                                            <NullNode/>
                                                            <IdentNode start="(217, 9)" end="(217, 13)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </GroupNode>
                                                            <NullNode start="(217, 14)" end="(217, 18)">
                                                            <IdentNode start="(217, 14)" end="(217, 15)" leading="" trailing=" " raw_val="y" val="y"/>
                                                            <IdentNode start="(217, 16)" end="(217, 18)" leading="" trailing=" " raw_val="l'" val="l'"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <NullNode start="(217, 19)" end="(231, 16)">
                                                            <AtomNode start="(217, 19)" end="(217, 21)" leading="" trailing="&#10;        " val="=&amp;gt;"/>
                                                            <TacticTacticseqNode start="(218, 9)" end="(231, 16)">
                                                            <TacticTacticseq1IndentedNode start="(218, 9)" end="(231, 16)">
                                                            <NullNode start="(218, 9)" end="(231, 16)">
                                                            <OtherNode start="(218, 9)" end="(218, 23)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl.cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    (x :: y :: l').mergeSort le" state_after="case refl.cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    ((splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val.mergeSort le) le" tactic="rw [mergeSort]">
                                                            <AtomNode start="(218, 9)" end="(218, 11)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(218, 12)" end="(218, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(218, 12)" end="(218, 13)" leading="" trailing="" val="["/>
                                                            <NullNode start="(218, 13)" end="(218, 22)">
                                                            <OtherNode start="(218, 13)" end="(218, 22)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(218, 13)" end="(218, 22)" leading="" trailing="" raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(218, 22)" end="(218, 23)" leading="" trailing="&#10;        " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(219, 9)" end="(219, 16)" kind="Lean.Parser.Tactic.congr" state_before="case refl.cons.cons&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse.mergeSort le).merge&#10;      (⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val.mergeSort le) le =&#10;    ((splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val.mergeSort le).merge ((splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val.mergeSort le) le" state_after="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse =&#10;    (splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val&#10;&#10;case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" tactic="congr 2">
                                                            <AtomNode start="(219, 9)" end="(219, 14)" leading="" trailing=" " val="congr"/>
                                                            <NullNode start="(219, 15)" end="(219, 16)">
                                                            <OtherNode start="(219, 15)" end="(219, 16)" kind="num">
                                                            <AtomNode start="(219, 15)" end="(219, 16)" leading="" trailing="&#10;        " val="2"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(220, 9)" end="(225, 15)" kind="Lean.cdot" state_before="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse =&#10;    (splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val&#10;&#10;case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" state_after="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" tactic="· dsimp at w&#10;  simp only [w]&#10;  simp only [splitInTwo_fst, splitInTwo_snd, reverse_take, take_reverse]&#10;  congr 1&#10;  rw [w, length_reverse]&#10;  simp">
                                                            <OtherNode start="(220, 9)" end="(220, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(220, 9)" end="(220, 10)" kind="patternIgnore">
                                                            <OtherNode start="(220, 9)" end="(220, 10)" kind="token.«· »">
                                                            <AtomNode start="(220, 9)" end="(220, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(220, 11)" end="(225, 15)">
                                                            <TacticTacticseq1IndentedNode start="(220, 11)" end="(225, 15)">
                                                            <NullNode start="(220, 11)" end="(225, 15)">
                                                            <OtherNode start="(220, 11)" end="(220, 21)" kind="Lean.Parser.Tactic.dsimp" state_before="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse =&#10;    (splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val" state_after="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse =&#10;    (splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val" tactic="dsimp at w">
                                                            <AtomNode start="(220, 11)" end="(220, 16)" leading="" trailing=" " val="dsimp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(220, 17)" end="(220, 21)">
                                                            <OtherNode start="(220, 17)" end="(220, 21)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(220, 17)" end="(220, 19)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(220, 20)" end="(220, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(220, 20)" end="(220, 21)">
                                                            <IdentNode start="(220, 20)" end="(220, 21)" leading="" trailing="&#10;          " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(221, 11)" end="(221, 24)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).fst.val.reverse, ⋯⟩.val.reverse =&#10;    (splitInTwo ⟨x :: y :: l', ⋯⟩).fst.val" state_after="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).fst.val.reverse.reverse = (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).fst.val" tactic="simp only [w]">
                                                            <AtomNode start="(221, 11)" end="(221, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(221, 16)" end="(221, 20)">
                                                            <AtomNode start="(221, 16)" end="(221, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(221, 21)" end="(221, 24)">
                                                            <AtomNode start="(221, 21)" end="(221, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(221, 22)" end="(221, 23)">
                                                            <OtherNode start="(221, 22)" end="(221, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(221, 22)" end="(221, 23)" leading="" trailing="" raw_val="w" val="w"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(221, 23)" end="(221, 24)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(222, 11)" end="(222, 81)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).fst.val.reverse.reverse = (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).fst.val" state_after="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (drop ((a :: b :: l).length - (l.length + 2 + 1) / 2) (a :: b :: l)).reverse.reverse.reverse =&#10;    (drop ((a :: b :: l).length - ((x :: y :: l').length + 1) / 2) (a :: b :: l)).reverse" tactic="simp only [splitInTwo_fst, splitInTwo_snd, reverse_take, take_reverse]">
                                                            <AtomNode start="(222, 11)" end="(222, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(222, 16)" end="(222, 20)">
                                                            <AtomNode start="(222, 16)" end="(222, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(222, 21)" end="(222, 81)">
                                                            <AtomNode start="(222, 21)" end="(222, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(222, 22)" end="(222, 80)">
                                                            <OtherNode start="(222, 22)" end="(222, 36)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(222, 22)" end="(222, 36)" leading="" trailing="" raw_val="splitInTwo_fst" val="splitInTwo_fst" full_name="List.MergeSort.Internal.splitInTwo_fst" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(222, 36)" end="(222, 37)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(222, 38)" end="(222, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(222, 38)" end="(222, 52)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(222, 52)" end="(222, 53)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(222, 54)" end="(222, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(222, 54)" end="(222, 66)" leading="" trailing="" raw_val="reverse_take" val="reverse_take" full_name="List.reverse_take" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(222, 66)" end="(222, 67)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(222, 68)" end="(222, 80)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(222, 68)" end="(222, 80)" leading="" trailing="" raw_val="take_reverse" val="take_reverse" full_name="List.take_reverse" mod_name="Init.Data.List.Nat.TakeDrop" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Nat/TakeDrop.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(222, 80)" end="(222, 81)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(223, 11)" end="(223, 18)" kind="Lean.Parser.Tactic.congr" state_before="case refl.cons.cons.e_xs.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (drop ((a :: b :: l).length - (l.length + 2 + 1) / 2) (a :: b :: l)).reverse.reverse.reverse =&#10;    (drop ((a :: b :: l).length - ((x :: y :: l').length + 1) / 2) (a :: b :: l)).reverse" state_after="case refl.cons.cons.e_xs.e_xs.e_as&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (drop ((a :: b :: l).length - (l.length + 2 + 1) / 2) (a :: b :: l)).reverse.reverse =&#10;    drop ((a :: b :: l).length - ((x :: y :: l').length + 1) / 2) (a :: b :: l)" tactic="congr 1">
                                                            <AtomNode start="(223, 11)" end="(223, 16)" leading="" trailing=" " val="congr"/>
                                                            <NullNode start="(223, 17)" end="(223, 18)">
                                                            <OtherNode start="(223, 17)" end="(223, 18)" kind="num">
                                                            <AtomNode start="(223, 17)" end="(223, 18)" leading="" trailing="&#10;          " val="1"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(224, 11)" end="(224, 33)" kind="Lean.Parser.Tactic.rwSeq" state_before="case refl.cons.cons.e_xs.e_xs.e_as&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (drop ((a :: b :: l).length - (l.length + 2 + 1) / 2) (a :: b :: l)).reverse.reverse =&#10;    drop ((a :: b :: l).length - ((x :: y :: l').length + 1) / 2) (a :: b :: l)" state_after="case refl.cons.cons.e_xs.e_xs.e_as&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (drop ((a :: b :: l).length - (l.length + 2 + 1) / 2) (a :: b :: l)).reverse.reverse =&#10;    drop ((a :: b :: l).length - ((a :: b :: l).length + 1) / 2) (a :: b :: l)" tactic="rw [w, length_reverse]">
                                                            <AtomNode start="(224, 11)" end="(224, 13)" leading="" trailing=" " val="rw"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <OtherNode start="(224, 14)" end="(224, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(224, 14)" end="(224, 15)" leading="" trailing="" val="["/>
                                                            <NullNode start="(224, 15)" end="(224, 32)">
                                                            <OtherNode start="(224, 15)" end="(224, 16)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(224, 15)" end="(224, 16)" leading="" trailing="" raw_val="w" val="w"/>
                                                            </OtherNode>
                                                            <AtomNode start="(224, 16)" end="(224, 17)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(224, 18)" end="(224, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(224, 18)" end="(224, 32)" leading="" trailing="" raw_val="length_reverse" val="length_reverse" full_name="List.length_reverse" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(224, 32)" end="(224, 33)" leading="" trailing="&#10;          " val="]"/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(225, 11)" end="(225, 15)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.cons.e_xs.e_xs.e_as&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (drop ((a :: b :: l).length - (l.length + 2 + 1) / 2) (a :: b :: l)).reverse.reverse =&#10;    drop ((a :: b :: l).length - ((a :: b :: l).length + 1) / 2) (a :: b :: l)" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(225, 11)" end="(225, 15)" leading="" trailing="&#10;        " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(226, 9)" end="(231, 16)" kind="Lean.cdot" state_before="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" state_after="no goals" tactic="· dsimp at w&#10;  simp only [w]&#10;  simp only [reverse_cons, append_assoc, singleton_append, splitInTwo_snd, length_cons]&#10;  congr 1&#10;  simp at w'&#10;  omega">
                                                            <OtherNode start="(226, 9)" end="(226, 10)" kind="Lean.cdotTk">
                                                            <OtherNode start="(226, 9)" end="(226, 10)" kind="patternIgnore">
                                                            <OtherNode start="(226, 9)" end="(226, 10)" kind="token.«· »">
                                                            <AtomNode start="(226, 9)" end="(226, 10)" leading="" trailing=" " val="·"/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            <TacticTacticseqNode start="(226, 11)" end="(231, 16)">
                                                            <TacticTacticseq1IndentedNode start="(226, 11)" end="(231, 16)">
                                                            <NullNode start="(226, 11)" end="(231, 16)">
                                                            <OtherNode start="(226, 11)" end="(226, 21)" kind="Lean.Parser.Tactic.dsimp" state_before="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = ⟨a :: b :: l, ⋯⟩.val.reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" state_after="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" tactic="dsimp at w">
                                                            <AtomNode start="(226, 11)" end="(226, 16)" leading="" trailing=" " val="dsimp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(226, 17)" end="(226, 21)">
                                                            <OtherNode start="(226, 17)" end="(226, 21)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(226, 17)" end="(226, 19)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(226, 20)" end="(226, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(226, 20)" end="(226, 21)">
                                                            <IdentNode start="(226, 20)" end="(226, 21)" leading="" trailing="&#10;          " raw_val="w" val="w"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(227, 11)" end="(227, 24)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ ⟨(splitInTwo ⟨⟨a :: b :: l, ⋯⟩.val.reverse, ⋯⟩).snd.val, ⋯⟩.val = (splitInTwo ⟨x :: y :: l', ⋯⟩).snd.val" state_after="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).snd.val = (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).snd.val" tactic="simp only [w]">
                                                            <AtomNode start="(227, 11)" end="(227, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(227, 16)" end="(227, 20)">
                                                            <AtomNode start="(227, 16)" end="(227, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(227, 21)" end="(227, 24)">
                                                            <AtomNode start="(227, 21)" end="(227, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(227, 22)" end="(227, 23)">
                                                            <OtherNode start="(227, 22)" end="(227, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(227, 22)" end="(227, 23)" leading="" trailing="" raw_val="w" val="w"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(227, 23)" end="(227, 24)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(228, 11)" end="(228, 96)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).snd.val = (splitInTwo ⟨(a :: b :: l).reverse, ⋯⟩).snd.val" state_after="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ drop ((l.length + 2 + 1) / 2) (l.reverse ++ [b, a]) = drop ((l'.length + 1 + 1 + 1) / 2) (l.reverse ++ [b, a])" tactic="simp only [reverse_cons, append_assoc, singleton_append, splitInTwo_snd, length_cons]">
                                                            <AtomNode start="(228, 11)" end="(228, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode start="(228, 16)" end="(228, 20)">
                                                            <AtomNode start="(228, 16)" end="(228, 20)" leading="" trailing=" " val="only"/>
                                                            </NullNode>
                                                            <NullNode start="(228, 21)" end="(228, 96)">
                                                            <AtomNode start="(228, 21)" end="(228, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(228, 22)" end="(228, 95)">
                                                            <OtherNode start="(228, 22)" end="(228, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(228, 22)" end="(228, 34)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(228, 34)" end="(228, 35)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(228, 36)" end="(228, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(228, 36)" end="(228, 48)" leading="" trailing="" raw_val="append_assoc" val="append_assoc" full_name="List.append_assoc" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(228, 48)" end="(228, 49)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(228, 50)" end="(228, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(228, 50)" end="(228, 66)" leading="" trailing="" raw_val="singleton_append" val="singleton_append" full_name="List.singleton_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(228, 66)" end="(228, 67)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(228, 68)" end="(228, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(228, 68)" end="(228, 82)" leading="" trailing="" raw_val="splitInTwo_snd" val="splitInTwo_snd" full_name="List.MergeSort.Internal.splitInTwo_snd" mod_name="Init.Data.List.Sort.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Lemmas.lean"/>
                                                            </OtherNode>
                                                            <AtomNode start="(228, 82)" end="(228, 83)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(228, 84)" end="(228, 95)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(228, 84)" end="(228, 95)" leading="" trailing="" raw_val="length_cons" val="length_cons" full_name="List.length_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(228, 95)" end="(228, 96)" leading="" trailing="&#10;          " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(229, 11)" end="(229, 18)" kind="Lean.Parser.Tactic.congr" state_before="case refl.cons.cons.e_ys.e_xs&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ drop ((l.length + 2 + 1) / 2) (l.reverse ++ [b, a]) = drop ((l'.length + 1 + 1 + 1) / 2) (l.reverse ++ [b, a])" state_after="case refl.cons.cons.e_ys.e_xs.e_n&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (l.length + 2 + 1) / 2 = (l'.length + 1 + 1 + 1) / 2" tactic="congr 1">
                                                            <AtomNode start="(229, 11)" end="(229, 16)" leading="" trailing=" " val="congr"/>
                                                            <NullNode start="(229, 17)" end="(229, 18)">
                                                            <OtherNode start="(229, 17)" end="(229, 18)" kind="num">
                                                            <AtomNode start="(229, 17)" end="(229, 18)" leading="" trailing="&#10;          " val="1"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(230, 11)" end="(230, 21)" kind="Lean.Parser.Tactic.simp" state_before="case refl.cons.cons.e_ys.e_xs.e_n&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : (x :: y :: l').length = l.length + 2&#10;⊢ (l.length + 2 + 1) / 2 = (l'.length + 1 + 1 + 1) / 2" state_after="case refl.cons.cons.e_ys.e_xs.e_n&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : l'.length = l.length&#10;⊢ (l.length + 2 + 1) / 2 = (l'.length + 1 + 1 + 1) / 2" tactic="simp at w'">
                                                            <AtomNode start="(230, 11)" end="(230, 15)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(230, 16)" end="(230, 21)">
                                                            <OtherNode start="(230, 16)" end="(230, 21)" kind="Lean.Parser.Tactic.location">
                                                            <AtomNode start="(230, 16)" end="(230, 18)" leading="" trailing=" " val="at"/>
                                                            <OtherNode start="(230, 19)" end="(230, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                                            <NullNode start="(230, 19)" end="(230, 21)">
                                                            <IdentNode start="(230, 19)" end="(230, 21)" leading="" trailing="&#10;          " raw_val="w'" val="w'"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <OtherNode start="(231, 11)" end="(231, 16)" kind="Lean.Parser.Tactic.omega" state_before="case refl.cons.cons.e_ys.e_xs.e_n&#10;α : Type u_1&#10;le : α → α → Bool&#10;a b : α&#10;l : List α&#10;x y : α&#10;l' : List α&#10;w : x :: y :: l' = (a :: b :: l).reverse&#10;w' : l'.length = l.length&#10;⊢ (l.length + 2 + 1) / 2 = (l'.length + 1 + 1 + 1) / 2" state_after="no goals" tactic="omega">
                                                            <AtomNode start="(231, 11)" end="(231, 16)" leading="" trailing="&#10;" val="omega"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </TacticTacticseq1IndentedNode>
                                                            </TacticTacticseqNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <OtherNode start="(232, 1)" end="(232, 22)" kind="Lean.Parser.Termination.suffix">
                    <NullNode start="(232, 1)" end="(232, 22)">
                      <OtherNode start="(232, 1)" end="(232, 22)" kind="Lean.Parser.Termination.terminationBy">
                        <AtomNode start="(232, 1)" end="(232, 15)" leading="" trailing=" " val="termination_by"/>
                        <NullNode/>
                        <NullNode start="(232, 16)" end="(232, 20)">
                          <NullNode start="(232, 16)" end="(232, 17)">
                            <IdentNode start="(232, 16)" end="(232, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          </NullNode>
                          <AtomNode start="(232, 18)" end="(232, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                        </NullNode>
                        <IdentNode start="(232, 21)" end="(232, 22)" leading="" trailing="&#10;&#10;" raw_val="n" val="n"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                </OtherNode>
              </CommandDeclvaleqnsNode>
            </CommandTheoremNode>
          </CommandDeclarationNode>
        </NullNode>
        <AtomNode start="(234, 1)" end="(234, 4)" leading="" trailing="&#10;&#10;" val="end"/>
      </OtherNode>
    </OtherNode>
    <CommandDeclarationNode start="(236, 1)" end="(238, 51)" name="mergeSort_eq_mergeSortTR₂" full_name="List.MergeSort.Internal.mergeSort_eq_mergeSortTR₂">
      <CommandDeclmodifiersNode start="(236, 1)" end="(236, 9)">
        <NullNode/>
        <NullNode start="(236, 1)" end="(236, 9)">
          <OtherNode start="(236, 1)" end="(236, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(236, 1)" end="(236, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(236, 3)" end="(236, 8)">
              <OtherNode start="(236, 3)" end="(236, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(236, 3)" end="(236, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(236, 3)" end="(236, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(236, 8)" end="(236, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(236, 10)" end="(238, 51)" name="mergeSort_eq_mergeSortTR₂" full_name="List.MergeSort.Internal.mergeSort_eq_mergeSortTR₂" _is_private_decl="False">
        <AtomNode start="(236, 10)" end="(236, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(236, 18)" end="(236, 43)">
          <IdentNode start="(236, 18)" end="(236, 43)" leading="" trailing=" " raw_val="mergeSort_eq_mergeSortTR₂" val="mergeSort_eq_mergeSortTR₂"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(236, 44)" end="(236, 72)">
          <NullNode/>
          <TermTypespecNode start="(236, 44)" end="(236, 72)">
            <AtomNode start="(236, 44)" end="(236, 45)" leading="" trailing=" " val=":"/>
            <OtherNode start="(236, 46)" end="(236, 72)" kind="«term_=_»">
              <OtherNode start="(236, 46)" end="(236, 56)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(236, 46)" end="(236, 47)" leading="" trailing="" val="@"/>
                <IdentNode start="(236, 47)" end="(236, 56)" leading="" trailing=" " raw_val="mergeSort" val="mergeSort" full_name="List.mergeSort" mod_name="Init.Data.List.Sort.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(236, 57)" end="(236, 58)" leading="" trailing=" " val="="/>
              <OtherNode start="(236, 59)" end="(236, 72)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(236, 59)" end="(236, 60)" leading="" trailing="" val="@"/>
                <IdentNode start="(236, 60)" end="(236, 72)" leading="" trailing=" " raw_val="mergeSortTR₂" val="mergeSortTR₂" full_name="List.MergeSort.Internal.mergeSortTR₂" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(138, 5)" def_end="(138, 17)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(236, 73)" end="(238, 51)">
          <AtomNode start="(236, 73)" end="(236, 75)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(236, 76)" end="(238, 51)">
            <AtomNode start="(236, 76)" end="(236, 78)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(237, 3)" end="(238, 51)">
              <TacticTacticseq1IndentedNode start="(237, 3)" end="(238, 51)">
                <NullNode start="(237, 3)" end="(238, 51)">
                  <OtherNode start="(237, 3)" end="(237, 9)" kind="tacticFunext___" state_before="⊢ @mergeSort = @mergeSortTR₂" state_after="case h.h.h&#10;x✝² : Type u_1&#10;x✝¹ : List x✝²&#10;x✝ : autoParam (x✝² → x✝² → Bool) _auto✝&#10;⊢ x✝¹.mergeSort x✝ = mergeSortTR₂ x✝¹ x✝" tactic="funext">
                    <AtomNode start="(237, 3)" end="(237, 9)" leading="" trailing="&#10;  " val="funext"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(238, 3)" end="(238, 51)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.h.h&#10;x✝² : Type u_1&#10;x✝¹ : List x✝²&#10;x✝ : autoParam (x✝² → x✝² → Bool) _auto✝&#10;⊢ x✝¹.mergeSort x✝ = mergeSortTR₂ x✝¹ x✝" state_after="no goals" tactic="rw [mergeSortTR₂, mergeSortTR₂_run_eq_mergeSort]">
                    <AtomNode start="(238, 3)" end="(238, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(238, 6)" end="(238, 51)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(238, 6)" end="(238, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(238, 7)" end="(238, 50)">
                        <OtherNode start="(238, 7)" end="(238, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(238, 7)" end="(238, 19)" leading="" trailing="" raw_val="mergeSortTR₂" val="mergeSortTR₂" full_name="List.MergeSort.Internal.mergeSortTR₂" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(138, 5)" def_end="(138, 17)"/>
                        </OtherNode>
                        <AtomNode start="(238, 19)" end="(238, 20)" leading="" trailing=" " val=","/>
                        <OtherNode start="(238, 21)" end="(238, 50)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(238, 21)" end="(238, 50)" leading="" trailing="" raw_val="mergeSortTR₂_run_eq_mergeSort" val="mergeSortTR₂_run_eq_mergeSort" full_name="List.MergeSort.Internal.mergeSortTR₂_run_eq_mergeSort" mod_name="Init.Data.List.Sort.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Sort/Impl.lean" def_start="(189, 9)" def_end="(189, 38)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(238, 50)" end="(238, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(240, 1)" end="(240, 28)" name="List.MergeSort.Internal">
      <AtomNode start="(240, 1)" end="(240, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(240, 5)" end="(240, 28)">
        <IdentNode start="(240, 5)" end="(240, 28)" leading="" trailing="&#10;" raw_val="List.MergeSort.Internal" val="List.MergeSort.Internal"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(11, 1)" end="(34, 3)" text="# Replacing `merge` and `mergeSort` at runtime with tail-recursive and faster versions.&#10;&#10;We replace `merge` with `mergeTR` using a `@[csimp]` lemma.&#10;&#10;We replace `mergeSort` in two steps:&#10;* first with `mergeSortTR`, which while not tail-recursive itself (it can't be),&#10;  uses `mergeTR` internally.&#10;* second with `mergeSortTR₂`, which achieves an ~20% speed-up over `mergeSortTR`&#10;  by avoiding some unnecessary list reversals.&#10;&#10;There is no public API in this file; it solely exists to implement the `@[csimp]` lemmas&#10;affecting runtime behaviour.&#10;&#10;## Future work&#10;The current runtime implementation could be further improved in a number of ways, e.g.:&#10;* only walking the list once during splitting,&#10;* using insertion sort for small chunks rather than splitting all the way down to singletons,&#10;* identifying already sorted or reverse sorted chunks and skipping them.&#10;&#10;Because the theory developed for `mergeSort` is independent of the runtime implementation,&#10;as long as such improvements are carefully validated by benchmarking,&#10;they can be done without changing the theory, as long as a `@[csimp]` lemma is provided.&#10;-/"/>
    <Comment start="(36, 38)" end="(37, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(37, 39)" end="(39, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(43, 1)" end="(45, 3)" text="`O(|l₁| + |l₂|)`. Merge two lists using `le` as a switch.&#10;-/"/>
    <Comment start="(71, 1)" end="(77, 3)" text="Variant of `splitAt`, that does not reverse the first list, i.e&#10;`splitRevAt n l = ((l.take n).reverse, l.drop n)`.&#10;&#10;This exists solely as an optimization for `mergeSortTR` and `mergeSortTR₂`,&#10;and should not be used elsewhere.&#10;-/"/>
    <Comment start="(79, 3)" end="(79, 105)" text="Auxiliary for `splitAtRev`: `splitAtRev.go xs n acc = ((take n xs).reverse ++ acc, drop n xs)`. -/"/>
    <Comment start="(98, 1)" end="(104, 3)" text="An intermediate speed-up for `mergeSort`.&#10;This version uses the tail-recurive `mergeTR` function as a subroutine.&#10;&#10;This is not the final version we use at runtime, as `mergeSortTR₂` is faster.&#10;This definition is useful as an intermediate step in proving the `@[csimp]` lemma for `mergeSortTR₂`.&#10;-/"/>
    <Comment start="(114, 1)" end="(117, 3)" text="Split a list in two equal parts, reversing the first part.&#10;If the length is odd, the first part will be one element longer.&#10;-/"/>
    <Comment start="(123, 1)" end="(126, 3)" text="Split a list in two equal parts, reversing the first part.&#10;If the length is odd, the second part will be one element longer.&#10;-/"/>
    <Comment start="(132, 1)" end="(134, 3)" text="Faster version of `mergeSortTR`, which avoids unnecessary list reversals.&#10;-/"/>
    <Comment start="(135, 1)" end="(138, 1)" text="-- Per the benchmark in `tests/bench/mergeSort/`&#10;-- (which averages over 4 use cases: already sorted lists, reverse sorted lists, almost sorted lists, and random lists),&#10;-- for lists of length 10^6, `mergeSortTR₂` is about 20% faster than `mergeSortTR`.&#10;"/>
    <Comment start="(181, 1)" end="(182, 1)" text="-- We don't make this a `@[csimp]` lemma because `mergeSort_eq_mergeSortTR₂` is faster.&#10;"/>
    <Comment start="(186, 1)" end="(187, 1)" text="-- This mutual block is unfortunately quite slow to elaborate.&#10;"/>
  </Comments>
</TracedFile>
