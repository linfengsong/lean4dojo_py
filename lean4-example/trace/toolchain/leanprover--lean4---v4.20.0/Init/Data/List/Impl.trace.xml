<TracedFile path="src/lean/Init/Data/List/Impl.lean" md5="f45e658187bc59c95b05b5eae88853d4">
  <FileNode start="(1, 1)" end="(624, 9)">
    <ModuleHeaderNode start="(6, 1)" end="(9, 33)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(9, 33)">
        <ModuleImportNode start="(9, 1)" end="(9, 33)" module="Init.Data.Array.Bootstrap" path="src/lean/Init/Data/Array/Bootstrap.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 33)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Array.Bootstrap" val="Init.Data.Array.Bootstrap"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(11, 1)" end="(19, 3)" comment="## Tail recursive implementations for `List` definitions.&#10;&#10;Many of the proofs require theorems about `Array`,&#10;so these are in a separate file to minimize imports.&#10;&#10;If you import `Init.Data.List.Basic` but do not import this file,&#10;then at runtime you will get non-tail recursive versions of the following definitions.&#10;-/">
      <AtomNode start="(11, 1)" end="(11, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(12, 1)" end="(19, 3)" leading="" trailing="&#10;&#10;" val="## Tail recursive implementations for `List` definitions.&#10;&#10;Many of the proofs require theorems about `Array`,&#10;so these are in a separate file to minimize imports.&#10;&#10;If you import `Init.Data.List.Basic` but do not import this file,&#10;then at runtime you will get non-tail recursive versions of the following definitions.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(21, 1)" end="(21, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(21, 1)" end="(21, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(21, 12)" end="(21, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(21, 33)" end="(21, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(22, 1)" end="(22, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(22, 1)" end="(22, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(22, 12)" end="(22, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(22, 34)" end="(22, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(24, 1)" end="(24, 15)" name="List">
      <AtomNode start="(24, 1)" end="(24, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(24, 11)" end="(24, 15)" leading="" trailing="&#10;&#10;" raw_val="List" val="List"/>
    </CommandNamespaceNode>
    <CommandModuledocNode start="(26, 1)" end="(49, 3)" comment="## Basic `List` operations.&#10;&#10;The following operations are already tail-recursive, and do not need `@[csimp]` replacements:&#10;`get`, `foldl`, `beq`, `isEqv`, `reverse`, `elem` (and hence `contains`), `drop`, `dropWhile`,&#10;`partition`, `isPrefixOf`, `isPrefixOf?`, `find?`, `findSome?`, `lookup`, `any` (and hence `or`),&#10;`all` (and hence `and`) , `range`, `eraseDups`, `eraseReps`, `span`, `splitBy`.&#10;&#10;The following operations are still missing `@[csimp]` replacements:&#10;`concat`, `zipWithAll`.&#10;&#10;The following operations are not recursive to begin with&#10;(or are defined in terms of recursive primitives):&#10;`isEmpty`, `isSuffixOf`, `isSuffixOf?`, `rotateLeft`, `rotateRight`, `insert`, `zip`, `enum`,&#10;`min?`, `max?`, and `removeAll`.&#10;&#10;The following operations were already given `@[csimp]` replacements in `Init/Data/List/Basic.lean`:&#10;`length`, `map`, `filter`, `replicate`, `leftPad`, `unzip`, `range'`, `iota`, `intersperse`.&#10;&#10;The following operations are given `@[csimp]` replacements below:&#10;`set`, `filterMap`, `foldr`, `append`, `bind`, `join`,&#10;`take`, `takeWhile`, `dropLast`, `replace`, `modify`, `insertIdx`, `erase`, `eraseIdx`, `zipWith`,&#10;`enumFrom`, and `intercalate`.&#10;&#10;-/">
      <AtomNode start="(26, 1)" end="(26, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(26, 5)" end="(49, 3)" leading="" trailing="&#10;&#10;&#10;" val="## Basic `List` operations.&#10;&#10;The following operations are already tail-recursive, and do not need `@[csimp]` replacements:&#10;`get`, `foldl`, `beq`, `isEqv`, `reverse`, `elem` (and hence `contains`), `drop`, `dropWhile`,&#10;`partition`, `isPrefixOf`, `isPrefixOf?`, `find?`, `findSome?`, `lookup`, `any` (and hence `or`),&#10;`all` (and hence `and`) , `range`, `eraseDups`, `eraseReps`, `span`, `splitBy`.&#10;&#10;The following operations are still missing `@[csimp]` replacements:&#10;`concat`, `zipWithAll`.&#10;&#10;The following operations are not recursive to begin with&#10;(or are defined in terms of recursive primitives):&#10;`isEmpty`, `isSuffixOf`, `isSuffixOf?`, `rotateLeft`, `rotateRight`, `insert`, `zip`, `enum`,&#10;`min?`, `max?`, and `removeAll`.&#10;&#10;The following operations were already given `@[csimp]` replacements in `Init/Data/List/Basic.lean`:&#10;`length`, `map`, `filter`, `replicate`, `leftPad`, `unzip`, `range'`, `iota`, `intersperse`.&#10;&#10;The following operations are given `@[csimp]` replacements below:&#10;`set`, `filterMap`, `foldr`, `append`, `bind`, `join`,&#10;`take`, `takeWhile`, `dropLast`, `replace`, `modify`, `insertIdx`, `erase`, `eraseIdx`, `zipWith`,&#10;`enumFrom`, and `intercalate`.&#10;&#10;-/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(52, 1)" end="(52, 15)" comment="### set -/">
      <AtomNode start="(52, 1)" end="(52, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(52, 5)" end="(52, 15)" leading="" trailing="&#10;&#10;" val="### set -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(54, 1)" end="(70, 44)" name="setTR" full_name="List.setTR">
      <CommandDeclmodifiersNode start="(54, 1)" end="(64, 10)">
        <NullNode start="(54, 1)" end="(63, 3)">
          <CommandDoccommentNode start="(54, 1)" end="(63, 3)" comment="Replaces the value at (zero-based) index `n` in `l` with `a`. If the index is out of bounds, then&#10;the list is returned unmodified.&#10;&#10;This is a tail-recursive version of `List.set` that's used at runtime.&#10;&#10;Examples:&#10;* `[&amp;quot;water&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;].set 1 &amp;quot;tea&amp;quot; = [&amp;quot;water&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;]`&#10;* `[&amp;quot;water&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;].set 4 &amp;quot;tea&amp;quot; = [&amp;quot;water&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;]`&#10;-/">
            <AtomNode start="(54, 1)" end="(54, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(55, 1)" end="(63, 3)" leading="" trailing="&#10;" val="Replaces the value at (zero-based) index `n` in `l` with `a`. If the index is out of bounds, then&#10;the list is returned unmodified.&#10;&#10;This is a tail-recursive version of `List.set` that's used at runtime.&#10;&#10;Examples:&#10;* `[&amp;quot;water&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;].set 1 &amp;quot;tea&amp;quot; = [&amp;quot;water&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;]`&#10;* `[&amp;quot;water&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;].set 4 &amp;quot;tea&amp;quot; = [&amp;quot;water&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;soda&amp;quot;, &amp;quot;juice&amp;quot;]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(64, 1)" end="(64, 10)">
          <OtherNode start="(64, 1)" end="(64, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(64, 1)" end="(64, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(64, 3)" end="(64, 9)">
              <OtherNode start="(64, 3)" end="(64, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(64, 3)" end="(64, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(64, 3)" end="(64, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(64, 9)" end="(64, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(64, 11)" end="(70, 44)" name="setTR">
        <AtomNode start="(64, 11)" end="(64, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(64, 15)" end="(64, 20)">
          <IdentNode start="(64, 15)" end="(64, 20)" leading="" trailing=" " raw_val="setTR" val="setTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(64, 21)" end="(64, 60)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(64, 21)" end="(64, 51)">
            <TermExplicitbinderNode start="(64, 21)" end="(64, 33)">
              <AtomNode start="(64, 21)" end="(64, 22)" leading="" trailing="" val="("/>
              <NullNode start="(64, 22)" end="(64, 23)">
                <IdentNode start="(64, 22)" end="(64, 23)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(64, 24)" end="(64, 32)">
                <AtomNode start="(64, 24)" end="(64, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(64, 26)" end="(64, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(64, 26)" end="(64, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(64, 31)" end="(64, 32)">
                    <IdentNode start="(64, 31)" end="(64, 32)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(64, 32)" end="(64, 33)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(64, 34)" end="(64, 43)">
              <AtomNode start="(64, 34)" end="(64, 35)" leading="" trailing="" val="("/>
              <NullNode start="(64, 35)" end="(64, 36)">
                <IdentNode start="(64, 35)" end="(64, 36)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(64, 37)" end="(64, 42)">
                <AtomNode start="(64, 37)" end="(64, 38)" leading="" trailing=" " val=":"/>
                <IdentNode start="(64, 39)" end="(64, 42)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(64, 42)" end="(64, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(64, 44)" end="(64, 51)">
              <AtomNode start="(64, 44)" end="(64, 45)" leading="" trailing="" val="("/>
              <NullNode start="(64, 45)" end="(64, 46)">
                <IdentNode start="(64, 45)" end="(64, 46)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(64, 47)" end="(64, 50)">
                <AtomNode start="(64, 47)" end="(64, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(64, 49)" end="(64, 50)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(64, 50)" end="(64, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(64, 52)" end="(64, 60)">
            <TermTypespecNode start="(64, 52)" end="(64, 60)">
              <AtomNode start="(64, 52)" end="(64, 53)" leading="" trailing=" " val=":"/>
              <OtherNode start="(64, 54)" end="(64, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(64, 54)" end="(64, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(64, 59)" end="(64, 60)">
                  <IdentNode start="(64, 59)" end="(64, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(64, 61)" end="(70, 44)">
          <AtomNode start="(64, 61)" end="(64, 63)" leading="" trailing=" " val=":="/>
          <OtherNode start="(64, 64)" end="(64, 74)" kind="Lean.Parser.Term.app">
            <IdentNode start="(64, 64)" end="(64, 66)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(64, 67)" end="(64, 74)">
              <IdentNode start="(64, 67)" end="(64, 68)" leading="" trailing=" " raw_val="l" val="l"/>
              <IdentNode start="(64, 69)" end="(64, 70)" leading="" trailing=" " raw_val="n" val="n"/>
              <OtherNode start="(64, 71)" end="(64, 74)" kind="«term#[_,]»">
                <AtomNode start="(64, 71)" end="(64, 73)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(64, 73)" end="(64, 74)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(64, 75)" end="(70, 44)">
            <OtherNode start="(64, 75)" end="(70, 44)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(64, 75)" end="(64, 80)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(65, 3)" end="(70, 44)">
                <OtherNode start="(65, 3)" end="(70, 44)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(65, 3)" end="(66, 56)">
                    <CommandDoccommentNode start="(65, 3)" end="(66, 56)" comment="Auxiliary for `setTR`: `setTR.go l a xs n acc = acc.toList ++ set xs a`,&#10;  unless `n ≥ l.length` in which case it returns `l` -/">
                      <AtomNode start="(65, 3)" end="(65, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(65, 7)" end="(66, 56)" leading="" trailing="&#10;  " val="Auxiliary for `setTR`: `setTR.go l a xs n acc = acc.toList ++ set xs a`,&#10;  unless `n ≥ l.length` in which case it returns `l` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(67, 3)" end="(70, 44)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(67, 3)" end="(70, 44)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(67, 3)" end="(67, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(67, 6)" end="(67, 39)">
                        <TermTypespecNode start="(67, 6)" end="(67, 39)">
                          <AtomNode start="(67, 6)" end="(67, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(67, 8)" end="(67, 39)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(67, 8)" end="(67, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(67, 8)" end="(67, 12)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(67, 13)" end="(67, 14)">
                                <IdentNode start="(67, 13)" end="(67, 14)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(67, 15)" end="(67, 16)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(67, 17)" end="(67, 39)" kind="Lean.Parser.Term.arrow">
                              <IdentNode start="(67, 17)" end="(67, 20)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(67, 21)" end="(67, 22)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(67, 23)" end="(67, 39)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(67, 23)" end="(67, 30)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(67, 23)" end="(67, 28)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(67, 29)" end="(67, 30)">
                                    <IdentNode start="(67, 29)" end="(67, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(67, 31)" end="(67, 32)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(67, 33)" end="(67, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(67, 33)" end="(67, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(67, 38)" end="(67, 39)">
                                    <IdentNode start="(67, 38)" end="(67, 39)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(68, 3)" end="(70, 44)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(68, 3)" end="(70, 44)">
                          <OtherNode start="(68, 3)" end="(68, 18)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(68, 3)" end="(68, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(68, 5)" end="(68, 13)">
                              <NullNode start="(68, 5)" end="(68, 13)">
                                <OtherNode start="(68, 5)" end="(68, 7)" kind="«term[_]»">
                                  <AtomNode start="(68, 5)" end="(68, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(68, 6)" end="(68, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(68, 7)" end="(68, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(68, 9)" end="(68, 10)">
                                  <AtomNode start="(68, 9)" end="(68, 10)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(68, 10)" end="(68, 11)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(68, 12)" end="(68, 13)">
                                  <AtomNode start="(68, 12)" end="(68, 13)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(68, 14)" end="(68, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(68, 17)" end="(68, 18)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(69, 3)" end="(69, 46)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(69, 3)" end="(69, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(69, 5)" end="(69, 18)">
                              <NullNode start="(69, 5)" end="(69, 18)">
                                <OtherNode start="(69, 5)" end="(69, 10)" kind="«term_::_»">
                                  <TermHoleNode start="(69, 5)" end="(69, 6)">
                                    <AtomNode start="(69, 5)" end="(69, 6)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(69, 6)" end="(69, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(69, 8)" end="(69, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(69, 10)" end="(69, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(69, 12)" end="(69, 13)" kind="num">
                                  <AtomNode start="(69, 12)" end="(69, 13)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(69, 13)" end="(69, 14)" leading="" trailing=" " val=","/>
                                <IdentNode start="(69, 15)" end="(69, 18)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(69, 19)" end="(69, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(69, 22)" end="(69, 46)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(69, 22)" end="(69, 38)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                              <NullNode start="(69, 39)" end="(69, 46)">
                                <OtherNode start="(69, 39)" end="(69, 46)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(69, 39)" end="(69, 40)" leading="" trailing="" val="("/>
                                  <OtherNode start="(69, 40)" end="(69, 45)" kind="«term_::_»">
                                    <IdentNode start="(69, 40)" end="(69, 41)" leading="" trailing="" raw_val="a" val="a"/>
                                    <AtomNode start="(69, 41)" end="(69, 43)" leading="" trailing="" val="::"/>
                                    <IdentNode start="(69, 43)" end="(69, 45)" leading="" trailing="" raw_val="xs" val="xs"/>
                                  </OtherNode>
                                  <AtomNode start="(69, 45)" end="(69, 46)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(70, 3)" end="(70, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(70, 3)" end="(70, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(70, 5)" end="(70, 20)">
                              <NullNode start="(70, 5)" end="(70, 20)">
                                <OtherNode start="(70, 5)" end="(70, 10)" kind="«term_::_»">
                                  <IdentNode start="(70, 5)" end="(70, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                  <AtomNode start="(70, 6)" end="(70, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(70, 8)" end="(70, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(70, 10)" end="(70, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(70, 12)" end="(70, 15)" kind="«term_+_»">
                                  <IdentNode start="(70, 12)" end="(70, 13)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(70, 13)" end="(70, 14)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(70, 14)" end="(70, 15)" kind="num">
                                    <AtomNode start="(70, 14)" end="(70, 15)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(70, 15)" end="(70, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(70, 17)" end="(70, 20)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(70, 21)" end="(70, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(70, 24)" end="(70, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(70, 24)" end="(70, 26)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(70, 27)" end="(70, 44)">
                                <IdentNode start="(70, 27)" end="(70, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(70, 30)" end="(70, 31)" leading="" trailing=" " raw_val="n" val="n"/>
                                <OtherNode start="(70, 32)" end="(70, 44)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(70, 32)" end="(70, 33)" leading="" trailing="" val="("/>
                                  <OtherNode start="(70, 33)" end="(70, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(70, 33)" end="(70, 41)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(70, 42)" end="(70, 43)">
                                      <IdentNode start="(70, 42)" end="(70, 43)" leading="" trailing="" raw_val="x" val="x"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(70, 43)" end="(70, 44)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(72, 1)" end="(79, 30)" name="set_eq_setTR" full_name="List.set_eq_setTR">
      <CommandDeclmodifiersNode start="(72, 1)" end="(72, 9)">
        <NullNode/>
        <NullNode start="(72, 1)" end="(72, 9)">
          <OtherNode start="(72, 1)" end="(72, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(72, 1)" end="(72, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(72, 3)" end="(72, 8)">
              <OtherNode start="(72, 3)" end="(72, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(72, 3)" end="(72, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(72, 3)" end="(72, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(72, 8)" end="(72, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(72, 10)" end="(79, 30)" name="set_eq_setTR" full_name="List.set_eq_setTR" _is_private_decl="False">
        <AtomNode start="(72, 10)" end="(72, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(72, 18)" end="(72, 30)">
          <IdentNode start="(72, 18)" end="(72, 30)" leading="" trailing=" " raw_val="set_eq_setTR" val="set_eq_setTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(72, 31)" end="(72, 46)">
          <NullNode/>
          <TermTypespecNode start="(72, 31)" end="(72, 46)">
            <AtomNode start="(72, 31)" end="(72, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(72, 33)" end="(72, 46)" kind="«term_=_»">
              <OtherNode start="(72, 33)" end="(72, 37)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(72, 33)" end="(72, 34)" leading="" trailing="" val="@"/>
                <IdentNode start="(72, 34)" end="(72, 37)" leading="" trailing=" " raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(72, 38)" end="(72, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(72, 40)" end="(72, 46)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(72, 40)" end="(72, 41)" leading="" trailing="" val="@"/>
                <IdentNode start="(72, 41)" end="(72, 46)" leading="" trailing=" " raw_val="setTR" val="setTR" full_name="List.setTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(64, 15)" def_end="(64, 20)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(72, 47)" end="(79, 30)">
          <AtomNode start="(72, 47)" end="(72, 49)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(72, 50)" end="(79, 30)">
            <AtomNode start="(72, 50)" end="(72, 52)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(73, 3)" end="(79, 30)">
              <TacticTacticseq1IndentedNode start="(73, 3)" end="(79, 30)">
                <NullNode start="(73, 3)" end="(79, 30)">
                  <OtherNode start="(73, 3)" end="(73, 17)" kind="tacticFunext___" state_before="⊢ @set = @setTR" state_after="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;a : α&#10;⊢ l.set n a = l.setTR n a" tactic="funext α l n a">
                    <AtomNode start="(73, 3)" end="(73, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(73, 10)" end="(73, 17)">
                      <IdentNode start="(73, 10)" end="(73, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(73, 12)" end="(73, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(73, 14)" end="(73, 15)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(73, 16)" end="(73, 17)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(73, 17)" end="(73, 18)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(73, 19)" end="(73, 31)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;a : α&#10;⊢ l.set n a = l.setTR n a" state_after="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;a : α&#10;⊢ l.set n a = setTR.go l a l n #[]" tactic="simp [setTR]">
                    <AtomNode start="(73, 19)" end="(73, 23)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(73, 24)" end="(73, 31)">
                      <AtomNode start="(73, 24)" end="(73, 25)" leading="" trailing="" val="["/>
                      <NullNode start="(73, 25)" end="(73, 30)">
                        <OtherNode start="(73, 25)" end="(73, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(73, 25)" end="(73, 30)" leading="" trailing="" raw_val="setTR" val="setTR" full_name="List.setTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(64, 15)" def_end="(64, 20)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(73, 30)" end="(73, 31)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(74, 3)" end="(78, 83)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(74, 3)" end="(74, 6)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(74, 7)" end="(74, 10)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(74, 11)" end="(78, 83)" kind="Lean.Parser.Term.letRecDecls">
                      <NullNode start="(74, 11)" end="(78, 83)">
                        <OtherNode start="(74, 11)" end="(78, 83)" kind="Lean.Parser.Term.letRecDecl">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(74, 11)" end="(78, 83)" kind="Lean.Parser.Term.letDecl">
                            <OtherNode start="(74, 11)" end="(78, 83)" kind="Lean.Parser.Term.letEqnsDecl">
                              <IdentNode start="(74, 11)" end="(74, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(74, 14)" end="(74, 19)">
                                <TermExplicitbinderNode start="(74, 14)" end="(74, 19)">
                                  <AtomNode start="(74, 14)" end="(74, 15)" leading="" trailing="" val="("/>
                                  <NullNode start="(74, 15)" end="(74, 18)">
                                    <IdentNode start="(74, 15)" end="(74, 18)" leading="" trailing="" raw_val="acc" val="acc"/>
                                  </NullNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(74, 18)" end="(74, 19)" leading="" trailing=" " val=")"/>
                                </TermExplicitbinderNode>
                              </NullNode>
                              <NullNode start="(74, 20)" end="(75, 53)">
                                <TermTypespecNode start="(74, 20)" end="(75, 53)">
                                  <AtomNode start="(74, 20)" end="(74, 21)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(74, 22)" end="(75, 53)" kind="Lean.Parser.Term.forall">
                                    <AtomNode start="(74, 22)" end="(74, 23)" leading="" trailing=" " val="∀"/>
                                    <NullNode start="(74, 24)" end="(74, 28)">
                                      <IdentNode start="(74, 24)" end="(74, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                      <IdentNode start="(74, 27)" end="(74, 28)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(74, 28)" end="(74, 29)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(74, 30)" end="(75, 53)" kind="Lean.Parser.Term.arrow">
                                      <OtherNode start="(74, 30)" end="(74, 50)" kind="«term_=_»">
                                        <IdentNode start="(74, 30)" end="(74, 31)" leading="" trailing=" " raw_val="l" val="l"/>
                                        <AtomNode start="(74, 32)" end="(74, 33)" leading="" trailing=" " val="="/>
                                        <OtherNode start="(74, 34)" end="(74, 50)" kind="«term_++_»">
                                          <IdentNode start="(74, 34)" end="(74, 44)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                          <AtomNode start="(74, 45)" end="(74, 47)" leading="" trailing=" " val="++"/>
                                          <IdentNode start="(74, 48)" end="(74, 50)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(74, 51)" end="(74, 52)" leading="" trailing="&#10;    " val="→"/>
                                      <OtherNode start="(75, 5)" end="(75, 53)" kind="«term_=_»">
                                        <OtherNode start="(75, 5)" end="(75, 26)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(75, 5)" end="(75, 13)" leading="" trailing=" " raw_val="setTR.go" val="setTR.go" full_name="List.setTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(67, 3)" def_end="(67, 5)"/>
                                          <NullNode start="(75, 14)" end="(75, 26)">
                                            <IdentNode start="(75, 14)" end="(75, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                                            <IdentNode start="(75, 16)" end="(75, 17)" leading="" trailing=" " raw_val="a" val="a"/>
                                            <IdentNode start="(75, 18)" end="(75, 20)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                            <IdentNode start="(75, 21)" end="(75, 22)" leading="" trailing=" " raw_val="i" val="i"/>
                                            <IdentNode start="(75, 23)" end="(75, 26)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(75, 27)" end="(75, 28)" leading="" trailing=" " val="="/>
                                        <OtherNode start="(75, 29)" end="(75, 53)" kind="«term_++_»">
                                          <IdentNode start="(75, 29)" end="(75, 39)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                          <AtomNode start="(75, 40)" end="(75, 42)" leading="" trailing=" " val="++"/>
                                          <OtherNode start="(75, 43)" end="(75, 53)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(75, 43)" end="(75, 49)" leading="" trailing=" " raw_val="xs.set" val="xs.set"/>
                                            <NullNode start="(75, 50)" end="(75, 53)">
                                              <IdentNode start="(75, 50)" end="(75, 51)" leading="" trailing=" " raw_val="i" val="i"/>
                                              <IdentNode start="(75, 52)" end="(75, 53)" leading="" trailing="&#10;  " raw_val="a" val="a"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </TermTypespecNode>
                              </NullNode>
                              <OtherNode start="(76, 3)" end="(78, 83)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(76, 3)" end="(78, 83)">
                                  <OtherNode start="(76, 3)" end="(76, 49)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(76, 3)" end="(76, 4)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(76, 5)" end="(76, 10)">
                                      <NullNode start="(76, 5)" end="(76, 10)">
                                        <OtherNode start="(76, 5)" end="(76, 7)" kind="«term[_]»">
                                          <AtomNode start="(76, 5)" end="(76, 6)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(76, 6)" end="(76, 7)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(76, 7)" end="(76, 8)" leading="" trailing=" " val=","/>
                                        <TermHoleNode start="(76, 9)" end="(76, 10)">
                                          <AtomNode start="(76, 9)" end="(76, 10)" leading="" trailing=" " val="_"/>
                                        </TermHoleNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(76, 11)" end="(76, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(76, 14)" end="(76, 49)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(76, 14)" end="(76, 17)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(76, 18)" end="(76, 49)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(76, 18)" end="(76, 19)">
                                          <IdentNode start="(76, 18)" end="(76, 19)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(76, 20)" end="(76, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <TermBytacticNode start="(76, 23)" end="(76, 49)">
                                          <AtomNode start="(76, 23)" end="(76, 25)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(76, 26)" end="(76, 49)">
                                            <TacticTacticseq1IndentedNode start="(76, 26)" end="(76, 49)">
                                              <NullNode start="(76, 26)" end="(76, 49)">
                                                <OtherNode start="(76, 26)" end="(76, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;n : Nat&#10;a : α&#10;acc : Array α&#10;x✝ : Nat&#10;h : l = acc.toList ++ []&#10;⊢ setTR.go l a [] x✝ acc = acc.toList ++ [].set x✝ a" state_after="no goals" tactic="simp [setTR.go, set, h]">
                                                  <AtomNode start="(76, 26)" end="(76, 30)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode start="(76, 31)" end="(76, 49)">
                                                    <AtomNode start="(76, 31)" end="(76, 32)" leading="" trailing="" val="["/>
                                                    <NullNode start="(76, 32)" end="(76, 48)">
                                                      <OtherNode start="(76, 32)" end="(76, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(76, 32)" end="(76, 40)" leading="" trailing="" raw_val="setTR.go" val="setTR.go" full_name="List.setTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(67, 3)" def_end="(67, 5)"/>
                                                      </OtherNode>
                                                      <AtomNode start="(76, 40)" end="(76, 41)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(76, 42)" end="(76, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(76, 42)" end="(76, 45)" leading="" trailing="" raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                      </OtherNode>
                                                      <AtomNode start="(76, 45)" end="(76, 46)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(76, 47)" end="(76, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(76, 47)" end="(76, 48)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(76, 48)" end="(76, 49)" leading="" trailing="&#10;  " val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(77, 3)" end="(77, 40)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(77, 3)" end="(77, 4)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(77, 5)" end="(77, 13)">
                                      <NullNode start="(77, 5)" end="(77, 13)">
                                        <OtherNode start="(77, 5)" end="(77, 10)" kind="«term_::_»">
                                          <IdentNode start="(77, 5)" end="(77, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                          <AtomNode start="(77, 6)" end="(77, 8)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(77, 8)" end="(77, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                                        </OtherNode>
                                        <AtomNode start="(77, 10)" end="(77, 11)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(77, 12)" end="(77, 13)" kind="num">
                                          <AtomNode start="(77, 12)" end="(77, 13)" leading="" trailing=" " val="0"/>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(77, 14)" end="(77, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(77, 17)" end="(77, 40)">
                                      <AtomNode start="(77, 17)" end="(77, 19)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(77, 20)" end="(77, 40)">
                                        <TacticTacticseq1IndentedNode start="(77, 20)" end="(77, 40)">
                                          <NullNode start="(77, 20)" end="(77, 40)">
                                            <OtherNode start="(77, 20)" end="(77, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;n : Nat&#10;a : α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs → setTR.go l a (x :: xs) 0 acc = acc.toList ++ (x :: xs).set 0 a" state_after="no goals" tactic="simp [setTR.go, set]">
                                              <AtomNode start="(77, 20)" end="(77, 24)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(77, 25)" end="(77, 40)">
                                                <AtomNode start="(77, 25)" end="(77, 26)" leading="" trailing="" val="["/>
                                                <NullNode start="(77, 26)" end="(77, 39)">
                                                  <OtherNode start="(77, 26)" end="(77, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(77, 26)" end="(77, 34)" leading="" trailing="" raw_val="setTR.go" val="setTR.go" full_name="List.setTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(67, 3)" def_end="(67, 5)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(77, 34)" end="(77, 35)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(77, 36)" end="(77, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(77, 36)" end="(77, 39)" leading="" trailing="" raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(77, 39)" end="(77, 40)" leading="" trailing="&#10;  " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                  <OtherNode start="(78, 3)" end="(78, 83)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(78, 3)" end="(78, 4)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(78, 5)" end="(78, 15)">
                                      <NullNode start="(78, 5)" end="(78, 15)">
                                        <OtherNode start="(78, 5)" end="(78, 10)" kind="«term_::_»">
                                          <IdentNode start="(78, 5)" end="(78, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                          <AtomNode start="(78, 6)" end="(78, 8)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(78, 8)" end="(78, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                                        </OtherNode>
                                        <AtomNode start="(78, 10)" end="(78, 11)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(78, 12)" end="(78, 15)" kind="«term_+_»">
                                          <IdentNode start="(78, 12)" end="(78, 13)" leading="" trailing="" raw_val="n" val="n"/>
                                          <AtomNode start="(78, 13)" end="(78, 14)" leading="" trailing="" val="+"/>
                                          <OtherNode start="(78, 14)" end="(78, 15)" kind="num">
                                            <AtomNode start="(78, 14)" end="(78, 15)" leading="" trailing=" " val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(78, 16)" end="(78, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(78, 19)" end="(78, 83)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(78, 19)" end="(78, 22)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(78, 23)" end="(78, 83)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(78, 23)" end="(78, 24)">
                                          <IdentNode start="(78, 23)" end="(78, 24)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(78, 25)" end="(78, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <TermBytacticNode start="(78, 28)" end="(78, 83)">
                                          <AtomNode start="(78, 28)" end="(78, 30)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(78, 31)" end="(78, 83)">
                                            <TacticTacticseq1IndentedNode start="(78, 31)" end="(78, 83)">
                                              <NullNode start="(78, 31)" end="(78, 83)">
                                                <OtherNode start="(78, 31)" end="(78, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;n✝ : Nat&#10;a : α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;n : Nat&#10;h : l = acc.toList ++ x :: xs&#10;⊢ setTR.go l a (x :: xs) (n + 1) acc = acc.toList ++ (x :: xs).set (n + 1) a" state_after="α : Type u_1&#10;l : List α&#10;n✝ : Nat&#10;a : α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;n : Nat&#10;h : l = acc.toList ++ x :: xs&#10;⊢ setTR.go l a xs n (acc.push x) = acc.toList ++ x :: xs.set n a" tactic="simp only [setTR.go, set]">
                                                  <AtomNode start="(78, 31)" end="(78, 35)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode start="(78, 36)" end="(78, 40)">
                                                    <AtomNode start="(78, 36)" end="(78, 40)" leading="" trailing=" " val="only"/>
                                                  </NullNode>
                                                  <NullNode start="(78, 41)" end="(78, 56)">
                                                    <AtomNode start="(78, 41)" end="(78, 42)" leading="" trailing="" val="["/>
                                                    <NullNode start="(78, 42)" end="(78, 55)">
                                                      <OtherNode start="(78, 42)" end="(78, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(78, 42)" end="(78, 50)" leading="" trailing="" raw_val="setTR.go" val="setTR.go" full_name="List.setTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(67, 3)" def_end="(67, 5)"/>
                                                      </OtherNode>
                                                      <AtomNode start="(78, 50)" end="(78, 51)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(78, 52)" end="(78, 55)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(78, 52)" end="(78, 55)" leading="" trailing="" raw_val="set" val="set" full_name="List.set" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(78, 55)" end="(78, 56)" leading="" trailing="" val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                                <AtomNode start="(78, 56)" end="(78, 57)" leading="" trailing=" " val=";"/>
                                                <OtherNode start="(78, 58)" end="(78, 83)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;l : List α&#10;n✝ : Nat&#10;a : α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;n : Nat&#10;h : l = acc.toList ++ x :: xs&#10;⊢ setTR.go l a xs n (acc.push x) = acc.toList ++ x :: xs.set n a" state_after="no goals" tactic="rw [go _ xs] &amp;lt;;&amp;gt; simp [h]">
                                                  <OtherNode start="(78, 58)" end="(78, 70)" kind="Lean.Parser.Tactic.rwSeq">
                                                    <AtomNode start="(78, 58)" end="(78, 60)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(78, 61)" end="(78, 70)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(78, 61)" end="(78, 62)" leading="" trailing="" val="["/>
                                                      <NullNode start="(78, 62)" end="(78, 69)">
                                                        <OtherNode start="(78, 62)" end="(78, 69)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <OtherNode start="(78, 62)" end="(78, 69)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(78, 62)" end="(78, 64)" leading="" trailing=" " raw_val="go" val="go"/>
                                                            <NullNode start="(78, 65)" end="(78, 69)">
                                                            <TermHoleNode start="(78, 65)" end="(78, 66)">
                                                            <AtomNode start="(78, 65)" end="(78, 66)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(78, 67)" end="(78, 69)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(78, 69)" end="(78, 70)" leading="" trailing=" " val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(78, 71)" end="(78, 74)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                  <OtherNode start="(78, 75)" end="(78, 83)" kind="Lean.Parser.Tactic.simp">
                                                    <AtomNode start="(78, 75)" end="(78, 79)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(78, 80)" end="(78, 83)">
                                                      <AtomNode start="(78, 80)" end="(78, 81)" leading="" trailing="" val="["/>
                                                      <NullNode start="(78, 81)" end="(78, 82)">
                                                        <OtherNode start="(78, 81)" end="(78, 82)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(78, 81)" end="(78, 82)" leading="" trailing="" raw_val="h" val="h"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(78, 82)" end="(78, 83)" leading="" trailing="&#10;  " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode kind="Lean.Parser.Termination.suffix">
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(79, 3)" end="(79, 30)" kind="Lean.Parser.Tactic.exact" state_before="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : Nat&#10;a : α&#10;⊢ l.set n a = setTR.go l a l n #[]" state_after="no goals" tactic="exact (go #[] _ _ rfl).symm">
                    <AtomNode start="(79, 3)" end="(79, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(79, 9)" end="(79, 30)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(79, 9)" end="(79, 25)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(79, 9)" end="(79, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(79, 10)" end="(79, 24)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(79, 10)" end="(79, 12)" leading="" trailing=" " raw_val="go" val="go"/>
                          <NullNode start="(79, 13)" end="(79, 24)">
                            <OtherNode start="(79, 13)" end="(79, 16)" kind="«term#[_,]»">
                              <AtomNode start="(79, 13)" end="(79, 15)" leading="" trailing="" val="#["/>
                              <NullNode/>
                              <AtomNode start="(79, 15)" end="(79, 16)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <TermHoleNode start="(79, 17)" end="(79, 18)">
                              <AtomNode start="(79, 17)" end="(79, 18)" leading="" trailing=" " val="_"/>
                            </TermHoleNode>
                            <TermHoleNode start="(79, 19)" end="(79, 20)">
                              <AtomNode start="(79, 19)" end="(79, 20)" leading="" trailing=" " val="_"/>
                            </TermHoleNode>
                            <IdentNode start="(79, 21)" end="(79, 24)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(79, 24)" end="(79, 25)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(79, 25)" end="(79, 26)" leading="" trailing="" val="."/>
                      <IdentNode start="(79, 26)" end="(79, 30)" leading="" trailing="&#10;&#10;" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(81, 1)" end="(81, 21)" comment="### filterMap -/">
      <AtomNode start="(81, 1)" end="(81, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(81, 5)" end="(81, 21)" leading="" trailing="&#10;&#10;&#10;" val="### filterMap -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(84, 1)" end="(105, 35)" name="filterMapTR" full_name="List.filterMapTR">
      <CommandDeclmodifiersNode start="(84, 1)" end="(99, 10)">
        <NullNode start="(84, 1)" end="(98, 3)">
          <CommandDoccommentNode start="(84, 1)" end="(98, 3)" comment="Applies a function that returns an `Option` to each element of a list, collecting the non-`none`&#10;values.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.filterMap`, used at runtime.&#10;&#10;Example:&#10;```lean example&#10;#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =&amp;gt;&#10;  if x &amp;gt; 2 then some (2 * x) else none&#10;```&#10;```output&#10;[10, 14, 14]&#10;```&#10;-/">
            <AtomNode start="(84, 1)" end="(84, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(85, 1)" end="(98, 3)" leading="" trailing="&#10;" val="Applies a function that returns an `Option` to each element of a list, collecting the non-`none`&#10;values.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.filterMap`, used at runtime.&#10;&#10;Example:&#10;```lean example&#10;#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =&amp;gt;&#10;  if x &amp;gt; 2 then some (2 * x) else none&#10;```&#10;```output&#10;[10, 14, 14]&#10;```&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(99, 1)" end="(99, 10)">
          <OtherNode start="(99, 1)" end="(99, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(99, 1)" end="(99, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(99, 3)" end="(99, 9)">
              <OtherNode start="(99, 3)" end="(99, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(99, 3)" end="(99, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(99, 3)" end="(99, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(99, 9)" end="(99, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(99, 11)" end="(105, 35)" name="filterMapTR">
        <AtomNode start="(99, 11)" end="(99, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(99, 15)" end="(99, 26)">
          <IdentNode start="(99, 15)" end="(99, 26)" leading="" trailing=" " raw_val="filterMapTR" val="filterMapTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(99, 27)" end="(99, 67)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(99, 27)" end="(99, 58)">
            <TermExplicitbinderNode start="(99, 27)" end="(99, 45)">
              <AtomNode start="(99, 27)" end="(99, 28)" leading="" trailing="" val="("/>
              <NullNode start="(99, 28)" end="(99, 29)">
                <IdentNode start="(99, 28)" end="(99, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(99, 30)" end="(99, 44)">
                <AtomNode start="(99, 30)" end="(99, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 32)" end="(99, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(99, 32)" end="(99, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(99, 34)" end="(99, 35)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(99, 36)" end="(99, 44)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(99, 36)" end="(99, 42)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(99, 43)" end="(99, 44)">
                      <IdentNode start="(99, 43)" end="(99, 44)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(99, 44)" end="(99, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(99, 46)" end="(99, 58)">
              <AtomNode start="(99, 46)" end="(99, 47)" leading="" trailing="" val="("/>
              <NullNode start="(99, 47)" end="(99, 48)">
                <IdentNode start="(99, 47)" end="(99, 48)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(99, 49)" end="(99, 57)">
                <AtomNode start="(99, 49)" end="(99, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(99, 51)" end="(99, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(99, 51)" end="(99, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(99, 56)" end="(99, 57)">
                    <IdentNode start="(99, 56)" end="(99, 57)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(99, 57)" end="(99, 58)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(99, 59)" end="(99, 67)">
            <TermTypespecNode start="(99, 59)" end="(99, 67)">
              <AtomNode start="(99, 59)" end="(99, 60)" leading="" trailing=" " val=":"/>
              <OtherNode start="(99, 61)" end="(99, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(99, 61)" end="(99, 65)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(99, 66)" end="(99, 67)">
                  <IdentNode start="(99, 66)" end="(99, 67)" leading="" trailing=" " raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(99, 68)" end="(105, 35)">
          <AtomNode start="(99, 68)" end="(99, 70)" leading="" trailing=" " val=":="/>
          <OtherNode start="(99, 71)" end="(99, 79)" kind="Lean.Parser.Term.app">
            <IdentNode start="(99, 71)" end="(99, 73)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(99, 74)" end="(99, 79)">
              <IdentNode start="(99, 74)" end="(99, 75)" leading="" trailing=" " raw_val="l" val="l"/>
              <OtherNode start="(99, 76)" end="(99, 79)" kind="«term#[_,]»">
                <AtomNode start="(99, 76)" end="(99, 78)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(99, 78)" end="(99, 79)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(99, 80)" end="(105, 35)">
            <OtherNode start="(99, 80)" end="(105, 35)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(99, 80)" end="(99, 85)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(100, 3)" end="(105, 35)">
                <OtherNode start="(100, 3)" end="(105, 35)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(100, 3)" end="(100, 85)">
                    <CommandDoccommentNode start="(100, 3)" end="(100, 85)" comment="Auxiliary for `filterMap`: `filterMap.go f l = acc.toList ++ filterMap f l` -/">
                      <AtomNode start="(100, 3)" end="(100, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(100, 7)" end="(100, 85)" leading="" trailing="&#10;  " val="Auxiliary for `filterMap`: `filterMap.go f l = acc.toList ++ filterMap f l` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(101, 3)" end="(101, 16)">
                    <OtherNode start="(101, 3)" end="(101, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(101, 3)" end="(101, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(101, 5)" end="(101, 15)">
                        <OtherNode start="(101, 5)" end="(101, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(101, 5)" end="(101, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(101, 5)" end="(101, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(101, 15)" end="(101, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(101, 17)" end="(105, 35)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(101, 17)" end="(105, 35)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(101, 17)" end="(101, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(101, 20)" end="(101, 47)">
                        <TermTypespecNode start="(101, 20)" end="(101, 47)">
                          <AtomNode start="(101, 20)" end="(101, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(101, 22)" end="(101, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(101, 22)" end="(101, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(101, 22)" end="(101, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(101, 27)" end="(101, 28)">
                                <IdentNode start="(101, 27)" end="(101, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(101, 29)" end="(101, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(101, 31)" end="(101, 47)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(101, 31)" end="(101, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(101, 31)" end="(101, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(101, 37)" end="(101, 38)">
                                  <IdentNode start="(101, 37)" end="(101, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(101, 39)" end="(101, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(101, 41)" end="(101, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(101, 41)" end="(101, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(101, 46)" end="(101, 47)">
                                  <IdentNode start="(101, 46)" end="(101, 47)" leading="" trailing="&#10;  " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(102, 3)" end="(105, 35)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(102, 3)" end="(105, 35)">
                          <OtherNode start="(102, 3)" end="(102, 26)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(102, 3)" end="(102, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(102, 5)" end="(102, 12)">
                              <NullNode start="(102, 5)" end="(102, 12)">
                                <OtherNode start="(102, 5)" end="(102, 7)" kind="«term[_]»">
                                  <AtomNode start="(102, 5)" end="(102, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(102, 6)" end="(102, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(102, 7)" end="(102, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(102, 9)" end="(102, 12)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(102, 13)" end="(102, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(102, 16)" end="(102, 26)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(103, 3)" end="(105, 35)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(103, 3)" end="(103, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(103, 5)" end="(103, 15)">
                              <NullNode start="(103, 5)" end="(103, 15)">
                                <OtherNode start="(103, 5)" end="(103, 10)" kind="«term_::_»">
                                  <IdentNode start="(103, 5)" end="(103, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(103, 6)" end="(103, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(103, 8)" end="(103, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(103, 10)" end="(103, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(103, 12)" end="(103, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(103, 16)" end="(103, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(103, 19)" end="(105, 35)" kind="Lean.Parser.Term.match">
                              <AtomNode start="(103, 19)" end="(103, 24)" leading="" trailing=" " val="match"/>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(103, 25)" end="(103, 28)">
                                <OtherNode start="(103, 25)" end="(103, 28)" kind="Lean.Parser.Term.matchDiscr">
                                  <NullNode/>
                                  <OtherNode start="(103, 25)" end="(103, 28)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(103, 25)" end="(103, 26)" leading="" trailing=" " raw_val="f" val="f"/>
                                    <NullNode start="(103, 27)" end="(103, 28)">
                                      <IdentNode start="(103, 27)" end="(103, 28)" leading="" trailing=" " raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(103, 29)" end="(103, 33)" leading="" trailing="&#10;    " val="with"/>
                              <OtherNode start="(104, 5)" end="(105, 35)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(104, 5)" end="(105, 35)">
                                  <OtherNode start="(104, 5)" end="(104, 24)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(104, 5)" end="(104, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(104, 7)" end="(104, 11)">
                                      <NullNode start="(104, 7)" end="(104, 11)">
                                        <IdentNode start="(104, 7)" end="(104, 11)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(104, 12)" end="(104, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(104, 15)" end="(104, 24)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(104, 15)" end="(104, 17)" leading="" trailing=" " raw_val="go" val="go"/>
                                      <NullNode start="(104, 18)" end="(104, 24)">
                                        <IdentNode start="(104, 18)" end="(104, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                                        <IdentNode start="(104, 21)" end="(104, 24)" leading="" trailing="&#10;    " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(105, 5)" end="(105, 35)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(105, 5)" end="(105, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(105, 7)" end="(105, 13)">
                                      <NullNode start="(105, 7)" end="(105, 13)">
                                        <OtherNode start="(105, 7)" end="(105, 13)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(105, 7)" end="(105, 11)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <NullNode start="(105, 12)" end="(105, 13)">
                                            <IdentNode start="(105, 12)" end="(105, 13)" leading="" trailing=" " raw_val="b" val="b"/>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(105, 14)" end="(105, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(105, 17)" end="(105, 35)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(105, 17)" end="(105, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                                      <NullNode start="(105, 20)" end="(105, 35)">
                                        <IdentNode start="(105, 20)" end="(105, 22)" leading="" trailing=" " raw_val="as" val="as"/>
                                        <OtherNode start="(105, 23)" end="(105, 35)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(105, 23)" end="(105, 24)" leading="" trailing="" val="("/>
                                          <OtherNode start="(105, 24)" end="(105, 34)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(105, 24)" end="(105, 32)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                            <NullNode start="(105, 33)" end="(105, 34)">
                                              <IdentNode start="(105, 33)" end="(105, 34)" leading="" trailing="" raw_val="b" val="b"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(105, 34)" end="(105, 35)" leading="" trailing="&#10;&#10;" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(107, 1)" end="(115, 24)" name="filterMap_eq_filterMapTR" full_name="List.filterMap_eq_filterMapTR">
      <CommandDeclmodifiersNode start="(107, 1)" end="(107, 9)">
        <NullNode/>
        <NullNode start="(107, 1)" end="(107, 9)">
          <OtherNode start="(107, 1)" end="(107, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(107, 1)" end="(107, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(107, 3)" end="(107, 8)">
              <OtherNode start="(107, 3)" end="(107, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(107, 3)" end="(107, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(107, 3)" end="(107, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(107, 8)" end="(107, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(107, 10)" end="(115, 24)" name="filterMap_eq_filterMapTR" full_name="List.filterMap_eq_filterMapTR" _is_private_decl="False">
        <AtomNode start="(107, 10)" end="(107, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(107, 18)" end="(107, 42)">
          <IdentNode start="(107, 18)" end="(107, 42)" leading="" trailing=" " raw_val="filterMap_eq_filterMapTR" val="filterMap_eq_filterMapTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(107, 43)" end="(107, 75)">
          <NullNode/>
          <TermTypespecNode start="(107, 43)" end="(107, 75)">
            <AtomNode start="(107, 43)" end="(107, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(107, 45)" end="(107, 75)" kind="«term_=_»">
              <OtherNode start="(107, 45)" end="(107, 60)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(107, 45)" end="(107, 46)" leading="" trailing="" val="@"/>
                <IdentNode start="(107, 46)" end="(107, 60)" leading="" trailing=" " raw_val="List.filterMap" val="List.filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(107, 61)" end="(107, 62)" leading="" trailing=" " val="="/>
              <OtherNode start="(107, 63)" end="(107, 75)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(107, 63)" end="(107, 64)" leading="" trailing="" val="@"/>
                <IdentNode start="(107, 64)" end="(107, 75)" leading="" trailing=" " raw_val="filterMapTR" val="filterMapTR" full_name="List.filterMapTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(99, 15)" def_end="(99, 26)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(107, 76)" end="(115, 24)">
          <AtomNode start="(107, 76)" end="(107, 78)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(107, 79)" end="(115, 24)">
            <AtomNode start="(107, 79)" end="(107, 81)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(108, 3)" end="(115, 24)">
              <TacticTacticseq1IndentedNode start="(108, 3)" end="(115, 24)">
                <NullNode start="(108, 3)" end="(115, 24)">
                  <OtherNode start="(108, 3)" end="(108, 17)" kind="tacticFunext___" state_before="⊢ @filterMap = @filterMapTR" state_after="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → Option β&#10;l : List α&#10;⊢ filterMap f l = filterMapTR f l" tactic="funext α β f l">
                    <AtomNode start="(108, 3)" end="(108, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(108, 10)" end="(108, 17)">
                      <IdentNode start="(108, 10)" end="(108, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(108, 12)" end="(108, 13)" leading="" trailing=" " raw_val="β" val="β"/>
                      <IdentNode start="(108, 14)" end="(108, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(108, 16)" end="(108, 17)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(109, 3)" end="(114, 25)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(109, 3)" end="(109, 6)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(109, 7)" end="(109, 10)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(109, 11)" end="(114, 25)" kind="Lean.Parser.Term.letRecDecls">
                      <NullNode start="(109, 11)" end="(114, 25)">
                        <OtherNode start="(109, 11)" end="(114, 25)" kind="Lean.Parser.Term.letRecDecl">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(109, 11)" end="(114, 25)" kind="Lean.Parser.Term.letDecl">
                            <OtherNode start="(109, 11)" end="(114, 25)" kind="Lean.Parser.Term.letEqnsDecl">
                              <IdentNode start="(109, 11)" end="(109, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode/>
                              <NullNode start="(109, 14)" end="(109, 80)">
                                <TermTypespecNode start="(109, 14)" end="(109, 80)">
                                  <AtomNode start="(109, 14)" end="(109, 15)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(109, 16)" end="(109, 80)" kind="Lean.Parser.Term.forall">
                                    <AtomNode start="(109, 16)" end="(109, 17)" leading="" trailing=" " val="∀"/>
                                    <NullNode start="(109, 18)" end="(109, 24)">
                                      <IdentNode start="(109, 18)" end="(109, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                                      <IdentNode start="(109, 21)" end="(109, 24)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(109, 24)" end="(109, 25)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(109, 26)" end="(109, 80)" kind="«term_=_»">
                                      <OtherNode start="(109, 26)" end="(109, 49)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(109, 26)" end="(109, 40)" leading="" trailing=" " raw_val="filterMapTR.go" val="filterMapTR.go" full_name="List.filterMapTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(101, 17)" def_end="(101, 19)"/>
                                        <NullNode start="(109, 41)" end="(109, 49)">
                                          <IdentNode start="(109, 41)" end="(109, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <IdentNode start="(109, 43)" end="(109, 45)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <IdentNode start="(109, 46)" end="(109, 49)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(109, 50)" end="(109, 51)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(109, 52)" end="(109, 80)" kind="«term_++_»">
                                        <IdentNode start="(109, 52)" end="(109, 62)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                        <AtomNode start="(109, 63)" end="(109, 65)" leading="" trailing=" " val="++"/>
                                        <OtherNode start="(109, 66)" end="(109, 80)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(109, 66)" end="(109, 78)" leading="" trailing=" " raw_val="as.filterMap" val="as.filterMap"/>
                                          <NullNode start="(109, 79)" end="(109, 80)">
                                            <IdentNode start="(109, 79)" end="(109, 80)" leading="" trailing="&#10;    " raw_val="f" val="f"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </TermTypespecNode>
                              </NullNode>
                              <OtherNode start="(110, 5)" end="(114, 25)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(110, 5)" end="(114, 25)">
                                  <OtherNode start="(110, 5)" end="(110, 53)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(110, 5)" end="(110, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(110, 7)" end="(110, 14)">
                                      <NullNode start="(110, 7)" end="(110, 14)">
                                        <OtherNode start="(110, 7)" end="(110, 9)" kind="«term[_]»">
                                          <AtomNode start="(110, 7)" end="(110, 8)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(110, 9)" end="(110, 10)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(110, 11)" end="(110, 14)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(110, 15)" end="(110, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(110, 18)" end="(110, 53)">
                                      <AtomNode start="(110, 18)" end="(110, 20)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(110, 21)" end="(110, 53)">
                                        <TacticTacticseq1IndentedNode start="(110, 21)" end="(110, 53)">
                                          <NullNode start="(110, 21)" end="(110, 53)">
                                            <OtherNode start="(110, 21)" end="(110, 53)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → Option β&#10;l : List α&#10;acc : Array β&#10;⊢ filterMapTR.go f [] acc = acc.toList ++ filterMap f []" state_after="no goals" tactic="simp [filterMapTR.go, filterMap]">
                                              <AtomNode start="(110, 21)" end="(110, 25)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(110, 26)" end="(110, 53)">
                                                <AtomNode start="(110, 26)" end="(110, 27)" leading="" trailing="" val="["/>
                                                <NullNode start="(110, 27)" end="(110, 52)">
                                                  <OtherNode start="(110, 27)" end="(110, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(110, 27)" end="(110, 41)" leading="" trailing="" raw_val="filterMapTR.go" val="filterMapTR.go" full_name="List.filterMapTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(101, 17)" def_end="(101, 19)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(110, 41)" end="(110, 42)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(110, 43)" end="(110, 52)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(110, 43)" end="(110, 52)" leading="" trailing="" raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(110, 52)" end="(110, 53)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                  <OtherNode start="(111, 5)" end="(114, 25)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(111, 5)" end="(111, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(111, 7)" end="(111, 17)">
                                      <NullNode start="(111, 7)" end="(111, 17)">
                                        <OtherNode start="(111, 7)" end="(111, 12)" kind="«term_::_»">
                                          <IdentNode start="(111, 7)" end="(111, 8)" leading="" trailing="" raw_val="a" val="a"/>
                                          <AtomNode start="(111, 8)" end="(111, 10)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(111, 10)" end="(111, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                        </OtherNode>
                                        <AtomNode start="(111, 12)" end="(111, 13)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(111, 14)" end="(111, 17)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(111, 18)" end="(111, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(111, 21)" end="(114, 25)">
                                      <AtomNode start="(111, 21)" end="(111, 23)" leading="" trailing="&#10;      " val="by"/>
                                      <TacticTacticseqNode start="(112, 7)" end="(114, 25)">
                                        <TacticTacticseq1IndentedNode start="(112, 7)" end="(114, 25)">
                                          <NullNode start="(112, 7)" end="(114, 25)">
                                            <OtherNode start="(112, 7)" end="(113, 19)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → Option β&#10;l : List α&#10;a : α&#10;as : List α&#10;acc : Array β&#10;⊢ filterMapTR.go f (a :: as) acc = acc.toList ++ filterMap f (a :: as)" state_after="α : Type u_2&#10;β : Type u_1&#10;f : α → Option β&#10;l : List α&#10;a : α&#10;as : List α&#10;acc : Array β&#10;⊢ (match f a with&#10;    | none =&amp;gt; acc.toList ++ filterMap f as&#10;    | some b =&amp;gt; acc.toList ++ b :: filterMap f as) =&#10;    acc.toList ++&#10;      match f a with&#10;      | none =&amp;gt; filterMap f as&#10;      | some b =&amp;gt; b :: filterMap f as" tactic="simp only [filterMapTR.go, go as, Array.push_toList, append_assoc, singleton_append,&#10;  filterMap]">
                                              <AtomNode start="(112, 7)" end="(112, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(112, 12)" end="(112, 16)">
                                                <AtomNode start="(112, 12)" end="(112, 16)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(112, 17)" end="(113, 19)">
                                                <AtomNode start="(112, 17)" end="(112, 18)" leading="" trailing="" val="["/>
                                                <NullNode start="(112, 18)" end="(113, 18)">
                                                  <OtherNode start="(112, 18)" end="(112, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(112, 18)" end="(112, 32)" leading="" trailing="" raw_val="filterMapTR.go" val="filterMapTR.go" full_name="List.filterMapTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(101, 17)" def_end="(101, 19)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(112, 32)" end="(112, 33)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(112, 34)" end="(112, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <OtherNode start="(112, 34)" end="(112, 39)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(112, 34)" end="(112, 36)" leading="" trailing=" " raw_val="go" val="go"/>
                                                      <NullNode start="(112, 37)" end="(112, 39)">
                                                        <IdentNode start="(112, 37)" end="(112, 39)" leading="" trailing="" raw_val="as" val="as"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(112, 39)" end="(112, 40)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(112, 41)" end="(112, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(112, 41)" end="(112, 58)" leading="" trailing="" raw_val="Array.push_toList" val="Array.push_toList" full_name="Array.push_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(112, 58)" end="(112, 59)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(112, 60)" end="(112, 72)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(112, 60)" end="(112, 72)" leading="" trailing="" raw_val="append_assoc" val="append_assoc" full_name="List.append_assoc" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(112, 72)" end="(112, 73)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(112, 74)" end="(112, 90)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(112, 74)" end="(112, 90)" leading="" trailing="" raw_val="singleton_append" val="singleton_append" full_name="List.singleton_append" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(112, 90)" end="(112, 91)" leading="" trailing="&#10;        " val=","/>
                                                  <OtherNode start="(113, 9)" end="(113, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(113, 9)" end="(113, 18)" leading="" trailing="" raw_val="filterMap" val="filterMap" full_name="List.filterMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(113, 18)" end="(113, 19)" leading="" trailing="&#10;      " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(114, 7)" end="(114, 25)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → Option β&#10;l : List α&#10;a : α&#10;as : List α&#10;acc : Array β&#10;⊢ (match f a with&#10;    | none =&amp;gt; acc.toList ++ filterMap f as&#10;    | some b =&amp;gt; acc.toList ++ b :: filterMap f as) =&#10;    acc.toList ++&#10;      match f a with&#10;      | none =&amp;gt; filterMap f as&#10;      | some b =&amp;gt; b :: filterMap f as" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp [*]">
                                              <OtherNode start="(114, 7)" end="(114, 12)" kind="Lean.Parser.Tactic.split">
                                                <AtomNode start="(114, 7)" end="(114, 12)" leading="" trailing=" " val="split"/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(114, 13)" end="(114, 16)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(114, 17)" end="(114, 25)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(114, 17)" end="(114, 21)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(114, 22)" end="(114, 25)">
                                                  <AtomNode start="(114, 22)" end="(114, 23)" leading="" trailing="" val="["/>
                                                  <NullNode start="(114, 23)" end="(114, 24)">
                                                    <OtherNode start="(114, 23)" end="(114, 24)" kind="Lean.Parser.Tactic.simpStar">
                                                      <AtomNode start="(114, 23)" end="(114, 24)" leading="" trailing="" val="*"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(114, 24)" end="(114, 25)" leading="" trailing="&#10;  " val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode kind="Lean.Parser.Termination.suffix">
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(115, 3)" end="(115, 24)" kind="Lean.Parser.Tactic.exact" state_before="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → Option β&#10;l : List α&#10;⊢ filterMap f l = filterMapTR f l" state_after="no goals" tactic="exact (go l #[]).symm">
                    <AtomNode start="(115, 3)" end="(115, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(115, 9)" end="(115, 24)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(115, 9)" end="(115, 19)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(115, 9)" end="(115, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(115, 10)" end="(115, 18)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(115, 10)" end="(115, 12)" leading="" trailing=" " raw_val="go" val="go"/>
                          <NullNode start="(115, 13)" end="(115, 18)">
                            <IdentNode start="(115, 13)" end="(115, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                            <OtherNode start="(115, 15)" end="(115, 18)" kind="«term#[_,]»">
                              <AtomNode start="(115, 15)" end="(115, 17)" leading="" trailing="" val="#["/>
                              <NullNode/>
                              <AtomNode start="(115, 17)" end="(115, 18)" leading="" trailing="" val="]"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(115, 18)" end="(115, 19)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(115, 19)" end="(115, 20)" leading="" trailing="" val="."/>
                      <IdentNode start="(115, 20)" end="(115, 24)" leading="" trailing="&#10;&#10;" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(117, 1)" end="(117, 17)" comment="### foldr -/">
      <AtomNode start="(117, 1)" end="(117, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(117, 5)" end="(117, 17)" leading="" trailing="&#10;&#10;" val="### foldr -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(119, 1)" end="(130, 96)" name="foldrTR" full_name="List.foldrTR">
      <CommandDeclmodifiersNode start="(119, 1)" end="(130, 14)">
        <NullNode start="(119, 1)" end="(129, 3)">
          <CommandDoccommentNode start="(119, 1)" end="(129, 3)" comment="Folds a function over a list from the right, accumulating a value starting with `init`. The&#10;accumulated value is combined with the each element of the list in reverse order, using `f`.&#10;&#10;`O(|l|)`. This is the tail-recursive replacement for `List.foldr` in runtime code.&#10;&#10;Examples:&#10; * `[a, b, c].foldrTR f init  = f a (f b (f c init))`&#10; * `[1, 2, 3].foldrTR (toString · ++ ·) &amp;quot;&amp;quot; = &amp;quot;123&amp;quot;`&#10; * `[1, 2, 3].foldrTR (s!&amp;quot;({·} {·})&amp;quot;) &amp;quot;!&amp;quot; = &amp;quot;(1 (2 (3 !)))&amp;quot;`&#10;-/">
            <AtomNode start="(119, 1)" end="(119, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(120, 1)" end="(129, 3)" leading="" trailing="&#10;" val="Folds a function over a list from the right, accumulating a value starting with `init`. The&#10;accumulated value is combined with the each element of the list in reverse order, using `f`.&#10;&#10;`O(|l|)`. This is the tail-recursive replacement for `List.foldr` in runtime code.&#10;&#10;Examples:&#10; * `[a, b, c].foldrTR f init  = f a (f b (f c init))`&#10; * `[1, 2, 3].foldrTR (toString · ++ ·) &amp;quot;&amp;quot; = &amp;quot;123&amp;quot;`&#10; * `[1, 2, 3].foldrTR (s!&amp;quot;({·} {·})&amp;quot;) &amp;quot;!&amp;quot; = &amp;quot;(1 (2 (3 !)))&amp;quot;`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(130, 1)" end="(130, 14)">
          <OtherNode start="(130, 1)" end="(130, 14)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(130, 1)" end="(130, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(130, 3)" end="(130, 13)">
              <OtherNode start="(130, 3)" end="(130, 13)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(130, 3)" end="(130, 13)" kind="Lean.Parser.Attr.specialize">
                  <AtomNode start="(130, 3)" end="(130, 13)" leading="" trailing="" val="specialize"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(130, 13)" end="(130, 14)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(130, 15)" end="(130, 96)" name="foldrTR">
        <AtomNode start="(130, 15)" end="(130, 18)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(130, 19)" end="(130, 26)">
          <IdentNode start="(130, 19)" end="(130, 26)" leading="" trailing=" " raw_val="foldrTR" val="foldrTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(130, 27)" end="(130, 70)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(130, 27)" end="(130, 66)">
            <TermExplicitbinderNode start="(130, 27)" end="(130, 42)">
              <AtomNode start="(130, 27)" end="(130, 28)" leading="" trailing="" val="("/>
              <NullNode start="(130, 28)" end="(130, 29)">
                <IdentNode start="(130, 28)" end="(130, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(130, 30)" end="(130, 41)">
                <AtomNode start="(130, 30)" end="(130, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 32)" end="(130, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(130, 32)" end="(130, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(130, 34)" end="(130, 35)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(130, 36)" end="(130, 41)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(130, 36)" end="(130, 37)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(130, 38)" end="(130, 39)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(130, 40)" end="(130, 41)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(130, 41)" end="(130, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(130, 43)" end="(130, 53)">
              <AtomNode start="(130, 43)" end="(130, 44)" leading="" trailing="" val="("/>
              <NullNode start="(130, 44)" end="(130, 48)">
                <IdentNode start="(130, 44)" end="(130, 48)" leading="" trailing=" " raw_val="init" val="init"/>
              </NullNode>
              <NullNode start="(130, 49)" end="(130, 52)">
                <AtomNode start="(130, 49)" end="(130, 50)" leading="" trailing=" " val=":"/>
                <IdentNode start="(130, 51)" end="(130, 52)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(130, 52)" end="(130, 53)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(130, 54)" end="(130, 66)">
              <AtomNode start="(130, 54)" end="(130, 55)" leading="" trailing="" val="("/>
              <NullNode start="(130, 55)" end="(130, 56)">
                <IdentNode start="(130, 55)" end="(130, 56)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(130, 57)" end="(130, 65)">
                <AtomNode start="(130, 57)" end="(130, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(130, 59)" end="(130, 65)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(130, 59)" end="(130, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(130, 64)" end="(130, 65)">
                    <IdentNode start="(130, 64)" end="(130, 65)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(130, 65)" end="(130, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(130, 67)" end="(130, 70)">
            <TermTypespecNode start="(130, 67)" end="(130, 70)">
              <AtomNode start="(130, 67)" end="(130, 68)" leading="" trailing=" " val=":"/>
              <IdentNode start="(130, 69)" end="(130, 70)" leading="" trailing=" " raw_val="β" val="β"/>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(130, 71)" end="(130, 96)">
          <AtomNode start="(130, 71)" end="(130, 73)" leading="" trailing=" " val=":="/>
          <OtherNode start="(130, 74)" end="(130, 96)" kind="Lean.Parser.Term.app">
            <IdentNode start="(130, 74)" end="(130, 89)" leading="" trailing=" " raw_val="l.toArray.foldr" val="l.toArray.foldr"/>
            <NullNode start="(130, 90)" end="(130, 96)">
              <IdentNode start="(130, 90)" end="(130, 91)" leading="" trailing=" " raw_val="f" val="f"/>
              <IdentNode start="(130, 92)" end="(130, 96)" leading="" trailing="&#10;&#10;" raw_val="init" val="init"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(132, 1)" end="(133, 65)" name="foldr_eq_foldrTR" full_name="List.foldr_eq_foldrTR">
      <CommandDeclmodifiersNode start="(132, 1)" end="(132, 9)">
        <NullNode/>
        <NullNode start="(132, 1)" end="(132, 9)">
          <OtherNode start="(132, 1)" end="(132, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(132, 1)" end="(132, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(132, 3)" end="(132, 8)">
              <OtherNode start="(132, 3)" end="(132, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(132, 3)" end="(132, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(132, 3)" end="(132, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(132, 8)" end="(132, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(132, 10)" end="(133, 65)" name="foldr_eq_foldrTR" full_name="List.foldr_eq_foldrTR" _is_private_decl="False">
        <AtomNode start="(132, 10)" end="(132, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(132, 18)" end="(132, 34)">
          <IdentNode start="(132, 18)" end="(132, 34)" leading="" trailing=" " raw_val="foldr_eq_foldrTR" val="foldr_eq_foldrTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(132, 35)" end="(132, 54)">
          <NullNode/>
          <TermTypespecNode start="(132, 35)" end="(132, 54)">
            <AtomNode start="(132, 35)" end="(132, 36)" leading="" trailing=" " val=":"/>
            <OtherNode start="(132, 37)" end="(132, 54)" kind="«term_=_»">
              <OtherNode start="(132, 37)" end="(132, 43)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(132, 37)" end="(132, 38)" leading="" trailing="" val="@"/>
                <IdentNode start="(132, 38)" end="(132, 43)" leading="" trailing=" " raw_val="foldr" val="foldr" full_name="List.foldr" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(132, 44)" end="(132, 45)" leading="" trailing=" " val="="/>
              <OtherNode start="(132, 46)" end="(132, 54)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(132, 46)" end="(132, 47)" leading="" trailing="" val="@"/>
                <IdentNode start="(132, 47)" end="(132, 54)" leading="" trailing=" " raw_val="foldrTR" val="foldrTR" full_name="List.foldrTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(130, 19)" def_end="(130, 26)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(132, 55)" end="(133, 65)">
          <AtomNode start="(132, 55)" end="(132, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(132, 58)" end="(133, 65)">
            <AtomNode start="(132, 58)" end="(132, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(133, 3)" end="(133, 65)">
              <TacticTacticseq1IndentedNode start="(133, 3)" end="(133, 65)">
                <NullNode start="(133, 3)" end="(133, 65)">
                  <OtherNode start="(133, 3)" end="(133, 22)" kind="tacticFunext___" state_before="⊢ @foldr = @foldrTR" state_after="case h.h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β → β&#10;init : β&#10;l : List α&#10;⊢ foldr f init l = foldrTR f init l" tactic="funext α β f init l">
                    <AtomNode start="(133, 3)" end="(133, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(133, 10)" end="(133, 22)">
                      <IdentNode start="(133, 10)" end="(133, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(133, 12)" end="(133, 13)" leading="" trailing=" " raw_val="β" val="β"/>
                      <IdentNode start="(133, 14)" end="(133, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(133, 16)" end="(133, 20)" leading="" trailing=" " raw_val="init" val="init"/>
                      <IdentNode start="(133, 21)" end="(133, 22)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(133, 22)" end="(133, 23)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(133, 24)" end="(133, 65)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → β → β&#10;init : β&#10;l : List α&#10;⊢ foldr f init l = foldrTR f init l" state_after="no goals" tactic="simp only [foldrTR, ← Array.foldr_toList]">
                    <AtomNode start="(133, 24)" end="(133, 28)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(133, 29)" end="(133, 33)">
                      <AtomNode start="(133, 29)" end="(133, 33)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(133, 34)" end="(133, 65)">
                      <AtomNode start="(133, 34)" end="(133, 35)" leading="" trailing="" val="["/>
                      <NullNode start="(133, 35)" end="(133, 64)">
                        <OtherNode start="(133, 35)" end="(133, 42)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(133, 35)" end="(133, 42)" leading="" trailing="" raw_val="foldrTR" val="foldrTR" full_name="List.foldrTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(130, 19)" def_end="(130, 26)"/>
                        </OtherNode>
                        <AtomNode start="(133, 42)" end="(133, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(133, 44)" end="(133, 64)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(133, 44)" end="(133, 45)">
                            <OtherNode start="(133, 44)" end="(133, 45)" kind="patternIgnore">
                              <OtherNode start="(133, 44)" end="(133, 45)" kind="token.«← »">
                                <AtomNode start="(133, 44)" end="(133, 45)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(133, 46)" end="(133, 64)" leading="" trailing="" raw_val="Array.foldr_toList" val="Array.foldr_toList" full_name="Array.foldr_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(133, 64)" end="(133, 65)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(135, 1)" end="(135, 20)" comment="### flatMap  -/">
      <AtomNode start="(135, 1)" end="(135, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(135, 5)" end="(135, 20)" leading="" trailing="&#10;&#10;" val="### flatMap  -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(137, 1)" end="(151, 37)" name="flatMapTR" full_name="List.flatMapTR">
      <CommandDeclmodifiersNode start="(137, 1)" end="(147, 10)">
        <NullNode start="(137, 1)" end="(146, 3)">
          <CommandDoccommentNode start="(137, 1)" end="(146, 3)" comment="Applies a function that returns a list to each element of a list, and concatenates the resulting&#10;lists.&#10;&#10;This is the tail-recursive version of `List.flatMap` that's used at runtime.&#10;&#10;Examples:&#10;* `[2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]`&#10;* `[&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`&#10;-/">
            <AtomNode start="(137, 1)" end="(137, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(138, 1)" end="(146, 3)" leading="" trailing="&#10;" val="Applies a function that returns a list to each element of a list, and concatenates the resulting&#10;lists.&#10;&#10;This is the tail-recursive version of `List.flatMap` that's used at runtime.&#10;&#10;Examples:&#10;* `[2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]`&#10;* `[&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(147, 1)" end="(147, 10)">
          <OtherNode start="(147, 1)" end="(147, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(147, 1)" end="(147, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(147, 3)" end="(147, 9)">
              <OtherNode start="(147, 3)" end="(147, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(147, 3)" end="(147, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(147, 3)" end="(147, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(147, 9)" end="(147, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(147, 11)" end="(151, 37)" name="flatMapTR">
        <AtomNode start="(147, 11)" end="(147, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(147, 15)" end="(147, 24)">
          <IdentNode start="(147, 15)" end="(147, 24)" leading="" trailing=" " raw_val="flatMapTR" val="flatMapTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(147, 25)" end="(147, 64)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(147, 25)" end="(147, 55)">
            <TermExplicitbinderNode start="(147, 25)" end="(147, 41)">
              <AtomNode start="(147, 25)" end="(147, 26)" leading="" trailing="" val="("/>
              <NullNode start="(147, 26)" end="(147, 27)">
                <IdentNode start="(147, 26)" end="(147, 27)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(147, 28)" end="(147, 40)">
                <AtomNode start="(147, 28)" end="(147, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(147, 30)" end="(147, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(147, 30)" end="(147, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(147, 32)" end="(147, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(147, 34)" end="(147, 40)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(147, 34)" end="(147, 38)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(147, 39)" end="(147, 40)">
                      <IdentNode start="(147, 39)" end="(147, 40)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(147, 40)" end="(147, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(147, 42)" end="(147, 55)">
              <AtomNode start="(147, 42)" end="(147, 43)" leading="" trailing="" val="("/>
              <NullNode start="(147, 43)" end="(147, 45)">
                <IdentNode start="(147, 43)" end="(147, 45)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(147, 46)" end="(147, 54)">
                <AtomNode start="(147, 46)" end="(147, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(147, 48)" end="(147, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(147, 48)" end="(147, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(147, 53)" end="(147, 54)">
                    <IdentNode start="(147, 53)" end="(147, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(147, 54)" end="(147, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(147, 56)" end="(147, 64)">
            <TermTypespecNode start="(147, 56)" end="(147, 64)">
              <AtomNode start="(147, 56)" end="(147, 57)" leading="" trailing=" " val=":"/>
              <OtherNode start="(147, 58)" end="(147, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(147, 58)" end="(147, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(147, 63)" end="(147, 64)">
                  <IdentNode start="(147, 63)" end="(147, 64)" leading="" trailing=" " raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(147, 65)" end="(151, 37)">
          <AtomNode start="(147, 65)" end="(147, 67)" leading="" trailing=" " val=":="/>
          <OtherNode start="(147, 68)" end="(147, 77)" kind="Lean.Parser.Term.app">
            <IdentNode start="(147, 68)" end="(147, 70)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(147, 71)" end="(147, 77)">
              <IdentNode start="(147, 71)" end="(147, 73)" leading="" trailing=" " raw_val="as" val="as"/>
              <OtherNode start="(147, 74)" end="(147, 77)" kind="«term#[_,]»">
                <AtomNode start="(147, 74)" end="(147, 76)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(147, 76)" end="(147, 77)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(147, 78)" end="(151, 37)">
            <OtherNode start="(147, 78)" end="(151, 37)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(147, 78)" end="(147, 83)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(148, 3)" end="(151, 37)">
                <OtherNode start="(148, 3)" end="(151, 37)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(148, 3)" end="(148, 78)">
                    <CommandDoccommentNode start="(148, 3)" end="(148, 78)" comment="Auxiliary for `flatMap`: `flatMap.go f as = acc.toList ++ bind f as` -/">
                      <AtomNode start="(148, 3)" end="(148, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(148, 7)" end="(148, 78)" leading="" trailing="&#10;  " val="Auxiliary for `flatMap`: `flatMap.go f as = acc.toList ++ bind f as` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(149, 3)" end="(149, 16)">
                    <OtherNode start="(149, 3)" end="(149, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(149, 3)" end="(149, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(149, 5)" end="(149, 15)">
                        <OtherNode start="(149, 5)" end="(149, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(149, 5)" end="(149, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(149, 5)" end="(149, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(149, 15)" end="(149, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(149, 17)" end="(151, 37)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(149, 17)" end="(151, 37)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(149, 17)" end="(149, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(149, 20)" end="(149, 47)">
                        <TermTypespecNode start="(149, 20)" end="(149, 47)">
                          <AtomNode start="(149, 20)" end="(149, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(149, 22)" end="(149, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(149, 22)" end="(149, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(149, 22)" end="(149, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(149, 27)" end="(149, 28)">
                                <IdentNode start="(149, 27)" end="(149, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(149, 29)" end="(149, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(149, 31)" end="(149, 47)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(149, 31)" end="(149, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(149, 31)" end="(149, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(149, 37)" end="(149, 38)">
                                  <IdentNode start="(149, 37)" end="(149, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(149, 39)" end="(149, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(149, 41)" end="(149, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(149, 41)" end="(149, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(149, 46)" end="(149, 47)">
                                  <IdentNode start="(149, 46)" end="(149, 47)" leading="" trailing="&#10;  " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(150, 3)" end="(151, 37)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(150, 3)" end="(151, 37)">
                          <OtherNode start="(150, 3)" end="(150, 26)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(150, 3)" end="(150, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(150, 5)" end="(150, 12)">
                              <NullNode start="(150, 5)" end="(150, 12)">
                                <OtherNode start="(150, 5)" end="(150, 7)" kind="«term[_]»">
                                  <AtomNode start="(150, 5)" end="(150, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(150, 6)" end="(150, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(150, 7)" end="(150, 8)" leading="" trailing=" " val=","/>
                                <IdentNode start="(150, 9)" end="(150, 12)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(150, 13)" end="(150, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(150, 16)" end="(150, 26)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(151, 3)" end="(151, 37)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(151, 3)" end="(151, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(151, 5)" end="(151, 15)">
                              <NullNode start="(151, 5)" end="(151, 15)">
                                <OtherNode start="(151, 5)" end="(151, 10)" kind="«term_::_»">
                                  <IdentNode start="(151, 5)" end="(151, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                  <AtomNode start="(151, 6)" end="(151, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(151, 8)" end="(151, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(151, 10)" end="(151, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(151, 12)" end="(151, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(151, 16)" end="(151, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(151, 19)" end="(151, 37)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(151, 19)" end="(151, 21)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(151, 22)" end="(151, 37)">
                                <IdentNode start="(151, 22)" end="(151, 24)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <OtherNode start="(151, 25)" end="(151, 37)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(151, 25)" end="(151, 26)" leading="" trailing="" val="("/>
                                  <OtherNode start="(151, 26)" end="(151, 36)" kind="«term_++_»">
                                    <IdentNode start="(151, 26)" end="(151, 29)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                    <AtomNode start="(151, 30)" end="(151, 32)" leading="" trailing=" " val="++"/>
                                    <OtherNode start="(151, 33)" end="(151, 36)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(151, 33)" end="(151, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(151, 35)" end="(151, 36)">
                                        <IdentNode start="(151, 35)" end="(151, 36)" leading="" trailing="" raw_val="x" val="x"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(151, 36)" end="(151, 37)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(158, 25)" name="flatMap_eq_flatMapTR" full_name="List.flatMap_eq_flatMapTR">
      <CommandDeclmodifiersNode start="(153, 1)" end="(153, 9)">
        <NullNode/>
        <NullNode start="(153, 1)" end="(153, 9)">
          <OtherNode start="(153, 1)" end="(153, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(153, 1)" end="(153, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(153, 3)" end="(153, 8)">
              <OtherNode start="(153, 3)" end="(153, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(153, 3)" end="(153, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(153, 3)" end="(153, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(153, 8)" end="(153, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(153, 10)" end="(158, 25)" name="flatMap_eq_flatMapTR" full_name="List.flatMap_eq_flatMapTR" _is_private_decl="False">
        <AtomNode start="(153, 10)" end="(153, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(153, 18)" end="(153, 38)">
          <IdentNode start="(153, 18)" end="(153, 38)" leading="" trailing=" " raw_val="flatMap_eq_flatMapTR" val="flatMap_eq_flatMapTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(153, 39)" end="(153, 67)">
          <NullNode/>
          <TermTypespecNode start="(153, 39)" end="(153, 67)">
            <AtomNode start="(153, 39)" end="(153, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(153, 41)" end="(153, 67)" kind="«term_=_»">
              <OtherNode start="(153, 41)" end="(153, 54)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(153, 41)" end="(153, 42)" leading="" trailing="" val="@"/>
                <IdentNode start="(153, 42)" end="(153, 54)" leading="" trailing=" " raw_val="List.flatMap" val="List.flatMap" full_name="List.flatMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(153, 55)" end="(153, 56)" leading="" trailing=" " val="="/>
              <OtherNode start="(153, 57)" end="(153, 67)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(153, 57)" end="(153, 58)" leading="" trailing="" val="@"/>
                <IdentNode start="(153, 58)" end="(153, 67)" leading="" trailing=" " raw_val="flatMapTR" val="flatMapTR" full_name="List.flatMapTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(147, 15)" def_end="(147, 24)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(153, 68)" end="(158, 25)">
          <AtomNode start="(153, 68)" end="(153, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(153, 71)" end="(158, 25)">
            <AtomNode start="(153, 71)" end="(153, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(154, 3)" end="(158, 25)">
              <TacticTacticseq1IndentedNode start="(154, 3)" end="(158, 25)">
                <NullNode start="(154, 3)" end="(158, 25)">
                  <OtherNode start="(154, 3)" end="(154, 18)" kind="tacticFunext___" state_before="⊢ @flatMap = @flatMapTR" state_after="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → List β&#10;as : List α&#10;⊢ flatMap f as = flatMapTR f as" tactic="funext α β f as">
                    <AtomNode start="(154, 3)" end="(154, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(154, 10)" end="(154, 18)">
                      <IdentNode start="(154, 10)" end="(154, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(154, 12)" end="(154, 13)" leading="" trailing=" " raw_val="β" val="β"/>
                      <IdentNode start="(154, 14)" end="(154, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(154, 16)" end="(154, 18)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(155, 3)" end="(157, 59)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(155, 3)" end="(155, 6)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(155, 7)" end="(155, 10)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(155, 11)" end="(157, 59)" kind="Lean.Parser.Term.letRecDecls">
                      <NullNode start="(155, 11)" end="(157, 59)">
                        <OtherNode start="(155, 11)" end="(157, 59)" kind="Lean.Parser.Term.letRecDecl">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(155, 11)" end="(157, 59)" kind="Lean.Parser.Term.letDecl">
                            <OtherNode start="(155, 11)" end="(157, 59)" kind="Lean.Parser.Term.letEqnsDecl">
                              <IdentNode start="(155, 11)" end="(155, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode/>
                              <NullNode start="(155, 14)" end="(155, 76)">
                                <TermTypespecNode start="(155, 14)" end="(155, 76)">
                                  <AtomNode start="(155, 14)" end="(155, 15)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(155, 16)" end="(155, 76)" kind="Lean.Parser.Term.forall">
                                    <AtomNode start="(155, 16)" end="(155, 17)" leading="" trailing=" " val="∀"/>
                                    <NullNode start="(155, 18)" end="(155, 24)">
                                      <IdentNode start="(155, 18)" end="(155, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                                      <IdentNode start="(155, 21)" end="(155, 24)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(155, 24)" end="(155, 25)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(155, 26)" end="(155, 76)" kind="«term_=_»">
                                      <OtherNode start="(155, 26)" end="(155, 47)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(155, 26)" end="(155, 38)" leading="" trailing=" " raw_val="flatMapTR.go" val="flatMapTR.go" full_name="List.flatMapTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(149, 17)" def_end="(149, 19)"/>
                                        <NullNode start="(155, 39)" end="(155, 47)">
                                          <IdentNode start="(155, 39)" end="(155, 40)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <IdentNode start="(155, 41)" end="(155, 43)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <IdentNode start="(155, 44)" end="(155, 47)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(155, 48)" end="(155, 49)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(155, 50)" end="(155, 76)" kind="«term_++_»">
                                        <IdentNode start="(155, 50)" end="(155, 60)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                        <AtomNode start="(155, 61)" end="(155, 63)" leading="" trailing=" " val="++"/>
                                        <OtherNode start="(155, 64)" end="(155, 76)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(155, 64)" end="(155, 74)" leading="" trailing=" " raw_val="as.flatMap" val="as.flatMap"/>
                                          <NullNode start="(155, 75)" end="(155, 76)">
                                            <IdentNode start="(155, 75)" end="(155, 76)" leading="" trailing="&#10;    " raw_val="f" val="f"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </TermTypespecNode>
                              </NullNode>
                              <OtherNode start="(156, 5)" end="(157, 59)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(156, 5)" end="(157, 59)">
                                  <OtherNode start="(156, 5)" end="(156, 49)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(156, 5)" end="(156, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(156, 7)" end="(156, 14)">
                                      <NullNode start="(156, 7)" end="(156, 14)">
                                        <OtherNode start="(156, 7)" end="(156, 9)" kind="«term[_]»">
                                          <AtomNode start="(156, 7)" end="(156, 8)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(156, 8)" end="(156, 9)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(156, 9)" end="(156, 10)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(156, 11)" end="(156, 14)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(156, 15)" end="(156, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(156, 18)" end="(156, 49)">
                                      <AtomNode start="(156, 18)" end="(156, 20)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(156, 21)" end="(156, 49)">
                                        <TacticTacticseq1IndentedNode start="(156, 21)" end="(156, 49)">
                                          <NullNode start="(156, 21)" end="(156, 49)">
                                            <OtherNode start="(156, 21)" end="(156, 49)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → List β&#10;as : List α&#10;acc : Array β&#10;⊢ flatMapTR.go f [] acc = acc.toList ++ flatMap f []" state_after="no goals" tactic="simp [flatMapTR.go, flatMap]">
                                              <AtomNode start="(156, 21)" end="(156, 25)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(156, 26)" end="(156, 49)">
                                                <AtomNode start="(156, 26)" end="(156, 27)" leading="" trailing="" val="["/>
                                                <NullNode start="(156, 27)" end="(156, 48)">
                                                  <OtherNode start="(156, 27)" end="(156, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(156, 27)" end="(156, 39)" leading="" trailing="" raw_val="flatMapTR.go" val="flatMapTR.go" full_name="List.flatMapTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(149, 17)" def_end="(149, 19)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(156, 39)" end="(156, 40)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(156, 41)" end="(156, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(156, 41)" end="(156, 48)" leading="" trailing="" raw_val="flatMap" val="flatMap" full_name="List.flatMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(156, 48)" end="(156, 49)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                  <OtherNode start="(157, 5)" end="(157, 59)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(157, 5)" end="(157, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(157, 7)" end="(157, 17)">
                                      <NullNode start="(157, 7)" end="(157, 17)">
                                        <OtherNode start="(157, 7)" end="(157, 12)" kind="«term_::_»">
                                          <IdentNode start="(157, 7)" end="(157, 8)" leading="" trailing="" raw_val="x" val="x"/>
                                          <AtomNode start="(157, 8)" end="(157, 10)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(157, 10)" end="(157, 12)" leading="" trailing="" raw_val="xs" val="xs"/>
                                        </OtherNode>
                                        <AtomNode start="(157, 12)" end="(157, 13)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(157, 14)" end="(157, 17)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(157, 18)" end="(157, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(157, 21)" end="(157, 59)">
                                      <AtomNode start="(157, 21)" end="(157, 23)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(157, 24)" end="(157, 59)">
                                        <TacticTacticseq1IndentedNode start="(157, 24)" end="(157, 59)">
                                          <NullNode start="(157, 24)" end="(157, 59)">
                                            <OtherNode start="(157, 24)" end="(157, 59)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_2&#10;β : Type u_1&#10;f : α → List β&#10;as : List α&#10;x : α&#10;xs : List α&#10;acc : Array β&#10;⊢ flatMapTR.go f (x :: xs) acc = acc.toList ++ flatMap f (x :: xs)" state_after="no goals" tactic="simp [flatMapTR.go, flatMap, go xs]">
                                              <AtomNode start="(157, 24)" end="(157, 28)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(157, 29)" end="(157, 59)">
                                                <AtomNode start="(157, 29)" end="(157, 30)" leading="" trailing="" val="["/>
                                                <NullNode start="(157, 30)" end="(157, 58)">
                                                  <OtherNode start="(157, 30)" end="(157, 42)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(157, 30)" end="(157, 42)" leading="" trailing="" raw_val="flatMapTR.go" val="flatMapTR.go" full_name="List.flatMapTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(149, 17)" def_end="(149, 19)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(157, 42)" end="(157, 43)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(157, 44)" end="(157, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(157, 44)" end="(157, 51)" leading="" trailing="" raw_val="flatMap" val="flatMap" full_name="List.flatMap" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(157, 51)" end="(157, 52)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(157, 53)" end="(157, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <OtherNode start="(157, 53)" end="(157, 58)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(157, 53)" end="(157, 55)" leading="" trailing=" " raw_val="go" val="go"/>
                                                      <NullNode start="(157, 56)" end="(157, 58)">
                                                        <IdentNode start="(157, 56)" end="(157, 58)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(157, 58)" end="(157, 59)" leading="" trailing="&#10;  " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode kind="Lean.Parser.Termination.suffix">
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(158, 3)" end="(158, 25)" kind="Lean.Parser.Tactic.exact" state_before="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;f : α → List β&#10;as : List α&#10;⊢ flatMap f as = flatMapTR f as" state_after="no goals" tactic="exact (go as #[]).symm">
                    <AtomNode start="(158, 3)" end="(158, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(158, 9)" end="(158, 25)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(158, 9)" end="(158, 20)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(158, 9)" end="(158, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(158, 10)" end="(158, 19)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(158, 10)" end="(158, 12)" leading="" trailing=" " raw_val="go" val="go"/>
                          <NullNode start="(158, 13)" end="(158, 19)">
                            <IdentNode start="(158, 13)" end="(158, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                            <OtherNode start="(158, 16)" end="(158, 19)" kind="«term#[_,]»">
                              <AtomNode start="(158, 16)" end="(158, 18)" leading="" trailing="" val="#["/>
                              <NullNode/>
                              <AtomNode start="(158, 18)" end="(158, 19)" leading="" trailing="" val="]"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(158, 19)" end="(158, 20)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(158, 20)" end="(158, 21)" leading="" trailing="" val="."/>
                      <IdentNode start="(158, 21)" end="(158, 25)" leading="" trailing="&#10;&#10;" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(160, 1)" end="(160, 19)" comment="### flatten -/">
      <AtomNode start="(160, 1)" end="(160, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(160, 5)" end="(160, 19)" leading="" trailing="&#10;&#10;" val="### flatten -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(162, 1)" end="(171, 71)" name="flattenTR" full_name="List.flattenTR">
      <CommandDeclmodifiersNode start="(162, 1)" end="(171, 10)">
        <NullNode start="(162, 1)" end="(170, 3)">
          <CommandDoccommentNode start="(162, 1)" end="(170, 3)" comment="Concatenates a list of lists into a single list, preserving the order of the elements.&#10;&#10;`O(|flatten L|)`. This is a tail-recursive version of `List.flatten`, used in runtime code.&#10;&#10;Examples:&#10;* `[[&amp;quot;a&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]].flattenTR = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]`&#10;* `[[&amp;quot;a&amp;quot;], [], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;], [&amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]].flattenTR = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]`&#10;-/">
            <AtomNode start="(162, 1)" end="(162, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(163, 1)" end="(170, 3)" leading="" trailing="&#10;" val="Concatenates a list of lists into a single list, preserving the order of the elements.&#10;&#10;`O(|flatten L|)`. This is a tail-recursive version of `List.flatten`, used in runtime code.&#10;&#10;Examples:&#10;* `[[&amp;quot;a&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]].flattenTR = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]`&#10;* `[[&amp;quot;a&amp;quot;], [], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;], [&amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]].flattenTR = [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(171, 1)" end="(171, 10)">
          <OtherNode start="(171, 1)" end="(171, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(171, 1)" end="(171, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(171, 3)" end="(171, 9)">
              <OtherNode start="(171, 3)" end="(171, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(171, 3)" end="(171, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(171, 3)" end="(171, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(171, 9)" end="(171, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(171, 11)" end="(171, 71)" name="flattenTR">
        <AtomNode start="(171, 11)" end="(171, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(171, 15)" end="(171, 24)">
          <IdentNode start="(171, 15)" end="(171, 24)" leading="" trailing=" " raw_val="flattenTR" val="flattenTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(171, 25)" end="(171, 53)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(171, 25)" end="(171, 44)">
            <TermExplicitbinderNode start="(171, 25)" end="(171, 44)">
              <AtomNode start="(171, 25)" end="(171, 26)" leading="" trailing="" val="("/>
              <NullNode start="(171, 26)" end="(171, 27)">
                <IdentNode start="(171, 26)" end="(171, 27)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(171, 28)" end="(171, 43)">
                <AtomNode start="(171, 28)" end="(171, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(171, 30)" end="(171, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(171, 30)" end="(171, 34)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(171, 35)" end="(171, 43)">
                    <OtherNode start="(171, 35)" end="(171, 43)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(171, 35)" end="(171, 36)" leading="" trailing="" val="("/>
                      <OtherNode start="(171, 36)" end="(171, 42)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(171, 36)" end="(171, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(171, 41)" end="(171, 42)">
                          <IdentNode start="(171, 41)" end="(171, 42)" leading="" trailing="" raw_val="α" val="α"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(171, 42)" end="(171, 43)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(171, 43)" end="(171, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(171, 45)" end="(171, 53)">
            <TermTypespecNode start="(171, 45)" end="(171, 53)">
              <AtomNode start="(171, 45)" end="(171, 46)" leading="" trailing=" " val=":"/>
              <OtherNode start="(171, 47)" end="(171, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(171, 47)" end="(171, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(171, 52)" end="(171, 53)">
                  <IdentNode start="(171, 52)" end="(171, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(171, 54)" end="(171, 71)">
          <AtomNode start="(171, 54)" end="(171, 56)" leading="" trailing=" " val=":="/>
          <OtherNode start="(171, 57)" end="(171, 71)" kind="Lean.Parser.Term.app">
            <IdentNode start="(171, 57)" end="(171, 68)" leading="" trailing=" " raw_val="l.flatMapTR" val="l.flatMapTR"/>
            <NullNode start="(171, 69)" end="(171, 71)">
              <IdentNode start="(171, 69)" end="(171, 71)" leading="" trailing="&#10;&#10;" raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(173, 1)" end="(174, 69)" name="flatten_eq_flattenTR" full_name="List.flatten_eq_flattenTR">
      <CommandDeclmodifiersNode start="(173, 1)" end="(173, 9)">
        <NullNode/>
        <NullNode start="(173, 1)" end="(173, 9)">
          <OtherNode start="(173, 1)" end="(173, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(173, 1)" end="(173, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(173, 3)" end="(173, 8)">
              <OtherNode start="(173, 3)" end="(173, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(173, 3)" end="(173, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(173, 3)" end="(173, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(173, 8)" end="(173, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(173, 10)" end="(174, 69)" name="flatten_eq_flattenTR" full_name="List.flatten_eq_flattenTR" _is_private_decl="False">
        <AtomNode start="(173, 10)" end="(173, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(173, 18)" end="(173, 38)">
          <IdentNode start="(173, 18)" end="(173, 38)" leading="" trailing=" " raw_val="flatten_eq_flattenTR" val="flatten_eq_flattenTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(173, 39)" end="(173, 62)">
          <NullNode/>
          <TermTypespecNode start="(173, 39)" end="(173, 62)">
            <AtomNode start="(173, 39)" end="(173, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(173, 41)" end="(173, 62)" kind="«term_=_»">
              <OtherNode start="(173, 41)" end="(173, 49)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(173, 41)" end="(173, 42)" leading="" trailing="" val="@"/>
                <IdentNode start="(173, 42)" end="(173, 49)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="List.flatten" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(173, 50)" end="(173, 51)" leading="" trailing=" " val="="/>
              <OtherNode start="(173, 52)" end="(173, 62)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(173, 52)" end="(173, 53)" leading="" trailing="" val="@"/>
                <IdentNode start="(173, 53)" end="(173, 62)" leading="" trailing=" " raw_val="flattenTR" val="flattenTR" full_name="List.flattenTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(171, 15)" def_end="(171, 24)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(173, 63)" end="(174, 69)">
          <AtomNode start="(173, 63)" end="(173, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(173, 66)" end="(174, 69)">
            <AtomNode start="(173, 66)" end="(173, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(174, 3)" end="(174, 69)">
              <TacticTacticseq1IndentedNode start="(174, 3)" end="(174, 69)">
                <NullNode start="(174, 3)" end="(174, 69)">
                  <OtherNode start="(174, 3)" end="(174, 13)" kind="tacticFunext___" state_before="⊢ @flatten = @flattenTR" state_after="case h.h&#10;α : Type u_1&#10;l : List (List α)&#10;⊢ l.flatten = l.flattenTR" tactic="funext α l">
                    <AtomNode start="(174, 3)" end="(174, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(174, 10)" end="(174, 13)">
                      <IdentNode start="(174, 10)" end="(174, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(174, 12)" end="(174, 13)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(174, 13)" end="(174, 14)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(174, 15)" end="(174, 64)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.h&#10;α : Type u_1&#10;l : List (List α)&#10;⊢ l.flatten = l.flattenTR" state_after="case h.h&#10;α : Type u_1&#10;l : List (List α)&#10;⊢ flatMapTR id l = l.flattenTR" tactic="rw [← List.flatMap_id, List.flatMap_eq_flatMapTR]">
                    <AtomNode start="(174, 15)" end="(174, 17)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(174, 18)" end="(174, 64)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(174, 18)" end="(174, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(174, 19)" end="(174, 63)">
                        <OtherNode start="(174, 19)" end="(174, 36)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(174, 19)" end="(174, 20)">
                            <OtherNode start="(174, 19)" end="(174, 20)" kind="patternIgnore">
                              <OtherNode start="(174, 19)" end="(174, 20)" kind="token.«← »">
                                <AtomNode start="(174, 19)" end="(174, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(174, 21)" end="(174, 36)" leading="" trailing="" raw_val="List.flatMap_id" val="List.flatMap_id" full_name="List.flatMap_id" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(174, 36)" end="(174, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(174, 38)" end="(174, 63)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(174, 38)" end="(174, 63)" leading="" trailing="" raw_val="List.flatMap_eq_flatMapTR" val="List.flatMap_eq_flatMapTR" full_name="List.flatMap_eq_flatMapTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(153, 18)" def_end="(153, 38)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(174, 63)" end="(174, 64)" leading="" trailing="" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(174, 64)" end="(174, 65)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(174, 66)" end="(174, 69)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case h.h&#10;α : Type u_1&#10;l : List (List α)&#10;⊢ flatMapTR id l = l.flattenTR" state_after="no goals" tactic="rfl">
                    <AtomNode start="(174, 66)" end="(174, 69)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(176, 1)" end="(176, 19)" comment="## Sublists -/">
      <AtomNode start="(176, 1)" end="(176, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(176, 5)" end="(176, 19)" leading="" trailing="&#10;&#10;" val="## Sublists -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(178, 1)" end="(178, 16)" comment="### take -/">
      <AtomNode start="(178, 1)" end="(178, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(178, 5)" end="(178, 16)" leading="" trailing="&#10;&#10;" val="### take -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(180, 1)" end="(196, 44)" name="takeTR" full_name="List.takeTR">
      <CommandDeclmodifiersNode start="(180, 1)" end="(190, 10)">
        <NullNode start="(180, 1)" end="(189, 3)">
          <CommandDoccommentNode start="(180, 1)" end="(189, 3)" comment="Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.&#10;&#10;`O(min n |xs|)`. This is a tail-recursive version of `List.take`, used at runtime.&#10;&#10;Examples:&#10;* `[a, b, c, d, e].takeTR 0 = []`&#10;* `[a, b, c, d, e].takeTR 3 = [a, b, c]`&#10;* `[a, b, c, d, e].takeTR 6 = [a, b, c, d, e]`&#10;-/">
            <AtomNode start="(180, 1)" end="(180, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(181, 1)" end="(189, 3)" leading="" trailing="&#10;" val="Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.&#10;&#10;`O(min n |xs|)`. This is a tail-recursive version of `List.take`, used at runtime.&#10;&#10;Examples:&#10;* `[a, b, c, d, e].takeTR 0 = []`&#10;* `[a, b, c, d, e].takeTR 3 = [a, b, c]`&#10;* `[a, b, c, d, e].takeTR 6 = [a, b, c, d, e]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(190, 1)" end="(190, 10)">
          <OtherNode start="(190, 1)" end="(190, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(190, 1)" end="(190, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(190, 3)" end="(190, 9)">
              <OtherNode start="(190, 3)" end="(190, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(190, 3)" end="(190, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(190, 3)" end="(190, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(190, 9)" end="(190, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(190, 11)" end="(196, 44)" name="takeTR">
        <AtomNode start="(190, 11)" end="(190, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(190, 15)" end="(190, 21)">
          <IdentNode start="(190, 15)" end="(190, 21)" leading="" trailing=" " raw_val="takeTR" val="takeTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(190, 22)" end="(190, 53)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(190, 22)" end="(190, 44)">
            <TermExplicitbinderNode start="(190, 22)" end="(190, 31)">
              <AtomNode start="(190, 22)" end="(190, 23)" leading="" trailing="" val="("/>
              <NullNode start="(190, 23)" end="(190, 24)">
                <IdentNode start="(190, 23)" end="(190, 24)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(190, 25)" end="(190, 30)">
                <AtomNode start="(190, 25)" end="(190, 26)" leading="" trailing=" " val=":"/>
                <IdentNode start="(190, 27)" end="(190, 30)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(190, 30)" end="(190, 31)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(190, 32)" end="(190, 44)">
              <AtomNode start="(190, 32)" end="(190, 33)" leading="" trailing="" val="("/>
              <NullNode start="(190, 33)" end="(190, 34)">
                <IdentNode start="(190, 33)" end="(190, 34)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(190, 35)" end="(190, 43)">
                <AtomNode start="(190, 35)" end="(190, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 37)" end="(190, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 37)" end="(190, 41)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(190, 42)" end="(190, 43)">
                    <IdentNode start="(190, 42)" end="(190, 43)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(190, 43)" end="(190, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(190, 45)" end="(190, 53)">
            <TermTypespecNode start="(190, 45)" end="(190, 53)">
              <AtomNode start="(190, 45)" end="(190, 46)" leading="" trailing=" " val=":"/>
              <OtherNode start="(190, 47)" end="(190, 53)" kind="Lean.Parser.Term.app">
                <IdentNode start="(190, 47)" end="(190, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(190, 52)" end="(190, 53)">
                  <IdentNode start="(190, 52)" end="(190, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(190, 54)" end="(196, 44)">
          <AtomNode start="(190, 54)" end="(190, 56)" leading="" trailing=" " val=":="/>
          <OtherNode start="(190, 57)" end="(190, 67)" kind="Lean.Parser.Term.app">
            <IdentNode start="(190, 57)" end="(190, 59)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(190, 60)" end="(190, 67)">
              <IdentNode start="(190, 60)" end="(190, 61)" leading="" trailing=" " raw_val="l" val="l"/>
              <IdentNode start="(190, 62)" end="(190, 63)" leading="" trailing=" " raw_val="n" val="n"/>
              <OtherNode start="(190, 64)" end="(190, 67)" kind="«term#[_,]»">
                <AtomNode start="(190, 64)" end="(190, 66)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(190, 66)" end="(190, 67)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(190, 68)" end="(196, 44)">
            <OtherNode start="(190, 68)" end="(196, 44)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(190, 68)" end="(190, 73)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(191, 3)" end="(196, 44)">
                <OtherNode start="(191, 3)" end="(196, 44)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(191, 3)" end="(192, 58)">
                    <CommandDoccommentNode start="(191, 3)" end="(192, 58)" comment="Auxiliary for `take`: `take.go l xs n acc = acc.toList ++ take n xs`,&#10;  unless `n ≥ xs.length` in which case it returns `l`. -/">
                      <AtomNode start="(191, 3)" end="(191, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(191, 7)" end="(192, 58)" leading="" trailing="&#10;  " val="Auxiliary for `take`: `take.go l xs n acc = acc.toList ++ take n xs`,&#10;  unless `n ≥ xs.length` in which case it returns `l`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(193, 3)" end="(193, 16)">
                    <OtherNode start="(193, 3)" end="(193, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(193, 3)" end="(193, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(193, 5)" end="(193, 15)">
                        <OtherNode start="(193, 5)" end="(193, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(193, 5)" end="(193, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(193, 5)" end="(193, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(193, 15)" end="(193, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(193, 17)" end="(196, 44)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(193, 17)" end="(196, 44)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(193, 17)" end="(193, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(193, 20)" end="(193, 53)">
                        <TermTypespecNode start="(193, 20)" end="(193, 53)">
                          <AtomNode start="(193, 20)" end="(193, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(193, 22)" end="(193, 53)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(193, 22)" end="(193, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(193, 22)" end="(193, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(193, 27)" end="(193, 28)">
                                <IdentNode start="(193, 27)" end="(193, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(193, 29)" end="(193, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(193, 31)" end="(193, 53)" kind="Lean.Parser.Term.arrow">
                              <IdentNode start="(193, 31)" end="(193, 34)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(193, 35)" end="(193, 36)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(193, 37)" end="(193, 53)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(193, 37)" end="(193, 44)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(193, 37)" end="(193, 42)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(193, 43)" end="(193, 44)">
                                    <IdentNode start="(193, 43)" end="(193, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(193, 45)" end="(193, 46)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(193, 47)" end="(193, 53)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(193, 47)" end="(193, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(193, 52)" end="(193, 53)">
                                    <IdentNode start="(193, 52)" end="(193, 53)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(194, 3)" end="(196, 44)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(194, 3)" end="(196, 44)">
                          <OtherNode start="(194, 3)" end="(194, 18)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(194, 3)" end="(194, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(194, 5)" end="(194, 13)">
                              <NullNode start="(194, 5)" end="(194, 13)">
                                <OtherNode start="(194, 5)" end="(194, 7)" kind="«term[_]»">
                                  <AtomNode start="(194, 5)" end="(194, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(194, 6)" end="(194, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(194, 7)" end="(194, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(194, 9)" end="(194, 10)">
                                  <AtomNode start="(194, 9)" end="(194, 10)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(194, 10)" end="(194, 11)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(194, 12)" end="(194, 13)">
                                  <AtomNode start="(194, 12)" end="(194, 13)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(194, 14)" end="(194, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(194, 17)" end="(194, 18)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(195, 3)" end="(195, 31)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(195, 3)" end="(195, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(195, 5)" end="(195, 17)">
                              <NullNode start="(195, 5)" end="(195, 17)">
                                <OtherNode start="(195, 5)" end="(195, 9)" kind="«term_::_»">
                                  <TermHoleNode start="(195, 5)" end="(195, 6)">
                                    <AtomNode start="(195, 5)" end="(195, 6)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(195, 6)" end="(195, 8)" leading="" trailing="" val="::"/>
                                  <TermHoleNode start="(195, 8)" end="(195, 9)">
                                    <AtomNode start="(195, 8)" end="(195, 9)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                </OtherNode>
                                <AtomNode start="(195, 9)" end="(195, 10)" leading="" trailing=" " val=","/>
                                <OtherNode start="(195, 11)" end="(195, 12)" kind="num">
                                  <AtomNode start="(195, 11)" end="(195, 12)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(195, 12)" end="(195, 13)" leading="" trailing=" " val=","/>
                                <IdentNode start="(195, 14)" end="(195, 17)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(195, 18)" end="(195, 20)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(195, 21)" end="(195, 31)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(196, 3)" end="(196, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(196, 3)" end="(196, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(196, 5)" end="(196, 20)">
                              <NullNode start="(196, 5)" end="(196, 20)">
                                <OtherNode start="(196, 5)" end="(196, 10)" kind="«term_::_»">
                                  <IdentNode start="(196, 5)" end="(196, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(196, 6)" end="(196, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(196, 8)" end="(196, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(196, 10)" end="(196, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(196, 12)" end="(196, 15)" kind="«term_+_»">
                                  <IdentNode start="(196, 12)" end="(196, 13)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(196, 13)" end="(196, 14)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(196, 14)" end="(196, 15)" kind="num">
                                    <AtomNode start="(196, 14)" end="(196, 15)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(196, 15)" end="(196, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(196, 17)" end="(196, 20)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(196, 21)" end="(196, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(196, 24)" end="(196, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(196, 24)" end="(196, 26)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(196, 27)" end="(196, 44)">
                                <IdentNode start="(196, 27)" end="(196, 29)" leading="" trailing=" " raw_val="as" val="as"/>
                                <IdentNode start="(196, 30)" end="(196, 31)" leading="" trailing=" " raw_val="n" val="n"/>
                                <OtherNode start="(196, 32)" end="(196, 44)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(196, 32)" end="(196, 33)" leading="" trailing="" val="("/>
                                  <OtherNode start="(196, 33)" end="(196, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(196, 33)" end="(196, 41)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(196, 42)" end="(196, 43)">
                                      <IdentNode start="(196, 42)" end="(196, 43)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(196, 43)" end="(196, 44)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(198, 1)" end="(207, 46)" name="take_eq_takeTR" full_name="List.take_eq_takeTR">
      <CommandDeclmodifiersNode start="(198, 1)" end="(198, 9)">
        <NullNode/>
        <NullNode start="(198, 1)" end="(198, 9)">
          <OtherNode start="(198, 1)" end="(198, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(198, 1)" end="(198, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(198, 3)" end="(198, 8)">
              <OtherNode start="(198, 3)" end="(198, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(198, 3)" end="(198, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(198, 3)" end="(198, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(198, 8)" end="(198, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(198, 10)" end="(207, 46)" name="take_eq_takeTR" full_name="List.take_eq_takeTR" _is_private_decl="False">
        <AtomNode start="(198, 10)" end="(198, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(198, 18)" end="(198, 32)">
          <IdentNode start="(198, 18)" end="(198, 32)" leading="" trailing=" " raw_val="take_eq_takeTR" val="take_eq_takeTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(198, 33)" end="(198, 50)">
          <NullNode/>
          <TermTypespecNode start="(198, 33)" end="(198, 50)">
            <AtomNode start="(198, 33)" end="(198, 34)" leading="" trailing=" " val=":"/>
            <OtherNode start="(198, 35)" end="(198, 50)" kind="«term_=_»">
              <OtherNode start="(198, 35)" end="(198, 40)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(198, 35)" end="(198, 36)" leading="" trailing="" val="@"/>
                <IdentNode start="(198, 36)" end="(198, 40)" leading="" trailing=" " raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(198, 41)" end="(198, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(198, 43)" end="(198, 50)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(198, 43)" end="(198, 44)" leading="" trailing="" val="@"/>
                <IdentNode start="(198, 44)" end="(198, 50)" leading="" trailing=" " raw_val="takeTR" val="takeTR" full_name="List.takeTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(190, 15)" def_end="(190, 21)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(198, 51)" end="(207, 46)">
          <AtomNode start="(198, 51)" end="(198, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(198, 54)" end="(207, 46)">
            <AtomNode start="(198, 54)" end="(198, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(199, 3)" end="(207, 46)">
              <TacticTacticseq1IndentedNode start="(199, 3)" end="(207, 46)">
                <NullNode start="(199, 3)" end="(207, 46)">
                  <OtherNode start="(199, 3)" end="(199, 15)" kind="tacticFunext___" state_before="⊢ @take = @takeTR" state_after="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ take i l = takeTR i l" tactic="funext α i l">
                    <AtomNode start="(199, 3)" end="(199, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(199, 10)" end="(199, 15)">
                      <IdentNode start="(199, 10)" end="(199, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(199, 12)" end="(199, 13)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(199, 14)" end="(199, 15)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(199, 15)" end="(199, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(199, 17)" end="(199, 30)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ take i l = takeTR i l" state_after="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ take i l = takeTR.go l l i #[]" tactic="simp [takeTR]">
                    <AtomNode start="(199, 17)" end="(199, 21)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(199, 22)" end="(199, 30)">
                      <AtomNode start="(199, 22)" end="(199, 23)" leading="" trailing="" val="["/>
                      <NullNode start="(199, 23)" end="(199, 29)">
                        <OtherNode start="(199, 23)" end="(199, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(199, 23)" end="(199, 29)" leading="" trailing="" raw_val="takeTR" val="takeTR" full_name="List.takeTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(190, 15)" def_end="(190, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(199, 29)" end="(199, 30)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(200, 3)" end="(201, 32)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ take i l = takeTR.go l l i #[]" state_after="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs" tactic="suffices ∀ xs acc, l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ xs.take i from&#10;  (this l #[] (by simp)).symm">
                    <AtomNode start="(200, 3)" end="(200, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(200, 12)" end="(201, 32)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(200, 12)" end="(200, 12)" kind="hygieneInfo">
                        <IdentNode start="(200, 12)" end="(200, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(200, 12)" end="(200, 91)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(200, 12)" end="(200, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(200, 14)" end="(200, 20)">
                          <IdentNode start="(200, 14)" end="(200, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <IdentNode start="(200, 17)" end="(200, 20)" leading="" trailing="" raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(200, 20)" end="(200, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(200, 22)" end="(200, 91)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(200, 22)" end="(200, 42)" kind="«term_=_»">
                            <IdentNode start="(200, 22)" end="(200, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                            <AtomNode start="(200, 24)" end="(200, 25)" leading="" trailing=" " val="="/>
                            <OtherNode start="(200, 26)" end="(200, 42)" kind="«term_++_»">
                              <IdentNode start="(200, 26)" end="(200, 36)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(200, 37)" end="(200, 39)" leading="" trailing=" " val="++"/>
                              <IdentNode start="(200, 40)" end="(200, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(200, 43)" end="(200, 44)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(200, 45)" end="(200, 91)" kind="«term_=_»">
                            <OtherNode start="(200, 45)" end="(200, 65)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(200, 45)" end="(200, 54)" leading="" trailing=" " raw_val="takeTR.go" val="takeTR.go" full_name="List.takeTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(193, 17)" def_end="(193, 19)"/>
                              <NullNode start="(200, 55)" end="(200, 65)">
                                <IdentNode start="(200, 55)" end="(200, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(200, 57)" end="(200, 59)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(200, 60)" end="(200, 61)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(200, 62)" end="(200, 65)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(200, 66)" end="(200, 67)" leading="" trailing=" " val="="/>
                            <OtherNode start="(200, 68)" end="(200, 91)" kind="«term_++_»">
                              <IdentNode start="(200, 68)" end="(200, 78)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(200, 79)" end="(200, 81)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(200, 82)" end="(200, 91)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(200, 82)" end="(200, 89)" leading="" trailing=" " raw_val="xs.take" val="xs.take"/>
                                <NullNode start="(200, 90)" end="(200, 91)">
                                  <IdentNode start="(200, 90)" end="(200, 91)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(200, 92)" end="(201, 32)" kind="Lean.Parser.Term.fromTerm">
                        <AtomNode start="(200, 92)" end="(200, 96)" leading="" trailing="&#10;    " val="from"/>
                        <OtherNode start="(201, 5)" end="(201, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(201, 5)" end="(201, 27)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(201, 5)" end="(201, 6)" leading="" trailing="" val="("/>
                            <OtherNode start="(201, 6)" end="(201, 26)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(201, 6)" end="(201, 10)" leading="" trailing=" " raw_val="this" val="this"/>
                              <NullNode start="(201, 11)" end="(201, 26)">
                                <IdentNode start="(201, 11)" end="(201, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(201, 13)" end="(201, 16)" kind="«term#[_,]»">
                                  <AtomNode start="(201, 13)" end="(201, 15)" leading="" trailing="" val="#["/>
                                  <NullNode/>
                                  <AtomNode start="(201, 15)" end="(201, 16)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                                <OtherNode start="(201, 17)" end="(201, 26)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(201, 17)" end="(201, 18)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(201, 18)" end="(201, 25)">
                                    <AtomNode start="(201, 18)" end="(201, 20)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(201, 21)" end="(201, 25)">
                                      <TacticTacticseq1IndentedNode start="(201, 21)" end="(201, 25)">
                                        <NullNode start="(201, 21)" end="(201, 25)">
                                          <OtherNode start="(201, 21)" end="(201, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;i : Nat&#10;l : List α&#10;this : ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs&#10;⊢ l = #[].toList ++ l" state_after="no goals" tactic="simp">
                                            <AtomNode start="(201, 21)" end="(201, 25)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(201, 25)" end="(201, 26)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(201, 26)" end="(201, 27)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(201, 27)" end="(201, 28)" leading="" trailing="" val="."/>
                          <IdentNode start="(201, 28)" end="(201, 32)" leading="" trailing="&#10;  " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(202, 3)" end="(202, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l : List α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs" state_after="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs" tactic="intro xs">
                    <AtomNode start="(202, 3)" end="(202, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(202, 9)" end="(202, 11)">
                      <IdentNode start="(202, 9)" end="(202, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(202, 11)" end="(202, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(202, 13)" end="(207, 46)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h&#10;α : Type u_1&#10;i : Nat&#10;l xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs" state_after="no goals" tactic="induction xs generalizing i with intro acc&#10;| nil =&amp;gt; cases i &amp;lt;;&amp;gt; simp [take, takeTR.go]&#10;| cons x xs IH =&amp;gt;&#10;cases i with simp only [take, takeTR.go]&#10;| zero =&amp;gt; simp&#10;| succ n =&amp;gt; intro h; rw [IH] &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(202, 13)" end="(202, 22)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(202, 23)" end="(202, 25)">
                      <OtherNode start="(202, 23)" end="(202, 25)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(202, 23)" end="(202, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(202, 26)" end="(202, 40)">
                      <AtomNode start="(202, 26)" end="(202, 38)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(202, 39)" end="(202, 40)">
                        <IdentNode start="(202, 39)" end="(202, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(202, 41)" end="(207, 46)">
                      <OtherNode start="(202, 41)" end="(207, 46)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(202, 41)" end="(202, 45)" leading="" trailing=" " val="with"/>
                        <NullNode start="(202, 46)" end="(202, 55)">
                          <OtherNode start="(202, 46)" end="(202, 55)" kind="Lean.Parser.Tactic.intro">
                            <AtomNode start="(202, 46)" end="(202, 51)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(202, 52)" end="(202, 55)">
                              <IdentNode start="(202, 52)" end="(202, 55)" leading="" trailing="&#10;  " raw_val="acc" val="acc"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(203, 3)" end="(207, 46)">
                          <OtherNode start="(203, 3)" end="(203, 46)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(203, 3)" end="(203, 8)">
                              <OtherNode start="(203, 3)" end="(203, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(203, 3)" end="(203, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(203, 5)" end="(203, 8)">
                                  <NullNode/>
                                  <IdentNode start="(203, 5)" end="(203, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(203, 9)" end="(203, 46)">
                              <AtomNode start="(203, 9)" end="(203, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(203, 12)" end="(203, 46)">
                                <TacticTacticseq1IndentedNode start="(203, 12)" end="(203, 46)">
                                  <NullNode start="(203, 12)" end="(203, 46)">
                                    <OtherNode start="(203, 12)" end="(203, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.nil&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;acc : Array α&#10;⊢ l = acc.toList ++ [] → takeTR.go l [] i acc = acc.toList ++ take i []" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp [take, takeTR.go]">
                                      <OtherNode start="(203, 12)" end="(203, 19)" kind="Lean.Parser.Tactic.cases">
                                        <AtomNode start="(203, 12)" end="(203, 17)" leading="" trailing=" " val="cases"/>
                                        <NullNode start="(203, 18)" end="(203, 19)">
                                          <OtherNode start="(203, 18)" end="(203, 19)" kind="Lean.Parser.Tactic.elimTarget">
                                            <NullNode/>
                                            <IdentNode start="(203, 18)" end="(203, 19)" leading="" trailing=" " raw_val="i" val="i"/>
                                          </OtherNode>
                                        </NullNode>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(203, 20)" end="(203, 23)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(203, 24)" end="(203, 46)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(203, 24)" end="(203, 28)" leading="" trailing=" " val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode start="(203, 29)" end="(203, 46)">
                                          <AtomNode start="(203, 29)" end="(203, 30)" leading="" trailing="" val="["/>
                                          <NullNode start="(203, 30)" end="(203, 45)">
                                            <OtherNode start="(203, 30)" end="(203, 34)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(203, 30)" end="(203, 34)" leading="" trailing="" raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                            </OtherNode>
                                            <AtomNode start="(203, 34)" end="(203, 35)" leading="" trailing=" " val=","/>
                                            <OtherNode start="(203, 36)" end="(203, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                              <NullNode/>
                                              <NullNode/>
                                              <IdentNode start="(203, 36)" end="(203, 45)" leading="" trailing="" raw_val="takeTR.go" val="takeTR.go" full_name="List.takeTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(193, 17)" def_end="(193, 19)"/>
                                            </OtherNode>
                                          </NullNode>
                                          <AtomNode start="(203, 45)" end="(203, 46)" leading="" trailing="&#10;  " val="]"/>
                                        </NullNode>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(204, 3)" end="(207, 46)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(204, 3)" end="(204, 17)">
                              <OtherNode start="(204, 3)" end="(204, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(204, 3)" end="(204, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(204, 5)" end="(204, 9)">
                                  <NullNode/>
                                  <IdentNode start="(204, 5)" end="(204, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(204, 10)" end="(204, 17)">
                                  <IdentNode start="(204, 10)" end="(204, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(204, 12)" end="(204, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(204, 15)" end="(204, 17)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(204, 18)" end="(207, 46)">
                              <AtomNode start="(204, 18)" end="(204, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(205, 5)" end="(207, 46)">
                                <TacticTacticseq1IndentedNode start="(205, 5)" end="(207, 46)">
                                  <NullNode start="(205, 5)" end="(207, 46)">
                                    <OtherNode start="(205, 5)" end="(207, 46)" kind="Lean.Parser.Tactic.cases" state_before="case h.h.h.cons&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs&#10;i : Nat&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs → takeTR.go l (x :: xs) i acc = acc.toList ++ take i (x :: xs)" state_after="no goals" tactic="cases i with simp only [take, takeTR.go]&#10;| zero =&amp;gt; simp&#10;| succ n =&amp;gt; intro h; rw [IH] &amp;lt;;&amp;gt; simp_all">
                                      <AtomNode start="(205, 5)" end="(205, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(205, 11)" end="(205, 12)">
                                        <OtherNode start="(205, 11)" end="(205, 12)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <IdentNode start="(205, 11)" end="(205, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode start="(205, 13)" end="(207, 46)">
                                        <OtherNode start="(205, 13)" end="(207, 46)" kind="Lean.Parser.Tactic.inductionAlts">
                                          <AtomNode start="(205, 13)" end="(205, 17)" leading="" trailing=" " val="with"/>
                                          <NullNode start="(205, 18)" end="(205, 45)">
                                            <OtherNode start="(205, 18)" end="(205, 45)" kind="Lean.Parser.Tactic.simp">
                                              <AtomNode start="(205, 18)" end="(205, 22)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode start="(205, 23)" end="(205, 27)">
                                                <AtomNode start="(205, 23)" end="(205, 27)" leading="" trailing=" " val="only"/>
                                              </NullNode>
                                              <NullNode start="(205, 28)" end="(205, 45)">
                                                <AtomNode start="(205, 28)" end="(205, 29)" leading="" trailing="" val="["/>
                                                <NullNode start="(205, 29)" end="(205, 44)">
                                                  <OtherNode start="(205, 29)" end="(205, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(205, 29)" end="(205, 33)" leading="" trailing="" raw_val="take" val="take" full_name="List.take" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(205, 33)" end="(205, 34)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(205, 35)" end="(205, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(205, 35)" end="(205, 44)" leading="" trailing="" raw_val="takeTR.go" val="takeTR.go" full_name="List.takeTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(193, 17)" def_end="(193, 19)"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(205, 44)" end="(205, 45)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                          <NullNode start="(206, 5)" end="(207, 46)">
                                            <OtherNode start="(206, 5)" end="(206, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(206, 5)" end="(206, 11)">
                                                <OtherNode start="(206, 5)" end="(206, 11)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(206, 5)" end="(206, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(206, 7)" end="(206, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(206, 7)" end="(206, 11)" leading="" trailing=" " raw_val="zero" val="zero"/>
                                                  </GroupNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(206, 12)" end="(206, 19)">
                                                <AtomNode start="(206, 12)" end="(206, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(206, 15)" end="(206, 19)">
                                                  <TacticTacticseq1IndentedNode start="(206, 15)" end="(206, 19)">
                                                    <NullNode start="(206, 15)" end="(206, 19)">
                                                      <OtherNode start="(206, 15)" end="(206, 19)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.cons.zero&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs → acc.toList = acc.toList ++ []" state_after="no goals" tactic="simp">
                                                        <AtomNode start="(206, 15)" end="(206, 19)" leading="" trailing="&#10;    " val="simp"/>
                                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <NullNode/>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                            <OtherNode start="(207, 5)" end="(207, 46)" kind="Lean.Parser.Tactic.inductionAlt">
                                              <NullNode start="(207, 5)" end="(207, 13)">
                                                <OtherNode start="(207, 5)" end="(207, 13)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                                  <AtomNode start="(207, 5)" end="(207, 6)" leading="" trailing=" " val="|"/>
                                                  <GroupNode start="(207, 7)" end="(207, 11)">
                                                    <NullNode/>
                                                    <IdentNode start="(207, 7)" end="(207, 11)" leading="" trailing=" " raw_val="succ" val="succ"/>
                                                  </GroupNode>
                                                  <NullNode start="(207, 12)" end="(207, 13)">
                                                    <IdentNode start="(207, 12)" end="(207, 13)" leading="" trailing=" " raw_val="n" val="n"/>
                                                  </NullNode>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(207, 14)" end="(207, 46)">
                                                <AtomNode start="(207, 14)" end="(207, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                                                <TacticTacticseqNode start="(207, 17)" end="(207, 46)">
                                                  <TacticTacticseq1IndentedNode start="(207, 17)" end="(207, 46)">
                                                    <NullNode start="(207, 17)" end="(207, 46)">
                                                      <OtherNode start="(207, 17)" end="(207, 24)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h.cons.succ&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs&#10;acc : Array α&#10;n : Nat&#10;⊢ l = acc.toList ++ x :: xs → takeTR.go l xs n (acc.push x) = acc.toList ++ x :: take n xs" state_after="case h.h.h.cons.succ&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs&#10;acc : Array α&#10;n : Nat&#10;h : l = acc.toList ++ x :: xs&#10;⊢ takeTR.go l xs n (acc.push x) = acc.toList ++ x :: take n xs" tactic="intro h">
                                                        <AtomNode start="(207, 17)" end="(207, 22)" leading="" trailing=" " val="intro"/>
                                                        <NullNode start="(207, 23)" end="(207, 24)">
                                                          <IdentNode start="(207, 23)" end="(207, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(207, 24)" end="(207, 25)" leading="" trailing=" " val=";"/>
                                                      <OtherNode start="(207, 26)" end="(207, 46)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.cons.succ&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → takeTR.go l xs i acc = acc.toList ++ take i xs&#10;acc : Array α&#10;n : Nat&#10;h : l = acc.toList ++ x :: xs&#10;⊢ takeTR.go l xs n (acc.push x) = acc.toList ++ x :: take n xs" state_after="no goals" tactic="rw [IH] &amp;lt;;&amp;gt; simp_all">
                                                        <OtherNode start="(207, 26)" end="(207, 33)" kind="Lean.Parser.Tactic.rwSeq">
                                                          <AtomNode start="(207, 26)" end="(207, 28)" leading="" trailing=" " val="rw"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <OtherNode start="(207, 29)" end="(207, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                            <AtomNode start="(207, 29)" end="(207, 30)" leading="" trailing="" val="["/>
                                                            <NullNode start="(207, 30)" end="(207, 32)">
                                                            <OtherNode start="(207, 30)" end="(207, 32)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <IdentNode start="(207, 30)" end="(207, 32)" leading="" trailing="" raw_val="IH" val="IH"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(207, 32)" end="(207, 33)" leading="" trailing=" " val="]"/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                        </OtherNode>
                                                        <AtomNode start="(207, 34)" end="(207, 37)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                                        <OtherNode start="(207, 38)" end="(207, 46)" kind="Lean.Parser.Tactic.simpAll">
                                                          <AtomNode start="(207, 38)" end="(207, 46)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(209, 1)" end="(209, 21)" comment="### takeWhile -/">
      <AtomNode start="(209, 1)" end="(209, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(209, 5)" end="(209, 21)" leading="" trailing="&#10;&#10;&#10;" val="### takeWhile -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(212, 1)" end="(227, 66)" name="takeWhileTR" full_name="List.takeWhileTR">
      <CommandDeclmodifiersNode start="(212, 1)" end="(222, 10)">
        <NullNode start="(212, 1)" end="(221, 3)">
          <CommandDoccommentNode start="(212, 1)" end="(221, 3)" comment="Returns the longest initial segment of `xs` for which `p` returns true.&#10;&#10;`O(|xs|)`. This is a tail-recursive version of `List.take`, used at runtime.&#10;&#10;Examples:&#10;* `[7, 6, 4, 8].takeWhileTR (· &amp;gt; 5) = [7, 6]`&#10;* `[7, 6, 6, 5].takeWhileTR (· &amp;gt; 5) = [7, 6, 6]`&#10;* `[7, 6, 6, 8].takeWhileTR (· &amp;gt; 5) = [7, 6, 6, 8]`&#10;-/">
            <AtomNode start="(212, 1)" end="(212, 4)" leading="" trailing="&#10; " val="/--"/>
            <AtomNode start="(213, 2)" end="(221, 3)" leading="" trailing="&#10;" val="Returns the longest initial segment of `xs` for which `p` returns true.&#10;&#10;`O(|xs|)`. This is a tail-recursive version of `List.take`, used at runtime.&#10;&#10;Examples:&#10;* `[7, 6, 4, 8].takeWhileTR (· &amp;gt; 5) = [7, 6]`&#10;* `[7, 6, 6, 5].takeWhileTR (· &amp;gt; 5) = [7, 6, 6]`&#10;* `[7, 6, 6, 8].takeWhileTR (· &amp;gt; 5) = [7, 6, 6, 8]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(222, 1)" end="(222, 10)">
          <OtherNode start="(222, 1)" end="(222, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(222, 1)" end="(222, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(222, 3)" end="(222, 9)">
              <OtherNode start="(222, 3)" end="(222, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(222, 3)" end="(222, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(222, 3)" end="(222, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(222, 9)" end="(222, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(222, 11)" end="(227, 66)" name="takeWhileTR">
        <AtomNode start="(222, 11)" end="(222, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(222, 15)" end="(222, 26)">
          <IdentNode start="(222, 15)" end="(222, 26)" leading="" trailing=" " raw_val="takeWhileTR" val="takeWhileTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(222, 27)" end="(222, 63)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(222, 27)" end="(222, 54)">
            <TermExplicitbinderNode start="(222, 27)" end="(222, 41)">
              <AtomNode start="(222, 27)" end="(222, 28)" leading="" trailing="" val="("/>
              <NullNode start="(222, 28)" end="(222, 29)">
                <IdentNode start="(222, 28)" end="(222, 29)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(222, 30)" end="(222, 40)">
                <AtomNode start="(222, 30)" end="(222, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(222, 32)" end="(222, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(222, 32)" end="(222, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(222, 34)" end="(222, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(222, 36)" end="(222, 40)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(222, 40)" end="(222, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(222, 42)" end="(222, 54)">
              <AtomNode start="(222, 42)" end="(222, 43)" leading="" trailing="" val="("/>
              <NullNode start="(222, 43)" end="(222, 44)">
                <IdentNode start="(222, 43)" end="(222, 44)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(222, 45)" end="(222, 53)">
                <AtomNode start="(222, 45)" end="(222, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(222, 47)" end="(222, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(222, 47)" end="(222, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(222, 52)" end="(222, 53)">
                    <IdentNode start="(222, 52)" end="(222, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(222, 53)" end="(222, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(222, 55)" end="(222, 63)">
            <TermTypespecNode start="(222, 55)" end="(222, 63)">
              <AtomNode start="(222, 55)" end="(222, 56)" leading="" trailing=" " val=":"/>
              <OtherNode start="(222, 57)" end="(222, 63)" kind="Lean.Parser.Term.app">
                <IdentNode start="(222, 57)" end="(222, 61)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(222, 62)" end="(222, 63)">
                  <IdentNode start="(222, 62)" end="(222, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(222, 64)" end="(227, 66)">
          <AtomNode start="(222, 64)" end="(222, 66)" leading="" trailing=" " val=":="/>
          <OtherNode start="(222, 67)" end="(222, 75)" kind="Lean.Parser.Term.app">
            <IdentNode start="(222, 67)" end="(222, 69)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(222, 70)" end="(222, 75)">
              <IdentNode start="(222, 70)" end="(222, 71)" leading="" trailing=" " raw_val="l" val="l"/>
              <OtherNode start="(222, 72)" end="(222, 75)" kind="«term#[_,]»">
                <AtomNode start="(222, 72)" end="(222, 74)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(222, 74)" end="(222, 75)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(222, 76)" end="(227, 66)">
            <OtherNode start="(222, 76)" end="(227, 66)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(222, 76)" end="(222, 81)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(223, 3)" end="(227, 66)">
                <OtherNode start="(223, 3)" end="(227, 66)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(223, 3)" end="(224, 85)">
                    <CommandDoccommentNode start="(223, 3)" end="(224, 85)" comment="Auxiliary for `takeWhile`: `takeWhile.go p l xs acc = acc.toList ++ takeWhile p xs`,&#10;  unless no element satisfying `p` is found in `xs` in which case it returns `l`. -/">
                      <AtomNode start="(223, 3)" end="(223, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(223, 7)" end="(224, 85)" leading="" trailing="&#10;  " val="Auxiliary for `takeWhile`: `takeWhile.go p l xs acc = acc.toList ++ takeWhile p xs`,&#10;  unless no element satisfying `p` is found in `xs` in which case it returns `l`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(225, 3)" end="(225, 16)">
                    <OtherNode start="(225, 3)" end="(225, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(225, 3)" end="(225, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(225, 5)" end="(225, 15)">
                        <OtherNode start="(225, 5)" end="(225, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(225, 5)" end="(225, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(225, 5)" end="(225, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(225, 15)" end="(225, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(225, 17)" end="(227, 66)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(225, 17)" end="(227, 66)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(225, 17)" end="(225, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(225, 20)" end="(225, 47)">
                        <TermTypespecNode start="(225, 20)" end="(225, 47)">
                          <AtomNode start="(225, 20)" end="(225, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(225, 22)" end="(225, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(225, 22)" end="(225, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(225, 22)" end="(225, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(225, 27)" end="(225, 28)">
                                <IdentNode start="(225, 27)" end="(225, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(225, 29)" end="(225, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(225, 31)" end="(225, 47)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(225, 31)" end="(225, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(225, 31)" end="(225, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(225, 37)" end="(225, 38)">
                                  <IdentNode start="(225, 37)" end="(225, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(225, 39)" end="(225, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(225, 41)" end="(225, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(225, 41)" end="(225, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(225, 46)" end="(225, 47)">
                                  <IdentNode start="(225, 46)" end="(225, 47)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(226, 3)" end="(227, 66)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(226, 3)" end="(227, 66)">
                          <OtherNode start="(226, 3)" end="(226, 15)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(226, 3)" end="(226, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(226, 5)" end="(226, 10)">
                              <NullNode start="(226, 5)" end="(226, 10)">
                                <OtherNode start="(226, 5)" end="(226, 7)" kind="«term[_]»">
                                  <AtomNode start="(226, 5)" end="(226, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(226, 6)" end="(226, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(226, 7)" end="(226, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(226, 9)" end="(226, 10)">
                                  <AtomNode start="(226, 9)" end="(226, 10)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(226, 11)" end="(226, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(226, 14)" end="(226, 15)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(227, 3)" end="(227, 66)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(227, 3)" end="(227, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(227, 5)" end="(227, 15)">
                              <NullNode start="(227, 5)" end="(227, 15)">
                                <OtherNode start="(227, 5)" end="(227, 10)" kind="«term_::_»">
                                  <IdentNode start="(227, 5)" end="(227, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(227, 6)" end="(227, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(227, 8)" end="(227, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(227, 10)" end="(227, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(227, 12)" end="(227, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(227, 16)" end="(227, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(227, 19)" end="(227, 66)" kind="boolIfThenElse">
                              <AtomNode start="(227, 19)" end="(227, 22)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(227, 23)" end="(227, 26)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(227, 23)" end="(227, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(227, 25)" end="(227, 26)">
                                  <IdentNode start="(227, 25)" end="(227, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(227, 27)" end="(227, 31)" leading="" trailing=" " val="then"/>
                              <OtherNode start="(227, 32)" end="(227, 50)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(227, 32)" end="(227, 34)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(227, 35)" end="(227, 50)">
                                  <IdentNode start="(227, 35)" end="(227, 37)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <OtherNode start="(227, 38)" end="(227, 50)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(227, 38)" end="(227, 39)" leading="" trailing="" val="("/>
                                    <OtherNode start="(227, 39)" end="(227, 49)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(227, 39)" end="(227, 47)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                      <NullNode start="(227, 48)" end="(227, 49)">
                                        <IdentNode start="(227, 48)" end="(227, 49)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(227, 49)" end="(227, 50)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(227, 51)" end="(227, 55)" leading="" trailing=" " val="else"/>
                              <IdentNode start="(227, 56)" end="(227, 66)" leading="" trailing="&#10;&#10;" raw_val="acc.toList" val="acc.toList"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(229, 1)" end="(240, 15)" name="takeWhile_eq_takeWhileTR" full_name="List.takeWhile_eq_takeWhileTR">
      <CommandDeclmodifiersNode start="(229, 1)" end="(229, 9)">
        <NullNode/>
        <NullNode start="(229, 1)" end="(229, 9)">
          <OtherNode start="(229, 1)" end="(229, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(229, 1)" end="(229, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(229, 3)" end="(229, 8)">
              <OtherNode start="(229, 3)" end="(229, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(229, 3)" end="(229, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(229, 3)" end="(229, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(229, 8)" end="(229, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(229, 10)" end="(240, 15)" name="takeWhile_eq_takeWhileTR" full_name="List.takeWhile_eq_takeWhileTR" _is_private_decl="False">
        <AtomNode start="(229, 10)" end="(229, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(229, 18)" end="(229, 42)">
          <IdentNode start="(229, 18)" end="(229, 42)" leading="" trailing=" " raw_val="takeWhile_eq_takeWhileTR" val="takeWhile_eq_takeWhileTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(229, 43)" end="(229, 70)">
          <NullNode/>
          <TermTypespecNode start="(229, 43)" end="(229, 70)">
            <AtomNode start="(229, 43)" end="(229, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(229, 45)" end="(229, 70)" kind="«term_=_»">
              <OtherNode start="(229, 45)" end="(229, 55)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(229, 45)" end="(229, 46)" leading="" trailing="" val="@"/>
                <IdentNode start="(229, 46)" end="(229, 55)" leading="" trailing=" " raw_val="takeWhile" val="takeWhile" full_name="List.takeWhile" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(229, 56)" end="(229, 57)" leading="" trailing=" " val="="/>
              <OtherNode start="(229, 58)" end="(229, 70)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(229, 58)" end="(229, 59)" leading="" trailing="" val="@"/>
                <IdentNode start="(229, 59)" end="(229, 70)" leading="" trailing=" " raw_val="takeWhileTR" val="takeWhileTR" full_name="List.takeWhileTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(222, 15)" def_end="(222, 26)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(229, 71)" end="(240, 15)">
          <AtomNode start="(229, 71)" end="(229, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(229, 74)" end="(240, 15)">
            <AtomNode start="(229, 74)" end="(229, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(230, 3)" end="(240, 15)">
              <TacticTacticseq1IndentedNode start="(230, 3)" end="(240, 15)">
                <NullNode start="(230, 3)" end="(240, 15)">
                  <OtherNode start="(230, 3)" end="(230, 15)" kind="tacticFunext___" state_before="⊢ @takeWhile = @takeWhileTR" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ takeWhile p l = takeWhileTR p l" tactic="funext α p l">
                    <AtomNode start="(230, 3)" end="(230, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(230, 10)" end="(230, 15)">
                      <IdentNode start="(230, 10)" end="(230, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(230, 12)" end="(230, 13)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(230, 14)" end="(230, 15)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(230, 15)" end="(230, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(230, 17)" end="(230, 35)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ takeWhile p l = takeWhileTR p l" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ takeWhile p l = takeWhileTR.go p l l #[]" tactic="simp [takeWhileTR]">
                    <AtomNode start="(230, 17)" end="(230, 21)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(230, 22)" end="(230, 35)">
                      <AtomNode start="(230, 22)" end="(230, 23)" leading="" trailing="" val="["/>
                      <NullNode start="(230, 23)" end="(230, 34)">
                        <OtherNode start="(230, 23)" end="(230, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(230, 23)" end="(230, 34)" leading="" trailing="" raw_val="takeWhileTR" val="takeWhileTR" full_name="List.takeWhileTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(222, 15)" def_end="(222, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(230, 34)" end="(230, 35)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(231, 3)" end="(233, 32)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ takeWhile p l = takeWhileTR.go p l l #[]" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs" tactic="suffices ∀ xs acc, l = acc.toList ++ xs →&#10;    takeWhileTR.go p l xs acc = acc.toList ++ xs.takeWhile p from&#10;  (this l #[] (by simp)).symm">
                    <AtomNode start="(231, 3)" end="(231, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(231, 12)" end="(233, 32)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(231, 12)" end="(231, 12)" kind="hygieneInfo">
                        <IdentNode start="(231, 12)" end="(231, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(231, 12)" end="(232, 63)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(231, 12)" end="(231, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(231, 14)" end="(231, 20)">
                          <IdentNode start="(231, 14)" end="(231, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <IdentNode start="(231, 17)" end="(231, 20)" leading="" trailing="" raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(231, 20)" end="(231, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(231, 22)" end="(232, 63)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(231, 22)" end="(231, 42)" kind="«term_=_»">
                            <IdentNode start="(231, 22)" end="(231, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                            <AtomNode start="(231, 24)" end="(231, 25)" leading="" trailing=" " val="="/>
                            <OtherNode start="(231, 26)" end="(231, 42)" kind="«term_++_»">
                              <IdentNode start="(231, 26)" end="(231, 36)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(231, 37)" end="(231, 39)" leading="" trailing=" " val="++"/>
                              <IdentNode start="(231, 40)" end="(231, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(231, 43)" end="(231, 44)" leading="" trailing="&#10;      " val="→"/>
                          <OtherNode start="(232, 7)" end="(232, 63)" kind="«term_=_»">
                            <OtherNode start="(232, 7)" end="(232, 32)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(232, 7)" end="(232, 21)" leading="" trailing=" " raw_val="takeWhileTR.go" val="takeWhileTR.go" full_name="List.takeWhileTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(225, 17)" def_end="(225, 19)"/>
                              <NullNode start="(232, 22)" end="(232, 32)">
                                <IdentNode start="(232, 22)" end="(232, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                                <IdentNode start="(232, 24)" end="(232, 25)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(232, 26)" end="(232, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(232, 29)" end="(232, 32)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(232, 33)" end="(232, 34)" leading="" trailing=" " val="="/>
                            <OtherNode start="(232, 35)" end="(232, 63)" kind="«term_++_»">
                              <IdentNode start="(232, 35)" end="(232, 45)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(232, 46)" end="(232, 48)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(232, 49)" end="(232, 63)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(232, 49)" end="(232, 61)" leading="" trailing=" " raw_val="xs.takeWhile" val="xs.takeWhile"/>
                                <NullNode start="(232, 62)" end="(232, 63)">
                                  <IdentNode start="(232, 62)" end="(232, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(232, 64)" end="(233, 32)" kind="Lean.Parser.Term.fromTerm">
                        <AtomNode start="(232, 64)" end="(232, 68)" leading="" trailing="&#10;    " val="from"/>
                        <OtherNode start="(233, 5)" end="(233, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(233, 5)" end="(233, 27)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(233, 5)" end="(233, 6)" leading="" trailing="" val="("/>
                            <OtherNode start="(233, 6)" end="(233, 26)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(233, 6)" end="(233, 10)" leading="" trailing=" " raw_val="this" val="this"/>
                              <NullNode start="(233, 11)" end="(233, 26)">
                                <IdentNode start="(233, 11)" end="(233, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(233, 13)" end="(233, 16)" kind="«term#[_,]»">
                                  <AtomNode start="(233, 13)" end="(233, 15)" leading="" trailing="" val="#["/>
                                  <NullNode/>
                                  <AtomNode start="(233, 15)" end="(233, 16)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                                <OtherNode start="(233, 17)" end="(233, 26)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(233, 17)" end="(233, 18)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(233, 18)" end="(233, 25)">
                                    <AtomNode start="(233, 18)" end="(233, 20)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(233, 21)" end="(233, 25)">
                                      <TacticTacticseq1IndentedNode start="(233, 21)" end="(233, 25)">
                                        <NullNode start="(233, 21)" end="(233, 25)">
                                          <OtherNode start="(233, 21)" end="(233, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;this : ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;⊢ l = #[].toList ++ l" state_after="no goals" tactic="simp">
                                            <AtomNode start="(233, 21)" end="(233, 25)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(233, 25)" end="(233, 26)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(233, 26)" end="(233, 27)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(233, 27)" end="(233, 28)" leading="" trailing="" val="."/>
                          <IdentNode start="(233, 28)" end="(233, 32)" leading="" trailing="&#10;  " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(234, 3)" end="(234, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs" tactic="intro xs">
                    <AtomNode start="(234, 3)" end="(234, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(234, 9)" end="(234, 11)">
                      <IdentNode start="(234, 9)" end="(234, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(234, 11)" end="(234, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(234, 13)" end="(240, 15)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs" state_after="no goals" tactic="induction xs with intro acc&#10;| nil =&amp;gt; simp [takeWhile, takeWhileTR.go]&#10;| cons x xs IH =&amp;gt;&#10;simp only [takeWhileTR.go, Array.toListImpl_eq, takeWhile]&#10;split&#10;· intro h; rw [IH] &amp;lt;;&amp;gt; simp_all&#10;· simp [*]">
                    <AtomNode start="(234, 13)" end="(234, 22)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(234, 23)" end="(234, 25)">
                      <OtherNode start="(234, 23)" end="(234, 25)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(234, 23)" end="(234, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(234, 26)" end="(240, 15)">
                      <OtherNode start="(234, 26)" end="(240, 15)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(234, 26)" end="(234, 30)" leading="" trailing=" " val="with"/>
                        <NullNode start="(234, 31)" end="(234, 40)">
                          <OtherNode start="(234, 31)" end="(234, 40)" kind="Lean.Parser.Tactic.intro">
                            <AtomNode start="(234, 31)" end="(234, 36)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(234, 37)" end="(234, 40)">
                              <IdentNode start="(234, 37)" end="(234, 40)" leading="" trailing="&#10;  " raw_val="acc" val="acc"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(235, 3)" end="(240, 15)">
                          <OtherNode start="(235, 3)" end="(235, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(235, 3)" end="(235, 8)">
                              <OtherNode start="(235, 3)" end="(235, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(235, 3)" end="(235, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(235, 5)" end="(235, 8)">
                                  <NullNode/>
                                  <IdentNode start="(235, 5)" end="(235, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(235, 9)" end="(235, 44)">
                              <AtomNode start="(235, 9)" end="(235, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(235, 12)" end="(235, 44)">
                                <TacticTacticseq1IndentedNode start="(235, 12)" end="(235, 44)">
                                  <NullNode start="(235, 12)" end="(235, 44)">
                                    <OtherNode start="(235, 12)" end="(235, 44)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.nil&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;⊢ l = acc.toList ++ [] → takeWhileTR.go p l [] acc = acc.toList ++ takeWhile p []" state_after="no goals" tactic="simp [takeWhile, takeWhileTR.go]">
                                      <AtomNode start="(235, 12)" end="(235, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(235, 17)" end="(235, 44)">
                                        <AtomNode start="(235, 17)" end="(235, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(235, 18)" end="(235, 43)">
                                          <OtherNode start="(235, 18)" end="(235, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(235, 18)" end="(235, 27)" leading="" trailing="" raw_val="takeWhile" val="takeWhile" full_name="List.takeWhile" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(235, 27)" end="(235, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(235, 29)" end="(235, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(235, 29)" end="(235, 43)" leading="" trailing="" raw_val="takeWhileTR.go" val="takeWhileTR.go" full_name="List.takeWhileTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(225, 17)" def_end="(225, 19)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(235, 43)" end="(235, 44)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(236, 3)" end="(240, 15)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(236, 3)" end="(236, 17)">
                              <OtherNode start="(236, 3)" end="(236, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(236, 3)" end="(236, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(236, 5)" end="(236, 9)">
                                  <NullNode/>
                                  <IdentNode start="(236, 5)" end="(236, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(236, 10)" end="(236, 17)">
                                  <IdentNode start="(236, 10)" end="(236, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(236, 12)" end="(236, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(236, 15)" end="(236, 17)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(236, 18)" end="(240, 15)">
                              <AtomNode start="(236, 18)" end="(236, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(237, 5)" end="(240, 15)">
                                <TacticTacticseq1IndentedNode start="(237, 5)" end="(240, 15)">
                                  <NullNode start="(237, 5)" end="(240, 15)">
                                    <OtherNode start="(237, 5)" end="(237, 63)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.cons&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs → takeWhileTR.go p l (x :: xs) acc = acc.toList ++ takeWhile p (x :: xs)" state_after="case h.h.h.cons&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) =&#10;      acc.toList ++&#10;        match p x with&#10;        | true =&amp;gt; x :: takeWhile p xs&#10;        | false =&amp;gt; []" tactic="simp only [takeWhileTR.go, Array.toListImpl_eq, takeWhile]">
                                      <AtomNode start="(237, 5)" end="(237, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(237, 10)" end="(237, 14)">
                                        <AtomNode start="(237, 10)" end="(237, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(237, 15)" end="(237, 63)">
                                        <AtomNode start="(237, 15)" end="(237, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(237, 16)" end="(237, 62)">
                                          <OtherNode start="(237, 16)" end="(237, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(237, 16)" end="(237, 30)" leading="" trailing="" raw_val="takeWhileTR.go" val="takeWhileTR.go" full_name="List.takeWhileTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(225, 17)" def_end="(225, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(237, 30)" end="(237, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(237, 32)" end="(237, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(237, 32)" end="(237, 51)" leading="" trailing="" raw_val="Array.toListImpl_eq" val="Array.toListImpl_eq" full_name="Array.toListImpl_eq" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(237, 51)" end="(237, 52)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(237, 53)" end="(237, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(237, 53)" end="(237, 62)" leading="" trailing="" raw_val="takeWhile" val="takeWhile" full_name="List.takeWhile" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(237, 62)" end="(237, 63)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(238, 5)" end="(238, 10)" kind="Lean.Parser.Tactic.split" state_before="case h.h.h.cons&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) =&#10;      acc.toList ++&#10;        match p x with&#10;        | true =&amp;gt; x :: takeWhile p xs&#10;        | false =&amp;gt; []" state_after="case h.h.h.cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = true&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ x :: takeWhile p xs&#10;&#10;case h.h.h.cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = false&#10;⊢ l = acc.toList ++ x :: xs → (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ []" tactic="split">
                                      <AtomNode start="(238, 5)" end="(238, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(239, 5)" end="(239, 36)" kind="Lean.cdot" state_before="case h.h.h.cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = true&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ x :: takeWhile p xs&#10;&#10;case h.h.h.cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = false&#10;⊢ l = acc.toList ++ x :: xs → (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ []" state_after="case h.h.h.cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = false&#10;⊢ l = acc.toList ++ x :: xs → (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ []" tactic="· intro h; rw [IH] &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(239, 5)" end="(239, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(239, 5)" end="(239, 6)" kind="patternIgnore">
                                          <OtherNode start="(239, 5)" end="(239, 6)" kind="token.«· »">
                                            <AtomNode start="(239, 5)" end="(239, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(239, 7)" end="(239, 36)">
                                        <TacticTacticseq1IndentedNode start="(239, 7)" end="(239, 36)">
                                          <NullNode start="(239, 7)" end="(239, 36)">
                                            <OtherNode start="(239, 7)" end="(239, 14)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h.cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = true&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ x :: takeWhile p xs" state_after="case h.h.h.cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = true&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ x :: takeWhile p xs" tactic="intro h">
                                              <AtomNode start="(239, 7)" end="(239, 12)" leading="" trailing=" " val="intro"/>
                                              <NullNode start="(239, 13)" end="(239, 14)">
                                                <IdentNode start="(239, 13)" end="(239, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(239, 14)" end="(239, 15)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(239, 16)" end="(239, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.cons.h_1&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = true&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ x :: takeWhile p xs" state_after="no goals" tactic="rw [IH] &amp;lt;;&amp;gt; simp_all">
                                              <OtherNode start="(239, 16)" end="(239, 23)" kind="Lean.Parser.Tactic.rwSeq">
                                                <AtomNode start="(239, 16)" end="(239, 18)" leading="" trailing=" " val="rw"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <OtherNode start="(239, 19)" end="(239, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                  <AtomNode start="(239, 19)" end="(239, 20)" leading="" trailing="" val="["/>
                                                  <NullNode start="(239, 20)" end="(239, 22)">
                                                    <OtherNode start="(239, 20)" end="(239, 22)" kind="Lean.Parser.Tactic.rwRule">
                                                      <NullNode/>
                                                      <IdentNode start="(239, 20)" end="(239, 22)" leading="" trailing="" raw_val="IH" val="IH"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(239, 22)" end="(239, 23)" leading="" trailing=" " val="]"/>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(239, 24)" end="(239, 27)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(239, 28)" end="(239, 36)" kind="Lean.Parser.Tactic.simpAll">
                                                <AtomNode start="(239, 28)" end="(239, 36)" leading="" trailing="&#10;    " val="simp_all"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(240, 5)" end="(240, 15)" kind="Lean.cdot" state_before="case h.h.h.cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = false&#10;⊢ l = acc.toList ++ x :: xs → (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ []" state_after="no goals" tactic="· simp [*]">
                                      <OtherNode start="(240, 5)" end="(240, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(240, 5)" end="(240, 6)" kind="patternIgnore">
                                          <OtherNode start="(240, 5)" end="(240, 6)" kind="token.«· »">
                                            <AtomNode start="(240, 5)" end="(240, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(240, 7)" end="(240, 15)">
                                        <TacticTacticseq1IndentedNode start="(240, 7)" end="(240, 15)">
                                          <NullNode start="(240, 7)" end="(240, 15)">
                                            <OtherNode start="(240, 7)" end="(240, 15)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.cons.h_2&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → takeWhileTR.go p l xs acc = acc.toList ++ takeWhile p xs&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : p x = false&#10;⊢ l = acc.toList ++ x :: xs → (bif p x then takeWhileTR.go p l xs (acc.push x) else acc.toList) = acc.toList ++ []" state_after="no goals" tactic="simp [*]">
                                              <AtomNode start="(240, 7)" end="(240, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(240, 12)" end="(240, 15)">
                                                <AtomNode start="(240, 12)" end="(240, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(240, 13)" end="(240, 14)">
                                                  <OtherNode start="(240, 13)" end="(240, 14)" kind="Lean.Parser.Tactic.simpStar">
                                                    <AtomNode start="(240, 13)" end="(240, 14)" leading="" trailing="" val="*"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(240, 14)" end="(240, 15)" leading="" trailing="&#10;&#10;" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(242, 1)" end="(242, 20)" comment="### dropLast -/">
      <AtomNode start="(242, 1)" end="(242, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(242, 5)" end="(242, 20)" leading="" trailing="&#10;&#10;" val="### dropLast -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(244, 1)" end="(254, 71)" name="dropLastTR" full_name="List.dropLastTR">
      <CommandDeclmodifiersNode start="(244, 1)" end="(254, 10)">
        <NullNode start="(244, 1)" end="(253, 3)">
          <CommandDoccommentNode start="(244, 1)" end="(253, 3)" comment="Removes the last element of the list, if one exists.&#10;&#10;This is a tail-recursive version of `List.dropLast`, used at runtime.&#10;&#10;Examples:&#10;* `[].dropLastTR = []`&#10;* `[&amp;quot;tea&amp;quot;].dropLastTR = []`&#10;* `[&amp;quot;tea&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;juice&amp;quot;].dropLastTR = [&amp;quot;tea&amp;quot;, &amp;quot;coffee&amp;quot;]`&#10;-/">
            <AtomNode start="(244, 1)" end="(244, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(245, 1)" end="(253, 3)" leading="" trailing="&#10;" val="Removes the last element of the list, if one exists.&#10;&#10;This is a tail-recursive version of `List.dropLast`, used at runtime.&#10;&#10;Examples:&#10;* `[].dropLastTR = []`&#10;* `[&amp;quot;tea&amp;quot;].dropLastTR = []`&#10;* `[&amp;quot;tea&amp;quot;, &amp;quot;coffee&amp;quot;, &amp;quot;juice&amp;quot;].dropLastTR = [&amp;quot;tea&amp;quot;, &amp;quot;coffee&amp;quot;]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(254, 1)" end="(254, 10)">
          <OtherNode start="(254, 1)" end="(254, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(254, 1)" end="(254, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(254, 3)" end="(254, 9)">
              <OtherNode start="(254, 3)" end="(254, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(254, 3)" end="(254, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(254, 3)" end="(254, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(254, 9)" end="(254, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(254, 11)" end="(254, 71)" name="dropLastTR">
        <AtomNode start="(254, 11)" end="(254, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(254, 15)" end="(254, 25)">
          <IdentNode start="(254, 15)" end="(254, 25)" leading="" trailing=" " raw_val="dropLastTR" val="dropLastTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(254, 26)" end="(254, 47)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(254, 26)" end="(254, 38)">
            <TermExplicitbinderNode start="(254, 26)" end="(254, 38)">
              <AtomNode start="(254, 26)" end="(254, 27)" leading="" trailing="" val="("/>
              <NullNode start="(254, 27)" end="(254, 28)">
                <IdentNode start="(254, 27)" end="(254, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(254, 29)" end="(254, 37)">
                <AtomNode start="(254, 29)" end="(254, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(254, 31)" end="(254, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(254, 31)" end="(254, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(254, 36)" end="(254, 37)">
                    <IdentNode start="(254, 36)" end="(254, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(254, 37)" end="(254, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(254, 39)" end="(254, 47)">
            <TermTypespecNode start="(254, 39)" end="(254, 47)">
              <AtomNode start="(254, 39)" end="(254, 40)" leading="" trailing=" " val=":"/>
              <OtherNode start="(254, 41)" end="(254, 47)" kind="Lean.Parser.Term.app">
                <IdentNode start="(254, 41)" end="(254, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(254, 46)" end="(254, 47)">
                  <IdentNode start="(254, 46)" end="(254, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(254, 48)" end="(254, 71)">
          <AtomNode start="(254, 48)" end="(254, 50)" leading="" trailing=" " val=":="/>
          <IdentNode start="(254, 51)" end="(254, 71)" leading="" trailing="&#10;&#10;" raw_val="l.toArray.pop.toList" val="l.toArray.pop.toList"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(256, 1)" end="(257, 32)" name="dropLast_eq_dropLastTR" full_name="List.dropLast_eq_dropLastTR">
      <CommandDeclmodifiersNode start="(256, 1)" end="(256, 9)">
        <NullNode/>
        <NullNode start="(256, 1)" end="(256, 9)">
          <OtherNode start="(256, 1)" end="(256, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(256, 1)" end="(256, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(256, 3)" end="(256, 8)">
              <OtherNode start="(256, 3)" end="(256, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(256, 3)" end="(256, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(256, 3)" end="(256, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(256, 8)" end="(256, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(256, 10)" end="(257, 32)" name="dropLast_eq_dropLastTR" full_name="List.dropLast_eq_dropLastTR" _is_private_decl="False">
        <AtomNode start="(256, 10)" end="(256, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(256, 18)" end="(256, 40)">
          <IdentNode start="(256, 18)" end="(256, 40)" leading="" trailing=" " raw_val="dropLast_eq_dropLastTR" val="dropLast_eq_dropLastTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(256, 41)" end="(256, 66)">
          <NullNode/>
          <TermTypespecNode start="(256, 41)" end="(256, 66)">
            <AtomNode start="(256, 41)" end="(256, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(256, 43)" end="(256, 66)" kind="«term_=_»">
              <OtherNode start="(256, 43)" end="(256, 52)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(256, 43)" end="(256, 44)" leading="" trailing="" val="@"/>
                <IdentNode start="(256, 44)" end="(256, 52)" leading="" trailing=" " raw_val="dropLast" val="dropLast" full_name="List.dropLast" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(256, 53)" end="(256, 54)" leading="" trailing=" " val="="/>
              <OtherNode start="(256, 55)" end="(256, 66)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(256, 55)" end="(256, 56)" leading="" trailing="" val="@"/>
                <IdentNode start="(256, 56)" end="(256, 66)" leading="" trailing=" " raw_val="dropLastTR" val="dropLastTR" full_name="List.dropLastTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(254, 15)" def_end="(254, 25)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(256, 67)" end="(257, 32)">
          <AtomNode start="(256, 67)" end="(256, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(256, 70)" end="(257, 32)">
            <AtomNode start="(256, 70)" end="(256, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(257, 3)" end="(257, 32)">
              <TacticTacticseq1IndentedNode start="(257, 3)" end="(257, 32)">
                <NullNode start="(257, 3)" end="(257, 32)">
                  <OtherNode start="(257, 3)" end="(257, 13)" kind="tacticFunext___" state_before="⊢ @dropLast = @dropLastTR" state_after="case h.h&#10;α : Type u_1&#10;l : List α&#10;⊢ l.dropLast = l.dropLastTR" tactic="funext α l">
                    <AtomNode start="(257, 3)" end="(257, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(257, 10)" end="(257, 13)">
                      <IdentNode start="(257, 10)" end="(257, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(257, 12)" end="(257, 13)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(257, 13)" end="(257, 14)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(257, 15)" end="(257, 32)" kind="Lean.Parser.Tactic.simp" state_before="case h.h&#10;α : Type u_1&#10;l : List α&#10;⊢ l.dropLast = l.dropLastTR" state_after="no goals" tactic="simp [dropLastTR]">
                    <AtomNode start="(257, 15)" end="(257, 19)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(257, 20)" end="(257, 32)">
                      <AtomNode start="(257, 20)" end="(257, 21)" leading="" trailing="" val="["/>
                      <NullNode start="(257, 21)" end="(257, 31)">
                        <OtherNode start="(257, 21)" end="(257, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(257, 21)" end="(257, 31)" leading="" trailing="" raw_val="dropLastTR" val="dropLastTR" full_name="List.dropLastTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(254, 15)" def_end="(254, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(257, 31)" end="(257, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(259, 1)" end="(259, 27)" comment="## Finding elements -/">
      <AtomNode start="(259, 1)" end="(259, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(259, 5)" end="(259, 27)" leading="" trailing="&#10;&#10;" val="## Finding elements -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(261, 1)" end="(262, 75)" name="findRev?TR" full_name="List.findRev?TR">
      <CommandDeclmodifiersNode start="(261, 1)" end="(261, 82)">
        <NullNode start="(261, 1)" end="(261, 82)">
          <CommandDoccommentNode start="(261, 1)" end="(261, 82)" comment="Tail recursive implementation of `findRev?`. This is only used at runtime. -/">
            <AtomNode start="(261, 1)" end="(261, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(261, 5)" end="(261, 82)" leading="" trailing="&#10;" val="Tail recursive implementation of `findRev?`. This is only used at runtime. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(262, 1)" end="(262, 75)" name="findRev?TR">
        <AtomNode start="(262, 1)" end="(262, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(262, 5)" end="(262, 15)">
          <IdentNode start="(262, 5)" end="(262, 15)" leading="" trailing=" " raw_val="findRev?TR" val="findRev?TR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(262, 16)" end="(262, 54)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(262, 16)" end="(262, 43)">
            <TermExplicitbinderNode start="(262, 16)" end="(262, 30)">
              <AtomNode start="(262, 16)" end="(262, 17)" leading="" trailing="" val="("/>
              <NullNode start="(262, 17)" end="(262, 18)">
                <IdentNode start="(262, 17)" end="(262, 18)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(262, 19)" end="(262, 29)">
                <AtomNode start="(262, 19)" end="(262, 20)" leading="" trailing=" " val=":"/>
                <OtherNode start="(262, 21)" end="(262, 29)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(262, 21)" end="(262, 22)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(262, 23)" end="(262, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(262, 25)" end="(262, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(262, 29)" end="(262, 30)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(262, 31)" end="(262, 43)">
              <AtomNode start="(262, 31)" end="(262, 32)" leading="" trailing="" val="("/>
              <NullNode start="(262, 32)" end="(262, 33)">
                <IdentNode start="(262, 32)" end="(262, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(262, 34)" end="(262, 42)">
                <AtomNode start="(262, 34)" end="(262, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(262, 36)" end="(262, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(262, 36)" end="(262, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(262, 41)" end="(262, 42)">
                    <IdentNode start="(262, 41)" end="(262, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(262, 42)" end="(262, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(262, 44)" end="(262, 54)">
            <TermTypespecNode start="(262, 44)" end="(262, 54)">
              <AtomNode start="(262, 44)" end="(262, 45)" leading="" trailing=" " val=":"/>
              <OtherNode start="(262, 46)" end="(262, 54)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 46)" end="(262, 52)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(262, 53)" end="(262, 54)">
                  <IdentNode start="(262, 53)" end="(262, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(262, 55)" end="(262, 75)">
          <AtomNode start="(262, 55)" end="(262, 57)" leading="" trailing=" " val=":="/>
          <OtherNode start="(262, 58)" end="(262, 75)" kind="Lean.Parser.Term.app">
            <IdentNode start="(262, 58)" end="(262, 73)" leading="" trailing=" " raw_val="l.reverse.find?" val="l.reverse.find?"/>
            <NullNode start="(262, 74)" end="(262, 75)">
              <IdentNode start="(262, 74)" end="(262, 75)" leading="" trailing="&#10;&#10;" raw_val="p" val="p"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(264, 1)" end="(266, 21)" name="find?_singleton" full_name="List.find?_singleton">
      <CommandDeclmodifiersNode start="(264, 1)" end="(264, 8)">
        <NullNode/>
        <NullNode start="(264, 1)" end="(264, 8)">
          <OtherNode start="(264, 1)" end="(264, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(264, 1)" end="(264, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(264, 3)" end="(264, 7)">
              <OtherNode start="(264, 3)" end="(264, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(264, 3)" end="(264, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(264, 3)" end="(264, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(264, 7)" end="(264, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(264, 9)" end="(266, 21)" name="find?_singleton" full_name="List.find?_singleton" _is_private_decl="False">
        <AtomNode start="(264, 9)" end="(264, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(264, 17)" end="(264, 32)">
          <IdentNode start="(264, 17)" end="(264, 32)" leading="" trailing=" " raw_val="find?_singleton" val="find?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(264, 33)" end="(264, 85)">
          <NullNode start="(264, 33)" end="(264, 40)">
            <OtherNode start="(264, 33)" end="(264, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(264, 33)" end="(264, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(264, 34)" end="(264, 35)">
                <IdentNode start="(264, 34)" end="(264, 35)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(264, 36)" end="(264, 39)">
                <AtomNode start="(264, 36)" end="(264, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(264, 38)" end="(264, 39)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(264, 39)" end="(264, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(264, 41)" end="(264, 85)">
            <AtomNode start="(264, 41)" end="(264, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(264, 43)" end="(264, 85)" kind="«term_=_»">
              <OtherNode start="(264, 43)" end="(264, 54)" kind="Lean.Parser.Term.app">
                <OtherNode start="(264, 43)" end="(264, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(264, 43)" end="(264, 46)" kind="«term[_]»">
                    <AtomNode start="(264, 43)" end="(264, 44)" leading="" trailing="" val="["/>
                    <NullNode start="(264, 44)" end="(264, 45)">
                      <IdentNode start="(264, 44)" end="(264, 45)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(264, 45)" end="(264, 46)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(264, 46)" end="(264, 47)" leading="" trailing="" val="."/>
                  <IdentNode start="(264, 47)" end="(264, 52)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(264, 53)" end="(264, 54)">
                  <IdentNode start="(264, 53)" end="(264, 54)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(264, 55)" end="(264, 56)" leading="" trailing=" " val="="/>
              <OtherNode start="(264, 57)" end="(264, 85)" kind="termIfThenElse">
                <AtomNode start="(264, 57)" end="(264, 59)" leading="" trailing=" " val="if"/>
                <OtherNode start="(264, 60)" end="(264, 63)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(264, 60)" end="(264, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(264, 62)" end="(264, 63)">
                    <IdentNode start="(264, 62)" end="(264, 63)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(264, 64)" end="(264, 68)" leading="" trailing=" " val="then"/>
                <OtherNode start="(264, 69)" end="(264, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(264, 69)" end="(264, 73)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(264, 74)" end="(264, 75)">
                    <IdentNode start="(264, 74)" end="(264, 75)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(264, 76)" end="(264, 80)" leading="" trailing=" " val="else"/>
                <IdentNode start="(264, 81)" end="(264, 85)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(264, 86)" end="(266, 21)">
          <AtomNode start="(264, 86)" end="(264, 88)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(264, 89)" end="(266, 21)">
            <AtomNode start="(264, 89)" end="(264, 91)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(265, 3)" end="(266, 21)">
              <TacticTacticseq1IndentedNode start="(265, 3)" end="(266, 21)">
                <NullNode start="(265, 3)" end="(266, 21)">
                  <OtherNode start="(265, 3)" end="(265, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;⊢ find? p [a] = if p a = true then some a else none" state_after="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;⊢ (match p a with&#10;    | true =&amp;gt; some a&#10;    | false =&amp;gt; none) =&#10;    if p a = true then some a else none" tactic="simp only [find?]">
                    <AtomNode start="(265, 3)" end="(265, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(265, 8)" end="(265, 12)">
                      <AtomNode start="(265, 8)" end="(265, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(265, 13)" end="(265, 20)">
                      <AtomNode start="(265, 13)" end="(265, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(265, 14)" end="(265, 19)">
                        <OtherNode start="(265, 14)" end="(265, 19)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(265, 14)" end="(265, 19)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(265, 19)" end="(265, 20)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(266, 3)" end="(266, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;a : α&#10;⊢ (match p a with&#10;    | true =&amp;gt; some a&#10;    | false =&amp;gt; none) =&#10;    if p a = true then some a else none" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(266, 3)" end="(266, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(266, 3)" end="(266, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(266, 9)" end="(266, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(266, 13)" end="(266, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(266, 13)" end="(266, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(268, 1)" end="(273, 19)" name="find?_append" full_name="List.find?_append">
      <CommandDeclmodifiersNode start="(268, 1)" end="(268, 8)">
        <NullNode/>
        <NullNode start="(268, 1)" end="(268, 8)">
          <OtherNode start="(268, 1)" end="(268, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(268, 1)" end="(268, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(268, 3)" end="(268, 7)">
              <OtherNode start="(268, 3)" end="(268, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(268, 3)" end="(268, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(268, 3)" end="(268, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(268, 7)" end="(268, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(268, 9)" end="(273, 19)" name="find?_append" full_name="List.find?_append" _is_private_decl="False">
        <AtomNode start="(268, 9)" end="(268, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(268, 17)" end="(268, 29)">
          <IdentNode start="(268, 17)" end="(268, 29)" leading="" trailing=" " raw_val="find?_append" val="find?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(268, 30)" end="(268, 98)">
          <NullNode start="(268, 30)" end="(268, 46)">
            <OtherNode start="(268, 30)" end="(268, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(268, 30)" end="(268, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(268, 31)" end="(268, 36)">
                <IdentNode start="(268, 31)" end="(268, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(268, 34)" end="(268, 36)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(268, 37)" end="(268, 45)">
                <AtomNode start="(268, 37)" end="(268, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(268, 39)" end="(268, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(268, 39)" end="(268, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(268, 44)" end="(268, 45)">
                    <IdentNode start="(268, 44)" end="(268, 45)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(268, 45)" end="(268, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(268, 47)" end="(268, 98)">
            <AtomNode start="(268, 47)" end="(268, 48)" leading="" trailing=" " val=":"/>
            <OtherNode start="(268, 49)" end="(268, 98)" kind="«term_=_»">
              <OtherNode start="(268, 49)" end="(268, 67)" kind="Lean.Parser.Term.app">
                <OtherNode start="(268, 49)" end="(268, 65)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(268, 49)" end="(268, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(268, 49)" end="(268, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(268, 50)" end="(268, 58)" kind="«term_++_»">
                      <IdentNode start="(268, 50)" end="(268, 52)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(268, 53)" end="(268, 55)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(268, 56)" end="(268, 58)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(268, 58)" end="(268, 59)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(268, 59)" end="(268, 60)" leading="" trailing="" val="."/>
                  <IdentNode start="(268, 60)" end="(268, 65)" leading="" trailing=" " raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(268, 66)" end="(268, 67)">
                  <IdentNode start="(268, 66)" end="(268, 67)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(268, 68)" end="(268, 69)" leading="" trailing=" " val="="/>
              <OtherNode start="(268, 70)" end="(268, 98)" kind="Lean.Parser.Term.app">
                <OtherNode start="(268, 70)" end="(268, 85)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(268, 70)" end="(268, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(268, 70)" end="(268, 71)" leading="" trailing="" val="("/>
                    <OtherNode start="(268, 71)" end="(268, 81)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(268, 71)" end="(268, 79)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(268, 80)" end="(268, 81)">
                        <IdentNode start="(268, 80)" end="(268, 81)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(268, 81)" end="(268, 82)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(268, 82)" end="(268, 83)" leading="" trailing="" val="."/>
                  <IdentNode start="(268, 83)" end="(268, 85)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(268, 86)" end="(268, 98)">
                  <OtherNode start="(268, 86)" end="(268, 98)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(268, 86)" end="(268, 87)" leading="" trailing="" val="("/>
                    <OtherNode start="(268, 87)" end="(268, 97)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(268, 87)" end="(268, 95)" leading="" trailing=" " raw_val="ys.find?" val="ys.find?"/>
                      <NullNode start="(268, 96)" end="(268, 97)">
                        <IdentNode start="(268, 96)" end="(268, 97)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(268, 97)" end="(268, 98)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(268, 99)" end="(273, 19)">
          <AtomNode start="(268, 99)" end="(268, 101)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(268, 102)" end="(273, 19)">
            <AtomNode start="(268, 102)" end="(268, 104)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(269, 3)" end="(273, 19)">
              <TacticTacticseq1IndentedNode start="(269, 3)" end="(273, 19)">
                <NullNode start="(269, 3)" end="(273, 19)">
                  <OtherNode start="(269, 3)" end="(273, 19)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;p : α → Bool&#10;xs ys : List α&#10;⊢ find? p (xs ++ ys) = (find? p xs).or (find? p ys)" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp [find?]&#10;| cons x xs ih =&amp;gt;&#10;  simp only [cons_append, find?_cons, ih]&#10;  split &amp;lt;;&amp;gt; simp">
                    <AtomNode start="(269, 3)" end="(269, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(269, 13)" end="(269, 15)">
                      <OtherNode start="(269, 13)" end="(269, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(269, 13)" end="(269, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(269, 16)" end="(273, 19)">
                      <OtherNode start="(269, 16)" end="(273, 19)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(269, 16)" end="(269, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(270, 3)" end="(273, 19)">
                          <OtherNode start="(270, 3)" end="(270, 24)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(270, 3)" end="(270, 8)">
                              <OtherNode start="(270, 3)" end="(270, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(270, 3)" end="(270, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(270, 5)" end="(270, 8)">
                                  <NullNode/>
                                  <IdentNode start="(270, 5)" end="(270, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(270, 9)" end="(270, 24)">
                              <AtomNode start="(270, 9)" end="(270, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(270, 12)" end="(270, 24)">
                                <TacticTacticseq1IndentedNode start="(270, 12)" end="(270, 24)">
                                  <NullNode start="(270, 12)" end="(270, 24)">
                                    <OtherNode start="(270, 12)" end="(270, 24)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;p : α → Bool&#10;ys : List α&#10;⊢ find? p ([] ++ ys) = (find? p []).or (find? p ys)" state_after="no goals" tactic="simp [find?]">
                                      <AtomNode start="(270, 12)" end="(270, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(270, 17)" end="(270, 24)">
                                        <AtomNode start="(270, 17)" end="(270, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(270, 18)" end="(270, 23)">
                                          <OtherNode start="(270, 18)" end="(270, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(270, 18)" end="(270, 23)" leading="" trailing="" raw_val="find?" val="find?" full_name="List.find?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(270, 23)" end="(270, 24)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(271, 3)" end="(273, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(271, 3)" end="(271, 17)">
                              <OtherNode start="(271, 3)" end="(271, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(271, 3)" end="(271, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(271, 5)" end="(271, 9)">
                                  <NullNode/>
                                  <IdentNode start="(271, 5)" end="(271, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(271, 10)" end="(271, 17)">
                                  <IdentNode start="(271, 10)" end="(271, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(271, 12)" end="(271, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(271, 15)" end="(271, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(271, 18)" end="(273, 19)">
                              <AtomNode start="(271, 18)" end="(271, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(272, 5)" end="(273, 19)">
                                <TacticTacticseq1IndentedNode start="(272, 5)" end="(273, 19)">
                                  <NullNode start="(272, 5)" end="(273, 19)">
                                    <OtherNode start="(272, 5)" end="(272, 44)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;ys : List α&#10;x : α&#10;xs : List α&#10;ih : find? p (xs ++ ys) = (find? p xs).or (find? p ys)&#10;⊢ find? p (x :: xs ++ ys) = (find? p (x :: xs)).or (find? p ys)" state_after="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;ys : List α&#10;x : α&#10;xs : List α&#10;ih : find? p (xs ++ ys) = (find? p xs).or (find? p ys)&#10;⊢ (match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; (find? p xs).or (find? p ys)) =&#10;    (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).or&#10;      (find? p ys)" tactic="simp only [cons_append, find?_cons, ih]">
                                      <AtomNode start="(272, 5)" end="(272, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(272, 10)" end="(272, 14)">
                                        <AtomNode start="(272, 10)" end="(272, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(272, 15)" end="(272, 44)">
                                        <AtomNode start="(272, 15)" end="(272, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(272, 16)" end="(272, 43)">
                                          <OtherNode start="(272, 16)" end="(272, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(272, 16)" end="(272, 27)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(272, 27)" end="(272, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(272, 29)" end="(272, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(272, 29)" end="(272, 39)" leading="" trailing="" raw_val="find?_cons" val="find?_cons" full_name="List.find?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(272, 39)" end="(272, 40)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(272, 41)" end="(272, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(272, 41)" end="(272, 43)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(272, 43)" end="(272, 44)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(273, 5)" end="(273, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;p : α → Bool&#10;ys : List α&#10;x : α&#10;xs : List α&#10;ih : find? p (xs ++ ys) = (find? p xs).or (find? p ys)&#10;⊢ (match p x with&#10;    | true =&amp;gt; some x&#10;    | false =&amp;gt; (find? p xs).or (find? p ys)) =&#10;    (match p x with&#10;        | true =&amp;gt; some x&#10;        | false =&amp;gt; find? p xs).or&#10;      (find? p ys)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                                      <OtherNode start="(273, 5)" end="(273, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(273, 5)" end="(273, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(273, 11)" end="(273, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(273, 15)" end="(273, 19)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(273, 15)" end="(273, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(275, 1)" end="(281, 23)" name="findRev?_eq_findRev?TR" full_name="List.findRev?_eq_findRev?TR">
      <CommandDeclmodifiersNode start="(275, 1)" end="(275, 9)">
        <NullNode/>
        <NullNode start="(275, 1)" end="(275, 9)">
          <OtherNode start="(275, 1)" end="(275, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(275, 1)" end="(275, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(275, 3)" end="(275, 8)">
              <OtherNode start="(275, 3)" end="(275, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(275, 3)" end="(275, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(275, 3)" end="(275, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(275, 8)" end="(275, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(275, 10)" end="(281, 23)" name="findRev?_eq_findRev?TR" full_name="List.findRev?_eq_findRev?TR" _is_private_decl="False">
        <AtomNode start="(275, 10)" end="(275, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(275, 18)" end="(275, 40)">
          <IdentNode start="(275, 18)" end="(275, 40)" leading="" trailing=" " raw_val="findRev?_eq_findRev?TR" val="findRev?_eq_findRev?TR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(275, 41)" end="(275, 76)">
          <NullNode/>
          <TermTypespecNode start="(275, 41)" end="(275, 76)">
            <AtomNode start="(275, 41)" end="(275, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(275, 43)" end="(275, 76)" kind="«term_=_»">
              <OtherNode start="(275, 43)" end="(275, 57)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(275, 43)" end="(275, 44)" leading="" trailing="" val="@"/>
                <IdentNode start="(275, 44)" end="(275, 57)" leading="" trailing=" " raw_val="List.findRev?" val="List.findRev?" full_name="List.findRev?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(275, 58)" end="(275, 59)" leading="" trailing=" " val="="/>
              <OtherNode start="(275, 60)" end="(275, 76)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(275, 60)" end="(275, 61)" leading="" trailing="" val="@"/>
                <IdentNode start="(275, 61)" end="(275, 76)" leading="" trailing=" " raw_val="List.findRev?TR" val="List.findRev?TR" full_name="List.findRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(262, 5)" def_end="(262, 15)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(275, 77)" end="(281, 23)">
          <AtomNode start="(275, 77)" end="(275, 79)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(275, 80)" end="(281, 23)">
            <AtomNode start="(275, 80)" end="(275, 82)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(276, 3)" end="(281, 23)">
              <TacticTacticseq1IndentedNode start="(276, 3)" end="(281, 23)">
                <NullNode start="(276, 3)" end="(281, 23)">
                  <OtherNode start="(276, 3)" end="(276, 15)" kind="Lean.Parser.Tactic.apply" state_before="⊢ @findRev? = @findRev?TR" state_after="case h&#10;&#10;⊢ ∀ (x : Type u_1), findRev? = findRev?TR" tactic="apply funext">
                    <AtomNode start="(276, 3)" end="(276, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(276, 9)" end="(276, 15)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(276, 15)" end="(276, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(276, 17)" end="(276, 24)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;&#10;⊢ ∀ (x : Type u_1), findRev? = findRev?TR" state_after="case h&#10;α : Type u_1&#10;⊢ findRev? = findRev?TR" tactic="intro α">
                    <AtomNode start="(276, 17)" end="(276, 22)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(276, 23)" end="(276, 24)">
                      <IdentNode start="(276, 23)" end="(276, 24)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(276, 24)" end="(276, 25)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(276, 26)" end="(276, 38)" kind="Lean.Parser.Tactic.apply" state_before="case h&#10;α : Type u_1&#10;⊢ findRev? = findRev?TR" state_after="case h.h&#10;α : Type u_1&#10;⊢ ∀ (x : α → Bool), findRev? x = findRev?TR x" tactic="apply funext">
                    <AtomNode start="(276, 26)" end="(276, 31)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(276, 32)" end="(276, 38)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(276, 38)" end="(276, 39)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(276, 40)" end="(276, 47)" kind="Lean.Parser.Tactic.intro" state_before="case h.h&#10;α : Type u_1&#10;⊢ ∀ (x : α → Bool), findRev? x = findRev?TR x" state_after="case h.h&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findRev? p = findRev?TR p" tactic="intro p">
                    <AtomNode start="(276, 40)" end="(276, 45)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(276, 46)" end="(276, 47)">
                      <IdentNode start="(276, 46)" end="(276, 47)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(276, 47)" end="(276, 48)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(276, 49)" end="(276, 61)" kind="Lean.Parser.Tactic.apply" state_before="case h.h&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findRev? p = findRev?TR p" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ ∀ (x : List α), findRev? p x = findRev?TR p x" tactic="apply funext">
                    <AtomNode start="(276, 49)" end="(276, 54)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(276, 55)" end="(276, 61)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(276, 61)" end="(276, 62)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(276, 63)" end="(276, 70)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ ∀ (x : List α), findRev? p x = findRev?TR p x" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ findRev? p l = findRev?TR p l" tactic="intro l">
                    <AtomNode start="(276, 63)" end="(276, 68)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(276, 69)" end="(276, 70)">
                      <IdentNode start="(276, 69)" end="(276, 70)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(277, 3)" end="(281, 23)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ findRev? p l = findRev?TR p l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp [findRev?, findRev?TR]&#10;| cons x l ih =&amp;gt;&#10;  simp only [findRev?, ih, findRev?TR, reverse_cons, find?_append, find?_singleton]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(277, 3)" end="(277, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(277, 13)" end="(277, 14)">
                      <OtherNode start="(277, 13)" end="(277, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(277, 13)" end="(277, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(277, 15)" end="(281, 23)">
                      <OtherNode start="(277, 15)" end="(281, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(277, 15)" end="(277, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(278, 3)" end="(281, 23)">
                          <OtherNode start="(278, 3)" end="(278, 39)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(278, 3)" end="(278, 8)">
                              <OtherNode start="(278, 3)" end="(278, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(278, 3)" end="(278, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(278, 5)" end="(278, 8)">
                                  <NullNode/>
                                  <IdentNode start="(278, 5)" end="(278, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(278, 9)" end="(278, 39)">
                              <AtomNode start="(278, 9)" end="(278, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(278, 12)" end="(278, 39)">
                                <TacticTacticseq1IndentedNode start="(278, 12)" end="(278, 39)">
                                  <NullNode start="(278, 12)" end="(278, 39)">
                                    <OtherNode start="(278, 12)" end="(278, 39)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.nil&#10;α : Type u_1&#10;p : α → Bool&#10;⊢ findRev? p [] = findRev?TR p []" state_after="no goals" tactic="simp [findRev?, findRev?TR]">
                                      <AtomNode start="(278, 12)" end="(278, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(278, 17)" end="(278, 39)">
                                        <AtomNode start="(278, 17)" end="(278, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(278, 18)" end="(278, 38)">
                                          <OtherNode start="(278, 18)" end="(278, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(278, 18)" end="(278, 26)" leading="" trailing="" raw_val="findRev?" val="findRev?" full_name="List.findRev?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(278, 26)" end="(278, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(278, 28)" end="(278, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(278, 28)" end="(278, 38)" leading="" trailing="" raw_val="findRev?TR" val="findRev?TR" full_name="List.findRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(262, 5)" def_end="(262, 15)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(278, 38)" end="(278, 39)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(279, 3)" end="(281, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(279, 3)" end="(279, 16)">
                              <OtherNode start="(279, 3)" end="(279, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(279, 3)" end="(279, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(279, 5)" end="(279, 9)">
                                  <NullNode/>
                                  <IdentNode start="(279, 5)" end="(279, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(279, 10)" end="(279, 16)">
                                  <IdentNode start="(279, 10)" end="(279, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(279, 12)" end="(279, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(279, 14)" end="(279, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(279, 17)" end="(281, 23)">
                              <AtomNode start="(279, 17)" end="(279, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(280, 5)" end="(281, 23)">
                                <TacticTacticseq1IndentedNode start="(280, 5)" end="(281, 23)">
                                  <NullNode start="(280, 5)" end="(281, 23)">
                                    <OtherNode start="(280, 5)" end="(280, 86)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih : findRev? p l = findRev?TR p l&#10;⊢ findRev? p (x :: l) = findRev?TR p (x :: l)" state_after="case h.h.h.cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih : findRev? p l = findRev?TR p l&#10;⊢ (match find? p l.reverse with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; if p x = true then some x else none) =&#10;    (find? p l.reverse).or (if p x = true then some x else none)" tactic="simp only [findRev?, ih, findRev?TR, reverse_cons, find?_append, find?_singleton]">
                                      <AtomNode start="(280, 5)" end="(280, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(280, 10)" end="(280, 14)">
                                        <AtomNode start="(280, 10)" end="(280, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(280, 15)" end="(280, 86)">
                                        <AtomNode start="(280, 15)" end="(280, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(280, 16)" end="(280, 85)">
                                          <OtherNode start="(280, 16)" end="(280, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(280, 16)" end="(280, 24)" leading="" trailing="" raw_val="findRev?" val="findRev?" full_name="List.findRev?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(280, 24)" end="(280, 25)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(280, 26)" end="(280, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(280, 26)" end="(280, 28)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(280, 28)" end="(280, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(280, 30)" end="(280, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(280, 30)" end="(280, 40)" leading="" trailing="" raw_val="findRev?TR" val="findRev?TR" full_name="List.findRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(262, 5)" def_end="(262, 15)"/>
                                          </OtherNode>
                                          <AtomNode start="(280, 40)" end="(280, 41)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(280, 42)" end="(280, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(280, 42)" end="(280, 54)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(280, 54)" end="(280, 55)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(280, 56)" end="(280, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(280, 56)" end="(280, 68)" leading="" trailing="" raw_val="find?_append" val="find?_append" full_name="List.find?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(268, 17)" def_end="(268, 29)"/>
                                          </OtherNode>
                                          <AtomNode start="(280, 68)" end="(280, 69)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(280, 70)" end="(280, 85)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(280, 70)" end="(280, 85)" leading="" trailing="" raw_val="find?_singleton" val="find?_singleton" full_name="List.find?_singleton" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(264, 17)" def_end="(264, 32)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(280, 85)" end="(280, 86)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(281, 5)" end="(281, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.cons&#10;α : Type u_1&#10;p : α → Bool&#10;x : α&#10;l : List α&#10;ih : findRev? p l = findRev?TR p l&#10;⊢ (match find? p l.reverse with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; if p x = true then some x else none) =&#10;    (find? p l.reverse).or (if p x = true then some x else none)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(281, 5)" end="(281, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(281, 5)" end="(281, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(281, 11)" end="(281, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(281, 15)" end="(281, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(281, 15)" end="(281, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(283, 1)" end="(285, 44)" name="findRev?_eq_find?_reverse" full_name="List.findRev?_eq_find?_reverse">
      <CommandDeclmodifiersNode start="(283, 1)" end="(283, 8)">
        <NullNode/>
        <NullNode start="(283, 1)" end="(283, 8)">
          <OtherNode start="(283, 1)" end="(283, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(283, 1)" end="(283, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(283, 3)" end="(283, 7)">
              <OtherNode start="(283, 3)" end="(283, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(283, 3)" end="(283, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(283, 3)" end="(283, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(283, 7)" end="(283, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(283, 9)" end="(285, 44)" name="findRev?_eq_find?_reverse" full_name="List.findRev?_eq_find?_reverse" _is_private_decl="False">
        <AtomNode start="(283, 9)" end="(283, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(283, 17)" end="(283, 42)">
          <IdentNode start="(283, 17)" end="(283, 42)" leading="" trailing=" " raw_val="findRev?_eq_find?_reverse" val="findRev?_eq_find?_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(283, 43)" end="(284, 37)">
          <NullNode start="(283, 43)" end="(283, 70)">
            <OtherNode start="(283, 43)" end="(283, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(283, 43)" end="(283, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(283, 44)" end="(283, 45)">
                <IdentNode start="(283, 44)" end="(283, 45)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(283, 46)" end="(283, 54)">
                <AtomNode start="(283, 46)" end="(283, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(283, 48)" end="(283, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(283, 48)" end="(283, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(283, 53)" end="(283, 54)">
                    <IdentNode start="(283, 53)" end="(283, 54)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(283, 54)" end="(283, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(283, 56)" end="(283, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(283, 56)" end="(283, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(283, 57)" end="(283, 58)">
                <IdentNode start="(283, 57)" end="(283, 58)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(283, 59)" end="(283, 69)">
                <AtomNode start="(283, 59)" end="(283, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(283, 61)" end="(283, 69)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(283, 61)" end="(283, 62)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(283, 63)" end="(283, 64)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(283, 65)" end="(283, 69)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(283, 69)" end="(283, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(283, 71)" end="(284, 37)">
            <AtomNode start="(283, 71)" end="(283, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(284, 5)" end="(284, 37)" kind="«term_=_»">
              <OtherNode start="(284, 5)" end="(284, 17)" kind="Lean.Parser.Term.app">
                <IdentNode start="(284, 5)" end="(284, 15)" leading="" trailing=" " raw_val="l.findRev?" val="l.findRev?"/>
                <NullNode start="(284, 16)" end="(284, 17)">
                  <IdentNode start="(284, 16)" end="(284, 17)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(284, 18)" end="(284, 19)" leading="" trailing=" " val="="/>
              <OtherNode start="(284, 20)" end="(284, 37)" kind="Lean.Parser.Term.app">
                <IdentNode start="(284, 20)" end="(284, 35)" leading="" trailing=" " raw_val="l.reverse.find?" val="l.reverse.find?"/>
                <NullNode start="(284, 36)" end="(284, 37)">
                  <IdentNode start="(284, 36)" end="(284, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(284, 38)" end="(285, 44)">
          <AtomNode start="(284, 38)" end="(284, 40)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(284, 41)" end="(285, 44)">
            <AtomNode start="(284, 41)" end="(284, 43)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(285, 3)" end="(285, 44)">
              <TacticTacticseq1IndentedNode start="(285, 3)" end="(285, 44)">
                <NullNode start="(285, 3)" end="(285, 44)">
                  <OtherNode start="(285, 3)" end="(285, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;p : α → Bool&#10;⊢ findRev? p l = find? p l.reverse" state_after="no goals" tactic="simp [findRev?_eq_findRev?TR, findRev?TR]">
                    <AtomNode start="(285, 3)" end="(285, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(285, 8)" end="(285, 44)">
                      <AtomNode start="(285, 8)" end="(285, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(285, 9)" end="(285, 43)">
                        <OtherNode start="(285, 9)" end="(285, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(285, 9)" end="(285, 31)" leading="" trailing="" raw_val="findRev?_eq_findRev?TR" val="findRev?_eq_findRev?TR" full_name="List.findRev?_eq_findRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(275, 18)" def_end="(275, 40)"/>
                        </OtherNode>
                        <AtomNode start="(285, 31)" end="(285, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(285, 33)" end="(285, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(285, 33)" end="(285, 43)" leading="" trailing="" raw_val="findRev?TR" val="findRev?TR" full_name="List.findRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(262, 5)" def_end="(262, 15)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(285, 43)" end="(285, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(287, 1)" end="(288, 87)" name="findSomeRev?TR" full_name="List.findSomeRev?TR">
      <CommandDeclmodifiersNode start="(287, 1)" end="(287, 86)">
        <NullNode start="(287, 1)" end="(287, 86)">
          <CommandDoccommentNode start="(287, 1)" end="(287, 86)" comment="Tail recursive implementation of `finSomedRev?`. This is only used at runtime. -/">
            <AtomNode start="(287, 1)" end="(287, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(287, 5)" end="(287, 86)" leading="" trailing="&#10;" val="Tail recursive implementation of `finSomedRev?`. This is only used at runtime. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(288, 1)" end="(288, 87)" name="findSomeRev?TR">
        <AtomNode start="(288, 1)" end="(288, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(288, 5)" end="(288, 19)">
          <IdentNode start="(288, 5)" end="(288, 19)" leading="" trailing=" " raw_val="findSomeRev?TR" val="findSomeRev?TR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(288, 20)" end="(288, 62)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(288, 20)" end="(288, 51)">
            <TermExplicitbinderNode start="(288, 20)" end="(288, 38)">
              <AtomNode start="(288, 20)" end="(288, 21)" leading="" trailing="" val="("/>
              <NullNode start="(288, 21)" end="(288, 22)">
                <IdentNode start="(288, 21)" end="(288, 22)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(288, 23)" end="(288, 37)">
                <AtomNode start="(288, 23)" end="(288, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(288, 25)" end="(288, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(288, 25)" end="(288, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(288, 27)" end="(288, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(288, 29)" end="(288, 37)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(288, 29)" end="(288, 35)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(288, 36)" end="(288, 37)">
                      <IdentNode start="(288, 36)" end="(288, 37)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(288, 37)" end="(288, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(288, 39)" end="(288, 51)">
              <AtomNode start="(288, 39)" end="(288, 40)" leading="" trailing="" val="("/>
              <NullNode start="(288, 40)" end="(288, 41)">
                <IdentNode start="(288, 40)" end="(288, 41)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(288, 42)" end="(288, 50)">
                <AtomNode start="(288, 42)" end="(288, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(288, 44)" end="(288, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(288, 44)" end="(288, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(288, 49)" end="(288, 50)">
                    <IdentNode start="(288, 49)" end="(288, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(288, 50)" end="(288, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(288, 52)" end="(288, 62)">
            <TermTypespecNode start="(288, 52)" end="(288, 62)">
              <AtomNode start="(288, 52)" end="(288, 53)" leading="" trailing=" " val=":"/>
              <OtherNode start="(288, 54)" end="(288, 62)" kind="Lean.Parser.Term.app">
                <IdentNode start="(288, 54)" end="(288, 60)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(288, 61)" end="(288, 62)">
                  <IdentNode start="(288, 61)" end="(288, 62)" leading="" trailing=" " raw_val="β" val="β"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(288, 63)" end="(288, 87)">
          <AtomNode start="(288, 63)" end="(288, 65)" leading="" trailing=" " val=":="/>
          <OtherNode start="(288, 66)" end="(288, 87)" kind="Lean.Parser.Term.app">
            <IdentNode start="(288, 66)" end="(288, 85)" leading="" trailing=" " raw_val="l.reverse.findSome?" val="l.reverse.findSome?"/>
            <NullNode start="(288, 86)" end="(288, 87)">
              <IdentNode start="(288, 86)" end="(288, 87)" leading="" trailing="&#10;&#10;" raw_val="f" val="f"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(290, 1)" end="(293, 21)" name="findSome?_singleton" full_name="List.findSome?_singleton">
      <CommandDeclmodifiersNode start="(290, 1)" end="(290, 8)">
        <NullNode/>
        <NullNode start="(290, 1)" end="(290, 8)">
          <OtherNode start="(290, 1)" end="(290, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(290, 1)" end="(290, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(290, 3)" end="(290, 7)">
              <OtherNode start="(290, 3)" end="(290, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(290, 3)" end="(290, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(290, 3)" end="(290, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(290, 7)" end="(290, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(290, 9)" end="(293, 21)" name="findSome?_singleton" full_name="List.findSome?_singleton" _is_private_decl="False">
        <AtomNode start="(290, 9)" end="(290, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(290, 17)" end="(290, 36)">
          <IdentNode start="(290, 17)" end="(290, 36)" leading="" trailing=" " raw_val="findSome?_singleton" val="findSome?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(290, 37)" end="(291, 26)">
          <NullNode start="(290, 37)" end="(290, 44)">
            <OtherNode start="(290, 37)" end="(290, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(290, 37)" end="(290, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(290, 38)" end="(290, 39)">
                <IdentNode start="(290, 38)" end="(290, 39)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(290, 40)" end="(290, 43)">
                <AtomNode start="(290, 40)" end="(290, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(290, 42)" end="(290, 43)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(290, 43)" end="(290, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(290, 45)" end="(291, 26)">
            <AtomNode start="(290, 45)" end="(290, 46)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(291, 5)" end="(291, 26)" kind="«term_=_»">
              <OtherNode start="(291, 5)" end="(291, 20)" kind="Lean.Parser.Term.app">
                <OtherNode start="(291, 5)" end="(291, 18)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(291, 5)" end="(291, 8)" kind="«term[_]»">
                    <AtomNode start="(291, 5)" end="(291, 6)" leading="" trailing="" val="["/>
                    <NullNode start="(291, 6)" end="(291, 7)">
                      <IdentNode start="(291, 6)" end="(291, 7)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(291, 7)" end="(291, 8)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(291, 8)" end="(291, 9)" leading="" trailing="" val="."/>
                  <IdentNode start="(291, 9)" end="(291, 18)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(291, 19)" end="(291, 20)">
                  <IdentNode start="(291, 19)" end="(291, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(291, 21)" end="(291, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(291, 23)" end="(291, 26)" kind="Lean.Parser.Term.app">
                <IdentNode start="(291, 23)" end="(291, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(291, 25)" end="(291, 26)">
                  <IdentNode start="(291, 25)" end="(291, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(291, 27)" end="(293, 21)">
          <AtomNode start="(291, 27)" end="(291, 29)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(291, 30)" end="(293, 21)">
            <AtomNode start="(291, 30)" end="(291, 32)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(292, 3)" end="(293, 21)">
              <TacticTacticseq1IndentedNode start="(292, 3)" end="(293, 21)">
                <NullNode start="(292, 3)" end="(293, 21)">
                  <OtherNode start="(292, 3)" end="(292, 44)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;⊢ findSome? f [a] = f a" state_after="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; none) =&#10;    f a" tactic="simp only [findSome?_cons, findSome?_nil]">
                    <AtomNode start="(292, 3)" end="(292, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(292, 8)" end="(292, 12)">
                      <AtomNode start="(292, 8)" end="(292, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(292, 13)" end="(292, 44)">
                      <AtomNode start="(292, 13)" end="(292, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(292, 14)" end="(292, 43)">
                        <OtherNode start="(292, 14)" end="(292, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(292, 14)" end="(292, 28)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                        <AtomNode start="(292, 28)" end="(292, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(292, 30)" end="(292, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(292, 30)" end="(292, 43)" leading="" trailing="" raw_val="findSome?_nil" val="findSome?_nil" full_name="List.findSome?_nil" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(292, 43)" end="(292, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(293, 3)" end="(293, 21)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;⊢ (match f a with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; none) =&#10;    f a" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                    <OtherNode start="(293, 3)" end="(293, 8)" kind="Lean.Parser.Tactic.split">
                      <AtomNode start="(293, 3)" end="(293, 8)" leading="" trailing=" " val="split"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(293, 9)" end="(293, 12)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(293, 13)" end="(293, 21)" kind="Lean.Parser.Tactic.simpAll">
                      <AtomNode start="(293, 13)" end="(293, 21)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(295, 1)" end="(300, 19)" name="findSome?_append" full_name="List.findSome?_append">
      <CommandDeclmodifiersNode start="(295, 1)" end="(295, 8)">
        <NullNode/>
        <NullNode start="(295, 1)" end="(295, 8)">
          <OtherNode start="(295, 1)" end="(295, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(295, 1)" end="(295, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(295, 3)" end="(295, 7)">
              <OtherNode start="(295, 3)" end="(295, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(295, 3)" end="(295, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(295, 3)" end="(295, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(295, 7)" end="(295, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(295, 9)" end="(300, 19)" name="findSome?_append" full_name="List.findSome?_append" _is_private_decl="False">
        <AtomNode start="(295, 9)" end="(295, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(295, 17)" end="(295, 33)">
          <IdentNode start="(295, 17)" end="(295, 33)" leading="" trailing=" " raw_val="findSome?_append" val="findSome?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(295, 34)" end="(295, 114)">
          <NullNode start="(295, 34)" end="(295, 50)">
            <OtherNode start="(295, 34)" end="(295, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(295, 34)" end="(295, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(295, 35)" end="(295, 40)">
                <IdentNode start="(295, 35)" end="(295, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(295, 38)" end="(295, 40)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(295, 41)" end="(295, 49)">
                <AtomNode start="(295, 41)" end="(295, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(295, 43)" end="(295, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(295, 43)" end="(295, 47)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(295, 48)" end="(295, 49)">
                    <IdentNode start="(295, 48)" end="(295, 49)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(295, 49)" end="(295, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(295, 51)" end="(295, 114)">
            <AtomNode start="(295, 51)" end="(295, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(295, 53)" end="(295, 114)" kind="«term_=_»">
              <OtherNode start="(295, 53)" end="(295, 75)" kind="Lean.Parser.Term.app">
                <OtherNode start="(295, 53)" end="(295, 73)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(295, 53)" end="(295, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(295, 53)" end="(295, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(295, 54)" end="(295, 62)" kind="«term_++_»">
                      <IdentNode start="(295, 54)" end="(295, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(295, 57)" end="(295, 59)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(295, 60)" end="(295, 62)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(295, 62)" end="(295, 63)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(295, 63)" end="(295, 64)" leading="" trailing="" val="."/>
                  <IdentNode start="(295, 64)" end="(295, 73)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <NullNode start="(295, 74)" end="(295, 75)">
                  <IdentNode start="(295, 74)" end="(295, 75)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(295, 76)" end="(295, 77)" leading="" trailing=" " val="="/>
              <OtherNode start="(295, 78)" end="(295, 114)" kind="Lean.Parser.Term.app">
                <OtherNode start="(295, 78)" end="(295, 97)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(295, 78)" end="(295, 94)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(295, 78)" end="(295, 79)" leading="" trailing="" val="("/>
                    <OtherNode start="(295, 79)" end="(295, 93)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(295, 79)" end="(295, 91)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(295, 92)" end="(295, 93)">
                        <IdentNode start="(295, 92)" end="(295, 93)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(295, 93)" end="(295, 94)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(295, 94)" end="(295, 95)" leading="" trailing="" val="."/>
                  <IdentNode start="(295, 95)" end="(295, 97)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(295, 98)" end="(295, 114)">
                  <OtherNode start="(295, 98)" end="(295, 114)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(295, 98)" end="(295, 99)" leading="" trailing="" val="("/>
                    <OtherNode start="(295, 99)" end="(295, 113)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(295, 99)" end="(295, 111)" leading="" trailing=" " raw_val="ys.findSome?" val="ys.findSome?"/>
                      <NullNode start="(295, 112)" end="(295, 113)">
                        <IdentNode start="(295, 112)" end="(295, 113)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(295, 113)" end="(295, 114)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(295, 115)" end="(300, 19)">
          <AtomNode start="(295, 115)" end="(295, 117)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(295, 118)" end="(300, 19)">
            <AtomNode start="(295, 118)" end="(295, 120)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(296, 3)" end="(300, 19)">
              <TacticTacticseq1IndentedNode start="(296, 3)" end="(300, 19)">
                <NullNode start="(296, 3)" end="(300, 19)">
                  <OtherNode start="(296, 3)" end="(300, 19)" kind="Lean.Parser.Tactic.induction" state_before="α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;xs ys : List α&#10;⊢ findSome? f (xs ++ ys) = (findSome? f xs).or (findSome? f ys)" state_after="no goals" tactic="induction xs with&#10;| nil =&amp;gt; simp [findSome?]&#10;| cons x xs ih =&amp;gt;&#10;  simp only [cons_append, findSome?_cons, ih]&#10;  split &amp;lt;;&amp;gt; simp">
                    <AtomNode start="(296, 3)" end="(296, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(296, 13)" end="(296, 15)">
                      <OtherNode start="(296, 13)" end="(296, 15)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(296, 13)" end="(296, 15)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(296, 16)" end="(300, 19)">
                      <OtherNode start="(296, 16)" end="(300, 19)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(296, 16)" end="(296, 20)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(297, 3)" end="(300, 19)">
                          <OtherNode start="(297, 3)" end="(297, 28)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(297, 3)" end="(297, 8)">
                              <OtherNode start="(297, 3)" end="(297, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(297, 3)" end="(297, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(297, 5)" end="(297, 8)">
                                  <NullNode/>
                                  <IdentNode start="(297, 5)" end="(297, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(297, 9)" end="(297, 28)">
                              <AtomNode start="(297, 9)" end="(297, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(297, 12)" end="(297, 28)">
                                <TacticTacticseq1IndentedNode start="(297, 12)" end="(297, 28)">
                                  <NullNode start="(297, 12)" end="(297, 28)">
                                    <OtherNode start="(297, 12)" end="(297, 28)" kind="Lean.Parser.Tactic.simp" state_before="case nil&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : List α&#10;⊢ findSome? f ([] ++ ys) = (findSome? f []).or (findSome? f ys)" state_after="no goals" tactic="simp [findSome?]">
                                      <AtomNode start="(297, 12)" end="(297, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(297, 17)" end="(297, 28)">
                                        <AtomNode start="(297, 17)" end="(297, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(297, 18)" end="(297, 27)">
                                          <OtherNode start="(297, 18)" end="(297, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(297, 18)" end="(297, 27)" leading="" trailing="" raw_val="findSome?" val="findSome?" full_name="List.findSome?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(297, 27)" end="(297, 28)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(298, 3)" end="(300, 19)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(298, 3)" end="(298, 17)">
                              <OtherNode start="(298, 3)" end="(298, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(298, 3)" end="(298, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(298, 5)" end="(298, 9)">
                                  <NullNode/>
                                  <IdentNode start="(298, 5)" end="(298, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(298, 10)" end="(298, 17)">
                                  <IdentNode start="(298, 10)" end="(298, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(298, 12)" end="(298, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(298, 15)" end="(298, 17)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(298, 18)" end="(300, 19)">
                              <AtomNode start="(298, 18)" end="(298, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(299, 5)" end="(300, 19)">
                                <TacticTacticseq1IndentedNode start="(299, 5)" end="(300, 19)">
                                  <NullNode start="(299, 5)" end="(300, 19)">
                                    <OtherNode start="(299, 5)" end="(299, 48)" kind="Lean.Parser.Tactic.simp" state_before="case cons&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : List α&#10;x : α&#10;xs : List α&#10;ih : findSome? f (xs ++ ys) = (findSome? f xs).or (findSome? f ys)&#10;⊢ findSome? f (x :: xs ++ ys) = (findSome? f (x :: xs)).or (findSome? f ys)" state_after="case cons&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : List α&#10;x : α&#10;xs : List α&#10;ih : findSome? f (xs ++ ys) = (findSome? f xs).or (findSome? f ys)&#10;⊢ (match f x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; (findSome? f xs).or (findSome? f ys)) =&#10;    (match f x with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f xs).or&#10;      (findSome? f ys)" tactic="simp only [cons_append, findSome?_cons, ih]">
                                      <AtomNode start="(299, 5)" end="(299, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(299, 10)" end="(299, 14)">
                                        <AtomNode start="(299, 10)" end="(299, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(299, 15)" end="(299, 48)">
                                        <AtomNode start="(299, 15)" end="(299, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(299, 16)" end="(299, 47)">
                                          <OtherNode start="(299, 16)" end="(299, 27)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(299, 16)" end="(299, 27)" leading="" trailing="" raw_val="cons_append" val="cons_append" full_name="List.cons_append" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(299, 27)" end="(299, 28)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(299, 29)" end="(299, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(299, 29)" end="(299, 43)" leading="" trailing="" raw_val="findSome?_cons" val="findSome?_cons" full_name="List.findSome?_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(299, 43)" end="(299, 44)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(299, 45)" end="(299, 47)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(299, 45)" end="(299, 47)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(299, 47)" end="(299, 48)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(300, 5)" end="(300, 19)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case cons&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : List α&#10;x : α&#10;xs : List α&#10;ih : findSome? f (xs ++ ys) = (findSome? f xs).or (findSome? f ys)&#10;⊢ (match f x with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; (findSome? f xs).or (findSome? f ys)) =&#10;    (match f x with&#10;        | some b =&amp;gt; some b&#10;        | none =&amp;gt; findSome? f xs).or&#10;      (findSome? f ys)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp">
                                      <OtherNode start="(300, 5)" end="(300, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(300, 5)" end="(300, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(300, 11)" end="(300, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(300, 15)" end="(300, 19)" kind="Lean.Parser.Tactic.simp">
                                        <AtomNode start="(300, 15)" end="(300, 19)" leading="" trailing="&#10;&#10;" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(302, 1)" end="(309, 23)" name="findSomeRev?_eq_findSomeRev?TR" full_name="List.findSomeRev?_eq_findSomeRev?TR">
      <CommandDeclmodifiersNode start="(302, 1)" end="(302, 9)">
        <NullNode/>
        <NullNode start="(302, 1)" end="(302, 9)">
          <OtherNode start="(302, 1)" end="(302, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(302, 1)" end="(302, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(302, 3)" end="(302, 8)">
              <OtherNode start="(302, 3)" end="(302, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(302, 3)" end="(302, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(302, 3)" end="(302, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(302, 8)" end="(302, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(302, 10)" end="(309, 23)" name="findSomeRev?_eq_findSomeRev?TR" full_name="List.findSomeRev?_eq_findSomeRev?TR" _is_private_decl="False">
        <AtomNode start="(302, 10)" end="(302, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(302, 18)" end="(302, 48)">
          <IdentNode start="(302, 18)" end="(302, 48)" leading="" trailing=" " raw_val="findSomeRev?_eq_findSomeRev?TR" val="findSomeRev?_eq_findSomeRev?TR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(302, 49)" end="(302, 92)">
          <NullNode/>
          <TermTypespecNode start="(302, 49)" end="(302, 92)">
            <AtomNode start="(302, 49)" end="(302, 50)" leading="" trailing=" " val=":"/>
            <OtherNode start="(302, 51)" end="(302, 92)" kind="«term_=_»">
              <OtherNode start="(302, 51)" end="(302, 69)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(302, 51)" end="(302, 52)" leading="" trailing="" val="@"/>
                <IdentNode start="(302, 52)" end="(302, 69)" leading="" trailing=" " raw_val="List.findSomeRev?" val="List.findSomeRev?" full_name="List.findSomeRev?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(302, 70)" end="(302, 71)" leading="" trailing=" " val="="/>
              <OtherNode start="(302, 72)" end="(302, 92)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(302, 72)" end="(302, 73)" leading="" trailing="" val="@"/>
                <IdentNode start="(302, 73)" end="(302, 92)" leading="" trailing=" " raw_val="List.findSomeRev?TR" val="List.findSomeRev?TR" full_name="List.findSomeRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(288, 5)" def_end="(288, 19)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(302, 93)" end="(309, 23)">
          <AtomNode start="(302, 93)" end="(302, 95)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(302, 96)" end="(309, 23)">
            <AtomNode start="(302, 96)" end="(302, 98)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(303, 3)" end="(309, 23)">
              <TacticTacticseq1IndentedNode start="(303, 3)" end="(309, 23)">
                <NullNode start="(303, 3)" end="(309, 23)">
                  <OtherNode start="(303, 3)" end="(303, 15)" kind="Lean.Parser.Tactic.apply" state_before="⊢ @findSomeRev? = @findSomeRev?TR" state_after="case h&#10;&#10;⊢ ∀ (x : Type u_2), @findSomeRev? x = @findSomeRev?TR x" tactic="apply funext">
                    <AtomNode start="(303, 3)" end="(303, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(303, 9)" end="(303, 15)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(303, 15)" end="(303, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 17)" end="(303, 24)" kind="Lean.Parser.Tactic.intro" state_before="case h&#10;&#10;⊢ ∀ (x : Type u_2), @findSomeRev? x = @findSomeRev?TR x" state_after="case h&#10;α : Type u_2&#10;⊢ @findSomeRev? α = @findSomeRev?TR α" tactic="intro α">
                    <AtomNode start="(303, 17)" end="(303, 22)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(303, 23)" end="(303, 24)">
                      <IdentNode start="(303, 23)" end="(303, 24)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(303, 24)" end="(303, 25)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 26)" end="(303, 38)" kind="Lean.Parser.Tactic.apply" state_before="case h&#10;α : Type u_2&#10;⊢ @findSomeRev? α = @findSomeRev?TR α" state_after="case h.h&#10;α : Type u_2&#10;⊢ ∀ (x : Type u_1), findSomeRev? = findSomeRev?TR" tactic="apply funext">
                    <AtomNode start="(303, 26)" end="(303, 31)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(303, 32)" end="(303, 38)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(303, 38)" end="(303, 39)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 40)" end="(303, 47)" kind="Lean.Parser.Tactic.intro" state_before="case h.h&#10;α : Type u_2&#10;⊢ ∀ (x : Type u_1), findSomeRev? = findSomeRev?TR" state_after="case h.h&#10;α : Type u_2&#10;β : Type u_1&#10;⊢ findSomeRev? = findSomeRev?TR" tactic="intro β">
                    <AtomNode start="(303, 40)" end="(303, 45)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(303, 46)" end="(303, 47)">
                      <IdentNode start="(303, 46)" end="(303, 47)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(303, 47)" end="(303, 48)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 49)" end="(303, 61)" kind="Lean.Parser.Tactic.apply" state_before="case h.h&#10;α : Type u_2&#10;β : Type u_1&#10;⊢ findSomeRev? = findSomeRev?TR" state_after="case h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;⊢ ∀ (x : α → Option β), findSomeRev? x = findSomeRev?TR x" tactic="apply funext">
                    <AtomNode start="(303, 49)" end="(303, 54)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(303, 55)" end="(303, 61)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(303, 61)" end="(303, 62)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 63)" end="(303, 70)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;⊢ ∀ (x : α → Option β), findSomeRev? x = findSomeRev?TR x" state_after="case h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;⊢ findSomeRev? p = findSomeRev?TR p" tactic="intro p">
                    <AtomNode start="(303, 63)" end="(303, 68)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(303, 69)" end="(303, 70)">
                      <IdentNode start="(303, 69)" end="(303, 70)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(303, 70)" end="(303, 71)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 72)" end="(303, 84)" kind="Lean.Parser.Tactic.apply" state_before="case h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;⊢ findSomeRev? p = findSomeRev?TR p" state_after="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;⊢ ∀ (x : List α), findSomeRev? p x = findSomeRev?TR p x" tactic="apply funext">
                    <AtomNode start="(303, 72)" end="(303, 77)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(303, 78)" end="(303, 84)" leading="" trailing="" raw_val="funext" val="funext" full_name="funext" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                  </OtherNode>
                  <AtomNode start="(303, 84)" end="(303, 85)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(303, 86)" end="(303, 93)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;⊢ ∀ (x : List α), findSomeRev? p x = findSomeRev?TR p x" state_after="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;l : List α&#10;⊢ findSomeRev? p l = findSomeRev?TR p l" tactic="intro l">
                    <AtomNode start="(303, 86)" end="(303, 91)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(303, 92)" end="(303, 93)">
                      <IdentNode start="(303, 92)" end="(303, 93)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(304, 3)" end="(309, 23)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h.h&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;l : List α&#10;⊢ findSomeRev? p l = findSomeRev?TR p l" state_after="no goals" tactic="induction l with&#10;| nil =&amp;gt; simp [findSomeRev?, findSomeRev?TR]&#10;| cons x l ih =&amp;gt;&#10;  simp only [findSomeRev?, ih, findSomeRev?TR, reverse_cons, findSome?_append,&#10;    findSome?_singleton]&#10;  split &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(304, 3)" end="(304, 12)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(304, 13)" end="(304, 14)">
                      <OtherNode start="(304, 13)" end="(304, 14)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(304, 13)" end="(304, 14)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(304, 15)" end="(309, 23)">
                      <OtherNode start="(304, 15)" end="(309, 23)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(304, 15)" end="(304, 19)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(305, 3)" end="(309, 23)">
                          <OtherNode start="(305, 3)" end="(305, 47)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(305, 3)" end="(305, 8)">
                              <OtherNode start="(305, 3)" end="(305, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(305, 3)" end="(305, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(305, 5)" end="(305, 8)">
                                  <NullNode/>
                                  <IdentNode start="(305, 5)" end="(305, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(305, 9)" end="(305, 47)">
                              <AtomNode start="(305, 9)" end="(305, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(305, 12)" end="(305, 47)">
                                <TacticTacticseq1IndentedNode start="(305, 12)" end="(305, 47)">
                                  <NullNode start="(305, 12)" end="(305, 47)">
                                    <OtherNode start="(305, 12)" end="(305, 47)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.nil&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;⊢ findSomeRev? p [] = findSomeRev?TR p []" state_after="no goals" tactic="simp [findSomeRev?, findSomeRev?TR]">
                                      <AtomNode start="(305, 12)" end="(305, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(305, 17)" end="(305, 47)">
                                        <AtomNode start="(305, 17)" end="(305, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(305, 18)" end="(305, 46)">
                                          <OtherNode start="(305, 18)" end="(305, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(305, 18)" end="(305, 30)" leading="" trailing="" raw_val="findSomeRev?" val="findSomeRev?" full_name="List.findSomeRev?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(305, 30)" end="(305, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(305, 32)" end="(305, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(305, 32)" end="(305, 46)" leading="" trailing="" raw_val="findSomeRev?TR" val="findSomeRev?TR" full_name="List.findSomeRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(288, 5)" def_end="(288, 19)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(305, 46)" end="(305, 47)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(306, 3)" end="(309, 23)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(306, 3)" end="(306, 16)">
                              <OtherNode start="(306, 3)" end="(306, 16)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(306, 3)" end="(306, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(306, 5)" end="(306, 9)">
                                  <NullNode/>
                                  <IdentNode start="(306, 5)" end="(306, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(306, 10)" end="(306, 16)">
                                  <IdentNode start="(306, 10)" end="(306, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(306, 12)" end="(306, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <IdentNode start="(306, 14)" end="(306, 16)" leading="" trailing=" " raw_val="ih" val="ih"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(306, 17)" end="(309, 23)">
                              <AtomNode start="(306, 17)" end="(306, 19)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(307, 5)" end="(309, 23)">
                                <TacticTacticseq1IndentedNode start="(307, 5)" end="(309, 23)">
                                  <NullNode start="(307, 5)" end="(309, 23)">
                                    <OtherNode start="(307, 5)" end="(308, 27)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.cons&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;x : α&#10;l : List α&#10;ih : findSomeRev? p l = findSomeRev?TR p l&#10;⊢ findSomeRev? p (x :: l) = findSomeRev?TR p (x :: l)" state_after="case h.h.h.h.cons&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;x : α&#10;l : List α&#10;ih : findSomeRev? p l = findSomeRev?TR p l&#10;⊢ (match findSome? p l.reverse with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; p x) =&#10;    (findSome? p l.reverse).or (p x)" tactic="simp only [findSomeRev?, ih, findSomeRev?TR, reverse_cons, findSome?_append,&#10;  findSome?_singleton]">
                                      <AtomNode start="(307, 5)" end="(307, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(307, 10)" end="(307, 14)">
                                        <AtomNode start="(307, 10)" end="(307, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(307, 15)" end="(308, 27)">
                                        <AtomNode start="(307, 15)" end="(307, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(307, 16)" end="(308, 26)">
                                          <OtherNode start="(307, 16)" end="(307, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(307, 16)" end="(307, 28)" leading="" trailing="" raw_val="findSomeRev?" val="findSomeRev?" full_name="List.findSomeRev?" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(307, 28)" end="(307, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(307, 30)" end="(307, 32)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(307, 30)" end="(307, 32)" leading="" trailing="" raw_val="ih" val="ih"/>
                                          </OtherNode>
                                          <AtomNode start="(307, 32)" end="(307, 33)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(307, 34)" end="(307, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(307, 34)" end="(307, 48)" leading="" trailing="" raw_val="findSomeRev?TR" val="findSomeRev?TR" full_name="List.findSomeRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(288, 5)" def_end="(288, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(307, 48)" end="(307, 49)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(307, 50)" end="(307, 62)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(307, 50)" end="(307, 62)" leading="" trailing="" raw_val="reverse_cons" val="reverse_cons" full_name="List.reverse_cons" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(307, 62)" end="(307, 63)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(307, 64)" end="(307, 80)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(307, 64)" end="(307, 80)" leading="" trailing="" raw_val="findSome?_append" val="findSome?_append" full_name="List.findSome?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(295, 17)" def_end="(295, 33)"/>
                                          </OtherNode>
                                          <AtomNode start="(307, 80)" end="(307, 81)" leading="" trailing="&#10;      " val=","/>
                                          <OtherNode start="(308, 7)" end="(308, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(308, 7)" end="(308, 26)" leading="" trailing="" raw_val="findSome?_singleton" val="findSome?_singleton" full_name="List.findSome?_singleton" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(290, 17)" def_end="(290, 36)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(308, 26)" end="(308, 27)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(309, 5)" end="(309, 23)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.h.cons&#10;α : Type u_2&#10;β : Type u_1&#10;p : α → Option β&#10;x : α&#10;l : List α&#10;ih : findSomeRev? p l = findSomeRev?TR p l&#10;⊢ (match findSome? p l.reverse with&#10;    | some b =&amp;gt; some b&#10;    | none =&amp;gt; p x) =&#10;    (findSome? p l.reverse).or (p x)" state_after="no goals" tactic="split &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(309, 5)" end="(309, 10)" kind="Lean.Parser.Tactic.split">
                                        <AtomNode start="(309, 5)" end="(309, 10)" leading="" trailing=" " val="split"/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                      <AtomNode start="(309, 11)" end="(309, 14)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                      <OtherNode start="(309, 15)" end="(309, 23)" kind="Lean.Parser.Tactic.simpAll">
                                        <AtomNode start="(309, 15)" end="(309, 23)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(311, 1)" end="(313, 56)" name="findSomeRev?_eq_findSome?_reverse" full_name="List.findSomeRev?_eq_findSome?_reverse">
      <CommandDeclmodifiersNode start="(311, 1)" end="(311, 8)">
        <NullNode/>
        <NullNode start="(311, 1)" end="(311, 8)">
          <OtherNode start="(311, 1)" end="(311, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(311, 1)" end="(311, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(311, 3)" end="(311, 7)">
              <OtherNode start="(311, 3)" end="(311, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(311, 3)" end="(311, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(311, 3)" end="(311, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(311, 7)" end="(311, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(311, 9)" end="(313, 56)" name="findSomeRev?_eq_findSome?_reverse" full_name="List.findSomeRev?_eq_findSome?_reverse" _is_private_decl="False">
        <AtomNode start="(311, 9)" end="(311, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(311, 17)" end="(311, 50)">
          <IdentNode start="(311, 17)" end="(311, 50)" leading="" trailing=" " raw_val="findSomeRev?_eq_findSome?_reverse" val="findSomeRev?_eq_findSome?_reverse"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(311, 51)" end="(312, 45)">
          <NullNode start="(311, 51)" end="(311, 82)">
            <OtherNode start="(311, 51)" end="(311, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(311, 51)" end="(311, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(311, 52)" end="(311, 53)">
                <IdentNode start="(311, 52)" end="(311, 53)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(311, 54)" end="(311, 62)">
                <AtomNode start="(311, 54)" end="(311, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 56)" end="(311, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(311, 56)" end="(311, 60)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(311, 61)" end="(311, 62)">
                    <IdentNode start="(311, 61)" end="(311, 62)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(311, 62)" end="(311, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(311, 64)" end="(311, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(311, 64)" end="(311, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(311, 65)" end="(311, 66)">
                <IdentNode start="(311, 65)" end="(311, 66)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(311, 67)" end="(311, 81)">
                <AtomNode start="(311, 67)" end="(311, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 69)" end="(311, 81)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(311, 69)" end="(311, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(311, 71)" end="(311, 72)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(311, 73)" end="(311, 81)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(311, 73)" end="(311, 79)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(311, 80)" end="(311, 81)">
                      <IdentNode start="(311, 80)" end="(311, 81)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(311, 81)" end="(311, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(311, 83)" end="(312, 45)">
            <AtomNode start="(311, 83)" end="(311, 84)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(312, 5)" end="(312, 45)" kind="«term_=_»">
              <OtherNode start="(312, 5)" end="(312, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(312, 5)" end="(312, 19)" leading="" trailing=" " raw_val="l.findSomeRev?" val="l.findSomeRev?"/>
                <NullNode start="(312, 20)" end="(312, 21)">
                  <IdentNode start="(312, 20)" end="(312, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(312, 22)" end="(312, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(312, 24)" end="(312, 45)" kind="Lean.Parser.Term.app">
                <IdentNode start="(312, 24)" end="(312, 43)" leading="" trailing=" " raw_val="l.reverse.findSome?" val="l.reverse.findSome?"/>
                <NullNode start="(312, 44)" end="(312, 45)">
                  <IdentNode start="(312, 44)" end="(312, 45)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(312, 46)" end="(313, 56)">
          <AtomNode start="(312, 46)" end="(312, 48)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(312, 49)" end="(313, 56)">
            <AtomNode start="(312, 49)" end="(312, 51)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(313, 3)" end="(313, 56)">
              <TacticTacticseq1IndentedNode start="(313, 3)" end="(313, 56)">
                <NullNode start="(313, 3)" end="(313, 56)">
                  <OtherNode start="(313, 3)" end="(313, 56)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;l : List α&#10;f : α → Option β&#10;⊢ findSomeRev? f l = findSome? f l.reverse" state_after="no goals" tactic="simp [findSomeRev?_eq_findSomeRev?TR, findSomeRev?TR]">
                    <AtomNode start="(313, 3)" end="(313, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(313, 8)" end="(313, 56)">
                      <AtomNode start="(313, 8)" end="(313, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(313, 9)" end="(313, 55)">
                        <OtherNode start="(313, 9)" end="(313, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(313, 9)" end="(313, 39)" leading="" trailing="" raw_val="findSomeRev?_eq_findSomeRev?TR" val="findSomeRev?_eq_findSomeRev?TR" full_name="List.findSomeRev?_eq_findSomeRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(302, 18)" def_end="(302, 48)"/>
                        </OtherNode>
                        <AtomNode start="(313, 39)" end="(313, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(313, 41)" end="(313, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(313, 41)" end="(313, 55)" leading="" trailing="" raw_val="findSomeRev?TR" val="findSomeRev?TR" full_name="List.findSomeRev?TR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(288, 5)" def_end="(288, 19)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(313, 55)" end="(313, 56)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(315, 1)" end="(315, 32)" comment="## Manipulating elements -/">
      <AtomNode start="(315, 1)" end="(315, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(315, 5)" end="(315, 32)" leading="" trailing="&#10;&#10;" val="## Manipulating elements -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(317, 1)" end="(317, 19)" comment="### replace -/">
      <AtomNode start="(317, 1)" end="(317, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(317, 5)" end="(317, 19)" leading="" trailing="&#10;&#10;" val="### replace -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(319, 1)" end="(334, 83)" name="replaceTR" full_name="List.replaceTR">
      <CommandDeclmodifiersNode start="(319, 1)" end="(329, 10)">
        <NullNode start="(319, 1)" end="(328, 3)">
          <CommandDoccommentNode start="(319, 1)" end="(328, 3)" comment="Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to&#10;`a`, then the list is returned unchanged.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.replace` that's used in runtime code.&#10;&#10;Examples:&#10;* `[1, 4, 2, 3, 3, 7].replaceTR 3 6 = [1, 4, 2, 6, 3, 7]`&#10;* `[1, 4, 2, 3, 3, 7].replaceTR 5 6 = [1, 4, 2, 3, 3, 7]`&#10;-/">
            <AtomNode start="(319, 1)" end="(319, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(320, 1)" end="(328, 3)" leading="" trailing="&#10;" val="Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to&#10;`a`, then the list is returned unchanged.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.replace` that's used in runtime code.&#10;&#10;Examples:&#10;* `[1, 4, 2, 3, 3, 7].replaceTR 3 6 = [1, 4, 2, 6, 3, 7]`&#10;* `[1, 4, 2, 3, 3, 7].replaceTR 5 6 = [1, 4, 2, 3, 3, 7]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(329, 1)" end="(329, 10)">
          <OtherNode start="(329, 1)" end="(329, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(329, 1)" end="(329, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(329, 3)" end="(329, 9)">
              <OtherNode start="(329, 3)" end="(329, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(329, 3)" end="(329, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(329, 3)" end="(329, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(329, 9)" end="(329, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(329, 11)" end="(334, 83)" name="replaceTR">
        <AtomNode start="(329, 11)" end="(329, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(329, 15)" end="(329, 24)">
          <IdentNode start="(329, 15)" end="(329, 24)" leading="" trailing=" " raw_val="replaceTR" val="replaceTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(329, 25)" end="(329, 64)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(329, 25)" end="(329, 55)">
            <OtherNode start="(329, 25)" end="(329, 32)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(329, 25)" end="(329, 26)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(329, 26)" end="(329, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(329, 26)" end="(329, 29)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(329, 30)" end="(329, 31)">
                  <IdentNode start="(329, 30)" end="(329, 31)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(329, 31)" end="(329, 32)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(329, 33)" end="(329, 45)">
              <AtomNode start="(329, 33)" end="(329, 34)" leading="" trailing="" val="("/>
              <NullNode start="(329, 34)" end="(329, 35)">
                <IdentNode start="(329, 34)" end="(329, 35)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(329, 36)" end="(329, 44)">
                <AtomNode start="(329, 36)" end="(329, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(329, 38)" end="(329, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(329, 38)" end="(329, 42)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(329, 43)" end="(329, 44)">
                    <IdentNode start="(329, 43)" end="(329, 44)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(329, 44)" end="(329, 45)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(329, 46)" end="(329, 55)">
              <AtomNode start="(329, 46)" end="(329, 47)" leading="" trailing="" val="("/>
              <NullNode start="(329, 47)" end="(329, 50)">
                <IdentNode start="(329, 47)" end="(329, 48)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(329, 49)" end="(329, 50)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(329, 51)" end="(329, 54)">
                <AtomNode start="(329, 51)" end="(329, 52)" leading="" trailing=" " val=":"/>
                <IdentNode start="(329, 53)" end="(329, 54)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(329, 54)" end="(329, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(329, 56)" end="(329, 64)">
            <TermTypespecNode start="(329, 56)" end="(329, 64)">
              <AtomNode start="(329, 56)" end="(329, 57)" leading="" trailing=" " val=":"/>
              <OtherNode start="(329, 58)" end="(329, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(329, 58)" end="(329, 62)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(329, 63)" end="(329, 64)">
                  <IdentNode start="(329, 63)" end="(329, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(329, 65)" end="(334, 83)">
          <AtomNode start="(329, 65)" end="(329, 67)" leading="" trailing=" " val=":="/>
          <OtherNode start="(329, 68)" end="(329, 76)" kind="Lean.Parser.Term.app">
            <IdentNode start="(329, 68)" end="(329, 70)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(329, 71)" end="(329, 76)">
              <IdentNode start="(329, 71)" end="(329, 72)" leading="" trailing=" " raw_val="l" val="l"/>
              <OtherNode start="(329, 73)" end="(329, 76)" kind="«term#[_,]»">
                <AtomNode start="(329, 73)" end="(329, 75)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(329, 75)" end="(329, 76)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(329, 77)" end="(334, 83)">
            <OtherNode start="(329, 77)" end="(334, 83)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(329, 77)" end="(329, 82)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(330, 3)" end="(334, 83)">
                <OtherNode start="(330, 3)" end="(334, 83)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(330, 3)" end="(331, 67)">
                    <CommandDoccommentNode start="(330, 3)" end="(331, 67)" comment="Auxiliary for `replace`: `replace.go l b c xs acc = acc.toList ++ replace xs b c`,&#10;  unless `b` is not found in `xs` in which case it returns `l`. -/">
                      <AtomNode start="(330, 3)" end="(330, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(330, 7)" end="(331, 67)" leading="" trailing="&#10;  " val="Auxiliary for `replace`: `replace.go l b c xs acc = acc.toList ++ replace xs b c`,&#10;  unless `b` is not found in `xs` in which case it returns `l`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(332, 3)" end="(332, 16)">
                    <OtherNode start="(332, 3)" end="(332, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(332, 3)" end="(332, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(332, 5)" end="(332, 15)">
                        <OtherNode start="(332, 5)" end="(332, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(332, 5)" end="(332, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(332, 5)" end="(332, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(332, 15)" end="(332, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(332, 17)" end="(334, 83)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(332, 17)" end="(334, 83)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(332, 17)" end="(332, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(332, 20)" end="(332, 47)">
                        <TermTypespecNode start="(332, 20)" end="(332, 47)">
                          <AtomNode start="(332, 20)" end="(332, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(332, 22)" end="(332, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(332, 22)" end="(332, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(332, 22)" end="(332, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(332, 27)" end="(332, 28)">
                                <IdentNode start="(332, 27)" end="(332, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(332, 29)" end="(332, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(332, 31)" end="(332, 47)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(332, 31)" end="(332, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(332, 31)" end="(332, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(332, 37)" end="(332, 38)">
                                  <IdentNode start="(332, 37)" end="(332, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(332, 39)" end="(332, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(332, 41)" end="(332, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(332, 41)" end="(332, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(332, 46)" end="(332, 47)">
                                  <IdentNode start="(332, 46)" end="(332, 47)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(333, 3)" end="(334, 83)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(333, 3)" end="(334, 83)">
                          <OtherNode start="(333, 3)" end="(333, 15)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(333, 3)" end="(333, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(333, 5)" end="(333, 10)">
                              <NullNode start="(333, 5)" end="(333, 10)">
                                <OtherNode start="(333, 5)" end="(333, 7)" kind="«term[_]»">
                                  <AtomNode start="(333, 5)" end="(333, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(333, 6)" end="(333, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(333, 7)" end="(333, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(333, 9)" end="(333, 10)">
                                  <AtomNode start="(333, 9)" end="(333, 10)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(333, 11)" end="(333, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(333, 14)" end="(333, 15)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(334, 3)" end="(334, 83)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(334, 3)" end="(334, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(334, 5)" end="(334, 15)">
                              <NullNode start="(334, 5)" end="(334, 15)">
                                <OtherNode start="(334, 5)" end="(334, 10)" kind="«term_::_»">
                                  <IdentNode start="(334, 5)" end="(334, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(334, 6)" end="(334, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(334, 8)" end="(334, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(334, 10)" end="(334, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(334, 12)" end="(334, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(334, 16)" end="(334, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(334, 19)" end="(334, 83)" kind="boolIfThenElse">
                              <AtomNode start="(334, 19)" end="(334, 22)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(334, 23)" end="(334, 29)" kind="«term_==_»">
                                <IdentNode start="(334, 23)" end="(334, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                                <AtomNode start="(334, 25)" end="(334, 27)" leading="" trailing=" " val="=="/>
                                <IdentNode start="(334, 28)" end="(334, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                              </OtherNode>
                              <AtomNode start="(334, 30)" end="(334, 34)" leading="" trailing=" " val="then"/>
                              <OtherNode start="(334, 35)" end="(334, 59)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(334, 35)" end="(334, 51)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                                <NullNode start="(334, 52)" end="(334, 59)">
                                  <OtherNode start="(334, 52)" end="(334, 59)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(334, 52)" end="(334, 53)" leading="" trailing="" val="("/>
                                    <OtherNode start="(334, 53)" end="(334, 58)" kind="«term_::_»">
                                      <IdentNode start="(334, 53)" end="(334, 54)" leading="" trailing="" raw_val="c" val="c"/>
                                      <AtomNode start="(334, 54)" end="(334, 56)" leading="" trailing="" val="::"/>
                                      <IdentNode start="(334, 56)" end="(334, 58)" leading="" trailing="" raw_val="as" val="as"/>
                                    </OtherNode>
                                    <AtomNode start="(334, 58)" end="(334, 59)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(334, 60)" end="(334, 64)" leading="" trailing=" " val="else"/>
                              <OtherNode start="(334, 65)" end="(334, 83)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(334, 65)" end="(334, 67)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(334, 68)" end="(334, 83)">
                                  <IdentNode start="(334, 68)" end="(334, 70)" leading="" trailing=" " raw_val="as" val="as"/>
                                  <OtherNode start="(334, 71)" end="(334, 83)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(334, 71)" end="(334, 72)" leading="" trailing="" val="("/>
                                    <OtherNode start="(334, 72)" end="(334, 82)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(334, 72)" end="(334, 80)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                      <NullNode start="(334, 81)" end="(334, 82)">
                                        <IdentNode start="(334, 81)" end="(334, 82)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(334, 82)" end="(334, 83)" leading="" trailing="&#10;&#10;" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(336, 1)" end="(347, 36)" name="replace_eq_replaceTR" full_name="List.replace_eq_replaceTR">
      <CommandDeclmodifiersNode start="(336, 1)" end="(336, 9)">
        <NullNode/>
        <NullNode start="(336, 1)" end="(336, 9)">
          <OtherNode start="(336, 1)" end="(336, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(336, 1)" end="(336, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(336, 3)" end="(336, 8)">
              <OtherNode start="(336, 3)" end="(336, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(336, 3)" end="(336, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(336, 3)" end="(336, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(336, 8)" end="(336, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(336, 10)" end="(347, 36)" name="replace_eq_replaceTR" full_name="List.replace_eq_replaceTR" _is_private_decl="False">
        <AtomNode start="(336, 10)" end="(336, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(336, 18)" end="(336, 38)">
          <IdentNode start="(336, 18)" end="(336, 38)" leading="" trailing=" " raw_val="replace_eq_replaceTR" val="replace_eq_replaceTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(336, 39)" end="(336, 67)">
          <NullNode/>
          <TermTypespecNode start="(336, 39)" end="(336, 67)">
            <AtomNode start="(336, 39)" end="(336, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(336, 41)" end="(336, 67)" kind="«term_=_»">
              <OtherNode start="(336, 41)" end="(336, 54)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(336, 41)" end="(336, 42)" leading="" trailing="" val="@"/>
                <IdentNode start="(336, 42)" end="(336, 54)" leading="" trailing=" " raw_val="List.replace" val="List.replace" full_name="List.replace" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(336, 55)" end="(336, 56)" leading="" trailing=" " val="="/>
              <OtherNode start="(336, 57)" end="(336, 67)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(336, 57)" end="(336, 58)" leading="" trailing="" val="@"/>
                <IdentNode start="(336, 58)" end="(336, 67)" leading="" trailing=" " raw_val="replaceTR" val="replaceTR" full_name="List.replaceTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(329, 15)" def_end="(329, 24)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(336, 68)" end="(347, 36)">
          <AtomNode start="(336, 68)" end="(336, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(336, 71)" end="(347, 36)">
            <AtomNode start="(336, 71)" end="(336, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(337, 3)" end="(347, 36)">
              <TacticTacticseq1IndentedNode start="(337, 3)" end="(347, 36)">
                <NullNode start="(337, 3)" end="(347, 36)">
                  <OtherNode start="(337, 3)" end="(337, 19)" kind="tacticFunext___" state_before="⊢ @replace = @replaceTR" state_after="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;⊢ l.replace b c = l.replaceTR b c" tactic="funext α _ l b c">
                    <AtomNode start="(337, 3)" end="(337, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(337, 10)" end="(337, 19)">
                      <IdentNode start="(337, 10)" end="(337, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <TermHoleNode start="(337, 12)" end="(337, 13)">
                        <AtomNode start="(337, 12)" end="(337, 13)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <IdentNode start="(337, 14)" end="(337, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(337, 16)" end="(337, 17)" leading="" trailing=" " raw_val="b" val="b"/>
                      <IdentNode start="(337, 18)" end="(337, 19)" leading="" trailing="" raw_val="c" val="c"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(337, 19)" end="(337, 20)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(337, 21)" end="(337, 37)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;⊢ l.replace b c = l.replaceTR b c" state_after="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;⊢ l.replace b c = replaceTR.go l b c l #[]" tactic="simp [replaceTR]">
                    <AtomNode start="(337, 21)" end="(337, 25)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(337, 26)" end="(337, 37)">
                      <AtomNode start="(337, 26)" end="(337, 27)" leading="" trailing="" val="["/>
                      <NullNode start="(337, 27)" end="(337, 36)">
                        <OtherNode start="(337, 27)" end="(337, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(337, 27)" end="(337, 36)" leading="" trailing="" raw_val="replaceTR" val="replaceTR" full_name="List.replaceTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(329, 15)" def_end="(329, 24)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(337, 36)" end="(337, 37)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(338, 3)" end="(340, 32)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;⊢ l.replace b c = replaceTR.go l b c l #[]" state_after="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c" tactic="suffices ∀ xs acc, l = acc.toList ++ xs →&#10;    replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c from&#10;  (this l #[] (by simp)).symm">
                    <AtomNode start="(338, 3)" end="(338, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(338, 12)" end="(340, 32)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(338, 12)" end="(338, 12)" kind="hygieneInfo">
                        <IdentNode start="(338, 12)" end="(338, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(338, 12)" end="(339, 63)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(338, 12)" end="(338, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(338, 14)" end="(338, 20)">
                          <IdentNode start="(338, 14)" end="(338, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <IdentNode start="(338, 17)" end="(338, 20)" leading="" trailing="" raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(338, 20)" end="(338, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(338, 22)" end="(339, 63)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(338, 22)" end="(338, 42)" kind="«term_=_»">
                            <IdentNode start="(338, 22)" end="(338, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                            <AtomNode start="(338, 24)" end="(338, 25)" leading="" trailing=" " val="="/>
                            <OtherNode start="(338, 26)" end="(338, 42)" kind="«term_++_»">
                              <IdentNode start="(338, 26)" end="(338, 36)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(338, 37)" end="(338, 39)" leading="" trailing=" " val="++"/>
                              <IdentNode start="(338, 40)" end="(338, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(338, 43)" end="(338, 44)" leading="" trailing="&#10;      " val="→"/>
                          <OtherNode start="(339, 7)" end="(339, 63)" kind="«term_=_»">
                            <OtherNode start="(339, 7)" end="(339, 32)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(339, 7)" end="(339, 19)" leading="" trailing=" " raw_val="replaceTR.go" val="replaceTR.go" full_name="List.replaceTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(332, 17)" def_end="(332, 19)"/>
                              <NullNode start="(339, 20)" end="(339, 32)">
                                <IdentNode start="(339, 20)" end="(339, 21)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(339, 22)" end="(339, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                                <IdentNode start="(339, 24)" end="(339, 25)" leading="" trailing=" " raw_val="c" val="c"/>
                                <IdentNode start="(339, 26)" end="(339, 28)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(339, 29)" end="(339, 32)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(339, 33)" end="(339, 34)" leading="" trailing=" " val="="/>
                            <OtherNode start="(339, 35)" end="(339, 63)" kind="«term_++_»">
                              <IdentNode start="(339, 35)" end="(339, 45)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(339, 46)" end="(339, 48)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(339, 49)" end="(339, 63)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(339, 49)" end="(339, 59)" leading="" trailing=" " raw_val="xs.replace" val="xs.replace"/>
                                <NullNode start="(339, 60)" end="(339, 63)">
                                  <IdentNode start="(339, 60)" end="(339, 61)" leading="" trailing=" " raw_val="b" val="b"/>
                                  <IdentNode start="(339, 62)" end="(339, 63)" leading="" trailing=" " raw_val="c" val="c"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(339, 64)" end="(340, 32)" kind="Lean.Parser.Term.fromTerm">
                        <AtomNode start="(339, 64)" end="(339, 68)" leading="" trailing="&#10;    " val="from"/>
                        <OtherNode start="(340, 5)" end="(340, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(340, 5)" end="(340, 27)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(340, 5)" end="(340, 6)" leading="" trailing="" val="("/>
                            <OtherNode start="(340, 6)" end="(340, 26)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(340, 6)" end="(340, 10)" leading="" trailing=" " raw_val="this" val="this"/>
                              <NullNode start="(340, 11)" end="(340, 26)">
                                <IdentNode start="(340, 11)" end="(340, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(340, 13)" end="(340, 16)" kind="«term#[_,]»">
                                  <AtomNode start="(340, 13)" end="(340, 15)" leading="" trailing="" val="#["/>
                                  <NullNode/>
                                  <AtomNode start="(340, 15)" end="(340, 16)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                                <OtherNode start="(340, 17)" end="(340, 26)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(340, 17)" end="(340, 18)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(340, 18)" end="(340, 25)">
                                    <AtomNode start="(340, 18)" end="(340, 20)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(340, 21)" end="(340, 25)">
                                      <TacticTacticseq1IndentedNode start="(340, 21)" end="(340, 25)">
                                        <NullNode start="(340, 21)" end="(340, 25)">
                                          <OtherNode start="(340, 21)" end="(340, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;this : ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;⊢ l = #[].toList ++ l" state_after="no goals" tactic="simp">
                                            <AtomNode start="(340, 21)" end="(340, 25)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(340, 25)" end="(340, 26)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(340, 26)" end="(340, 27)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(340, 27)" end="(340, 28)" leading="" trailing="" val="."/>
                          <IdentNode start="(340, 28)" end="(340, 32)" leading="" trailing="&#10;  " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(341, 3)" end="(341, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c" state_after="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c" tactic="intro xs">
                    <AtomNode start="(341, 3)" end="(341, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(341, 9)" end="(341, 11)">
                      <IdentNode start="(341, 9)" end="(341, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(341, 11)" end="(341, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(341, 13)" end="(347, 36)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c" state_after="no goals" tactic="induction xs with intro acc&#10;| nil =&amp;gt; simp [replace, replaceTR.go]&#10;| cons x xs IH =&amp;gt;&#10;simp only [replaceTR.go, Array.toListAppend_eq, replace]&#10;split&#10;· simp [*]&#10;· intro h; rw [IH] &amp;lt;;&amp;gt; simp_all">
                    <AtomNode start="(341, 13)" end="(341, 22)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(341, 23)" end="(341, 25)">
                      <OtherNode start="(341, 23)" end="(341, 25)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(341, 23)" end="(341, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(341, 26)" end="(347, 36)">
                      <OtherNode start="(341, 26)" end="(347, 36)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(341, 26)" end="(341, 30)" leading="" trailing=" " val="with"/>
                        <NullNode start="(341, 31)" end="(341, 40)">
                          <OtherNode start="(341, 31)" end="(341, 40)" kind="Lean.Parser.Tactic.intro">
                            <AtomNode start="(341, 31)" end="(341, 36)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(341, 37)" end="(341, 40)">
                              <IdentNode start="(341, 37)" end="(341, 40)" leading="" trailing="&#10;  " raw_val="acc" val="acc"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(342, 3)" end="(347, 36)">
                          <OtherNode start="(342, 3)" end="(342, 40)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(342, 3)" end="(342, 8)">
                              <OtherNode start="(342, 3)" end="(342, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(342, 3)" end="(342, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(342, 5)" end="(342, 8)">
                                  <NullNode/>
                                  <IdentNode start="(342, 5)" end="(342, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(342, 9)" end="(342, 40)">
                              <AtomNode start="(342, 9)" end="(342, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(342, 12)" end="(342, 40)">
                                <TacticTacticseq1IndentedNode start="(342, 12)" end="(342, 40)">
                                  <NullNode start="(342, 12)" end="(342, 40)">
                                    <OtherNode start="(342, 12)" end="(342, 40)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.h.nil&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c : α&#10;acc : Array α&#10;⊢ l = acc.toList ++ [] → replaceTR.go l b c [] acc = acc.toList ++ [].replace b c" state_after="no goals" tactic="simp [replace, replaceTR.go]">
                                      <AtomNode start="(342, 12)" end="(342, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(342, 17)" end="(342, 40)">
                                        <AtomNode start="(342, 17)" end="(342, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(342, 18)" end="(342, 39)">
                                          <OtherNode start="(342, 18)" end="(342, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(342, 18)" end="(342, 25)" leading="" trailing="" raw_val="replace" val="replace" full_name="List.replace" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(342, 25)" end="(342, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(342, 27)" end="(342, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(342, 27)" end="(342, 39)" leading="" trailing="" raw_val="replaceTR.go" val="replaceTR.go" full_name="List.replaceTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(332, 17)" def_end="(332, 19)"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(342, 39)" end="(342, 40)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(343, 3)" end="(347, 36)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(343, 3)" end="(343, 17)">
                              <OtherNode start="(343, 3)" end="(343, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(343, 3)" end="(343, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(343, 5)" end="(343, 9)">
                                  <NullNode/>
                                  <IdentNode start="(343, 5)" end="(343, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(343, 10)" end="(343, 17)">
                                  <IdentNode start="(343, 10)" end="(343, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(343, 12)" end="(343, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(343, 15)" end="(343, 17)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(343, 18)" end="(347, 36)">
                              <AtomNode start="(343, 18)" end="(343, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(344, 5)" end="(347, 36)">
                                <TacticTacticseq1IndentedNode start="(344, 5)" end="(347, 36)">
                                  <NullNode start="(344, 5)" end="(347, 36)">
                                    <OtherNode start="(344, 5)" end="(344, 61)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.h.cons&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs → replaceTR.go l b c (x :: xs) acc = acc.toList ++ (x :: xs).replace b c" state_after="case h.h.h.h.h.cons&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) =&#10;      acc.toList ++&#10;        match b == x with&#10;        | true =&amp;gt; c :: xs&#10;        | false =&amp;gt; x :: xs.replace b c" tactic="simp only [replaceTR.go, Array.toListAppend_eq, replace]">
                                      <AtomNode start="(344, 5)" end="(344, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(344, 10)" end="(344, 14)">
                                        <AtomNode start="(344, 10)" end="(344, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(344, 15)" end="(344, 61)">
                                        <AtomNode start="(344, 15)" end="(344, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(344, 16)" end="(344, 60)">
                                          <OtherNode start="(344, 16)" end="(344, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(344, 16)" end="(344, 28)" leading="" trailing="" raw_val="replaceTR.go" val="replaceTR.go" full_name="List.replaceTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(332, 17)" def_end="(332, 19)"/>
                                          </OtherNode>
                                          <AtomNode start="(344, 28)" end="(344, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(344, 30)" end="(344, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(344, 30)" end="(344, 51)" leading="" trailing="" raw_val="Array.toListAppend_eq" val="Array.toListAppend_eq" full_name="Array.toListAppend_eq" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(344, 51)" end="(344, 52)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(344, 53)" end="(344, 60)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(344, 53)" end="(344, 60)" leading="" trailing="" raw_val="replace" val="replace" full_name="List.replace" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(344, 60)" end="(344, 61)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(345, 5)" end="(345, 10)" kind="Lean.Parser.Tactic.split" state_before="case h.h.h.h.h.cons&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) =&#10;      acc.toList ++&#10;        match b == x with&#10;        | true =&amp;gt; c :: xs&#10;        | false =&amp;gt; x :: xs.replace b c" state_after="case h.h.h.h.h.cons.h_1&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = true&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ c :: xs&#10;&#10;case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" tactic="split">
                                      <AtomNode start="(345, 5)" end="(345, 10)" leading="" trailing="&#10;    " val="split"/>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(346, 5)" end="(346, 15)" kind="Lean.cdot" state_before="case h.h.h.h.h.cons.h_1&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = true&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ c :: xs&#10;&#10;case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" state_after="case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" tactic="· simp [*]">
                                      <OtherNode start="(346, 5)" end="(346, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(346, 5)" end="(346, 6)" kind="patternIgnore">
                                          <OtherNode start="(346, 5)" end="(346, 6)" kind="token.«· »">
                                            <AtomNode start="(346, 5)" end="(346, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(346, 7)" end="(346, 15)">
                                        <TacticTacticseq1IndentedNode start="(346, 7)" end="(346, 15)">
                                          <NullNode start="(346, 7)" end="(346, 15)">
                                            <OtherNode start="(346, 7)" end="(346, 15)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.h.cons.h_1&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = true&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ c :: xs" state_after="no goals" tactic="simp [*]">
                                              <AtomNode start="(346, 7)" end="(346, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(346, 12)" end="(346, 15)">
                                                <AtomNode start="(346, 12)" end="(346, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(346, 13)" end="(346, 14)">
                                                  <OtherNode start="(346, 13)" end="(346, 14)" kind="Lean.Parser.Tactic.simpStar">
                                                    <AtomNode start="(346, 13)" end="(346, 14)" leading="" trailing="" val="*"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(346, 14)" end="(346, 15)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(347, 5)" end="(347, 36)" kind="Lean.cdot" state_before="case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" state_after="no goals" tactic="· intro h; rw [IH] &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(347, 5)" end="(347, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(347, 5)" end="(347, 6)" kind="patternIgnore">
                                          <OtherNode start="(347, 5)" end="(347, 6)" kind="token.«· »">
                                            <AtomNode start="(347, 5)" end="(347, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(347, 7)" end="(347, 36)">
                                        <TacticTacticseq1IndentedNode start="(347, 7)" end="(347, 36)">
                                          <NullNode start="(347, 7)" end="(347, 36)">
                                            <OtherNode start="(347, 7)" end="(347, 14)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" state_after="case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" tactic="intro h">
                                              <AtomNode start="(347, 7)" end="(347, 12)" leading="" trailing=" " val="intro"/>
                                              <NullNode start="(347, 13)" end="(347, 14)">
                                                <IdentNode start="(347, 13)" end="(347, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                              </NullNode>
                                            </OtherNode>
                                            <AtomNode start="(347, 14)" end="(347, 15)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(347, 16)" end="(347, 36)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.h.h.cons.h_2&#10;α : Type u_1&#10;x✝¹ : BEq α&#10;l : List α&#10;b c x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → replaceTR.go l b c xs acc = acc.toList ++ xs.replace b c&#10;acc : Array α&#10;x✝ : Bool&#10;heq✝ : (b == x) = false&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif b == x then acc.toList ++ c :: xs else replaceTR.go l b c xs (acc.push x)) = acc.toList ++ x :: xs.replace b c" state_after="no goals" tactic="rw [IH] &amp;lt;;&amp;gt; simp_all">
                                              <OtherNode start="(347, 16)" end="(347, 23)" kind="Lean.Parser.Tactic.rwSeq">
                                                <AtomNode start="(347, 16)" end="(347, 18)" leading="" trailing=" " val="rw"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <OtherNode start="(347, 19)" end="(347, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                  <AtomNode start="(347, 19)" end="(347, 20)" leading="" trailing="" val="["/>
                                                  <NullNode start="(347, 20)" end="(347, 22)">
                                                    <OtherNode start="(347, 20)" end="(347, 22)" kind="Lean.Parser.Tactic.rwRule">
                                                      <NullNode/>
                                                      <IdentNode start="(347, 20)" end="(347, 22)" leading="" trailing="" raw_val="IH" val="IH"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(347, 22)" end="(347, 23)" leading="" trailing=" " val="]"/>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(347, 24)" end="(347, 27)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(347, 28)" end="(347, 36)" kind="Lean.Parser.Tactic.simpAll">
                                                <AtomNode start="(347, 28)" end="(347, 36)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(349, 1)" end="(349, 18)" comment="### modify -/">
      <AtomNode start="(349, 1)" end="(349, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(349, 5)" end="(349, 18)" leading="" trailing="&#10;&#10;" val="### modify -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(351, 1)" end="(366, 44)" name="modifyTR" full_name="List.modifyTR">
      <CommandDeclmodifiersNode start="(351, 1)" end="(360, 3)">
        <NullNode start="(351, 1)" end="(360, 3)">
          <CommandDoccommentNode start="(351, 1)" end="(360, 3)" comment="Replaces the element at the given index, if it exists, with the result of applying `f` to it.&#10;&#10;This is a tail-recursive version of `List.modify`.&#10;&#10;Examples:&#10; * `[1, 2, 3].modifyTR 0 (· * 10) = [10, 2, 3]`&#10; * `[1, 2, 3].modifyTR 2 (· * 10) = [1, 2, 30]`&#10; * `[1, 2, 3].modifyTR 3 (· * 10) = [1, 2, 3]`&#10;-/">
            <AtomNode start="(351, 1)" end="(351, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(352, 1)" end="(360, 3)" leading="" trailing="&#10;" val="Replaces the element at the given index, if it exists, with the result of applying `f` to it.&#10;&#10;This is a tail-recursive version of `List.modify`.&#10;&#10;Examples:&#10; * `[1, 2, 3].modifyTR 0 (· * 10) = [10, 2, 3]`&#10; * `[1, 2, 3].modifyTR 2 (· * 10) = [1, 2, 30]`&#10; * `[1, 2, 3].modifyTR 3 (· * 10) = [1, 2, 3]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(361, 1)" end="(366, 44)" name="modifyTR">
        <AtomNode start="(361, 1)" end="(361, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(361, 5)" end="(361, 13)">
          <IdentNode start="(361, 5)" end="(361, 13)" leading="" trailing=" " raw_val="modifyTR" val="modifyTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(361, 14)" end="(361, 57)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(361, 14)" end="(361, 48)">
            <TermExplicitbinderNode start="(361, 14)" end="(361, 26)">
              <AtomNode start="(361, 14)" end="(361, 15)" leading="" trailing="" val="("/>
              <NullNode start="(361, 15)" end="(361, 16)">
                <IdentNode start="(361, 15)" end="(361, 16)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(361, 17)" end="(361, 25)">
                <AtomNode start="(361, 17)" end="(361, 18)" leading="" trailing=" " val=":"/>
                <OtherNode start="(361, 19)" end="(361, 25)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(361, 19)" end="(361, 23)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(361, 24)" end="(361, 25)">
                    <IdentNode start="(361, 24)" end="(361, 25)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(361, 25)" end="(361, 26)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(361, 27)" end="(361, 36)">
              <AtomNode start="(361, 27)" end="(361, 28)" leading="" trailing="" val="("/>
              <NullNode start="(361, 28)" end="(361, 29)">
                <IdentNode start="(361, 28)" end="(361, 29)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(361, 30)" end="(361, 35)">
                <AtomNode start="(361, 30)" end="(361, 31)" leading="" trailing=" " val=":"/>
                <IdentNode start="(361, 32)" end="(361, 35)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(361, 35)" end="(361, 36)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(361, 37)" end="(361, 48)">
              <AtomNode start="(361, 37)" end="(361, 38)" leading="" trailing="" val="("/>
              <NullNode start="(361, 38)" end="(361, 39)">
                <IdentNode start="(361, 38)" end="(361, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(361, 40)" end="(361, 47)">
                <AtomNode start="(361, 40)" end="(361, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(361, 42)" end="(361, 47)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(361, 42)" end="(361, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(361, 44)" end="(361, 45)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(361, 46)" end="(361, 47)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(361, 47)" end="(361, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(361, 49)" end="(361, 57)">
            <TermTypespecNode start="(361, 49)" end="(361, 57)">
              <AtomNode start="(361, 49)" end="(361, 50)" leading="" trailing=" " val=":"/>
              <OtherNode start="(361, 51)" end="(361, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(361, 51)" end="(361, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(361, 56)" end="(361, 57)">
                  <IdentNode start="(361, 56)" end="(361, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(361, 58)" end="(366, 44)">
          <AtomNode start="(361, 58)" end="(361, 60)" leading="" trailing=" " val=":="/>
          <OtherNode start="(361, 61)" end="(361, 71)" kind="Lean.Parser.Term.app">
            <IdentNode start="(361, 61)" end="(361, 63)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(361, 64)" end="(361, 71)">
              <IdentNode start="(361, 64)" end="(361, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              <IdentNode start="(361, 66)" end="(361, 67)" leading="" trailing=" " raw_val="i" val="i"/>
              <OtherNode start="(361, 68)" end="(361, 71)" kind="«term#[_,]»">
                <AtomNode start="(361, 68)" end="(361, 70)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(361, 70)" end="(361, 71)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(361, 72)" end="(366, 44)">
            <OtherNode start="(361, 72)" end="(366, 44)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(361, 72)" end="(361, 77)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(362, 3)" end="(366, 44)">
                <OtherNode start="(362, 3)" end="(366, 44)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(362, 3)" end="(362, 89)">
                    <CommandDoccommentNode start="(362, 3)" end="(362, 89)" comment="Auxiliary for `modifyTR`: `modifyTR.go f l i acc = acc.toList ++ modify f i l`. -/">
                      <AtomNode start="(362, 3)" end="(362, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(362, 7)" end="(362, 89)" leading="" trailing="&#10;  " val="Auxiliary for `modifyTR`: `modifyTR.go f l i acc = acc.toList ++ modify f i l`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(363, 3)" end="(366, 44)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(363, 3)" end="(366, 44)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(363, 3)" end="(363, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(363, 6)" end="(363, 39)">
                        <TermTypespecNode start="(363, 6)" end="(363, 39)">
                          <AtomNode start="(363, 6)" end="(363, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(363, 8)" end="(363, 39)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(363, 8)" end="(363, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(363, 8)" end="(363, 12)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(363, 13)" end="(363, 14)">
                                <IdentNode start="(363, 13)" end="(363, 14)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(363, 15)" end="(363, 16)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(363, 17)" end="(363, 39)" kind="Lean.Parser.Term.arrow">
                              <IdentNode start="(363, 17)" end="(363, 20)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(363, 21)" end="(363, 22)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(363, 23)" end="(363, 39)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(363, 23)" end="(363, 30)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(363, 23)" end="(363, 28)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(363, 29)" end="(363, 30)">
                                    <IdentNode start="(363, 29)" end="(363, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(363, 31)" end="(363, 32)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(363, 33)" end="(363, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(363, 33)" end="(363, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(363, 38)" end="(363, 39)">
                                    <IdentNode start="(363, 38)" end="(363, 39)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(364, 3)" end="(366, 44)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(364, 3)" end="(366, 44)">
                          <OtherNode start="(364, 3)" end="(364, 29)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(364, 3)" end="(364, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(364, 5)" end="(364, 15)">
                              <NullNode start="(364, 5)" end="(364, 15)">
                                <OtherNode start="(364, 5)" end="(364, 7)" kind="«term[_]»">
                                  <AtomNode start="(364, 5)" end="(364, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(364, 6)" end="(364, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(364, 7)" end="(364, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(364, 9)" end="(364, 10)">
                                  <AtomNode start="(364, 9)" end="(364, 10)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(364, 10)" end="(364, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(364, 12)" end="(364, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(364, 16)" end="(364, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(364, 19)" end="(364, 29)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(365, 3)" end="(365, 50)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(365, 3)" end="(365, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(365, 5)" end="(365, 19)">
                              <NullNode start="(365, 5)" end="(365, 19)">
                                <OtherNode start="(365, 5)" end="(365, 11)" kind="«term_::_»">
                                  <IdentNode start="(365, 5)" end="(365, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(365, 7)" end="(365, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(365, 10)" end="(365, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                </OtherNode>
                                <AtomNode start="(365, 11)" end="(365, 12)" leading="" trailing=" " val=","/>
                                <OtherNode start="(365, 13)" end="(365, 14)" kind="num">
                                  <AtomNode start="(365, 13)" end="(365, 14)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(365, 14)" end="(365, 15)" leading="" trailing=" " val=","/>
                                <IdentNode start="(365, 16)" end="(365, 19)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(365, 20)" end="(365, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(365, 23)" end="(365, 50)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(365, 23)" end="(365, 39)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                              <NullNode start="(365, 40)" end="(365, 50)">
                                <OtherNode start="(365, 40)" end="(365, 50)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(365, 40)" end="(365, 41)" leading="" trailing="" val="("/>
                                  <OtherNode start="(365, 41)" end="(365, 49)" kind="«term_::_»">
                                    <OtherNode start="(365, 41)" end="(365, 44)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(365, 41)" end="(365, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(365, 43)" end="(365, 44)">
                                        <IdentNode start="(365, 43)" end="(365, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(365, 45)" end="(365, 47)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(365, 48)" end="(365, 49)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                  <AtomNode start="(365, 49)" end="(365, 50)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(366, 3)" end="(366, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(366, 3)" end="(366, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(366, 5)" end="(366, 21)">
                              <NullNode start="(366, 5)" end="(366, 21)">
                                <OtherNode start="(366, 5)" end="(366, 11)" kind="«term_::_»">
                                  <IdentNode start="(366, 5)" end="(366, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(366, 7)" end="(366, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(366, 10)" end="(366, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                </OtherNode>
                                <AtomNode start="(366, 11)" end="(366, 12)" leading="" trailing=" " val=","/>
                                <OtherNode start="(366, 13)" end="(366, 16)" kind="«term_+_»">
                                  <IdentNode start="(366, 13)" end="(366, 14)" leading="" trailing="" raw_val="i" val="i"/>
                                  <AtomNode start="(366, 14)" end="(366, 15)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(366, 15)" end="(366, 16)" kind="num">
                                    <AtomNode start="(366, 15)" end="(366, 16)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(366, 16)" end="(366, 17)" leading="" trailing=" " val=","/>
                                <IdentNode start="(366, 18)" end="(366, 21)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(366, 22)" end="(366, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(366, 25)" end="(366, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(366, 25)" end="(366, 27)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(366, 28)" end="(366, 44)">
                                <IdentNode start="(366, 28)" end="(366, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(366, 30)" end="(366, 31)" leading="" trailing=" " raw_val="i" val="i"/>
                                <OtherNode start="(366, 32)" end="(366, 44)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(366, 32)" end="(366, 33)" leading="" trailing="" val="("/>
                                  <OtherNode start="(366, 33)" end="(366, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(366, 33)" end="(366, 41)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(366, 42)" end="(366, 43)">
                                      <IdentNode start="(366, 42)" end="(366, 43)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(366, 43)" end="(366, 44)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(368, 1)" end="(371, 67)" name="modifyTR_go_eq" full_name="List.modifyTR_go_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(368, 1)" end="(371, 67)" name="modifyTR_go_eq" full_name="List.modifyTR_go_eq" _is_private_decl="False">
        <AtomNode start="(368, 1)" end="(368, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(368, 9)" end="(368, 23)">
          <IdentNode start="(368, 9)" end="(368, 23)" leading="" trailing=" " raw_val="modifyTR_go_eq" val="modifyTR_go_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(368, 24)" end="(368, 83)">
          <NullNode/>
          <TermTypespecNode start="(368, 24)" end="(368, 83)">
            <AtomNode start="(368, 24)" end="(368, 25)" leading="" trailing=" " val=":"/>
            <OtherNode start="(368, 26)" end="(368, 83)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(368, 26)" end="(368, 27)" leading="" trailing=" " val="∀"/>
              <NullNode start="(368, 28)" end="(368, 31)">
                <IdentNode start="(368, 28)" end="(368, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                <IdentNode start="(368, 30)" end="(368, 31)" leading="" trailing="" raw_val="i" val="i"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(368, 31)" end="(368, 32)" leading="" trailing=" " val=","/>
              <OtherNode start="(368, 33)" end="(368, 83)" kind="«term_=_»">
                <OtherNode start="(368, 33)" end="(368, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(368, 33)" end="(368, 44)" leading="" trailing=" " raw_val="modifyTR.go" val="modifyTR.go" full_name="List.modifyTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(363, 3)" def_end="(363, 5)"/>
                  <NullNode start="(368, 45)" end="(368, 54)">
                    <IdentNode start="(368, 45)" end="(368, 46)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(368, 47)" end="(368, 48)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(368, 49)" end="(368, 50)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(368, 51)" end="(368, 54)" leading="" trailing=" " raw_val="acc" val="acc"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(368, 55)" end="(368, 56)" leading="" trailing=" " val="="/>
                <OtherNode start="(368, 57)" end="(368, 83)" kind="«term_++_»">
                  <IdentNode start="(368, 57)" end="(368, 67)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                  <AtomNode start="(368, 68)" end="(368, 70)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(368, 71)" end="(368, 83)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(368, 71)" end="(368, 77)" leading="" trailing=" " raw_val="modify" val="modify" full_name="List.modify" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(368, 78)" end="(368, 83)">
                      <IdentNode start="(368, 78)" end="(368, 79)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(368, 80)" end="(368, 81)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(368, 82)" end="(368, 83)" leading="" trailing="&#10;  " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(369, 3)" end="(371, 67)">
          <OtherNode start="(369, 3)" end="(371, 67)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(369, 3)" end="(371, 67)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(369, 3)" end="(371, 67)">
                <OtherNode start="(369, 3)" end="(369, 55)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(369, 3)" end="(369, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(369, 5)" end="(369, 10)">
                    <NullNode start="(369, 5)" end="(369, 10)">
                      <OtherNode start="(369, 5)" end="(369, 7)" kind="«term[_]»">
                        <AtomNode start="(369, 5)" end="(369, 6)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(369, 6)" end="(369, 7)" leading="" trailing="" val="]"/>
                      </OtherNode>
                      <AtomNode start="(369, 7)" end="(369, 8)" leading="" trailing=" " val=","/>
                      <IdentNode start="(369, 9)" end="(369, 10)" leading="" trailing=" " raw_val="i" val="i"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(369, 11)" end="(369, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(369, 14)" end="(369, 55)">
                    <AtomNode start="(369, 14)" end="(369, 16)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(369, 17)" end="(369, 55)">
                      <TacticTacticseq1IndentedNode start="(369, 17)" end="(369, 55)">
                        <NullNode start="(369, 17)" end="(369, 55)">
                          <OtherNode start="(369, 17)" end="(369, 55)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α✝ : Type u_1&#10;f : α✝ → α✝&#10;acc : Array α✝&#10;i : Nat&#10;⊢ modifyTR.go f [] i acc = acc.toList ++ [].modify i f" state_after="no goals" tactic="cases i &amp;lt;;&amp;gt; simp [modifyTR.go, modify]">
                            <OtherNode start="(369, 17)" end="(369, 24)" kind="Lean.Parser.Tactic.cases">
                              <AtomNode start="(369, 17)" end="(369, 22)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(369, 23)" end="(369, 24)">
                                <OtherNode start="(369, 23)" end="(369, 24)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(369, 23)" end="(369, 24)" leading="" trailing=" " raw_val="i" val="i"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(369, 25)" end="(369, 28)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                            <OtherNode start="(369, 29)" end="(369, 55)" kind="Lean.Parser.Tactic.simp">
                              <AtomNode start="(369, 29)" end="(369, 33)" leading="" trailing=" " val="simp"/>
                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                <NullNode/>
                              </OtherNode>
                              <NullNode/>
                              <NullNode/>
                              <NullNode start="(369, 34)" end="(369, 55)">
                                <AtomNode start="(369, 34)" end="(369, 35)" leading="" trailing="" val="["/>
                                <NullNode start="(369, 35)" end="(369, 54)">
                                  <OtherNode start="(369, 35)" end="(369, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(369, 35)" end="(369, 46)" leading="" trailing="" raw_val="modifyTR.go" val="modifyTR.go" full_name="List.modifyTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(363, 3)" def_end="(363, 5)"/>
                                  </OtherNode>
                                  <AtomNode start="(369, 46)" end="(369, 47)" leading="" trailing=" " val=","/>
                                  <OtherNode start="(369, 48)" end="(369, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                    <NullNode/>
                                    <NullNode/>
                                    <IdentNode start="(369, 48)" end="(369, 54)" leading="" trailing="" raw_val="modify" val="modify" full_name="List.modify" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(369, 54)" end="(369, 55)" leading="" trailing="&#10;  " val="]"/>
                              </NullNode>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(370, 3)" end="(370, 47)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(370, 3)" end="(370, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(370, 5)" end="(370, 14)">
                    <NullNode start="(370, 5)" end="(370, 14)">
                      <OtherNode start="(370, 5)" end="(370, 11)" kind="«term_::_»">
                        <IdentNode start="(370, 5)" end="(370, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(370, 7)" end="(370, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(370, 10)" end="(370, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(370, 11)" end="(370, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(370, 13)" end="(370, 14)" kind="num">
                        <AtomNode start="(370, 13)" end="(370, 14)" leading="" trailing=" " val="0"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(370, 15)" end="(370, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(370, 18)" end="(370, 47)">
                    <AtomNode start="(370, 18)" end="(370, 20)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(370, 21)" end="(370, 47)">
                      <TacticTacticseq1IndentedNode start="(370, 21)" end="(370, 47)">
                        <NullNode start="(370, 21)" end="(370, 47)">
                          <OtherNode start="(370, 21)" end="(370, 47)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;f : α✝ → α✝&#10;acc : Array α✝&#10;a : α✝&#10;l : List α✝&#10;⊢ modifyTR.go f (a :: l) 0 acc = acc.toList ++ (a :: l).modify 0 f" state_after="no goals" tactic="simp [modifyTR.go, modify]">
                            <AtomNode start="(370, 21)" end="(370, 25)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(370, 26)" end="(370, 47)">
                              <AtomNode start="(370, 26)" end="(370, 27)" leading="" trailing="" val="["/>
                              <NullNode start="(370, 27)" end="(370, 46)">
                                <OtherNode start="(370, 27)" end="(370, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(370, 27)" end="(370, 38)" leading="" trailing="" raw_val="modifyTR.go" val="modifyTR.go" full_name="List.modifyTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(363, 3)" def_end="(363, 5)"/>
                                </OtherNode>
                                <AtomNode start="(370, 38)" end="(370, 39)" leading="" trailing=" " val=","/>
                                <OtherNode start="(370, 40)" end="(370, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(370, 40)" end="(370, 46)" leading="" trailing="" raw_val="modify" val="modify" full_name="List.modify" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(370, 46)" end="(370, 47)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(371, 3)" end="(371, 67)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(371, 3)" end="(371, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(371, 5)" end="(371, 16)">
                    <NullNode start="(371, 5)" end="(371, 16)">
                      <OtherNode start="(371, 5)" end="(371, 11)" kind="«term_::_»">
                        <IdentNode start="(371, 5)" end="(371, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(371, 7)" end="(371, 9)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(371, 10)" end="(371, 11)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                      <AtomNode start="(371, 11)" end="(371, 12)" leading="" trailing=" " val=","/>
                      <OtherNode start="(371, 13)" end="(371, 16)" kind="«term_+_»">
                        <IdentNode start="(371, 13)" end="(371, 14)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(371, 14)" end="(371, 15)" leading="" trailing="" val="+"/>
                        <OtherNode start="(371, 15)" end="(371, 16)" kind="num">
                          <AtomNode start="(371, 15)" end="(371, 16)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(371, 17)" end="(371, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(371, 20)" end="(371, 67)">
                    <AtomNode start="(371, 20)" end="(371, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(371, 23)" end="(371, 67)">
                      <TacticTacticseq1IndentedNode start="(371, 23)" end="(371, 67)">
                        <NullNode start="(371, 23)" end="(371, 67)">
                          <OtherNode start="(371, 23)" end="(371, 67)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;f : α✝ → α✝&#10;acc : Array α✝&#10;a : α✝&#10;l : List α✝&#10;i : Nat&#10;⊢ modifyTR.go f (a :: l) (i + 1) acc = acc.toList ++ (a :: l).modify (i + 1) f" state_after="no goals" tactic="simp [modifyTR.go, modify, modifyTR_go_eq l]">
                            <AtomNode start="(371, 23)" end="(371, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(371, 28)" end="(371, 67)">
                              <AtomNode start="(371, 28)" end="(371, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(371, 29)" end="(371, 66)">
                                <OtherNode start="(371, 29)" end="(371, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(371, 29)" end="(371, 40)" leading="" trailing="" raw_val="modifyTR.go" val="modifyTR.go" full_name="List.modifyTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(363, 3)" def_end="(363, 5)"/>
                                </OtherNode>
                                <AtomNode start="(371, 40)" end="(371, 41)" leading="" trailing=" " val=","/>
                                <OtherNode start="(371, 42)" end="(371, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(371, 42)" end="(371, 48)" leading="" trailing="" raw_val="modify" val="modify" full_name="List.modify" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(371, 48)" end="(371, 49)" leading="" trailing=" " val=","/>
                                <OtherNode start="(371, 50)" end="(371, 66)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(371, 50)" end="(371, 66)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(371, 50)" end="(371, 64)" leading="" trailing=" " raw_val="modifyTR_go_eq" val="modifyTR_go_eq"/>
                                    <NullNode start="(371, 65)" end="(371, 66)">
                                      <IdentNode start="(371, 65)" end="(371, 66)" leading="" trailing="" raw_val="l" val="l"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(371, 66)" end="(371, 67)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(373, 1)" end="(374, 50)" name="modify_eq_modifyTR" full_name="List.modify_eq_modifyTR">
      <CommandDeclmodifiersNode start="(373, 1)" end="(373, 9)">
        <NullNode/>
        <NullNode start="(373, 1)" end="(373, 9)">
          <OtherNode start="(373, 1)" end="(373, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(373, 1)" end="(373, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(373, 3)" end="(373, 8)">
              <OtherNode start="(373, 3)" end="(373, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(373, 3)" end="(373, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(373, 3)" end="(373, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(373, 8)" end="(373, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(373, 10)" end="(374, 50)" name="modify_eq_modifyTR" full_name="List.modify_eq_modifyTR" _is_private_decl="False">
        <AtomNode start="(373, 10)" end="(373, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(373, 18)" end="(373, 36)">
          <IdentNode start="(373, 18)" end="(373, 36)" leading="" trailing=" " raw_val="modify_eq_modifyTR" val="modify_eq_modifyTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(373, 37)" end="(373, 58)">
          <NullNode/>
          <TermTypespecNode start="(373, 37)" end="(373, 58)">
            <AtomNode start="(373, 37)" end="(373, 38)" leading="" trailing=" " val=":"/>
            <OtherNode start="(373, 39)" end="(373, 58)" kind="«term_=_»">
              <OtherNode start="(373, 39)" end="(373, 46)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(373, 39)" end="(373, 40)" leading="" trailing="" val="@"/>
                <IdentNode start="(373, 40)" end="(373, 46)" leading="" trailing=" " raw_val="modify" val="modify" full_name="List.modify" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(373, 47)" end="(373, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(373, 49)" end="(373, 58)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(373, 49)" end="(373, 50)" leading="" trailing="" val="@"/>
                <IdentNode start="(373, 50)" end="(373, 58)" leading="" trailing=" " raw_val="modifyTR" val="modifyTR" full_name="List.modifyTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(361, 5)" def_end="(361, 13)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(373, 59)" end="(374, 50)">
          <AtomNode start="(373, 59)" end="(373, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(373, 62)" end="(374, 50)">
            <AtomNode start="(373, 62)" end="(373, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(374, 3)" end="(374, 50)">
              <TacticTacticseq1IndentedNode start="(374, 3)" end="(374, 50)">
                <NullNode start="(374, 3)" end="(374, 50)">
                  <OtherNode start="(374, 3)" end="(374, 17)" kind="tacticFunext___" state_before="⊢ @modify = @modifyTR" state_after="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;f : α → α&#10;⊢ l.modify i f = l.modifyTR i f" tactic="funext α l i f">
                    <AtomNode start="(374, 3)" end="(374, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(374, 10)" end="(374, 17)">
                      <IdentNode start="(374, 10)" end="(374, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(374, 12)" end="(374, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(374, 14)" end="(374, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(374, 16)" end="(374, 17)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(374, 17)" end="(374, 18)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(374, 19)" end="(374, 50)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;f : α → α&#10;⊢ l.modify i f = l.modifyTR i f" state_after="no goals" tactic="simp [modifyTR, modifyTR_go_eq]">
                    <AtomNode start="(374, 19)" end="(374, 23)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(374, 24)" end="(374, 50)">
                      <AtomNode start="(374, 24)" end="(374, 25)" leading="" trailing="" val="["/>
                      <NullNode start="(374, 25)" end="(374, 49)">
                        <OtherNode start="(374, 25)" end="(374, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(374, 25)" end="(374, 33)" leading="" trailing="" raw_val="modifyTR" val="modifyTR" full_name="List.modifyTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(361, 5)" def_end="(361, 13)"/>
                        </OtherNode>
                        <AtomNode start="(374, 33)" end="(374, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(374, 35)" end="(374, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(374, 35)" end="(374, 49)" leading="" trailing="" raw_val="modifyTR_go_eq" val="modifyTR_go_eq" full_name="List.modifyTR_go_eq" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(368, 9)" def_end="(368, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(374, 49)" end="(374, 50)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(376, 1)" end="(376, 21)" comment="### insertIdx -/">
      <AtomNode start="(376, 1)" end="(376, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(376, 5)" end="(376, 21)" leading="" trailing="&#10;&#10;" val="### insertIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(378, 1)" end="(398, 44)" name="insertIdxTR" full_name="List.insertIdxTR">
      <CommandDeclmodifiersNode start="(378, 1)" end="(393, 10)">
        <NullNode start="(378, 1)" end="(392, 3)">
          <CommandDoccommentNode start="(378, 1)" end="(392, 3)" comment="Inserts an element into a list at the specified index. If the index is greater than the length of&#10;the list, then the list is returned unmodified.&#10;&#10;In other words, the new element is inserted into the list `l` after the first `i` elements of `l`.&#10;&#10;This is a tail-recursive version of `List.insertIdx`, used at runtime.&#10;&#10;Examples:&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 1 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;wed&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;]`&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 2 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;wed&amp;quot;, &amp;quot;sat&amp;quot;]`&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 3 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;, &amp;quot;wed&amp;quot;]`&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 4 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;]`&#10;&#10;-/">
            <AtomNode start="(378, 1)" end="(378, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(379, 1)" end="(392, 3)" leading="" trailing="&#10;" val="Inserts an element into a list at the specified index. If the index is greater than the length of&#10;the list, then the list is returned unmodified.&#10;&#10;In other words, the new element is inserted into the list `l` after the first `i` elements of `l`.&#10;&#10;This is a tail-recursive version of `List.insertIdx`, used at runtime.&#10;&#10;Examples:&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 1 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;wed&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;]`&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 2 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;wed&amp;quot;, &amp;quot;sat&amp;quot;]`&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 3 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;, &amp;quot;wed&amp;quot;]`&#10; * `[&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;].insertIdxTR 4 &amp;quot;wed&amp;quot; = [&amp;quot;tues&amp;quot;, &amp;quot;thur&amp;quot;, &amp;quot;sat&amp;quot;]`&#10;&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(393, 1)" end="(393, 10)">
          <OtherNode start="(393, 1)" end="(393, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(393, 1)" end="(393, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(393, 3)" end="(393, 9)">
              <OtherNode start="(393, 3)" end="(393, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(393, 3)" end="(393, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(393, 3)" end="(393, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(393, 9)" end="(393, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(393, 11)" end="(398, 44)" name="insertIdxTR">
        <AtomNode start="(393, 11)" end="(393, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(393, 15)" end="(393, 26)">
          <IdentNode start="(393, 15)" end="(393, 26)" leading="" trailing=" " raw_val="insertIdxTR" val="insertIdxTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(393, 27)" end="(393, 66)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(393, 27)" end="(393, 57)">
            <TermExplicitbinderNode start="(393, 27)" end="(393, 39)">
              <AtomNode start="(393, 27)" end="(393, 28)" leading="" trailing="" val="("/>
              <NullNode start="(393, 28)" end="(393, 29)">
                <IdentNode start="(393, 28)" end="(393, 29)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(393, 30)" end="(393, 38)">
                <AtomNode start="(393, 30)" end="(393, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(393, 32)" end="(393, 38)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(393, 32)" end="(393, 36)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(393, 37)" end="(393, 38)">
                    <IdentNode start="(393, 37)" end="(393, 38)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(393, 38)" end="(393, 39)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(393, 40)" end="(393, 49)">
              <AtomNode start="(393, 40)" end="(393, 41)" leading="" trailing="" val="("/>
              <NullNode start="(393, 41)" end="(393, 42)">
                <IdentNode start="(393, 41)" end="(393, 42)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(393, 43)" end="(393, 48)">
                <AtomNode start="(393, 43)" end="(393, 44)" leading="" trailing=" " val=":"/>
                <IdentNode start="(393, 45)" end="(393, 48)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(393, 48)" end="(393, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(393, 50)" end="(393, 57)">
              <AtomNode start="(393, 50)" end="(393, 51)" leading="" trailing="" val="("/>
              <NullNode start="(393, 51)" end="(393, 52)">
                <IdentNode start="(393, 51)" end="(393, 52)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(393, 53)" end="(393, 56)">
                <AtomNode start="(393, 53)" end="(393, 54)" leading="" trailing=" " val=":"/>
                <IdentNode start="(393, 55)" end="(393, 56)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(393, 56)" end="(393, 57)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(393, 58)" end="(393, 66)">
            <TermTypespecNode start="(393, 58)" end="(393, 66)">
              <AtomNode start="(393, 58)" end="(393, 59)" leading="" trailing=" " val=":"/>
              <OtherNode start="(393, 60)" end="(393, 66)" kind="Lean.Parser.Term.app">
                <IdentNode start="(393, 60)" end="(393, 64)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(393, 65)" end="(393, 66)">
                  <IdentNode start="(393, 65)" end="(393, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(393, 67)" end="(398, 44)">
          <AtomNode start="(393, 67)" end="(393, 69)" leading="" trailing=" " val=":="/>
          <OtherNode start="(393, 70)" end="(393, 80)" kind="Lean.Parser.Term.app">
            <IdentNode start="(393, 70)" end="(393, 72)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(393, 73)" end="(393, 80)">
              <IdentNode start="(393, 73)" end="(393, 74)" leading="" trailing=" " raw_val="n" val="n"/>
              <IdentNode start="(393, 75)" end="(393, 76)" leading="" trailing=" " raw_val="l" val="l"/>
              <OtherNode start="(393, 77)" end="(393, 80)" kind="«term#[_,]»">
                <AtomNode start="(393, 77)" end="(393, 79)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(393, 79)" end="(393, 80)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(393, 81)" end="(398, 44)">
            <OtherNode start="(393, 81)" end="(398, 44)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(393, 81)" end="(393, 86)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(394, 3)" end="(398, 44)">
                <OtherNode start="(394, 3)" end="(398, 44)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(394, 3)" end="(394, 98)">
                    <CommandDoccommentNode start="(394, 3)" end="(394, 98)" comment="Auxiliary for `insertIdxTR`: `insertIdxTR.go a n l acc = acc.toList ++ insertIdx n a l`. -/">
                      <AtomNode start="(394, 3)" end="(394, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(394, 7)" end="(394, 98)" leading="" trailing="&#10;  " val="Auxiliary for `insertIdxTR`: `insertIdxTR.go a n l acc = acc.toList ++ insertIdx n a l`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(395, 3)" end="(398, 44)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(395, 3)" end="(398, 44)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(395, 3)" end="(395, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(395, 6)" end="(395, 39)">
                        <TermTypespecNode start="(395, 6)" end="(395, 39)">
                          <AtomNode start="(395, 6)" end="(395, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(395, 8)" end="(395, 39)" kind="Lean.Parser.Term.arrow">
                            <IdentNode start="(395, 8)" end="(395, 11)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <AtomNode start="(395, 12)" end="(395, 13)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(395, 14)" end="(395, 39)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(395, 14)" end="(395, 20)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(395, 14)" end="(395, 18)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(395, 19)" end="(395, 20)">
                                  <IdentNode start="(395, 19)" end="(395, 20)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(395, 21)" end="(395, 22)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(395, 23)" end="(395, 39)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(395, 23)" end="(395, 30)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(395, 23)" end="(395, 28)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(395, 29)" end="(395, 30)">
                                    <IdentNode start="(395, 29)" end="(395, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(395, 31)" end="(395, 32)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(395, 33)" end="(395, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(395, 33)" end="(395, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(395, 38)" end="(395, 39)">
                                    <IdentNode start="(395, 38)" end="(395, 39)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(396, 3)" end="(398, 44)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(396, 3)" end="(398, 44)">
                          <OtherNode start="(396, 3)" end="(396, 43)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(396, 3)" end="(396, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(396, 5)" end="(396, 14)">
                              <NullNode start="(396, 5)" end="(396, 14)">
                                <OtherNode start="(396, 5)" end="(396, 6)" kind="num">
                                  <AtomNode start="(396, 5)" end="(396, 6)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(396, 6)" end="(396, 7)" leading="" trailing=" " val=","/>
                                <IdentNode start="(396, 8)" end="(396, 9)" leading="" trailing="" raw_val="l" val="l"/>
                                <AtomNode start="(396, 9)" end="(396, 10)" leading="" trailing=" " val=","/>
                                <IdentNode start="(396, 11)" end="(396, 14)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(396, 15)" end="(396, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(396, 18)" end="(396, 43)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(396, 18)" end="(396, 34)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                              <NullNode start="(396, 35)" end="(396, 43)">
                                <OtherNode start="(396, 35)" end="(396, 43)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(396, 35)" end="(396, 36)" leading="" trailing="" val="("/>
                                  <OtherNode start="(396, 36)" end="(396, 42)" kind="«term_::_»">
                                    <IdentNode start="(396, 36)" end="(396, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                                    <AtomNode start="(396, 38)" end="(396, 40)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(396, 41)" end="(396, 42)" leading="" trailing="" raw_val="l" val="l"/>
                                  </OtherNode>
                                  <AtomNode start="(396, 42)" end="(396, 43)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(397, 3)" end="(397, 29)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(397, 3)" end="(397, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(397, 5)" end="(397, 15)">
                              <NullNode start="(397, 5)" end="(397, 15)">
                                <TermHoleNode start="(397, 5)" end="(397, 6)">
                                  <AtomNode start="(397, 5)" end="(397, 6)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(397, 6)" end="(397, 7)" leading="" trailing=" " val=","/>
                                <OtherNode start="(397, 8)" end="(397, 10)" kind="«term[_]»">
                                  <AtomNode start="(397, 8)" end="(397, 9)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(397, 9)" end="(397, 10)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(397, 10)" end="(397, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(397, 12)" end="(397, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(397, 16)" end="(397, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(397, 19)" end="(397, 29)" leading="" trailing="&#10;  " raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                          <OtherNode start="(398, 3)" end="(398, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(398, 3)" end="(398, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(398, 5)" end="(398, 21)">
                              <NullNode start="(398, 5)" end="(398, 21)">
                                <OtherNode start="(398, 5)" end="(398, 8)" kind="«term_+_»">
                                  <IdentNode start="(398, 5)" end="(398, 6)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(398, 6)" end="(398, 7)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(398, 7)" end="(398, 8)" kind="num">
                                    <AtomNode start="(398, 7)" end="(398, 8)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(398, 8)" end="(398, 9)" leading="" trailing=" " val=","/>
                                <OtherNode start="(398, 10)" end="(398, 16)" kind="«term_::_»">
                                  <IdentNode start="(398, 10)" end="(398, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(398, 12)" end="(398, 14)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(398, 15)" end="(398, 16)" leading="" trailing="" raw_val="l" val="l"/>
                                </OtherNode>
                                <AtomNode start="(398, 16)" end="(398, 17)" leading="" trailing=" " val=","/>
                                <IdentNode start="(398, 18)" end="(398, 21)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(398, 22)" end="(398, 24)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(398, 25)" end="(398, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(398, 25)" end="(398, 27)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(398, 28)" end="(398, 44)">
                                <IdentNode start="(398, 28)" end="(398, 29)" leading="" trailing=" " raw_val="n" val="n"/>
                                <IdentNode start="(398, 30)" end="(398, 31)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(398, 32)" end="(398, 44)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(398, 32)" end="(398, 33)" leading="" trailing="" val="("/>
                                  <OtherNode start="(398, 33)" end="(398, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(398, 33)" end="(398, 41)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(398, 42)" end="(398, 43)">
                                      <IdentNode start="(398, 42)" end="(398, 43)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(398, 43)" end="(398, 44)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(400, 1)" end="(402, 78)" name="insertIdxTR_go_eq" full_name="List.insertIdxTR_go_eq">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(400, 1)" end="(402, 78)" name="insertIdxTR_go_eq" full_name="List.insertIdxTR_go_eq" _is_private_decl="False">
        <AtomNode start="(400, 1)" end="(400, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(400, 9)" end="(400, 26)">
          <IdentNode start="(400, 9)" end="(400, 26)" leading="" trailing=" " raw_val="insertIdxTR_go_eq" val="insertIdxTR_go_eq"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(400, 27)" end="(400, 92)">
          <NullNode/>
          <TermTypespecNode start="(400, 27)" end="(400, 92)">
            <AtomNode start="(400, 27)" end="(400, 28)" leading="" trailing=" " val=":"/>
            <OtherNode start="(400, 29)" end="(400, 92)" kind="Lean.Parser.Term.forall">
              <AtomNode start="(400, 29)" end="(400, 30)" leading="" trailing=" " val="∀"/>
              <NullNode start="(400, 31)" end="(400, 34)">
                <IdentNode start="(400, 31)" end="(400, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                <IdentNode start="(400, 33)" end="(400, 34)" leading="" trailing="" raw_val="l" val="l"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(400, 34)" end="(400, 35)" leading="" trailing=" " val=","/>
              <OtherNode start="(400, 36)" end="(400, 92)" kind="«term_=_»">
                <OtherNode start="(400, 36)" end="(400, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(400, 36)" end="(400, 50)" leading="" trailing=" " raw_val="insertIdxTR.go" val="insertIdxTR.go" full_name="List.insertIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(395, 3)" def_end="(395, 5)"/>
                  <NullNode start="(400, 51)" end="(400, 60)">
                    <IdentNode start="(400, 51)" end="(400, 52)" leading="" trailing=" " raw_val="a" val="a"/>
                    <IdentNode start="(400, 53)" end="(400, 54)" leading="" trailing=" " raw_val="i" val="i"/>
                    <IdentNode start="(400, 55)" end="(400, 56)" leading="" trailing=" " raw_val="l" val="l"/>
                    <IdentNode start="(400, 57)" end="(400, 60)" leading="" trailing=" " raw_val="acc" val="acc"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(400, 61)" end="(400, 62)" leading="" trailing=" " val="="/>
                <OtherNode start="(400, 63)" end="(400, 92)" kind="«term_++_»">
                  <IdentNode start="(400, 63)" end="(400, 73)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                  <AtomNode start="(400, 74)" end="(400, 76)" leading="" trailing=" " val="++"/>
                  <OtherNode start="(400, 77)" end="(400, 92)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(400, 77)" end="(400, 86)" leading="" trailing=" " raw_val="insertIdx" val="insertIdx" full_name="List.insertIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                    <NullNode start="(400, 87)" end="(400, 92)">
                      <IdentNode start="(400, 87)" end="(400, 88)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(400, 89)" end="(400, 90)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(400, 91)" end="(400, 92)" leading="" trailing="&#10;  " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvaleqnsNode start="(401, 3)" end="(402, 78)">
          <OtherNode start="(401, 3)" end="(402, 78)" kind="Lean.Parser.Term.matchAltsWhereDecls">
            <OtherNode start="(401, 3)" end="(402, 78)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(401, 3)" end="(402, 78)">
                <OtherNode start="(401, 3)" end="(401, 58)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(401, 3)" end="(401, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(401, 5)" end="(401, 19)">
                    <NullNode start="(401, 5)" end="(401, 9)">
                      <OtherNode start="(401, 5)" end="(401, 6)" kind="num">
                        <AtomNode start="(401, 5)" end="(401, 6)" leading="" trailing="" val="0"/>
                      </OtherNode>
                      <AtomNode start="(401, 6)" end="(401, 7)" leading="" trailing=" " val=","/>
                      <IdentNode start="(401, 8)" end="(401, 9)" leading="" trailing=" " raw_val="l" val="l"/>
                    </NullNode>
                    <AtomNode start="(401, 10)" end="(401, 11)" leading="" trailing=" " val="|"/>
                    <NullNode start="(401, 12)" end="(401, 19)">
                      <OtherNode start="(401, 12)" end="(401, 15)" kind="«term_+_»">
                        <TermHoleNode start="(401, 12)" end="(401, 13)">
                          <AtomNode start="(401, 12)" end="(401, 13)" leading="" trailing="" val="_"/>
                        </TermHoleNode>
                        <AtomNode start="(401, 13)" end="(401, 14)" leading="" trailing="" val="+"/>
                        <OtherNode start="(401, 14)" end="(401, 15)" kind="num">
                          <AtomNode start="(401, 14)" end="(401, 15)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(401, 15)" end="(401, 16)" leading="" trailing=" " val=","/>
                      <OtherNode start="(401, 17)" end="(401, 19)" kind="«term[_]»">
                        <AtomNode start="(401, 17)" end="(401, 18)" leading="" trailing="" val="["/>
                        <NullNode/>
                        <AtomNode start="(401, 18)" end="(401, 19)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(401, 20)" end="(401, 22)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(401, 23)" end="(401, 58)">
                    <AtomNode start="(401, 23)" end="(401, 25)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(401, 26)" end="(401, 58)">
                      <TacticTacticseq1IndentedNode start="(401, 26)" end="(401, 58)">
                        <NullNode start="(401, 26)" end="(401, 58)">
                          <OtherNode start="(401, 26)" end="(401, 58)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;a : α✝&#10;acc : Array α✝&#10;n✝ : Nat&#10;⊢ insertIdxTR.go a (n✝ + 1) [] acc = acc.toList ++ [].insertIdx (n✝ + 1) a" state_after="no goals" tactic="simp [insertIdxTR.go, insertIdx]">
                            <AtomNode start="(401, 26)" end="(401, 30)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(401, 31)" end="(401, 58)">
                              <AtomNode start="(401, 31)" end="(401, 32)" leading="" trailing="" val="["/>
                              <NullNode start="(401, 32)" end="(401, 57)">
                                <OtherNode start="(401, 32)" end="(401, 46)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(401, 32)" end="(401, 46)" leading="" trailing="" raw_val="insertIdxTR.go" val="insertIdxTR.go" full_name="List.insertIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(395, 3)" def_end="(395, 5)"/>
                                </OtherNode>
                                <AtomNode start="(401, 46)" end="(401, 47)" leading="" trailing=" " val=","/>
                                <OtherNode start="(401, 48)" end="(401, 57)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(401, 48)" end="(401, 57)" leading="" trailing="" raw_val="insertIdx" val="insertIdx" full_name="List.insertIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(401, 57)" end="(401, 58)" leading="" trailing="&#10;  " val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
                <OtherNode start="(402, 3)" end="(402, 78)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(402, 3)" end="(402, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(402, 5)" end="(402, 16)">
                    <NullNode start="(402, 5)" end="(402, 16)">
                      <OtherNode start="(402, 5)" end="(402, 8)" kind="«term_+_»">
                        <IdentNode start="(402, 5)" end="(402, 6)" leading="" trailing="" raw_val="n" val="n"/>
                        <AtomNode start="(402, 6)" end="(402, 7)" leading="" trailing="" val="+"/>
                        <OtherNode start="(402, 7)" end="(402, 8)" kind="num">
                          <AtomNode start="(402, 7)" end="(402, 8)" leading="" trailing="" val="1"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(402, 8)" end="(402, 9)" leading="" trailing=" " val=","/>
                      <OtherNode start="(402, 10)" end="(402, 16)" kind="«term_::_»">
                        <IdentNode start="(402, 10)" end="(402, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                        <AtomNode start="(402, 12)" end="(402, 14)" leading="" trailing=" " val="::"/>
                        <IdentNode start="(402, 15)" end="(402, 16)" leading="" trailing=" " raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(402, 17)" end="(402, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                  <TermBytacticNode start="(402, 20)" end="(402, 78)">
                    <AtomNode start="(402, 20)" end="(402, 22)" leading="" trailing=" " val="by"/>
                    <TacticTacticseqNode start="(402, 23)" end="(402, 78)">
                      <TacticTacticseq1IndentedNode start="(402, 23)" end="(402, 78)">
                        <NullNode start="(402, 23)" end="(402, 78)">
                          <OtherNode start="(402, 23)" end="(402, 78)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type u_1&#10;a✝ : α✝&#10;acc : Array α✝&#10;n : Nat&#10;a : α✝&#10;l : List α✝&#10;⊢ insertIdxTR.go a✝ (n + 1) (a :: l) acc = acc.toList ++ (a :: l).insertIdx (n + 1) a✝" state_after="no goals" tactic="simp [insertIdxTR.go, insertIdx, insertIdxTR_go_eq n l]">
                            <AtomNode start="(402, 23)" end="(402, 27)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode/>
                            <NullNode start="(402, 28)" end="(402, 78)">
                              <AtomNode start="(402, 28)" end="(402, 29)" leading="" trailing="" val="["/>
                              <NullNode start="(402, 29)" end="(402, 77)">
                                <OtherNode start="(402, 29)" end="(402, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(402, 29)" end="(402, 43)" leading="" trailing="" raw_val="insertIdxTR.go" val="insertIdxTR.go" full_name="List.insertIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(395, 3)" def_end="(395, 5)"/>
                                </OtherNode>
                                <AtomNode start="(402, 43)" end="(402, 44)" leading="" trailing=" " val=","/>
                                <OtherNode start="(402, 45)" end="(402, 54)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(402, 45)" end="(402, 54)" leading="" trailing="" raw_val="insertIdx" val="insertIdx" full_name="List.insertIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                </OtherNode>
                                <AtomNode start="(402, 54)" end="(402, 55)" leading="" trailing=" " val=","/>
                                <OtherNode start="(402, 56)" end="(402, 77)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <OtherNode start="(402, 56)" end="(402, 77)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(402, 56)" end="(402, 73)" leading="" trailing=" " raw_val="insertIdxTR_go_eq" val="insertIdxTR_go_eq"/>
                                    <NullNode start="(402, 74)" end="(402, 77)">
                                      <IdentNode start="(402, 74)" end="(402, 75)" leading="" trailing=" " raw_val="n" val="n"/>
                                      <IdentNode start="(402, 76)" end="(402, 77)" leading="" trailing="" raw_val="l" val="l"/>
                                    </NullNode>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(402, 77)" end="(402, 78)" leading="" trailing="&#10;&#10;" val="]"/>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </TermBytacticNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </OtherNode>
        </CommandDeclvaleqnsNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(404, 1)" end="(405, 56)" name="insertIdx_eq_insertIdxTR" full_name="List.insertIdx_eq_insertIdxTR">
      <CommandDeclmodifiersNode start="(404, 1)" end="(404, 9)">
        <NullNode/>
        <NullNode start="(404, 1)" end="(404, 9)">
          <OtherNode start="(404, 1)" end="(404, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(404, 1)" end="(404, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(404, 3)" end="(404, 8)">
              <OtherNode start="(404, 3)" end="(404, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(404, 3)" end="(404, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(404, 3)" end="(404, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(404, 8)" end="(404, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(404, 10)" end="(405, 56)" name="insertIdx_eq_insertIdxTR" full_name="List.insertIdx_eq_insertIdxTR" _is_private_decl="False">
        <AtomNode start="(404, 10)" end="(404, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(404, 18)" end="(404, 42)">
          <IdentNode start="(404, 18)" end="(404, 42)" leading="" trailing=" " raw_val="insertIdx_eq_insertIdxTR" val="insertIdx_eq_insertIdxTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(404, 43)" end="(404, 70)">
          <NullNode/>
          <TermTypespecNode start="(404, 43)" end="(404, 70)">
            <AtomNode start="(404, 43)" end="(404, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(404, 45)" end="(404, 70)" kind="«term_=_»">
              <OtherNode start="(404, 45)" end="(404, 55)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(404, 45)" end="(404, 46)" leading="" trailing="" val="@"/>
                <IdentNode start="(404, 46)" end="(404, 55)" leading="" trailing=" " raw_val="insertIdx" val="insertIdx" full_name="List.insertIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(404, 56)" end="(404, 57)" leading="" trailing=" " val="="/>
              <OtherNode start="(404, 58)" end="(404, 70)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(404, 58)" end="(404, 59)" leading="" trailing="" val="@"/>
                <IdentNode start="(404, 59)" end="(404, 70)" leading="" trailing=" " raw_val="insertIdxTR" val="insertIdxTR" full_name="List.insertIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(393, 15)" def_end="(393, 26)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(404, 71)" end="(405, 56)">
          <AtomNode start="(404, 71)" end="(404, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(404, 74)" end="(405, 56)">
            <AtomNode start="(404, 74)" end="(404, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(405, 3)" end="(405, 56)">
              <TacticTacticseq1IndentedNode start="(405, 3)" end="(405, 56)">
                <NullNode start="(405, 3)" end="(405, 56)">
                  <OtherNode start="(405, 3)" end="(405, 17)" kind="tacticFunext___" state_before="⊢ @insertIdx = @insertIdxTR" state_after="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ l.insertIdx i a = l.insertIdxTR i a" tactic="funext α l i a">
                    <AtomNode start="(405, 3)" end="(405, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(405, 10)" end="(405, 17)">
                      <IdentNode start="(405, 10)" end="(405, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(405, 12)" end="(405, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(405, 14)" end="(405, 15)" leading="" trailing=" " raw_val="i" val="i"/>
                      <IdentNode start="(405, 16)" end="(405, 17)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(405, 17)" end="(405, 18)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(405, 19)" end="(405, 56)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;a : α&#10;⊢ l.insertIdx i a = l.insertIdxTR i a" state_after="no goals" tactic="simp [insertIdxTR, insertIdxTR_go_eq]">
                    <AtomNode start="(405, 19)" end="(405, 23)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(405, 24)" end="(405, 56)">
                      <AtomNode start="(405, 24)" end="(405, 25)" leading="" trailing="" val="["/>
                      <NullNode start="(405, 25)" end="(405, 55)">
                        <OtherNode start="(405, 25)" end="(405, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(405, 25)" end="(405, 36)" leading="" trailing="" raw_val="insertIdxTR" val="insertIdxTR" full_name="List.insertIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(393, 15)" def_end="(393, 26)"/>
                        </OtherNode>
                        <AtomNode start="(405, 36)" end="(405, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(405, 38)" end="(405, 55)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(405, 38)" end="(405, 55)" leading="" trailing="" raw_val="insertIdxTR_go_eq" val="insertIdxTR_go_eq" full_name="List.insertIdxTR_go_eq" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(400, 9)" def_end="(400, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(405, 55)" end="(405, 56)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(407, 1)" end="(407, 17)" comment="### erase -/">
      <AtomNode start="(407, 1)" end="(407, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(407, 5)" end="(407, 17)" leading="" trailing="&#10;&#10;" val="### erase -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(409, 1)" end="(426, 78)" name="eraseTR" full_name="List.eraseTR">
      <CommandDeclmodifiersNode start="(409, 1)" end="(421, 10)">
        <NullNode start="(409, 1)" end="(420, 3)">
          <CommandDoccommentNode start="(409, 1)" end="(420, 3)" comment="Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned&#10;unmodified.&#10;&#10;`O(|l|)`.&#10;&#10;This is a tail-recursive version of `List.erase`, used in runtime code.&#10;&#10;Examples:&#10;* `[1, 5, 3, 2, 5].eraseTR 5 = [1, 3, 2, 5]`&#10;* `[1, 5, 3, 2, 5].eraseTR 6 = [1, 5, 3, 2, 5]`&#10;-/">
            <AtomNode start="(409, 1)" end="(409, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(410, 1)" end="(420, 3)" leading="" trailing="&#10;" val="Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned&#10;unmodified.&#10;&#10;`O(|l|)`.&#10;&#10;This is a tail-recursive version of `List.erase`, used in runtime code.&#10;&#10;Examples:&#10;* `[1, 5, 3, 2, 5].eraseTR 5 = [1, 3, 2, 5]`&#10;* `[1, 5, 3, 2, 5].eraseTR 6 = [1, 5, 3, 2, 5]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(421, 1)" end="(421, 10)">
          <OtherNode start="(421, 1)" end="(421, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(421, 1)" end="(421, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(421, 3)" end="(421, 9)">
              <OtherNode start="(421, 3)" end="(421, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(421, 3)" end="(421, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(421, 3)" end="(421, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(421, 9)" end="(421, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(421, 11)" end="(426, 78)" name="eraseTR">
        <AtomNode start="(421, 11)" end="(421, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(421, 15)" end="(421, 22)">
          <IdentNode start="(421, 15)" end="(421, 22)" leading="" trailing=" " raw_val="eraseTR" val="eraseTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(421, 23)" end="(421, 60)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(421, 23)" end="(421, 51)">
            <OtherNode start="(421, 23)" end="(421, 30)" kind="Lean.Parser.Term.instBinder">
              <AtomNode start="(421, 23)" end="(421, 24)" leading="" trailing="" val="["/>
              <NullNode/>
              <OtherNode start="(421, 24)" end="(421, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(421, 24)" end="(421, 27)" leading="" trailing=" " raw_val="BEq" val="BEq" full_name="BEq" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(421, 28)" end="(421, 29)">
                  <IdentNode start="(421, 28)" end="(421, 29)" leading="" trailing="" raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(421, 29)" end="(421, 30)" leading="" trailing=" " val="]"/>
            </OtherNode>
            <TermExplicitbinderNode start="(421, 31)" end="(421, 43)">
              <AtomNode start="(421, 31)" end="(421, 32)" leading="" trailing="" val="("/>
              <NullNode start="(421, 32)" end="(421, 33)">
                <IdentNode start="(421, 32)" end="(421, 33)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(421, 34)" end="(421, 42)">
                <AtomNode start="(421, 34)" end="(421, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(421, 36)" end="(421, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(421, 36)" end="(421, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(421, 41)" end="(421, 42)">
                    <IdentNode start="(421, 41)" end="(421, 42)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(421, 42)" end="(421, 43)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(421, 44)" end="(421, 51)">
              <AtomNode start="(421, 44)" end="(421, 45)" leading="" trailing="" val="("/>
              <NullNode start="(421, 45)" end="(421, 46)">
                <IdentNode start="(421, 45)" end="(421, 46)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(421, 47)" end="(421, 50)">
                <AtomNode start="(421, 47)" end="(421, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(421, 49)" end="(421, 50)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(421, 50)" end="(421, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(421, 52)" end="(421, 60)">
            <TermTypespecNode start="(421, 52)" end="(421, 60)">
              <AtomNode start="(421, 52)" end="(421, 53)" leading="" trailing=" " val=":"/>
              <OtherNode start="(421, 54)" end="(421, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(421, 54)" end="(421, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(421, 59)" end="(421, 60)">
                  <IdentNode start="(421, 59)" end="(421, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(421, 61)" end="(426, 78)">
          <AtomNode start="(421, 61)" end="(421, 63)" leading="" trailing=" " val=":="/>
          <OtherNode start="(421, 64)" end="(421, 72)" kind="Lean.Parser.Term.app">
            <IdentNode start="(421, 64)" end="(421, 66)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(421, 67)" end="(421, 72)">
              <IdentNode start="(421, 67)" end="(421, 68)" leading="" trailing=" " raw_val="l" val="l"/>
              <OtherNode start="(421, 69)" end="(421, 72)" kind="«term#[_,]»">
                <AtomNode start="(421, 69)" end="(421, 71)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(421, 71)" end="(421, 72)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(421, 73)" end="(426, 78)">
            <OtherNode start="(421, 73)" end="(426, 78)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(421, 73)" end="(421, 78)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(422, 3)" end="(426, 78)">
                <OtherNode start="(422, 3)" end="(426, 78)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(422, 3)" end="(423, 60)">
                    <CommandDoccommentNode start="(422, 3)" end="(423, 60)" comment="Auxiliary for `eraseTR`: `eraseTR.go l a xs acc = acc.toList ++ erase xs a`,&#10;  unless `a` is not present in which case it returns `l` -/">
                      <AtomNode start="(422, 3)" end="(422, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(422, 7)" end="(423, 60)" leading="" trailing="&#10;  " val="Auxiliary for `eraseTR`: `eraseTR.go l a xs acc = acc.toList ++ erase xs a`,&#10;  unless `a` is not present in which case it returns `l` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(424, 3)" end="(426, 78)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(424, 3)" end="(426, 78)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(424, 3)" end="(424, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(424, 6)" end="(424, 33)">
                        <TermTypespecNode start="(424, 6)" end="(424, 33)">
                          <AtomNode start="(424, 6)" end="(424, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(424, 8)" end="(424, 33)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(424, 8)" end="(424, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(424, 8)" end="(424, 12)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(424, 13)" end="(424, 14)">
                                <IdentNode start="(424, 13)" end="(424, 14)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(424, 15)" end="(424, 16)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(424, 17)" end="(424, 33)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(424, 17)" end="(424, 24)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(424, 17)" end="(424, 22)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(424, 23)" end="(424, 24)">
                                  <IdentNode start="(424, 23)" end="(424, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(424, 25)" end="(424, 26)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(424, 27)" end="(424, 33)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(424, 27)" end="(424, 31)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(424, 32)" end="(424, 33)">
                                  <IdentNode start="(424, 32)" end="(424, 33)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(425, 3)" end="(426, 78)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(425, 3)" end="(426, 78)">
                          <OtherNode start="(425, 3)" end="(425, 15)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(425, 3)" end="(425, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(425, 5)" end="(425, 10)">
                              <NullNode start="(425, 5)" end="(425, 10)">
                                <OtherNode start="(425, 5)" end="(425, 7)" kind="«term[_]»">
                                  <AtomNode start="(425, 5)" end="(425, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(425, 6)" end="(425, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(425, 7)" end="(425, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(425, 9)" end="(425, 10)">
                                  <AtomNode start="(425, 9)" end="(425, 10)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(425, 11)" end="(425, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(425, 14)" end="(425, 15)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(426, 3)" end="(426, 78)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(426, 3)" end="(426, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(426, 5)" end="(426, 15)">
                              <NullNode start="(426, 5)" end="(426, 15)">
                                <OtherNode start="(426, 5)" end="(426, 10)" kind="«term_::_»">
                                  <IdentNode start="(426, 5)" end="(426, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                  <AtomNode start="(426, 6)" end="(426, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(426, 8)" end="(426, 10)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                                <AtomNode start="(426, 10)" end="(426, 11)" leading="" trailing=" " val=","/>
                                <IdentNode start="(426, 12)" end="(426, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(426, 16)" end="(426, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(426, 19)" end="(426, 78)" kind="boolIfThenElse">
                              <AtomNode start="(426, 19)" end="(426, 22)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(426, 23)" end="(426, 29)" kind="«term_==_»">
                                <IdentNode start="(426, 23)" end="(426, 24)" leading="" trailing=" " raw_val="x" val="x"/>
                                <AtomNode start="(426, 25)" end="(426, 27)" leading="" trailing=" " val="=="/>
                                <IdentNode start="(426, 28)" end="(426, 29)" leading="" trailing=" " raw_val="a" val="a"/>
                              </OtherNode>
                              <AtomNode start="(426, 30)" end="(426, 34)" leading="" trailing=" " val="then"/>
                              <OtherNode start="(426, 35)" end="(426, 54)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(426, 35)" end="(426, 51)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                                <NullNode start="(426, 52)" end="(426, 54)">
                                  <IdentNode start="(426, 52)" end="(426, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(426, 55)" end="(426, 59)" leading="" trailing=" " val="else"/>
                              <OtherNode start="(426, 60)" end="(426, 78)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(426, 60)" end="(426, 62)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(426, 63)" end="(426, 78)">
                                  <IdentNode start="(426, 63)" end="(426, 65)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <OtherNode start="(426, 66)" end="(426, 78)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(426, 66)" end="(426, 67)" leading="" trailing="" val="("/>
                                    <OtherNode start="(426, 67)" end="(426, 77)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(426, 67)" end="(426, 75)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                      <NullNode start="(426, 76)" end="(426, 77)">
                                        <IdentNode start="(426, 76)" end="(426, 77)" leading="" trailing="" raw_val="x" val="x"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(426, 77)" end="(426, 78)" leading="" trailing="&#10;&#10;" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(428, 1)" end="(438, 11)" name="erase_eq_eraseTR" full_name="List.erase_eq_eraseTR">
      <CommandDeclmodifiersNode start="(428, 1)" end="(428, 9)">
        <NullNode/>
        <NullNode start="(428, 1)" end="(428, 9)">
          <OtherNode start="(428, 1)" end="(428, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(428, 1)" end="(428, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(428, 3)" end="(428, 8)">
              <OtherNode start="(428, 3)" end="(428, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(428, 3)" end="(428, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(428, 3)" end="(428, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(428, 8)" end="(428, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(428, 10)" end="(438, 11)" name="erase_eq_eraseTR" full_name="List.erase_eq_eraseTR" _is_private_decl="False">
        <AtomNode start="(428, 10)" end="(428, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(428, 18)" end="(428, 34)">
          <IdentNode start="(428, 18)" end="(428, 34)" leading="" trailing=" " raw_val="erase_eq_eraseTR" val="erase_eq_eraseTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(428, 35)" end="(428, 59)">
          <NullNode/>
          <TermTypespecNode start="(428, 35)" end="(428, 59)">
            <AtomNode start="(428, 35)" end="(428, 36)" leading="" trailing=" " val=":"/>
            <OtherNode start="(428, 37)" end="(428, 59)" kind="«term_=_»">
              <OtherNode start="(428, 37)" end="(428, 48)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(428, 37)" end="(428, 38)" leading="" trailing="" val="@"/>
                <IdentNode start="(428, 38)" end="(428, 48)" leading="" trailing=" " raw_val="List.erase" val="List.erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(428, 49)" end="(428, 50)" leading="" trailing=" " val="="/>
              <OtherNode start="(428, 51)" end="(428, 59)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(428, 51)" end="(428, 52)" leading="" trailing="" val="@"/>
                <IdentNode start="(428, 52)" end="(428, 59)" leading="" trailing=" " raw_val="eraseTR" val="eraseTR" full_name="List.eraseTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(421, 15)" def_end="(421, 22)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(428, 60)" end="(438, 11)">
          <AtomNode start="(428, 60)" end="(428, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(428, 63)" end="(438, 11)">
            <AtomNode start="(428, 63)" end="(428, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(429, 3)" end="(438, 11)">
              <TacticTacticseq1IndentedNode start="(429, 3)" end="(438, 11)">
                <NullNode start="(429, 3)" end="(438, 11)">
                  <OtherNode start="(429, 3)" end="(429, 17)" kind="tacticFunext___" state_before="⊢ @List.erase = @eraseTR" state_after="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a = l.eraseTR a" tactic="funext α _ l a">
                    <AtomNode start="(429, 3)" end="(429, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(429, 10)" end="(429, 17)">
                      <IdentNode start="(429, 10)" end="(429, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <TermHoleNode start="(429, 12)" end="(429, 13)">
                        <AtomNode start="(429, 12)" end="(429, 13)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                      <IdentNode start="(429, 14)" end="(429, 15)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(429, 16)" end="(429, 17)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(429, 17)" end="(429, 18)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(429, 19)" end="(429, 33)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a = l.eraseTR a" state_after="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a = eraseTR.go l a l #[]" tactic="simp [eraseTR]">
                    <AtomNode start="(429, 19)" end="(429, 23)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(429, 24)" end="(429, 33)">
                      <AtomNode start="(429, 24)" end="(429, 25)" leading="" trailing="" val="["/>
                      <NullNode start="(429, 25)" end="(429, 32)">
                        <OtherNode start="(429, 25)" end="(429, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(429, 25)" end="(429, 32)" leading="" trailing="" raw_val="eraseTR" val="eraseTR" full_name="List.eraseTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(421, 15)" def_end="(421, 22)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(429, 32)" end="(429, 33)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(430, 3)" end="(431, 32)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ l.erase a = eraseTR.go l a l #[]" state_after="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a" tactic="suffices ∀ xs acc, l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a from&#10;  (this l #[] (by simp)).symm">
                    <AtomNode start="(430, 3)" end="(430, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(430, 12)" end="(431, 32)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(430, 12)" end="(430, 12)" kind="hygieneInfo">
                        <IdentNode start="(430, 12)" end="(430, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(430, 12)" end="(430, 93)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(430, 12)" end="(430, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(430, 14)" end="(430, 20)">
                          <IdentNode start="(430, 14)" end="(430, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <IdentNode start="(430, 17)" end="(430, 20)" leading="" trailing="" raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(430, 20)" end="(430, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(430, 22)" end="(430, 93)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(430, 22)" end="(430, 42)" kind="«term_=_»">
                            <IdentNode start="(430, 22)" end="(430, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                            <AtomNode start="(430, 24)" end="(430, 25)" leading="" trailing=" " val="="/>
                            <OtherNode start="(430, 26)" end="(430, 42)" kind="«term_++_»">
                              <IdentNode start="(430, 26)" end="(430, 36)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(430, 37)" end="(430, 39)" leading="" trailing=" " val="++"/>
                              <IdentNode start="(430, 40)" end="(430, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(430, 43)" end="(430, 44)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(430, 45)" end="(430, 93)" kind="«term_=_»">
                            <OtherNode start="(430, 45)" end="(430, 66)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(430, 45)" end="(430, 55)" leading="" trailing=" " raw_val="eraseTR.go" val="eraseTR.go" full_name="List.eraseTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(424, 3)" def_end="(424, 5)"/>
                              <NullNode start="(430, 56)" end="(430, 66)">
                                <IdentNode start="(430, 56)" end="(430, 57)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(430, 58)" end="(430, 59)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(430, 60)" end="(430, 62)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(430, 63)" end="(430, 66)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(430, 67)" end="(430, 68)" leading="" trailing=" " val="="/>
                            <OtherNode start="(430, 69)" end="(430, 93)" kind="«term_++_»">
                              <IdentNode start="(430, 69)" end="(430, 79)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(430, 80)" end="(430, 82)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(430, 83)" end="(430, 93)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(430, 83)" end="(430, 91)" leading="" trailing=" " raw_val="xs.erase" val="xs.erase"/>
                                <NullNode start="(430, 92)" end="(430, 93)">
                                  <IdentNode start="(430, 92)" end="(430, 93)" leading="" trailing=" " raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(430, 94)" end="(431, 32)" kind="Lean.Parser.Term.fromTerm">
                        <AtomNode start="(430, 94)" end="(430, 98)" leading="" trailing="&#10;    " val="from"/>
                        <OtherNode start="(431, 5)" end="(431, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(431, 5)" end="(431, 27)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(431, 5)" end="(431, 6)" leading="" trailing="" val="("/>
                            <OtherNode start="(431, 6)" end="(431, 26)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(431, 6)" end="(431, 10)" leading="" trailing=" " raw_val="this" val="this"/>
                              <NullNode start="(431, 11)" end="(431, 26)">
                                <IdentNode start="(431, 11)" end="(431, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(431, 13)" end="(431, 16)" kind="«term#[_,]»">
                                  <AtomNode start="(431, 13)" end="(431, 15)" leading="" trailing="" val="#["/>
                                  <NullNode/>
                                  <AtomNode start="(431, 15)" end="(431, 16)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                                <OtherNode start="(431, 17)" end="(431, 26)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(431, 17)" end="(431, 18)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(431, 18)" end="(431, 25)">
                                    <AtomNode start="(431, 18)" end="(431, 20)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(431, 21)" end="(431, 25)">
                                      <TacticTacticseq1IndentedNode start="(431, 21)" end="(431, 25)">
                                        <NullNode start="(431, 21)" end="(431, 25)">
                                          <OtherNode start="(431, 21)" end="(431, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;this : ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;⊢ l = #[].toList ++ l" state_after="no goals" tactic="simp">
                                            <AtomNode start="(431, 21)" end="(431, 25)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(431, 25)" end="(431, 26)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(431, 26)" end="(431, 27)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(431, 27)" end="(431, 28)" leading="" trailing="" val="."/>
                          <IdentNode start="(431, 28)" end="(431, 32)" leading="" trailing="&#10;  " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(432, 3)" end="(432, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a" state_after="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a" tactic="intro xs">
                    <AtomNode start="(432, 3)" end="(432, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(432, 9)" end="(432, 11)">
                      <IdentNode start="(432, 9)" end="(432, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(432, 11)" end="(432, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(432, 13)" end="(438, 11)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h.h&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a" state_after="no goals" tactic="induction xs with intro acc h&#10;| nil =&amp;gt; simp [List.erase, eraseTR.go, h]&#10;| cons x xs IH =&amp;gt;&#10;simp only [eraseTR.go, Array.toListAppend_eq, List.erase]&#10;cases x == a&#10;· rw [IH] &amp;lt;;&amp;gt; simp_all&#10;· simp">
                    <AtomNode start="(432, 13)" end="(432, 22)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(432, 23)" end="(432, 25)">
                      <OtherNode start="(432, 23)" end="(432, 25)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(432, 23)" end="(432, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(432, 26)" end="(438, 11)">
                      <OtherNode start="(432, 26)" end="(438, 11)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(432, 26)" end="(432, 30)" leading="" trailing=" " val="with"/>
                        <NullNode start="(432, 31)" end="(432, 42)">
                          <OtherNode start="(432, 31)" end="(432, 42)" kind="Lean.Parser.Tactic.intro">
                            <AtomNode start="(432, 31)" end="(432, 36)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(432, 37)" end="(432, 42)">
                              <IdentNode start="(432, 37)" end="(432, 40)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              <IdentNode start="(432, 41)" end="(432, 42)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(433, 3)" end="(438, 11)">
                          <OtherNode start="(433, 3)" end="(433, 44)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(433, 3)" end="(433, 8)">
                              <OtherNode start="(433, 3)" end="(433, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(433, 3)" end="(433, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(433, 5)" end="(433, 8)">
                                  <NullNode/>
                                  <IdentNode start="(433, 5)" end="(433, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(433, 9)" end="(433, 44)">
                              <AtomNode start="(433, 9)" end="(433, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(433, 12)" end="(433, 44)">
                                <TacticTacticseq1IndentedNode start="(433, 12)" end="(433, 44)">
                                  <NullNode start="(433, 12)" end="(433, 44)">
                                    <OtherNode start="(433, 12)" end="(433, 44)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.nil&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a : α&#10;acc : Array α&#10;h : l = acc.toList ++ []&#10;⊢ eraseTR.go l a [] acc = acc.toList ++ [].erase a" state_after="no goals" tactic="simp [List.erase, eraseTR.go, h]">
                                      <AtomNode start="(433, 12)" end="(433, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(433, 17)" end="(433, 44)">
                                        <AtomNode start="(433, 17)" end="(433, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(433, 18)" end="(433, 43)">
                                          <OtherNode start="(433, 18)" end="(433, 28)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(433, 18)" end="(433, 28)" leading="" trailing="" raw_val="List.erase" val="List.erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(433, 28)" end="(433, 29)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(433, 30)" end="(433, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(433, 30)" end="(433, 40)" leading="" trailing="" raw_val="eraseTR.go" val="eraseTR.go" full_name="List.eraseTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(424, 3)" def_end="(424, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(433, 40)" end="(433, 41)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(433, 42)" end="(433, 43)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(433, 42)" end="(433, 43)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(433, 43)" end="(433, 44)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(434, 3)" end="(438, 11)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(434, 3)" end="(434, 17)">
                              <OtherNode start="(434, 3)" end="(434, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(434, 3)" end="(434, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(434, 5)" end="(434, 9)">
                                  <NullNode/>
                                  <IdentNode start="(434, 5)" end="(434, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(434, 10)" end="(434, 17)">
                                  <IdentNode start="(434, 10)" end="(434, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(434, 12)" end="(434, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(434, 15)" end="(434, 17)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(434, 18)" end="(438, 11)">
                              <AtomNode start="(434, 18)" end="(434, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(435, 5)" end="(438, 11)">
                                <TacticTacticseq1IndentedNode start="(435, 5)" end="(438, 11)">
                                  <NullNode start="(435, 5)" end="(438, 11)">
                                    <OtherNode start="(435, 5)" end="(435, 62)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.cons&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ eraseTR.go l a (x :: xs) acc = acc.toList ++ (x :: xs).erase a" state_after="case h.h.h.h.cons&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif x == a then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match x == a with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" tactic="simp only [eraseTR.go, Array.toListAppend_eq, List.erase]">
                                      <AtomNode start="(435, 5)" end="(435, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(435, 10)" end="(435, 14)">
                                        <AtomNode start="(435, 10)" end="(435, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(435, 15)" end="(435, 62)">
                                        <AtomNode start="(435, 15)" end="(435, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(435, 16)" end="(435, 61)">
                                          <OtherNode start="(435, 16)" end="(435, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(435, 16)" end="(435, 26)" leading="" trailing="" raw_val="eraseTR.go" val="eraseTR.go" full_name="List.eraseTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(424, 3)" def_end="(424, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(435, 26)" end="(435, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(435, 28)" end="(435, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(435, 28)" end="(435, 49)" leading="" trailing="" raw_val="Array.toListAppend_eq" val="Array.toListAppend_eq" full_name="Array.toListAppend_eq" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(435, 49)" end="(435, 50)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(435, 51)" end="(435, 61)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(435, 51)" end="(435, 61)" leading="" trailing="" raw_val="List.erase" val="List.erase" full_name="List.erase" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(435, 61)" end="(435, 62)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(436, 5)" end="(436, 17)" kind="Lean.Parser.Tactic.cases" state_before="case h.h.h.h.cons&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif x == a then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match x == a with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" state_after="case h.h.h.h.cons.false&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif false then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match false with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a&#10;&#10;case h.h.h.h.cons.true&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif true then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match true with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" tactic="cases x == a">
                                      <AtomNode start="(436, 5)" end="(436, 10)" leading="" trailing=" " val="cases"/>
                                      <NullNode start="(436, 11)" end="(436, 17)">
                                        <OtherNode start="(436, 11)" end="(436, 17)" kind="Lean.Parser.Tactic.elimTarget">
                                          <NullNode/>
                                          <OtherNode start="(436, 11)" end="(436, 17)" kind="«term_==_»">
                                            <IdentNode start="(436, 11)" end="(436, 12)" leading="" trailing=" " raw_val="x" val="x"/>
                                            <AtomNode start="(436, 13)" end="(436, 15)" leading="" trailing=" " val="=="/>
                                            <IdentNode start="(436, 16)" end="(436, 17)" leading="" trailing="&#10;    " raw_val="a" val="a"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                      <NullNode/>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(437, 5)" end="(437, 27)" kind="Lean.cdot" state_before="case h.h.h.h.cons.false&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif false then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match false with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a&#10;&#10;case h.h.h.h.cons.true&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif true then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match true with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" state_after="case h.h.h.h.cons.true&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif true then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match true with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" tactic="· rw [IH] &amp;lt;;&amp;gt; simp_all">
                                      <OtherNode start="(437, 5)" end="(437, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(437, 5)" end="(437, 6)" kind="patternIgnore">
                                          <OtherNode start="(437, 5)" end="(437, 6)" kind="token.«· »">
                                            <AtomNode start="(437, 5)" end="(437, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(437, 7)" end="(437, 27)">
                                        <TacticTacticseq1IndentedNode start="(437, 7)" end="(437, 27)">
                                          <NullNode start="(437, 7)" end="(437, 27)">
                                            <OtherNode start="(437, 7)" end="(437, 27)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="case h.h.h.h.cons.false&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif false then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match false with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" state_after="no goals" tactic="rw [IH] &amp;lt;;&amp;gt; simp_all">
                                              <OtherNode start="(437, 7)" end="(437, 14)" kind="Lean.Parser.Tactic.rwSeq">
                                                <AtomNode start="(437, 7)" end="(437, 9)" leading="" trailing=" " val="rw"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <OtherNode start="(437, 10)" end="(437, 14)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                  <AtomNode start="(437, 10)" end="(437, 11)" leading="" trailing="" val="["/>
                                                  <NullNode start="(437, 11)" end="(437, 13)">
                                                    <OtherNode start="(437, 11)" end="(437, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                      <NullNode/>
                                                      <IdentNode start="(437, 11)" end="(437, 13)" leading="" trailing="" raw_val="IH" val="IH"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(437, 13)" end="(437, 14)" leading="" trailing=" " val="]"/>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(437, 15)" end="(437, 18)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(437, 19)" end="(437, 27)" kind="Lean.Parser.Tactic.simpAll">
                                                <AtomNode start="(437, 19)" end="(437, 27)" leading="" trailing="&#10;    " val="simp_all"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(438, 5)" end="(438, 11)" kind="Lean.cdot" state_before="case h.h.h.h.cons.true&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif true then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match true with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" state_after="no goals" tactic="· simp">
                                      <OtherNode start="(438, 5)" end="(438, 6)" kind="Lean.cdotTk">
                                        <OtherNode start="(438, 5)" end="(438, 6)" kind="patternIgnore">
                                          <OtherNode start="(438, 5)" end="(438, 6)" kind="token.«· »">
                                            <AtomNode start="(438, 5)" end="(438, 6)" leading="" trailing=" " val="·"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                      <TacticTacticseqNode start="(438, 7)" end="(438, 11)">
                                        <TacticTacticseq1IndentedNode start="(438, 7)" end="(438, 11)">
                                          <NullNode start="(438, 7)" end="(438, 11)">
                                            <OtherNode start="(438, 7)" end="(438, 11)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.h.cons.true&#10;α : Type u_1&#10;x✝ : BEq α&#10;l : List α&#10;a x : α&#10;xs : List α&#10;IH : ∀ (acc : Array α), l = acc.toList ++ xs → eraseTR.go l a xs acc = acc.toList ++ xs.erase a&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (bif true then acc.toList ++ xs else eraseTR.go l a xs (acc.push x)) =&#10;    acc.toList ++&#10;      match true with&#10;      | true =&amp;gt; xs&#10;      | false =&amp;gt; x :: xs.erase a" state_after="no goals" tactic="simp">
                                              <AtomNode start="(438, 7)" end="(438, 11)" leading="" trailing="&#10;&#10;" val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(440, 1)" end="(456, 74)" name="erasePTR" full_name="List.erasePTR">
      <CommandDeclmodifiersNode start="(440, 1)" end="(451, 10)">
        <NullNode start="(440, 1)" end="(450, 3)">
          <CommandDoccommentNode start="(440, 1)" end="(450, 3)" comment="Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then&#10;the list is returned unchanged.&#10;&#10;This is a tail-recursive version of `eraseP`, used at runtime.&#10;&#10;Examples:&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &amp;lt; 2) = [2, 2, 1, 3, 4]`&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &amp;gt; 2) = [2, 1, 2, 1, 4]`&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &amp;gt; 8) = [2, 1, 2, 1, 3, 4]`&#10;-/">
            <AtomNode start="(440, 1)" end="(440, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(441, 1)" end="(450, 3)" leading="" trailing="&#10;" val="Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then&#10;the list is returned unchanged.&#10;&#10;This is a tail-recursive version of `eraseP`, used at runtime.&#10;&#10;Examples:&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &amp;lt; 2) = [2, 2, 1, 3, 4]`&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &amp;gt; 2) = [2, 1, 2, 1, 4]`&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &amp;gt; 8) = [2, 1, 2, 1, 3, 4]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(451, 1)" end="(451, 10)">
          <OtherNode start="(451, 1)" end="(451, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(451, 1)" end="(451, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(451, 3)" end="(451, 9)">
              <OtherNode start="(451, 3)" end="(451, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(451, 3)" end="(451, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(451, 3)" end="(451, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(451, 9)" end="(451, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(451, 11)" end="(456, 74)" name="erasePTR">
        <AtomNode start="(451, 11)" end="(451, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(451, 15)" end="(451, 23)">
          <IdentNode start="(451, 15)" end="(451, 23)" leading="" trailing=" " raw_val="erasePTR" val="erasePTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(451, 24)" end="(451, 60)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(451, 24)" end="(451, 51)">
            <TermExplicitbinderNode start="(451, 24)" end="(451, 38)">
              <AtomNode start="(451, 24)" end="(451, 25)" leading="" trailing="" val="("/>
              <NullNode start="(451, 25)" end="(451, 26)">
                <IdentNode start="(451, 25)" end="(451, 26)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(451, 27)" end="(451, 37)">
                <AtomNode start="(451, 27)" end="(451, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(451, 29)" end="(451, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(451, 29)" end="(451, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(451, 31)" end="(451, 32)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(451, 33)" end="(451, 37)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(451, 37)" end="(451, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(451, 39)" end="(451, 51)">
              <AtomNode start="(451, 39)" end="(451, 40)" leading="" trailing="" val="("/>
              <NullNode start="(451, 40)" end="(451, 41)">
                <IdentNode start="(451, 40)" end="(451, 41)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(451, 42)" end="(451, 50)">
                <AtomNode start="(451, 42)" end="(451, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(451, 44)" end="(451, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(451, 44)" end="(451, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(451, 49)" end="(451, 50)">
                    <IdentNode start="(451, 49)" end="(451, 50)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(451, 50)" end="(451, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(451, 52)" end="(451, 60)">
            <TermTypespecNode start="(451, 52)" end="(451, 60)">
              <AtomNode start="(451, 52)" end="(451, 53)" leading="" trailing=" " val=":"/>
              <OtherNode start="(451, 54)" end="(451, 60)" kind="Lean.Parser.Term.app">
                <IdentNode start="(451, 54)" end="(451, 58)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(451, 59)" end="(451, 60)">
                  <IdentNode start="(451, 59)" end="(451, 60)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(451, 61)" end="(456, 74)">
          <AtomNode start="(451, 61)" end="(451, 63)" leading="" trailing=" " val=":="/>
          <OtherNode start="(451, 64)" end="(451, 72)" kind="Lean.Parser.Term.app">
            <IdentNode start="(451, 64)" end="(451, 66)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(451, 67)" end="(451, 72)">
              <IdentNode start="(451, 67)" end="(451, 68)" leading="" trailing=" " raw_val="l" val="l"/>
              <OtherNode start="(451, 69)" end="(451, 72)" kind="«term#[_,]»">
                <AtomNode start="(451, 69)" end="(451, 71)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(451, 71)" end="(451, 72)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(451, 73)" end="(456, 74)">
            <OtherNode start="(451, 73)" end="(456, 74)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(451, 73)" end="(451, 78)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(452, 3)" end="(456, 74)">
                <OtherNode start="(452, 3)" end="(456, 74)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(452, 3)" end="(453, 85)">
                    <CommandDoccommentNode start="(452, 3)" end="(453, 85)" comment="Auxiliary for `erasePTR`: `erasePTR.go p l xs acc = acc.toList ++ eraseP p xs`,&#10;  unless `xs` does not contain any elements satisfying `p`, where it returns `l`. -/">
                      <AtomNode start="(452, 3)" end="(452, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(452, 7)" end="(453, 85)" leading="" trailing="&#10;  " val="Auxiliary for `erasePTR`: `erasePTR.go p l xs acc = acc.toList ++ eraseP p xs`,&#10;  unless `xs` does not contain any elements satisfying `p`, where it returns `l`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode start="(454, 3)" end="(454, 16)">
                    <OtherNode start="(454, 3)" end="(454, 16)" kind="Lean.Parser.Term.attributes">
                      <AtomNode start="(454, 3)" end="(454, 5)" leading="" trailing="" val="@["/>
                      <NullNode start="(454, 5)" end="(454, 15)">
                        <OtherNode start="(454, 5)" end="(454, 15)" kind="Lean.Parser.Term.attrInstance">
                          <TermAttrkindNode>
                            <NullNode/>
                          </TermAttrkindNode>
                          <OtherNode start="(454, 5)" end="(454, 15)" kind="Lean.Parser.Attr.specialize">
                            <AtomNode start="(454, 5)" end="(454, 15)" leading="" trailing="" val="specialize"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(454, 15)" end="(454, 16)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                  </NullNode>
                  <OtherNode start="(454, 17)" end="(456, 74)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(454, 17)" end="(456, 74)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(454, 17)" end="(454, 19)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(454, 20)" end="(454, 47)">
                        <TermTypespecNode start="(454, 20)" end="(454, 47)">
                          <AtomNode start="(454, 20)" end="(454, 21)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(454, 22)" end="(454, 47)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(454, 22)" end="(454, 28)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(454, 22)" end="(454, 26)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(454, 27)" end="(454, 28)">
                                <IdentNode start="(454, 27)" end="(454, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(454, 29)" end="(454, 30)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(454, 31)" end="(454, 47)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(454, 31)" end="(454, 38)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(454, 31)" end="(454, 36)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(454, 37)" end="(454, 38)">
                                  <IdentNode start="(454, 37)" end="(454, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(454, 39)" end="(454, 40)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(454, 41)" end="(454, 47)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(454, 41)" end="(454, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(454, 46)" end="(454, 47)">
                                  <IdentNode start="(454, 46)" end="(454, 47)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(455, 3)" end="(456, 74)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(455, 3)" end="(456, 74)">
                          <OtherNode start="(455, 3)" end="(455, 15)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(455, 3)" end="(455, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(455, 5)" end="(455, 10)">
                              <NullNode start="(455, 5)" end="(455, 10)">
                                <OtherNode start="(455, 5)" end="(455, 7)" kind="«term[_]»">
                                  <AtomNode start="(455, 5)" end="(455, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(455, 6)" end="(455, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(455, 7)" end="(455, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(455, 9)" end="(455, 10)">
                                  <AtomNode start="(455, 9)" end="(455, 10)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(455, 11)" end="(455, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(455, 14)" end="(455, 15)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(456, 3)" end="(456, 74)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(456, 3)" end="(456, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(456, 5)" end="(456, 16)">
                              <NullNode start="(456, 5)" end="(456, 16)">
                                <OtherNode start="(456, 5)" end="(456, 11)" kind="«term_::_»">
                                  <IdentNode start="(456, 5)" end="(456, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(456, 7)" end="(456, 9)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(456, 10)" end="(456, 11)" leading="" trailing="" raw_val="l" val="l"/>
                                </OtherNode>
                                <AtomNode start="(456, 11)" end="(456, 12)" leading="" trailing=" " val=","/>
                                <IdentNode start="(456, 13)" end="(456, 16)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(456, 17)" end="(456, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(456, 20)" end="(456, 74)" kind="boolIfThenElse">
                              <AtomNode start="(456, 20)" end="(456, 23)" leading="" trailing=" " val="bif"/>
                              <OtherNode start="(456, 24)" end="(456, 27)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(456, 24)" end="(456, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(456, 26)" end="(456, 27)">
                                  <IdentNode start="(456, 26)" end="(456, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(456, 28)" end="(456, 32)" leading="" trailing=" " val="then"/>
                              <OtherNode start="(456, 33)" end="(456, 51)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(456, 33)" end="(456, 49)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                                <NullNode start="(456, 50)" end="(456, 51)">
                                  <IdentNode start="(456, 50)" end="(456, 51)" leading="" trailing=" " raw_val="l" val="l"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(456, 52)" end="(456, 56)" leading="" trailing=" " val="else"/>
                              <OtherNode start="(456, 57)" end="(456, 74)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(456, 57)" end="(456, 59)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode start="(456, 60)" end="(456, 74)">
                                  <IdentNode start="(456, 60)" end="(456, 61)" leading="" trailing=" " raw_val="l" val="l"/>
                                  <OtherNode start="(456, 62)" end="(456, 74)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(456, 62)" end="(456, 63)" leading="" trailing="" val="("/>
                                    <OtherNode start="(456, 63)" end="(456, 73)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(456, 63)" end="(456, 71)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                      <NullNode start="(456, 72)" end="(456, 73)">
                                        <IdentNode start="(456, 72)" end="(456, 73)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(456, 73)" end="(456, 74)" leading="" trailing="&#10;&#10;" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(458, 1)" end="(466, 28)" name="eraseP_eq_erasePTR" full_name="List.eraseP_eq_erasePTR">
      <CommandDeclmodifiersNode start="(458, 1)" end="(458, 9)">
        <NullNode/>
        <NullNode start="(458, 1)" end="(458, 9)">
          <OtherNode start="(458, 1)" end="(458, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(458, 1)" end="(458, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(458, 3)" end="(458, 8)">
              <OtherNode start="(458, 3)" end="(458, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(458, 3)" end="(458, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(458, 3)" end="(458, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(458, 8)" end="(458, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(458, 10)" end="(466, 28)" name="eraseP_eq_erasePTR" full_name="List.eraseP_eq_erasePTR" _is_private_decl="False">
        <AtomNode start="(458, 10)" end="(458, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(458, 18)" end="(458, 36)">
          <IdentNode start="(458, 18)" end="(458, 36)" leading="" trailing=" " raw_val="eraseP_eq_erasePTR" val="eraseP_eq_erasePTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(458, 37)" end="(458, 58)">
          <NullNode/>
          <TermTypespecNode start="(458, 37)" end="(458, 58)">
            <AtomNode start="(458, 37)" end="(458, 38)" leading="" trailing=" " val=":"/>
            <OtherNode start="(458, 39)" end="(458, 58)" kind="«term_=_»">
              <OtherNode start="(458, 39)" end="(458, 46)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(458, 39)" end="(458, 40)" leading="" trailing="" val="@"/>
                <IdentNode start="(458, 40)" end="(458, 46)" leading="" trailing=" " raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(458, 47)" end="(458, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(458, 49)" end="(458, 58)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(458, 49)" end="(458, 50)" leading="" trailing="" val="@"/>
                <IdentNode start="(458, 50)" end="(458, 58)" leading="" trailing=" " raw_val="erasePTR" val="erasePTR" full_name="List.erasePTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(451, 15)" def_end="(451, 23)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(458, 59)" end="(466, 28)">
          <AtomNode start="(458, 59)" end="(458, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(458, 62)" end="(466, 28)">
            <AtomNode start="(458, 62)" end="(458, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(459, 3)" end="(466, 28)">
              <TacticTacticseq1IndentedNode start="(459, 3)" end="(466, 28)">
                <NullNode start="(459, 3)" end="(466, 28)">
                  <OtherNode start="(459, 3)" end="(459, 15)" kind="tacticFunext___" state_before="⊢ @eraseP = @erasePTR" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l = erasePTR p l" tactic="funext α p l">
                    <AtomNode start="(459, 3)" end="(459, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(459, 10)" end="(459, 15)">
                      <IdentNode start="(459, 10)" end="(459, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(459, 12)" end="(459, 13)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(459, 14)" end="(459, 15)" leading="" trailing="" raw_val="l" val="l"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(459, 15)" end="(459, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(459, 17)" end="(459, 32)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l = erasePTR p l" state_after="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l = erasePTR.go p l l #[]" tactic="simp [erasePTR]">
                    <AtomNode start="(459, 17)" end="(459, 21)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(459, 22)" end="(459, 32)">
                      <AtomNode start="(459, 22)" end="(459, 23)" leading="" trailing="" val="["/>
                      <NullNode start="(459, 23)" end="(459, 31)">
                        <OtherNode start="(459, 23)" end="(459, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(459, 23)" end="(459, 31)" leading="" trailing="" raw_val="erasePTR" val="erasePTR" full_name="List.erasePTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(451, 15)" def_end="(451, 23)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(459, 31)" end="(459, 32)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(460, 3)" end="(465, 46)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(460, 3)" end="(460, 6)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(460, 7)" end="(460, 10)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(460, 11)" end="(465, 46)" kind="Lean.Parser.Term.letRecDecls">
                      <NullNode start="(460, 11)" end="(465, 46)">
                        <OtherNode start="(460, 11)" end="(465, 46)" kind="Lean.Parser.Term.letRecDecl">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(460, 11)" end="(465, 46)" kind="Lean.Parser.Term.letDecl">
                            <OtherNode start="(460, 11)" end="(465, 46)" kind="Lean.Parser.Term.letEqnsDecl">
                              <IdentNode start="(460, 11)" end="(460, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(460, 14)" end="(460, 19)">
                                <TermExplicitbinderNode start="(460, 14)" end="(460, 19)">
                                  <AtomNode start="(460, 14)" end="(460, 15)" leading="" trailing="" val="("/>
                                  <NullNode start="(460, 15)" end="(460, 18)">
                                    <IdentNode start="(460, 15)" end="(460, 18)" leading="" trailing="" raw_val="acc" val="acc"/>
                                  </NullNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <AtomNode start="(460, 18)" end="(460, 19)" leading="" trailing=" " val=")"/>
                                </TermExplicitbinderNode>
                              </NullNode>
                              <NullNode start="(460, 20)" end="(461, 55)">
                                <TermTypespecNode start="(460, 20)" end="(461, 55)">
                                  <AtomNode start="(460, 20)" end="(460, 21)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(460, 22)" end="(461, 55)" kind="Lean.Parser.Term.forall">
                                    <AtomNode start="(460, 22)" end="(460, 23)" leading="" trailing=" " val="∀"/>
                                    <NullNode start="(460, 24)" end="(460, 26)">
                                      <IdentNode start="(460, 24)" end="(460, 26)" leading="" trailing="" raw_val="xs" val="xs"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(460, 26)" end="(460, 27)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(460, 28)" end="(461, 55)" kind="Lean.Parser.Term.arrow">
                                      <OtherNode start="(460, 28)" end="(460, 48)" kind="«term_=_»">
                                        <IdentNode start="(460, 28)" end="(460, 29)" leading="" trailing=" " raw_val="l" val="l"/>
                                        <AtomNode start="(460, 30)" end="(460, 31)" leading="" trailing=" " val="="/>
                                        <OtherNode start="(460, 32)" end="(460, 48)" kind="«term_++_»">
                                          <IdentNode start="(460, 32)" end="(460, 42)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                          <AtomNode start="(460, 43)" end="(460, 45)" leading="" trailing=" " val="++"/>
                                          <IdentNode start="(460, 46)" end="(460, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(460, 49)" end="(460, 50)" leading="" trailing="&#10;    " val="→"/>
                                      <OtherNode start="(461, 5)" end="(461, 55)" kind="«term_=_»">
                                        <OtherNode start="(461, 5)" end="(461, 27)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(461, 5)" end="(461, 16)" leading="" trailing=" " raw_val="erasePTR.go" val="erasePTR.go" full_name="List.erasePTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(454, 17)" def_end="(454, 19)"/>
                                          <NullNode start="(461, 17)" end="(461, 27)">
                                            <IdentNode start="(461, 17)" end="(461, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                                            <IdentNode start="(461, 19)" end="(461, 20)" leading="" trailing=" " raw_val="l" val="l"/>
                                            <IdentNode start="(461, 21)" end="(461, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                            <IdentNode start="(461, 24)" end="(461, 27)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(461, 28)" end="(461, 29)" leading="" trailing=" " val="="/>
                                        <OtherNode start="(461, 30)" end="(461, 55)" kind="«term_++_»">
                                          <IdentNode start="(461, 30)" end="(461, 40)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                          <AtomNode start="(461, 41)" end="(461, 43)" leading="" trailing=" " val="++"/>
                                          <OtherNode start="(461, 44)" end="(461, 55)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(461, 44)" end="(461, 53)" leading="" trailing=" " raw_val="xs.eraseP" val="xs.eraseP"/>
                                            <NullNode start="(461, 54)" end="(461, 55)">
                                              <IdentNode start="(461, 54)" end="(461, 55)" leading="" trailing="&#10;  " raw_val="p" val="p"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </TermTypespecNode>
                              </NullNode>
                              <OtherNode start="(462, 3)" end="(465, 46)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(462, 3)" end="(465, 46)">
                                  <OtherNode start="(462, 3)" end="(462, 52)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(462, 3)" end="(462, 4)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(462, 5)" end="(462, 7)">
                                      <NullNode start="(462, 5)" end="(462, 7)">
                                        <OtherNode start="(462, 5)" end="(462, 7)" kind="«term[_]»">
                                          <AtomNode start="(462, 5)" end="(462, 6)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(462, 6)" end="(462, 7)" leading="" trailing=" " val="]"/>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(462, 8)" end="(462, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <OtherNode start="(462, 11)" end="(462, 52)" kind="Lean.Parser.Term.fun">
                                      <AtomNode start="(462, 11)" end="(462, 14)" leading="" trailing=" " val="fun"/>
                                      <OtherNode start="(462, 15)" end="(462, 52)" kind="Lean.Parser.Term.basicFun">
                                        <NullNode start="(462, 15)" end="(462, 16)">
                                          <IdentNode start="(462, 15)" end="(462, 16)" leading="" trailing=" " raw_val="h" val="h"/>
                                        </NullNode>
                                        <NullNode/>
                                        <AtomNode start="(462, 17)" end="(462, 19)" leading="" trailing=" " val="=&amp;gt;"/>
                                        <TermBytacticNode start="(462, 20)" end="(462, 52)">
                                          <AtomNode start="(462, 20)" end="(462, 22)" leading="" trailing=" " val="by"/>
                                          <TacticTacticseqNode start="(462, 23)" end="(462, 52)">
                                            <TacticTacticseq1IndentedNode start="(462, 23)" end="(462, 52)">
                                              <NullNode start="(462, 23)" end="(462, 52)">
                                                <OtherNode start="(462, 23)" end="(462, 52)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;h : l = acc.toList ++ []&#10;⊢ erasePTR.go p l [] acc = acc.toList ++ eraseP p []" state_after="no goals" tactic="simp [erasePTR.go, eraseP, h]">
                                                  <AtomNode start="(462, 23)" end="(462, 27)" leading="" trailing=" " val="simp"/>
                                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <NullNode/>
                                                  <NullNode start="(462, 28)" end="(462, 52)">
                                                    <AtomNode start="(462, 28)" end="(462, 29)" leading="" trailing="" val="["/>
                                                    <NullNode start="(462, 29)" end="(462, 51)">
                                                      <OtherNode start="(462, 29)" end="(462, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(462, 29)" end="(462, 40)" leading="" trailing="" raw_val="erasePTR.go" val="erasePTR.go" full_name="List.erasePTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(454, 17)" def_end="(454, 19)"/>
                                                      </OtherNode>
                                                      <AtomNode start="(462, 40)" end="(462, 41)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(462, 42)" end="(462, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(462, 42)" end="(462, 48)" leading="" trailing="" raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                      </OtherNode>
                                                      <AtomNode start="(462, 48)" end="(462, 49)" leading="" trailing=" " val=","/>
                                                      <OtherNode start="(462, 50)" end="(462, 51)" kind="Lean.Parser.Tactic.simpLemma">
                                                        <NullNode/>
                                                        <NullNode/>
                                                        <IdentNode start="(462, 50)" end="(462, 51)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <AtomNode start="(462, 51)" end="(462, 52)" leading="" trailing="&#10;  " val="]"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                </OtherNode>
                                              </NullNode>
                                            </TacticTacticseq1IndentedNode>
                                          </TacticTacticseqNode>
                                        </TermBytacticNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(463, 3)" end="(465, 46)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(463, 3)" end="(463, 4)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(463, 5)" end="(463, 10)">
                                      <NullNode start="(463, 5)" end="(463, 10)">
                                        <OtherNode start="(463, 5)" end="(463, 10)" kind="«term_::_»">
                                          <IdentNode start="(463, 5)" end="(463, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                          <AtomNode start="(463, 6)" end="(463, 8)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(463, 8)" end="(463, 10)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(463, 11)" end="(463, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(463, 14)" end="(465, 46)">
                                      <AtomNode start="(463, 14)" end="(463, 16)" leading="" trailing="&#10;    " val="by"/>
                                      <TacticTacticseqNode start="(464, 5)" end="(465, 46)">
                                        <TacticTacticseq1IndentedNode start="(464, 5)" end="(465, 46)">
                                          <NullNode start="(464, 5)" end="(465, 46)">
                                            <OtherNode start="(464, 5)" end="(464, 31)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs → erasePTR.go p l (x :: xs) acc = acc.toList ++ eraseP p (x :: xs)" state_after="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then acc.toList ++ xs else erasePTR.go p l xs (acc.push x)) =&#10;      acc.toList ++ bif p x then xs else x :: eraseP p xs" tactic="simp [erasePTR.go, eraseP]">
                                              <AtomNode start="(464, 5)" end="(464, 9)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(464, 10)" end="(464, 31)">
                                                <AtomNode start="(464, 10)" end="(464, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(464, 11)" end="(464, 30)">
                                                  <OtherNode start="(464, 11)" end="(464, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(464, 11)" end="(464, 22)" leading="" trailing="" raw_val="erasePTR.go" val="erasePTR.go" full_name="List.erasePTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(454, 17)" def_end="(454, 19)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(464, 22)" end="(464, 23)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(464, 24)" end="(464, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(464, 24)" end="(464, 30)" leading="" trailing="" raw_val="eraseP" val="eraseP" full_name="List.eraseP" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(464, 30)" end="(464, 31)" leading="" trailing="" val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(464, 31)" end="(464, 32)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(464, 33)" end="(464, 51)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs →&#10;    (bif p x then acc.toList ++ xs else erasePTR.go p l xs (acc.push x)) =&#10;      acc.toList ++ bif p x then xs else x :: eraseP p xs" state_after="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs → erasePTR.go p l xs (acc.push x) = acc.toList ++ x :: eraseP p xs" tactic="cases p x &amp;lt;;&amp;gt; simp">
                                              <OtherNode start="(464, 33)" end="(464, 42)" kind="Lean.Parser.Tactic.cases">
                                                <AtomNode start="(464, 33)" end="(464, 38)" leading="" trailing=" " val="cases"/>
                                                <NullNode start="(464, 39)" end="(464, 42)">
                                                  <OtherNode start="(464, 39)" end="(464, 42)" kind="Lean.Parser.Tactic.elimTarget">
                                                    <NullNode/>
                                                    <OtherNode start="(464, 39)" end="(464, 42)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(464, 39)" end="(464, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                                                      <NullNode start="(464, 41)" end="(464, 42)">
                                                        <IdentNode start="(464, 41)" end="(464, 42)" leading="" trailing=" " raw_val="x" val="x"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(464, 43)" end="(464, 46)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                                              <OtherNode start="(464, 47)" end="(464, 51)" kind="Lean.Parser.Tactic.simp">
                                                <AtomNode start="(464, 47)" end="(464, 51)" leading="" trailing="&#10;    " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(465, 5)" end="(465, 46)" kind="Lean.cdot" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs → erasePTR.go p l xs (acc.push x) = acc.toList ++ x :: eraseP p xs" state_after="no goals" tactic="· intro h; rw [go _ xs]; {simp}; simp [h]">
                                              <OtherNode start="(465, 5)" end="(465, 6)" kind="Lean.cdotTk">
                                                <OtherNode start="(465, 5)" end="(465, 6)" kind="patternIgnore">
                                                  <OtherNode start="(465, 5)" end="(465, 6)" kind="token.«· »">
                                                    <AtomNode start="(465, 5)" end="(465, 6)" leading="" trailing=" " val="·"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </OtherNode>
                                              <TacticTacticseqNode start="(465, 7)" end="(465, 46)">
                                                <TacticTacticseq1IndentedNode start="(465, 7)" end="(465, 46)">
                                                  <NullNode start="(465, 7)" end="(465, 46)">
                                                    <OtherNode start="(465, 7)" end="(465, 14)" kind="Lean.Parser.Tactic.intro" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;⊢ l = acc.toList ++ x :: xs → erasePTR.go p l xs (acc.push x) = acc.toList ++ x :: eraseP p xs" state_after="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ erasePTR.go p l xs (acc.push x) = acc.toList ++ x :: eraseP p xs" tactic="intro h">
                                                      <AtomNode start="(465, 7)" end="(465, 12)" leading="" trailing=" " val="intro"/>
                                                      <NullNode start="(465, 13)" end="(465, 14)">
                                                        <IdentNode start="(465, 13)" end="(465, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                    <AtomNode start="(465, 14)" end="(465, 15)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(465, 16)" end="(465, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ erasePTR.go p l xs (acc.push x) = acc.toList ++ x :: eraseP p xs" state_after="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (acc.push x).toList ++ eraseP p xs = acc.toList ++ x :: eraseP p xs&#10;&#10;case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ l = (acc.push x).toList ++ xs" tactic="rw [go _ xs]">
                                                      <AtomNode start="(465, 16)" end="(465, 18)" leading="" trailing=" " val="rw"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <OtherNode start="(465, 19)" end="(465, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                        <AtomNode start="(465, 19)" end="(465, 20)" leading="" trailing="" val="["/>
                                                        <NullNode start="(465, 20)" end="(465, 27)">
                                                          <OtherNode start="(465, 20)" end="(465, 27)" kind="Lean.Parser.Tactic.rwRule">
                                                            <NullNode/>
                                                            <OtherNode start="(465, 20)" end="(465, 27)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(465, 20)" end="(465, 22)" leading="" trailing=" " raw_val="go" val="go"/>
                                                            <NullNode start="(465, 23)" end="(465, 27)">
                                                            <TermHoleNode start="(465, 23)" end="(465, 24)">
                                                            <AtomNode start="(465, 23)" end="(465, 24)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <IdentNode start="(465, 25)" end="(465, 27)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </NullNode>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(465, 27)" end="(465, 28)" leading="" trailing="" val="]"/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <AtomNode start="(465, 28)" end="(465, 29)" leading="" trailing=" " val=";"/>
                                                    <TacticTacticseqbracketedNode start="(465, 30)" end="(465, 36)" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (acc.push x).toList ++ eraseP p xs = acc.toList ++ x :: eraseP p xs&#10;&#10;case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ l = (acc.push x).toList ++ xs" state_after="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ l = (acc.push x).toList ++ xs" tactic="{simp}">
                                                      <AtomNode start="(465, 30)" end="(465, 31)" leading="" trailing="" val="{"/>
                                                      <NullNode start="(465, 31)" end="(465, 35)">
                                                        <OtherNode start="(465, 31)" end="(465, 35)" kind="Lean.Parser.Tactic.simp" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ (acc.push x).toList ++ eraseP p xs = acc.toList ++ x :: eraseP p xs" state_after="no goals" tactic="simp">
                                                          <AtomNode start="(465, 31)" end="(465, 35)" leading="" trailing="" val="simp"/>
                                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                          </OtherNode>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <NullNode/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(465, 35)" end="(465, 36)" leading="" trailing="" val="}"/>
                                                    </TacticTacticseqbracketedNode>
                                                    <AtomNode start="(465, 36)" end="(465, 37)" leading="" trailing=" " val=";"/>
                                                    <OtherNode start="(465, 38)" end="(465, 46)" kind="Lean.Parser.Tactic.simp" state_before="case false&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;acc : Array α&#10;x : α&#10;xs : List α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ l = (acc.push x).toList ++ xs" state_after="no goals" tactic="simp [h]">
                                                      <AtomNode start="(465, 38)" end="(465, 42)" leading="" trailing=" " val="simp"/>
                                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                        <NullNode/>
                                                      </OtherNode>
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <NullNode start="(465, 43)" end="(465, 46)">
                                                        <AtomNode start="(465, 43)" end="(465, 44)" leading="" trailing="" val="["/>
                                                        <NullNode start="(465, 44)" end="(465, 45)">
                                                          <OtherNode start="(465, 44)" end="(465, 45)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(465, 44)" end="(465, 45)" leading="" trailing="" raw_val="h" val="h"/>
                                                          </OtherNode>
                                                        </NullNode>
                                                        <AtomNode start="(465, 45)" end="(465, 46)" leading="" trailing="&#10;  " val="]"/>
                                                      </NullNode>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </TacticTacticseq1IndentedNode>
                                              </TacticTacticseqNode>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode kind="Lean.Parser.Termination.suffix">
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(466, 3)" end="(466, 28)" kind="Lean.Parser.Tactic.exact" state_before="case h.h.h&#10;α : Type u_1&#10;p : α → Bool&#10;l : List α&#10;⊢ eraseP p l = erasePTR.go p l l #[]" state_after="no goals" tactic="exact (go #[] _ rfl).symm">
                    <AtomNode start="(466, 3)" end="(466, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(466, 9)" end="(466, 28)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(466, 9)" end="(466, 23)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(466, 9)" end="(466, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(466, 10)" end="(466, 22)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(466, 10)" end="(466, 12)" leading="" trailing=" " raw_val="go" val="go"/>
                          <NullNode start="(466, 13)" end="(466, 22)">
                            <OtherNode start="(466, 13)" end="(466, 16)" kind="«term#[_,]»">
                              <AtomNode start="(466, 13)" end="(466, 15)" leading="" trailing="" val="#["/>
                              <NullNode/>
                              <AtomNode start="(466, 15)" end="(466, 16)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <TermHoleNode start="(466, 17)" end="(466, 18)">
                              <AtomNode start="(466, 17)" end="(466, 18)" leading="" trailing=" " val="_"/>
                            </TermHoleNode>
                            <IdentNode start="(466, 19)" end="(466, 22)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(466, 22)" end="(466, 23)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(466, 23)" end="(466, 24)" leading="" trailing="" val="."/>
                      <IdentNode start="(466, 24)" end="(466, 28)" leading="" trailing="&#10;&#10;" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(468, 1)" end="(468, 20)" comment="### eraseIdx -/">
      <AtomNode start="(468, 1)" end="(468, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(468, 5)" end="(468, 20)" leading="" trailing="&#10;&#10;&#10;" val="### eraseIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(471, 1)" end="(490, 44)" name="eraseIdxTR" full_name="List.eraseIdxTR">
      <CommandDeclmodifiersNode start="(471, 1)" end="(484, 10)">
        <NullNode start="(471, 1)" end="(483, 3)">
          <CommandDoccommentNode start="(471, 1)" end="(483, 3)" comment="Removes the element at the specified index. If the index is out of bounds, the list is returned&#10;unmodified.&#10;&#10;`O(i)`.&#10;&#10;This is a tail-recursive version of `List.eraseIdx`, used at runtime.&#10;&#10;Examples:&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 0 = [1, 2, 3, 4]`&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 1 = [0, 2, 3, 4]`&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 5 = [0, 1, 2, 3, 4]`&#10;-/">
            <AtomNode start="(471, 1)" end="(471, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(472, 1)" end="(483, 3)" leading="" trailing="&#10;" val="Removes the element at the specified index. If the index is out of bounds, the list is returned&#10;unmodified.&#10;&#10;`O(i)`.&#10;&#10;This is a tail-recursive version of `List.eraseIdx`, used at runtime.&#10;&#10;Examples:&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 0 = [1, 2, 3, 4]`&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 1 = [0, 2, 3, 4]`&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 5 = [0, 1, 2, 3, 4]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(484, 1)" end="(484, 10)">
          <OtherNode start="(484, 1)" end="(484, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(484, 1)" end="(484, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(484, 3)" end="(484, 9)">
              <OtherNode start="(484, 3)" end="(484, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(484, 3)" end="(484, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(484, 3)" end="(484, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(484, 9)" end="(484, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(484, 11)" end="(490, 44)" name="eraseIdxTR">
        <AtomNode start="(484, 11)" end="(484, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(484, 15)" end="(484, 25)">
          <IdentNode start="(484, 15)" end="(484, 25)" leading="" trailing=" " raw_val="eraseIdxTR" val="eraseIdxTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(484, 26)" end="(484, 57)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(484, 26)" end="(484, 48)">
            <TermExplicitbinderNode start="(484, 26)" end="(484, 38)">
              <AtomNode start="(484, 26)" end="(484, 27)" leading="" trailing="" val="("/>
              <NullNode start="(484, 27)" end="(484, 28)">
                <IdentNode start="(484, 27)" end="(484, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(484, 29)" end="(484, 37)">
                <AtomNode start="(484, 29)" end="(484, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(484, 31)" end="(484, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(484, 31)" end="(484, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(484, 36)" end="(484, 37)">
                    <IdentNode start="(484, 36)" end="(484, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(484, 37)" end="(484, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(484, 39)" end="(484, 48)">
              <AtomNode start="(484, 39)" end="(484, 40)" leading="" trailing="" val="("/>
              <NullNode start="(484, 40)" end="(484, 41)">
                <IdentNode start="(484, 40)" end="(484, 41)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(484, 42)" end="(484, 47)">
                <AtomNode start="(484, 42)" end="(484, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(484, 44)" end="(484, 47)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(484, 47)" end="(484, 48)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(484, 49)" end="(484, 57)">
            <TermTypespecNode start="(484, 49)" end="(484, 57)">
              <AtomNode start="(484, 49)" end="(484, 50)" leading="" trailing=" " val=":"/>
              <OtherNode start="(484, 51)" end="(484, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(484, 51)" end="(484, 55)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(484, 56)" end="(484, 57)">
                  <IdentNode start="(484, 56)" end="(484, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(484, 58)" end="(490, 44)">
          <AtomNode start="(484, 58)" end="(484, 60)" leading="" trailing=" " val=":="/>
          <OtherNode start="(484, 61)" end="(484, 71)" kind="Lean.Parser.Term.app">
            <IdentNode start="(484, 61)" end="(484, 63)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(484, 64)" end="(484, 71)">
              <IdentNode start="(484, 64)" end="(484, 65)" leading="" trailing=" " raw_val="l" val="l"/>
              <IdentNode start="(484, 66)" end="(484, 67)" leading="" trailing=" " raw_val="n" val="n"/>
              <OtherNode start="(484, 68)" end="(484, 71)" kind="«term#[_,]»">
                <AtomNode start="(484, 68)" end="(484, 70)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(484, 70)" end="(484, 71)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(484, 72)" end="(490, 44)">
            <OtherNode start="(484, 72)" end="(490, 44)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(484, 72)" end="(484, 77)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(485, 3)" end="(490, 44)">
                <OtherNode start="(485, 3)" end="(490, 44)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(485, 3)" end="(486, 60)">
                    <CommandDoccommentNode start="(485, 3)" end="(486, 60)" comment="Auxiliary for `eraseIdxTR`: `eraseIdxTR.go l n xs acc = acc.toList ++ eraseIdx xs a`,&#10;  unless `a` is not present in which case it returns `l` -/">
                      <AtomNode start="(485, 3)" end="(485, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(485, 7)" end="(486, 60)" leading="" trailing="&#10;  " val="Auxiliary for `eraseIdxTR`: `eraseIdxTR.go l n xs acc = acc.toList ++ eraseIdx xs a`,&#10;  unless `a` is not present in which case it returns `l` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(487, 3)" end="(490, 44)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(487, 3)" end="(490, 44)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(487, 3)" end="(487, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(487, 6)" end="(487, 39)">
                        <TermTypespecNode start="(487, 6)" end="(487, 39)">
                          <AtomNode start="(487, 6)" end="(487, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(487, 8)" end="(487, 39)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(487, 8)" end="(487, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(487, 8)" end="(487, 12)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(487, 13)" end="(487, 14)">
                                <IdentNode start="(487, 13)" end="(487, 14)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(487, 15)" end="(487, 16)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(487, 17)" end="(487, 39)" kind="Lean.Parser.Term.arrow">
                              <IdentNode start="(487, 17)" end="(487, 20)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <AtomNode start="(487, 21)" end="(487, 22)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(487, 23)" end="(487, 39)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(487, 23)" end="(487, 30)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(487, 23)" end="(487, 28)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(487, 29)" end="(487, 30)">
                                    <IdentNode start="(487, 29)" end="(487, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(487, 31)" end="(487, 32)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(487, 33)" end="(487, 39)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(487, 33)" end="(487, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(487, 38)" end="(487, 39)">
                                    <IdentNode start="(487, 38)" end="(487, 39)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(488, 3)" end="(490, 44)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(488, 3)" end="(490, 44)">
                          <OtherNode start="(488, 3)" end="(488, 18)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(488, 3)" end="(488, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(488, 5)" end="(488, 13)">
                              <NullNode start="(488, 5)" end="(488, 13)">
                                <OtherNode start="(488, 5)" end="(488, 7)" kind="«term[_]»">
                                  <AtomNode start="(488, 5)" end="(488, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(488, 6)" end="(488, 7)" leading="" trailing="" val="]"/>
                                </OtherNode>
                                <AtomNode start="(488, 7)" end="(488, 8)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(488, 9)" end="(488, 10)">
                                  <AtomNode start="(488, 9)" end="(488, 10)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(488, 10)" end="(488, 11)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(488, 12)" end="(488, 13)">
                                  <AtomNode start="(488, 12)" end="(488, 13)" leading="" trailing=" " val="_"/>
                                </TermHoleNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(488, 14)" end="(488, 16)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(488, 17)" end="(488, 18)" leading="" trailing="&#10;  " raw_val="l" val="l"/>
                          </OtherNode>
                          <OtherNode start="(489, 3)" end="(489, 41)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(489, 3)" end="(489, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(489, 5)" end="(489, 18)">
                              <NullNode start="(489, 5)" end="(489, 18)">
                                <OtherNode start="(489, 5)" end="(489, 10)" kind="«term_::_»">
                                  <TermHoleNode start="(489, 5)" end="(489, 6)">
                                    <AtomNode start="(489, 5)" end="(489, 6)" leading="" trailing="" val="_"/>
                                  </TermHoleNode>
                                  <AtomNode start="(489, 6)" end="(489, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(489, 8)" end="(489, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(489, 10)" end="(489, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(489, 12)" end="(489, 13)" kind="num">
                                  <AtomNode start="(489, 12)" end="(489, 13)" leading="" trailing="" val="0"/>
                                </OtherNode>
                                <AtomNode start="(489, 13)" end="(489, 14)" leading="" trailing=" " val=","/>
                                <IdentNode start="(489, 15)" end="(489, 18)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(489, 19)" end="(489, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(489, 22)" end="(489, 41)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(489, 22)" end="(489, 38)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                              <NullNode start="(489, 39)" end="(489, 41)">
                                <IdentNode start="(489, 39)" end="(489, 41)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(490, 3)" end="(490, 44)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(490, 3)" end="(490, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(490, 5)" end="(490, 20)">
                              <NullNode start="(490, 5)" end="(490, 20)">
                                <OtherNode start="(490, 5)" end="(490, 10)" kind="«term_::_»">
                                  <IdentNode start="(490, 5)" end="(490, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(490, 6)" end="(490, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(490, 8)" end="(490, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(490, 10)" end="(490, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(490, 12)" end="(490, 15)" kind="«term_+_»">
                                  <IdentNode start="(490, 12)" end="(490, 13)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(490, 13)" end="(490, 14)" leading="" trailing="" val="+"/>
                                  <OtherNode start="(490, 14)" end="(490, 15)" kind="num">
                                    <AtomNode start="(490, 14)" end="(490, 15)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(490, 15)" end="(490, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(490, 17)" end="(490, 20)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(490, 21)" end="(490, 23)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(490, 24)" end="(490, 44)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(490, 24)" end="(490, 26)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(490, 27)" end="(490, 44)">
                                <IdentNode start="(490, 27)" end="(490, 29)" leading="" trailing=" " raw_val="as" val="as"/>
                                <IdentNode start="(490, 30)" end="(490, 31)" leading="" trailing=" " raw_val="n" val="n"/>
                                <OtherNode start="(490, 32)" end="(490, 44)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(490, 32)" end="(490, 33)" leading="" trailing="" val="("/>
                                  <OtherNode start="(490, 33)" end="(490, 43)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(490, 33)" end="(490, 41)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(490, 42)" end="(490, 43)">
                                      <IdentNode start="(490, 42)" end="(490, 43)" leading="" trailing="" raw_val="a" val="a"/>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(490, 43)" end="(490, 44)" leading="" trailing="&#10;&#10;" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(492, 1)" end="(503, 35)" name="eraseIdx_eq_eraseIdxTR" full_name="List.eraseIdx_eq_eraseIdxTR">
      <CommandDeclmodifiersNode start="(492, 1)" end="(492, 9)">
        <NullNode/>
        <NullNode start="(492, 1)" end="(492, 9)">
          <OtherNode start="(492, 1)" end="(492, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(492, 1)" end="(492, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(492, 3)" end="(492, 8)">
              <OtherNode start="(492, 3)" end="(492, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(492, 3)" end="(492, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(492, 3)" end="(492, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(492, 8)" end="(492, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(492, 10)" end="(503, 35)" name="eraseIdx_eq_eraseIdxTR" full_name="List.eraseIdx_eq_eraseIdxTR" _is_private_decl="False">
        <AtomNode start="(492, 10)" end="(492, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(492, 18)" end="(492, 40)">
          <IdentNode start="(492, 18)" end="(492, 40)" leading="" trailing=" " raw_val="eraseIdx_eq_eraseIdxTR" val="eraseIdx_eq_eraseIdxTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(492, 41)" end="(492, 66)">
          <NullNode/>
          <TermTypespecNode start="(492, 41)" end="(492, 66)">
            <AtomNode start="(492, 41)" end="(492, 42)" leading="" trailing=" " val=":"/>
            <OtherNode start="(492, 43)" end="(492, 66)" kind="«term_=_»">
              <OtherNode start="(492, 43)" end="(492, 52)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(492, 43)" end="(492, 44)" leading="" trailing="" val="@"/>
                <IdentNode start="(492, 44)" end="(492, 52)" leading="" trailing=" " raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(492, 53)" end="(492, 54)" leading="" trailing=" " val="="/>
              <OtherNode start="(492, 55)" end="(492, 66)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(492, 55)" end="(492, 56)" leading="" trailing="" val="@"/>
                <IdentNode start="(492, 56)" end="(492, 66)" leading="" trailing=" " raw_val="eraseIdxTR" val="eraseIdxTR" full_name="List.eraseIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(484, 15)" def_end="(484, 25)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(492, 67)" end="(503, 35)">
          <AtomNode start="(492, 67)" end="(492, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(492, 70)" end="(503, 35)">
            <AtomNode start="(492, 70)" end="(492, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(493, 3)" end="(503, 35)">
              <TacticTacticseq1IndentedNode start="(493, 3)" end="(503, 35)">
                <NullNode start="(493, 3)" end="(503, 35)">
                  <OtherNode start="(493, 3)" end="(493, 15)" kind="tacticFunext___" state_before="⊢ @eraseIdx = @eraseIdxTR" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.eraseIdx i = l.eraseIdxTR i" tactic="funext α l i">
                    <AtomNode start="(493, 3)" end="(493, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(493, 10)" end="(493, 15)">
                      <IdentNode start="(493, 10)" end="(493, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(493, 12)" end="(493, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(493, 14)" end="(493, 15)" leading="" trailing="" raw_val="i" val="i"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(493, 15)" end="(493, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(493, 17)" end="(493, 34)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.eraseIdx i = l.eraseIdxTR i" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.eraseIdx i = eraseIdxTR.go l l i #[]" tactic="simp [eraseIdxTR]">
                    <AtomNode start="(493, 17)" end="(493, 21)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(493, 22)" end="(493, 34)">
                      <AtomNode start="(493, 22)" end="(493, 23)" leading="" trailing="" val="["/>
                      <NullNode start="(493, 23)" end="(493, 33)">
                        <OtherNode start="(493, 23)" end="(493, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(493, 23)" end="(493, 33)" leading="" trailing="" raw_val="eraseIdxTR" val="eraseIdxTR" full_name="List.eraseIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(484, 15)" def_end="(484, 25)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(493, 33)" end="(493, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(494, 3)" end="(495, 32)" kind="Lean.Parser.Tactic.tacticSuffices_" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ l.eraseIdx i = eraseIdxTR.go l l i #[]" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i" tactic="suffices ∀ xs acc, l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i from&#10;  (this l #[] (by simp)).symm">
                    <AtomNode start="(494, 3)" end="(494, 11)" leading="" trailing=" " val="suffices"/>
                    <OtherNode start="(494, 12)" end="(495, 32)" kind="Lean.Parser.Term.sufficesDecl">
                      <OtherNode start="(494, 12)" end="(494, 12)" kind="hygieneInfo">
                        <IdentNode start="(494, 12)" end="(494, 12)" leading="" trailing="" raw_val="" val="[anonymous]"/>
                      </OtherNode>
                      <OtherNode start="(494, 12)" end="(494, 99)" kind="Lean.Parser.Term.forall">
                        <AtomNode start="(494, 12)" end="(494, 13)" leading="" trailing=" " val="∀"/>
                        <NullNode start="(494, 14)" end="(494, 20)">
                          <IdentNode start="(494, 14)" end="(494, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <IdentNode start="(494, 17)" end="(494, 20)" leading="" trailing="" raw_val="acc" val="acc"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(494, 20)" end="(494, 21)" leading="" trailing=" " val=","/>
                        <OtherNode start="(494, 22)" end="(494, 99)" kind="Lean.Parser.Term.arrow">
                          <OtherNode start="(494, 22)" end="(494, 42)" kind="«term_=_»">
                            <IdentNode start="(494, 22)" end="(494, 23)" leading="" trailing=" " raw_val="l" val="l"/>
                            <AtomNode start="(494, 24)" end="(494, 25)" leading="" trailing=" " val="="/>
                            <OtherNode start="(494, 26)" end="(494, 42)" kind="«term_++_»">
                              <IdentNode start="(494, 26)" end="(494, 36)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(494, 37)" end="(494, 39)" leading="" trailing=" " val="++"/>
                              <IdentNode start="(494, 40)" end="(494, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(494, 43)" end="(494, 44)" leading="" trailing=" " val="→"/>
                          <OtherNode start="(494, 45)" end="(494, 99)" kind="«term_=_»">
                            <OtherNode start="(494, 45)" end="(494, 69)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(494, 45)" end="(494, 58)" leading="" trailing=" " raw_val="eraseIdxTR.go" val="eraseIdxTR.go" full_name="List.eraseIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(487, 3)" def_end="(487, 5)"/>
                              <NullNode start="(494, 59)" end="(494, 69)">
                                <IdentNode start="(494, 59)" end="(494, 60)" leading="" trailing=" " raw_val="l" val="l"/>
                                <IdentNode start="(494, 61)" end="(494, 63)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                <IdentNode start="(494, 64)" end="(494, 65)" leading="" trailing=" " raw_val="i" val="i"/>
                                <IdentNode start="(494, 66)" end="(494, 69)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(494, 70)" end="(494, 71)" leading="" trailing=" " val="="/>
                            <OtherNode start="(494, 72)" end="(494, 99)" kind="«term_++_»">
                              <IdentNode start="(494, 72)" end="(494, 82)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                              <AtomNode start="(494, 83)" end="(494, 85)" leading="" trailing=" " val="++"/>
                              <OtherNode start="(494, 86)" end="(494, 99)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(494, 86)" end="(494, 97)" leading="" trailing=" " raw_val="xs.eraseIdx" val="xs.eraseIdx"/>
                                <NullNode start="(494, 98)" end="(494, 99)">
                                  <IdentNode start="(494, 98)" end="(494, 99)" leading="" trailing=" " raw_val="i" val="i"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode start="(494, 100)" end="(495, 32)" kind="Lean.Parser.Term.fromTerm">
                        <AtomNode start="(494, 100)" end="(494, 104)" leading="" trailing="&#10;    " val="from"/>
                        <OtherNode start="(495, 5)" end="(495, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(495, 5)" end="(495, 27)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(495, 5)" end="(495, 6)" leading="" trailing="" val="("/>
                            <OtherNode start="(495, 6)" end="(495, 26)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(495, 6)" end="(495, 10)" leading="" trailing=" " raw_val="this" val="this"/>
                              <NullNode start="(495, 11)" end="(495, 26)">
                                <IdentNode start="(495, 11)" end="(495, 12)" leading="" trailing=" " raw_val="l" val="l"/>
                                <OtherNode start="(495, 13)" end="(495, 16)" kind="«term#[_,]»">
                                  <AtomNode start="(495, 13)" end="(495, 15)" leading="" trailing="" val="#["/>
                                  <NullNode/>
                                  <AtomNode start="(495, 15)" end="(495, 16)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                                <OtherNode start="(495, 17)" end="(495, 26)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(495, 17)" end="(495, 18)" leading="" trailing="" val="("/>
                                  <TermBytacticNode start="(495, 18)" end="(495, 25)">
                                    <AtomNode start="(495, 18)" end="(495, 20)" leading="" trailing=" " val="by"/>
                                    <TacticTacticseqNode start="(495, 21)" end="(495, 25)">
                                      <TacticTacticseq1IndentedNode start="(495, 21)" end="(495, 25)">
                                        <NullNode start="(495, 21)" end="(495, 25)">
                                          <OtherNode start="(495, 21)" end="(495, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;i : Nat&#10;this : ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;⊢ l = #[].toList ++ l" state_after="no goals" tactic="simp">
                                            <AtomNode start="(495, 21)" end="(495, 25)" leading="" trailing="" val="simp"/>
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                  </TermBytacticNode>
                                  <AtomNode start="(495, 25)" end="(495, 26)" leading="" trailing="" val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(495, 26)" end="(495, 27)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(495, 27)" end="(495, 28)" leading="" trailing="" val="."/>
                          <IdentNode start="(495, 28)" end="(495, 32)" leading="" trailing="&#10;  " raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(496, 3)" end="(496, 11)" kind="Lean.Parser.Tactic.intro" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;⊢ ∀ (xs : List α) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i" tactic="intro xs">
                    <AtomNode start="(496, 3)" end="(496, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(496, 9)" end="(496, 11)">
                      <IdentNode start="(496, 9)" end="(496, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(496, 11)" end="(496, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(496, 13)" end="(503, 35)" kind="Lean.Parser.Tactic.induction" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;xs : List α&#10;⊢ ∀ (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i" state_after="no goals" tactic="induction xs generalizing i with intro acc h&#10;| nil =&amp;gt; simp [eraseIdx, eraseIdxTR.go, h]&#10;| cons x xs IH =&amp;gt;&#10;match i with&#10;| 0 =&amp;gt; simp [eraseIdx, eraseIdxTR.go]&#10;| i+1 =&amp;gt;&#10;simp only [eraseIdxTR.go, eraseIdx]&#10;rw [IH]; simp; simp; exact h">
                    <AtomNode start="(496, 13)" end="(496, 22)" leading="" trailing=" " val="induction"/>
                    <NullNode start="(496, 23)" end="(496, 25)">
                      <OtherNode start="(496, 23)" end="(496, 25)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(496, 23)" end="(496, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(496, 26)" end="(496, 40)">
                      <AtomNode start="(496, 26)" end="(496, 38)" leading="" trailing=" " val="generalizing"/>
                      <NullNode start="(496, 39)" end="(496, 40)">
                        <IdentNode start="(496, 39)" end="(496, 40)" leading="" trailing=" " raw_val="i" val="i"/>
                      </NullNode>
                    </NullNode>
                    <NullNode start="(496, 41)" end="(503, 35)">
                      <OtherNode start="(496, 41)" end="(503, 35)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(496, 41)" end="(496, 45)" leading="" trailing=" " val="with"/>
                        <NullNode start="(496, 46)" end="(496, 57)">
                          <OtherNode start="(496, 46)" end="(496, 57)" kind="Lean.Parser.Tactic.intro">
                            <AtomNode start="(496, 46)" end="(496, 51)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(496, 52)" end="(496, 57)">
                              <IdentNode start="(496, 52)" end="(496, 55)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              <IdentNode start="(496, 56)" end="(496, 57)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(497, 3)" end="(503, 35)">
                          <OtherNode start="(497, 3)" end="(497, 45)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(497, 3)" end="(497, 8)">
                              <OtherNode start="(497, 3)" end="(497, 8)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(497, 3)" end="(497, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(497, 5)" end="(497, 8)">
                                  <NullNode/>
                                  <IdentNode start="(497, 5)" end="(497, 8)" leading="" trailing=" " raw_val="nil" val="nil" full_name="List.nil" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode/>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(497, 9)" end="(497, 45)">
                              <AtomNode start="(497, 9)" end="(497, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(497, 12)" end="(497, 45)">
                                <TacticTacticseq1IndentedNode start="(497, 12)" end="(497, 45)">
                                  <NullNode start="(497, 12)" end="(497, 45)">
                                    <OtherNode start="(497, 12)" end="(497, 45)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h.nil&#10;α : Type u_1&#10;l : List α&#10;i : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ []&#10;⊢ eraseIdxTR.go l [] i acc = acc.toList ++ [].eraseIdx i" state_after="no goals" tactic="simp [eraseIdx, eraseIdxTR.go, h]">
                                      <AtomNode start="(497, 12)" end="(497, 16)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(497, 17)" end="(497, 45)">
                                        <AtomNode start="(497, 17)" end="(497, 18)" leading="" trailing="" val="["/>
                                        <NullNode start="(497, 18)" end="(497, 44)">
                                          <OtherNode start="(497, 18)" end="(497, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(497, 18)" end="(497, 26)" leading="" trailing="" raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(497, 26)" end="(497, 27)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(497, 28)" end="(497, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(497, 28)" end="(497, 41)" leading="" trailing="" raw_val="eraseIdxTR.go" val="eraseIdxTR.go" full_name="List.eraseIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(487, 3)" def_end="(487, 5)"/>
                                          </OtherNode>
                                          <AtomNode start="(497, 41)" end="(497, 42)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(497, 43)" end="(497, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(497, 43)" end="(497, 44)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(497, 44)" end="(497, 45)" leading="" trailing="&#10;  " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                          <OtherNode start="(498, 3)" end="(503, 35)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(498, 3)" end="(498, 17)">
                              <OtherNode start="(498, 3)" end="(498, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(498, 3)" end="(498, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(498, 5)" end="(498, 9)">
                                  <NullNode/>
                                  <IdentNode start="(498, 5)" end="(498, 9)" leading="" trailing=" " raw_val="cons" val="cons" full_name="List.cons" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                </GroupNode>
                                <NullNode start="(498, 10)" end="(498, 17)">
                                  <IdentNode start="(498, 10)" end="(498, 11)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(498, 12)" end="(498, 14)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  <IdentNode start="(498, 15)" end="(498, 17)" leading="" trailing=" " raw_val="IH" val="IH"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(498, 18)" end="(503, 35)">
                              <AtomNode start="(498, 18)" end="(498, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(499, 5)" end="(503, 35)">
                                <TacticTacticseq1IndentedNode start="(499, 5)" end="(503, 35)">
                                  <NullNode start="(499, 5)" end="(503, 35)">
                                    <OtherNode start="(499, 5)" end="(503, 35)" kind="Lean.Parser.Tactic.match" state_before="case h.h.h.cons&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ eraseIdxTR.go l (x :: xs) i acc = acc.toList ++ (x :: xs).eraseIdx i" state_after="no goals" tactic="match i with&#10;| 0 =&amp;gt; simp [eraseIdx, eraseIdxTR.go]&#10;| i+1 =&amp;gt;&#10;  simp only [eraseIdxTR.go, eraseIdx]&#10;  rw [IH]; simp; simp; exact h">
                                      <AtomNode start="(499, 5)" end="(499, 10)" leading="" trailing=" " val="match"/>
                                      <NullNode/>
                                      <NullNode/>
                                      <NullNode start="(499, 11)" end="(499, 12)">
                                        <OtherNode start="(499, 11)" end="(499, 12)" kind="Lean.Parser.Term.matchDiscr">
                                          <NullNode/>
                                          <IdentNode start="(499, 11)" end="(499, 12)" leading="" trailing=" " raw_val="i" val="i"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(499, 13)" end="(499, 17)" leading="" trailing="&#10;    " val="with"/>
                                      <OtherNode start="(500, 5)" end="(503, 35)" kind="Lean.Parser.Term.matchAlts">
                                        <NullNode start="(500, 5)" end="(503, 35)">
                                          <OtherNode start="(500, 5)" end="(500, 42)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(500, 5)" end="(500, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(500, 7)" end="(500, 8)">
                                              <NullNode start="(500, 7)" end="(500, 8)">
                                                <OtherNode start="(500, 7)" end="(500, 8)" kind="num">
                                                  <AtomNode start="(500, 7)" end="(500, 8)" leading="" trailing=" " val="0"/>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(500, 9)" end="(500, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(500, 12)" end="(500, 42)">
                                              <TacticTacticseq1IndentedNode start="(500, 12)" end="(500, 42)">
                                                <NullNode start="(500, 12)" end="(500, 42)">
                                                  <OtherNode start="(500, 12)" end="(500, 42)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;⊢ eraseIdxTR.go l (x :: xs) 0 acc = acc.toList ++ (x :: xs).eraseIdx 0" state_after="no goals" tactic="simp [eraseIdx, eraseIdxTR.go]">
                                                    <AtomNode start="(500, 12)" end="(500, 16)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode start="(500, 17)" end="(500, 42)">
                                                      <AtomNode start="(500, 17)" end="(500, 18)" leading="" trailing="" val="["/>
                                                      <NullNode start="(500, 18)" end="(500, 41)">
                                                        <OtherNode start="(500, 18)" end="(500, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(500, 18)" end="(500, 26)" leading="" trailing="" raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                        </OtherNode>
                                                        <AtomNode start="(500, 26)" end="(500, 27)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(500, 28)" end="(500, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(500, 28)" end="(500, 41)" leading="" trailing="" raw_val="eraseIdxTR.go" val="eraseIdxTR.go" full_name="List.eraseIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(487, 3)" def_end="(487, 5)"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(500, 41)" end="(500, 42)" leading="" trailing="&#10;    " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                          <OtherNode start="(501, 5)" end="(503, 35)" kind="Lean.Parser.Term.matchAlt">
                                            <AtomNode start="(501, 5)" end="(501, 6)" leading="" trailing=" " val="|"/>
                                            <NullNode start="(501, 7)" end="(501, 10)">
                                              <NullNode start="(501, 7)" end="(501, 10)">
                                                <OtherNode start="(501, 7)" end="(501, 10)" kind="«term_+_»">
                                                  <IdentNode start="(501, 7)" end="(501, 8)" leading="" trailing="" raw_val="i" val="i"/>
                                                  <AtomNode start="(501, 8)" end="(501, 9)" leading="" trailing="" val="+"/>
                                                  <OtherNode start="(501, 9)" end="(501, 10)" kind="num">
                                                    <AtomNode start="(501, 9)" end="(501, 10)" leading="" trailing=" " val="1"/>
                                                  </OtherNode>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(501, 11)" end="(501, 13)" leading="" trailing="&#10;      " val="=&amp;gt;"/>
                                            <TacticTacticseqNode start="(502, 7)" end="(503, 35)">
                                              <TacticTacticseq1IndentedNode start="(502, 7)" end="(503, 35)">
                                                <NullNode start="(502, 7)" end="(503, 35)">
                                                  <OtherNode start="(502, 7)" end="(502, 42)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ eraseIdxTR.go l (x :: xs) (i + 1) acc = acc.toList ++ (x :: xs).eraseIdx (i + 1)" state_after="α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ eraseIdxTR.go l xs i (acc.push x) = acc.toList ++ x :: xs.eraseIdx i" tactic="simp only [eraseIdxTR.go, eraseIdx]">
                                                    <AtomNode start="(502, 7)" end="(502, 11)" leading="" trailing=" " val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode start="(502, 12)" end="(502, 16)">
                                                      <AtomNode start="(502, 12)" end="(502, 16)" leading="" trailing=" " val="only"/>
                                                    </NullNode>
                                                    <NullNode start="(502, 17)" end="(502, 42)">
                                                      <AtomNode start="(502, 17)" end="(502, 18)" leading="" trailing="" val="["/>
                                                      <NullNode start="(502, 18)" end="(502, 41)">
                                                        <OtherNode start="(502, 18)" end="(502, 31)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(502, 18)" end="(502, 31)" leading="" trailing="" raw_val="eraseIdxTR.go" val="eraseIdxTR.go" full_name="List.eraseIdxTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(487, 3)" def_end="(487, 5)"/>
                                                        </OtherNode>
                                                        <AtomNode start="(502, 31)" end="(502, 32)" leading="" trailing=" " val=","/>
                                                        <OtherNode start="(502, 33)" end="(502, 41)" kind="Lean.Parser.Tactic.simpLemma">
                                                          <NullNode/>
                                                          <NullNode/>
                                                          <IdentNode start="(502, 33)" end="(502, 41)" leading="" trailing="" raw_val="eraseIdx" val="eraseIdx" full_name="List.eraseIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(502, 41)" end="(502, 42)" leading="" trailing="&#10;      " val="]"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <NullNode/>
                                                  <OtherNode start="(503, 7)" end="(503, 14)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ eraseIdxTR.go l xs i (acc.push x) = acc.toList ++ x :: xs.eraseIdx i" state_after="α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ (acc.push x).toList ++ xs.eraseIdx i = acc.toList ++ x :: xs.eraseIdx i&#10;&#10;case a&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ l = (acc.push x).toList ++ xs" tactic="rw [IH]">
                                                    <AtomNode start="(503, 7)" end="(503, 9)" leading="" trailing=" " val="rw"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <OtherNode start="(503, 10)" end="(503, 14)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                      <AtomNode start="(503, 10)" end="(503, 11)" leading="" trailing="" val="["/>
                                                      <NullNode start="(503, 11)" end="(503, 13)">
                                                        <OtherNode start="(503, 11)" end="(503, 13)" kind="Lean.Parser.Tactic.rwRule">
                                                          <NullNode/>
                                                          <IdentNode start="(503, 11)" end="(503, 13)" leading="" trailing="" raw_val="IH" val="IH"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <AtomNode start="(503, 13)" end="(503, 14)" leading="" trailing="" val="]"/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(503, 14)" end="(503, 15)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(503, 16)" end="(503, 20)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ (acc.push x).toList ++ xs.eraseIdx i = acc.toList ++ x :: xs.eraseIdx i&#10;&#10;case a&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ l = (acc.push x).toList ++ xs" state_after="case a&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ l = (acc.push x).toList ++ xs" tactic="simp">
                                                    <AtomNode start="(503, 16)" end="(503, 20)" leading="" trailing="" val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(503, 20)" end="(503, 21)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(503, 22)" end="(503, 26)" kind="Lean.Parser.Tactic.simp" state_before="case a&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ l = (acc.push x).toList ++ xs" state_after="case a&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ l = acc.toList ++ x :: xs" tactic="simp">
                                                    <AtomNode start="(503, 22)" end="(503, 26)" leading="" trailing="" val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                  <AtomNode start="(503, 26)" end="(503, 27)" leading="" trailing=" " val=";"/>
                                                  <OtherNode start="(503, 28)" end="(503, 35)" kind="Lean.Parser.Tactic.exact" state_before="case a&#10;α : Type u_1&#10;l : List α&#10;x : α&#10;xs : List α&#10;IH : ∀ (i : Nat) (acc : Array α), l = acc.toList ++ xs → eraseIdxTR.go l xs i acc = acc.toList ++ xs.eraseIdx i&#10;i✝ : Nat&#10;acc : Array α&#10;h : l = acc.toList ++ x :: xs&#10;i : Nat&#10;⊢ l = acc.toList ++ x :: xs" state_after="no goals" tactic="exact h">
                                                    <AtomNode start="(503, 28)" end="(503, 33)" leading="" trailing=" " val="exact"/>
                                                    <IdentNode start="(503, 34)" end="(503, 35)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(505, 1)" end="(505, 18)" comment="## Zippers -/">
      <AtomNode start="(505, 1)" end="(505, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(505, 5)" end="(505, 18)" leading="" trailing="&#10;&#10;" val="## Zippers -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(507, 1)" end="(507, 19)" comment="### zipWith -/">
      <AtomNode start="(507, 1)" end="(507, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(507, 5)" end="(507, 19)" leading="" trailing="&#10;&#10;" val="### zipWith -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(509, 1)" end="(525, 28)" name="zipWithTR" full_name="List.zipWithTR">
      <CommandDeclmodifiersNode start="(509, 1)" end="(521, 10)">
        <NullNode start="(509, 1)" end="(520, 3)">
          <CommandDoccommentNode start="(509, 1)" end="(520, 3)" comment="Applies a function to the corresponding elements of two lists, stopping at the end of the shorter&#10;list.&#10;&#10;`O(min |xs| |ys|)`. This is a tail-recursive version of `List.zipWith` that's used at runtime.&#10;&#10;Examples:&#10;* `[1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]`&#10;* `[1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]`&#10;* `[].zipWithTR (· + ·) [5, 6] = []`&#10;* `[x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`&#10;-/">
            <AtomNode start="(509, 1)" end="(509, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(510, 1)" end="(520, 3)" leading="" trailing="&#10;" val="Applies a function to the corresponding elements of two lists, stopping at the end of the shorter&#10;list.&#10;&#10;`O(min |xs| |ys|)`. This is a tail-recursive version of `List.zipWith` that's used at runtime.&#10;&#10;Examples:&#10;* `[1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]`&#10;* `[1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]`&#10;* `[].zipWithTR (· + ·) [5, 6] = []`&#10;* `[x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(521, 1)" end="(521, 10)">
          <OtherNode start="(521, 1)" end="(521, 10)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(521, 1)" end="(521, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(521, 3)" end="(521, 9)">
              <OtherNode start="(521, 3)" end="(521, 9)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(521, 3)" end="(521, 9)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(521, 3)" end="(521, 9)" leading="" trailing="" raw_val="inline" val="inline"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(521, 9)" end="(521, 10)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(521, 11)" end="(525, 28)" name="zipWithTR">
        <AtomNode start="(521, 11)" end="(521, 14)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(521, 15)" end="(521, 24)">
          <IdentNode start="(521, 15)" end="(521, 24)" leading="" trailing=" " raw_val="zipWithTR" val="zipWithTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(521, 25)" end="(521, 77)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(521, 25)" end="(521, 68)">
            <TermExplicitbinderNode start="(521, 25)" end="(521, 40)">
              <AtomNode start="(521, 25)" end="(521, 26)" leading="" trailing="" val="("/>
              <NullNode start="(521, 26)" end="(521, 27)">
                <IdentNode start="(521, 26)" end="(521, 27)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(521, 28)" end="(521, 39)">
                <AtomNode start="(521, 28)" end="(521, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(521, 30)" end="(521, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(521, 30)" end="(521, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(521, 32)" end="(521, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(521, 34)" end="(521, 39)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(521, 34)" end="(521, 35)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(521, 36)" end="(521, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(521, 38)" end="(521, 39)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(521, 39)" end="(521, 40)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(521, 41)" end="(521, 54)">
              <AtomNode start="(521, 41)" end="(521, 42)" leading="" trailing="" val="("/>
              <NullNode start="(521, 42)" end="(521, 44)">
                <IdentNode start="(521, 42)" end="(521, 44)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(521, 45)" end="(521, 53)">
                <AtomNode start="(521, 45)" end="(521, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(521, 47)" end="(521, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(521, 47)" end="(521, 51)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(521, 52)" end="(521, 53)">
                    <IdentNode start="(521, 52)" end="(521, 53)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(521, 53)" end="(521, 54)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(521, 55)" end="(521, 68)">
              <AtomNode start="(521, 55)" end="(521, 56)" leading="" trailing="" val="("/>
              <NullNode start="(521, 56)" end="(521, 58)">
                <IdentNode start="(521, 56)" end="(521, 58)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(521, 59)" end="(521, 67)">
                <AtomNode start="(521, 59)" end="(521, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(521, 61)" end="(521, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(521, 61)" end="(521, 65)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(521, 66)" end="(521, 67)">
                    <IdentNode start="(521, 66)" end="(521, 67)" leading="" trailing="" raw_val="β" val="β"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(521, 67)" end="(521, 68)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(521, 69)" end="(521, 77)">
            <TermTypespecNode start="(521, 69)" end="(521, 77)">
              <AtomNode start="(521, 69)" end="(521, 70)" leading="" trailing=" " val=":"/>
              <OtherNode start="(521, 71)" end="(521, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(521, 71)" end="(521, 75)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(521, 76)" end="(521, 77)">
                  <IdentNode start="(521, 76)" end="(521, 77)" leading="" trailing=" " raw_val="γ" val="γ"/>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(521, 78)" end="(525, 28)">
          <AtomNode start="(521, 78)" end="(521, 80)" leading="" trailing=" " val=":="/>
          <OtherNode start="(521, 81)" end="(521, 93)" kind="Lean.Parser.Term.app">
            <IdentNode start="(521, 81)" end="(521, 83)" leading="" trailing=" " raw_val="go" val="go"/>
            <NullNode start="(521, 84)" end="(521, 93)">
              <IdentNode start="(521, 84)" end="(521, 86)" leading="" trailing=" " raw_val="as" val="as"/>
              <IdentNode start="(521, 87)" end="(521, 89)" leading="" trailing=" " raw_val="bs" val="bs"/>
              <OtherNode start="(521, 90)" end="(521, 93)" kind="«term#[_,]»">
                <AtomNode start="(521, 90)" end="(521, 92)" leading="" trailing="" val="#["/>
                <NullNode/>
                <AtomNode start="(521, 92)" end="(521, 93)" leading="" trailing=" " val="]"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode start="(521, 94)" end="(525, 28)">
            <OtherNode start="(521, 94)" end="(525, 28)" kind="Lean.Parser.Term.whereDecls">
              <AtomNode start="(521, 94)" end="(521, 99)" leading="" trailing="&#10;  " val="where"/>
              <NullNode start="(522, 3)" end="(525, 28)">
                <OtherNode start="(522, 3)" end="(525, 28)" kind="Lean.Parser.Term.letRecDecl">
                  <NullNode start="(522, 3)" end="(522, 91)">
                    <CommandDoccommentNode start="(522, 3)" end="(522, 91)" comment="Auxiliary for `zipWith`: `zipWith.go f as bs acc = acc.toList ++ zipWith f as bs` -/">
                      <AtomNode start="(522, 3)" end="(522, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(522, 7)" end="(522, 91)" leading="" trailing="&#10;  " val="Auxiliary for `zipWith`: `zipWith.go f as bs acc = acc.toList ++ zipWith f as bs` -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <OtherNode start="(523, 3)" end="(525, 28)" kind="Lean.Parser.Term.letDecl">
                    <OtherNode start="(523, 3)" end="(525, 28)" kind="Lean.Parser.Term.letEqnsDecl">
                      <IdentNode start="(523, 3)" end="(523, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode/>
                      <NullNode start="(523, 6)" end="(523, 42)">
                        <TermTypespecNode start="(523, 6)" end="(523, 42)">
                          <AtomNode start="(523, 6)" end="(523, 7)" leading="" trailing=" " val=":"/>
                          <OtherNode start="(523, 8)" end="(523, 42)" kind="Lean.Parser.Term.arrow">
                            <OtherNode start="(523, 8)" end="(523, 14)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(523, 8)" end="(523, 12)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(523, 13)" end="(523, 14)">
                                <IdentNode start="(523, 13)" end="(523, 14)" leading="" trailing=" " raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(523, 15)" end="(523, 16)" leading="" trailing=" " val="→"/>
                            <OtherNode start="(523, 17)" end="(523, 42)" kind="Lean.Parser.Term.arrow">
                              <OtherNode start="(523, 17)" end="(523, 23)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(523, 17)" end="(523, 21)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                <NullNode start="(523, 22)" end="(523, 23)">
                                  <IdentNode start="(523, 22)" end="(523, 23)" leading="" trailing=" " raw_val="β" val="β"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(523, 24)" end="(523, 25)" leading="" trailing=" " val="→"/>
                              <OtherNode start="(523, 26)" end="(523, 42)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(523, 26)" end="(523, 33)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(523, 26)" end="(523, 31)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(523, 32)" end="(523, 33)">
                                    <IdentNode start="(523, 32)" end="(523, 33)" leading="" trailing=" " raw_val="γ" val="γ"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(523, 34)" end="(523, 35)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(523, 36)" end="(523, 42)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(523, 36)" end="(523, 40)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(523, 41)" end="(523, 42)">
                                    <IdentNode start="(523, 41)" end="(523, 42)" leading="" trailing="&#10;  " raw_val="γ" val="γ"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </TermTypespecNode>
                      </NullNode>
                      <OtherNode start="(524, 3)" end="(525, 28)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(524, 3)" end="(525, 28)">
                          <OtherNode start="(524, 3)" end="(524, 53)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(524, 3)" end="(524, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(524, 5)" end="(524, 22)">
                              <NullNode start="(524, 5)" end="(524, 22)">
                                <OtherNode start="(524, 5)" end="(524, 10)" kind="«term_::_»">
                                  <IdentNode start="(524, 5)" end="(524, 6)" leading="" trailing="" raw_val="a" val="a"/>
                                  <AtomNode start="(524, 6)" end="(524, 8)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(524, 8)" end="(524, 10)" leading="" trailing="" raw_val="as" val="as"/>
                                </OtherNode>
                                <AtomNode start="(524, 10)" end="(524, 11)" leading="" trailing=" " val=","/>
                                <OtherNode start="(524, 12)" end="(524, 17)" kind="«term_::_»">
                                  <IdentNode start="(524, 12)" end="(524, 13)" leading="" trailing="" raw_val="b" val="b"/>
                                  <AtomNode start="(524, 13)" end="(524, 15)" leading="" trailing="" val="::"/>
                                  <IdentNode start="(524, 15)" end="(524, 17)" leading="" trailing="" raw_val="bs" val="bs"/>
                                </OtherNode>
                                <AtomNode start="(524, 17)" end="(524, 18)" leading="" trailing=" " val=","/>
                                <IdentNode start="(524, 19)" end="(524, 22)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(524, 23)" end="(524, 25)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(524, 26)" end="(524, 53)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(524, 26)" end="(524, 28)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode start="(524, 29)" end="(524, 53)">
                                <IdentNode start="(524, 29)" end="(524, 31)" leading="" trailing=" " raw_val="as" val="as"/>
                                <IdentNode start="(524, 32)" end="(524, 34)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                <OtherNode start="(524, 35)" end="(524, 53)" kind="Lean.Parser.Term.paren">
                                  <AtomNode start="(524, 35)" end="(524, 36)" leading="" trailing="" val="("/>
                                  <OtherNode start="(524, 36)" end="(524, 52)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(524, 36)" end="(524, 44)" leading="" trailing=" " raw_val="acc.push" val="acc.push"/>
                                    <NullNode start="(524, 45)" end="(524, 52)">
                                      <OtherNode start="(524, 45)" end="(524, 52)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(524, 45)" end="(524, 46)" leading="" trailing="" val="("/>
                                        <OtherNode start="(524, 46)" end="(524, 51)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(524, 46)" end="(524, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <NullNode start="(524, 48)" end="(524, 51)">
                                            <IdentNode start="(524, 48)" end="(524, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                                            <IdentNode start="(524, 50)" end="(524, 51)" leading="" trailing="" raw_val="b" val="b"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(524, 51)" end="(524, 52)" leading="" trailing="" val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(524, 52)" end="(524, 53)" leading="" trailing="&#10;  " val=")"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode start="(525, 3)" end="(525, 28)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(525, 3)" end="(525, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(525, 5)" end="(525, 14)">
                              <NullNode start="(525, 5)" end="(525, 14)">
                                <TermHoleNode start="(525, 5)" end="(525, 6)">
                                  <AtomNode start="(525, 5)" end="(525, 6)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(525, 6)" end="(525, 7)" leading="" trailing=" " val=","/>
                                <TermHoleNode start="(525, 8)" end="(525, 9)">
                                  <AtomNode start="(525, 8)" end="(525, 9)" leading="" trailing="" val="_"/>
                                </TermHoleNode>
                                <AtomNode start="(525, 9)" end="(525, 10)" leading="" trailing=" " val=","/>
                                <IdentNode start="(525, 11)" end="(525, 14)" leading="" trailing=" " raw_val="acc" val="acc"/>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(525, 15)" end="(525, 17)" leading="" trailing=" " val="=&amp;gt;"/>
                            <IdentNode start="(525, 18)" end="(525, 28)" leading="" trailing="&#10;&#10;" raw_val="acc.toList" val="acc.toList"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode kind="Lean.Parser.Termination.suffix">
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </NullNode>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(527, 1)" end="(532, 28)" name="zipWith_eq_zipWithTR" full_name="List.zipWith_eq_zipWithTR">
      <CommandDeclmodifiersNode start="(527, 1)" end="(527, 9)">
        <NullNode/>
        <NullNode start="(527, 1)" end="(527, 9)">
          <OtherNode start="(527, 1)" end="(527, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(527, 1)" end="(527, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(527, 3)" end="(527, 8)">
              <OtherNode start="(527, 3)" end="(527, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(527, 3)" end="(527, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(527, 3)" end="(527, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(527, 8)" end="(527, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(527, 10)" end="(532, 28)" name="zipWith_eq_zipWithTR" full_name="List.zipWith_eq_zipWithTR" _is_private_decl="False">
        <AtomNode start="(527, 10)" end="(527, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(527, 18)" end="(527, 38)">
          <IdentNode start="(527, 18)" end="(527, 38)" leading="" trailing=" " raw_val="zipWith_eq_zipWithTR" val="zipWith_eq_zipWithTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(527, 39)" end="(527, 62)">
          <NullNode/>
          <TermTypespecNode start="(527, 39)" end="(527, 62)">
            <AtomNode start="(527, 39)" end="(527, 40)" leading="" trailing=" " val=":"/>
            <OtherNode start="(527, 41)" end="(527, 62)" kind="«term_=_»">
              <OtherNode start="(527, 41)" end="(527, 49)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(527, 41)" end="(527, 42)" leading="" trailing="" val="@"/>
                <IdentNode start="(527, 42)" end="(527, 49)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(527, 50)" end="(527, 51)" leading="" trailing=" " val="="/>
              <OtherNode start="(527, 52)" end="(527, 62)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(527, 52)" end="(527, 53)" leading="" trailing="" val="@"/>
                <IdentNode start="(527, 53)" end="(527, 62)" leading="" trailing=" " raw_val="zipWithTR" val="zipWithTR" full_name="List.zipWithTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(521, 15)" def_end="(521, 24)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(527, 63)" end="(532, 28)">
          <AtomNode start="(527, 63)" end="(527, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(527, 66)" end="(532, 28)">
            <AtomNode start="(527, 66)" end="(527, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(528, 3)" end="(532, 28)">
              <TacticTacticseq1IndentedNode start="(528, 3)" end="(532, 28)">
                <NullNode start="(528, 3)" end="(532, 28)">
                  <OtherNode start="(528, 3)" end="(528, 23)" kind="tacticFunext___" state_before="⊢ @zipWith = @zipWithTR" state_after="case h.h.h.h.h.h&#10;α : Type u_3&#10;β : Type u_2&#10;γ : Type u_1&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;⊢ zipWith f as bs = zipWithTR f as bs" tactic="funext α β γ f as bs">
                    <AtomNode start="(528, 3)" end="(528, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(528, 10)" end="(528, 23)">
                      <IdentNode start="(528, 10)" end="(528, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(528, 12)" end="(528, 13)" leading="" trailing=" " raw_val="β" val="β"/>
                      <IdentNode start="(528, 14)" end="(528, 15)" leading="" trailing=" " raw_val="γ" val="γ"/>
                      <IdentNode start="(528, 16)" end="(528, 17)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(528, 18)" end="(528, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(528, 21)" end="(528, 23)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(529, 3)" end="(531, 69)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(529, 3)" end="(529, 6)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(529, 7)" end="(529, 10)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(529, 11)" end="(531, 69)" kind="Lean.Parser.Term.letRecDecls">
                      <NullNode start="(529, 11)" end="(531, 69)">
                        <OtherNode start="(529, 11)" end="(531, 69)" kind="Lean.Parser.Term.letRecDecl">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(529, 11)" end="(531, 69)" kind="Lean.Parser.Term.letDecl">
                            <OtherNode start="(529, 11)" end="(531, 69)" kind="Lean.Parser.Term.letEqnsDecl">
                              <IdentNode start="(529, 11)" end="(529, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode/>
                              <NullNode start="(529, 14)" end="(529, 85)">
                                <TermTypespecNode start="(529, 14)" end="(529, 85)">
                                  <AtomNode start="(529, 14)" end="(529, 15)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(529, 16)" end="(529, 85)" kind="Lean.Parser.Term.forall">
                                    <AtomNode start="(529, 16)" end="(529, 17)" leading="" trailing=" " val="∀"/>
                                    <NullNode start="(529, 18)" end="(529, 27)">
                                      <IdentNode start="(529, 18)" end="(529, 20)" leading="" trailing=" " raw_val="as" val="as"/>
                                      <IdentNode start="(529, 21)" end="(529, 23)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                      <IdentNode start="(529, 24)" end="(529, 27)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(529, 27)" end="(529, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(529, 29)" end="(529, 85)" kind="«term_=_»">
                                      <OtherNode start="(529, 29)" end="(529, 53)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(529, 29)" end="(529, 41)" leading="" trailing=" " raw_val="zipWithTR.go" val="zipWithTR.go" full_name="List.zipWithTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(523, 3)" def_end="(523, 5)"/>
                                        <NullNode start="(529, 42)" end="(529, 53)">
                                          <IdentNode start="(529, 42)" end="(529, 43)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <IdentNode start="(529, 44)" end="(529, 46)" leading="" trailing=" " raw_val="as" val="as"/>
                                          <IdentNode start="(529, 47)" end="(529, 49)" leading="" trailing=" " raw_val="bs" val="bs"/>
                                          <IdentNode start="(529, 50)" end="(529, 53)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(529, 54)" end="(529, 55)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(529, 56)" end="(529, 85)" kind="«term_++_»">
                                        <IdentNode start="(529, 56)" end="(529, 66)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                        <AtomNode start="(529, 67)" end="(529, 69)" leading="" trailing=" " val="++"/>
                                        <OtherNode start="(529, 70)" end="(529, 85)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(529, 70)" end="(529, 80)" leading="" trailing=" " raw_val="as.zipWith" val="as.zipWith"/>
                                          <NullNode start="(529, 81)" end="(529, 85)">
                                            <IdentNode start="(529, 81)" end="(529, 82)" leading="" trailing=" " raw_val="f" val="f"/>
                                            <IdentNode start="(529, 83)" end="(529, 85)" leading="" trailing="&#10;    " raw_val="bs" val="bs"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </TermTypespecNode>
                              </NullNode>
                              <OtherNode start="(530, 5)" end="(531, 69)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(530, 5)" end="(531, 69)">
                                  <OtherNode start="(530, 5)" end="(530, 68)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(530, 5)" end="(530, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(530, 7)" end="(530, 33)">
                                      <NullNode start="(530, 7)" end="(530, 17)">
                                        <OtherNode start="(530, 7)" end="(530, 9)" kind="«term[_]»">
                                          <AtomNode start="(530, 7)" end="(530, 8)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(530, 8)" end="(530, 9)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(530, 9)" end="(530, 10)" leading="" trailing=" " val=","/>
                                        <TermHoleNode start="(530, 11)" end="(530, 12)">
                                          <AtomNode start="(530, 11)" end="(530, 12)" leading="" trailing="" val="_"/>
                                        </TermHoleNode>
                                        <AtomNode start="(530, 12)" end="(530, 13)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(530, 14)" end="(530, 17)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                      <AtomNode start="(530, 18)" end="(530, 19)" leading="" trailing=" " val="|"/>
                                      <NullNode start="(530, 20)" end="(530, 33)">
                                        <OtherNode start="(530, 20)" end="(530, 24)" kind="«term_::_»">
                                          <TermHoleNode start="(530, 20)" end="(530, 21)">
                                            <AtomNode start="(530, 20)" end="(530, 21)" leading="" trailing="" val="_"/>
                                          </TermHoleNode>
                                          <AtomNode start="(530, 21)" end="(530, 23)" leading="" trailing="" val="::"/>
                                          <TermHoleNode start="(530, 23)" end="(530, 24)">
                                            <AtomNode start="(530, 23)" end="(530, 24)" leading="" trailing="" val="_"/>
                                          </TermHoleNode>
                                        </OtherNode>
                                        <AtomNode start="(530, 24)" end="(530, 25)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(530, 26)" end="(530, 28)" kind="«term[_]»">
                                          <AtomNode start="(530, 26)" end="(530, 27)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(530, 27)" end="(530, 28)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(530, 28)" end="(530, 29)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(530, 30)" end="(530, 33)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(530, 34)" end="(530, 36)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(530, 37)" end="(530, 68)">
                                      <AtomNode start="(530, 37)" end="(530, 39)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(530, 40)" end="(530, 68)">
                                        <TacticTacticseq1IndentedNode start="(530, 40)" end="(530, 68)">
                                          <NullNode start="(530, 40)" end="(530, 68)">
                                            <OtherNode start="(530, 40)" end="(530, 68)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_3&#10;β : Type u_2&#10;γ : Type u_1&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;head✝ : α&#10;tail✝ : List α&#10;acc : Array γ&#10;⊢ zipWithTR.go f (head✝ :: tail✝) [] acc = acc.toList ++ zipWith f (head✝ :: tail✝) []" state_after="no goals" tactic="simp [zipWithTR.go, zipWith]">
                                              <AtomNode start="(530, 40)" end="(530, 44)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(530, 45)" end="(530, 68)">
                                                <AtomNode start="(530, 45)" end="(530, 46)" leading="" trailing="" val="["/>
                                                <NullNode start="(530, 46)" end="(530, 67)">
                                                  <OtherNode start="(530, 46)" end="(530, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(530, 46)" end="(530, 58)" leading="" trailing="" raw_val="zipWithTR.go" val="zipWithTR.go" full_name="List.zipWithTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(523, 3)" def_end="(523, 5)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(530, 58)" end="(530, 59)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(530, 60)" end="(530, 67)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(530, 60)" end="(530, 67)" leading="" trailing="" raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(530, 67)" end="(530, 68)" leading="" trailing="&#10;    " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                  <OtherNode start="(531, 5)" end="(531, 69)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(531, 5)" end="(531, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(531, 7)" end="(531, 24)">
                                      <NullNode start="(531, 7)" end="(531, 24)">
                                        <OtherNode start="(531, 7)" end="(531, 12)" kind="«term_::_»">
                                          <IdentNode start="(531, 7)" end="(531, 8)" leading="" trailing="" raw_val="a" val="a"/>
                                          <AtomNode start="(531, 8)" end="(531, 10)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(531, 10)" end="(531, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                        </OtherNode>
                                        <AtomNode start="(531, 12)" end="(531, 13)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(531, 14)" end="(531, 19)" kind="«term_::_»">
                                          <IdentNode start="(531, 14)" end="(531, 15)" leading="" trailing="" raw_val="b" val="b"/>
                                          <AtomNode start="(531, 15)" end="(531, 17)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(531, 17)" end="(531, 19)" leading="" trailing="" raw_val="bs" val="bs"/>
                                        </OtherNode>
                                        <AtomNode start="(531, 19)" end="(531, 20)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(531, 21)" end="(531, 24)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(531, 25)" end="(531, 27)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(531, 28)" end="(531, 69)">
                                      <AtomNode start="(531, 28)" end="(531, 30)" leading="" trailing=" " val="by"/>
                                      <TacticTacticseqNode start="(531, 31)" end="(531, 69)">
                                        <TacticTacticseq1IndentedNode start="(531, 31)" end="(531, 69)">
                                          <NullNode start="(531, 31)" end="(531, 69)">
                                            <OtherNode start="(531, 31)" end="(531, 69)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_3&#10;β : Type u_2&#10;γ : Type u_1&#10;f : α → β → γ&#10;as✝ : List α&#10;bs✝ : List β&#10;a : α&#10;as : List α&#10;b : β&#10;bs : List β&#10;acc : Array γ&#10;⊢ zipWithTR.go f (a :: as) (b :: bs) acc = acc.toList ++ zipWith f (a :: as) (b :: bs)" state_after="no goals" tactic="simp [zipWithTR.go, zipWith, go as bs]">
                                              <AtomNode start="(531, 31)" end="(531, 35)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(531, 36)" end="(531, 69)">
                                                <AtomNode start="(531, 36)" end="(531, 37)" leading="" trailing="" val="["/>
                                                <NullNode start="(531, 37)" end="(531, 68)">
                                                  <OtherNode start="(531, 37)" end="(531, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(531, 37)" end="(531, 49)" leading="" trailing="" raw_val="zipWithTR.go" val="zipWithTR.go" full_name="List.zipWithTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(523, 3)" def_end="(523, 5)"/>
                                                  </OtherNode>
                                                  <AtomNode start="(531, 49)" end="(531, 50)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(531, 51)" end="(531, 58)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(531, 51)" end="(531, 58)" leading="" trailing="" raw_val="zipWith" val="zipWith" full_name="List.zipWith" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(531, 58)" end="(531, 59)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(531, 60)" end="(531, 68)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <OtherNode start="(531, 60)" end="(531, 68)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(531, 60)" end="(531, 62)" leading="" trailing=" " raw_val="go" val="go"/>
                                                      <NullNode start="(531, 63)" end="(531, 68)">
                                                        <IdentNode start="(531, 63)" end="(531, 65)" leading="" trailing=" " raw_val="as" val="as"/>
                                                        <IdentNode start="(531, 66)" end="(531, 68)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(531, 68)" end="(531, 69)" leading="" trailing="&#10;  " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode kind="Lean.Parser.Termination.suffix">
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(532, 3)" end="(532, 28)" kind="Lean.Parser.Tactic.exact" state_before="case h.h.h.h.h.h&#10;α : Type u_3&#10;β : Type u_2&#10;γ : Type u_1&#10;f : α → β → γ&#10;as : List α&#10;bs : List β&#10;⊢ zipWith f as bs = zipWithTR f as bs" state_after="no goals" tactic="exact (go as bs #[]).symm">
                    <AtomNode start="(532, 3)" end="(532, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(532, 9)" end="(532, 28)" kind="Lean.Parser.Term.proj">
                      <OtherNode start="(532, 9)" end="(532, 23)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(532, 9)" end="(532, 10)" leading="" trailing="" val="("/>
                        <OtherNode start="(532, 10)" end="(532, 22)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(532, 10)" end="(532, 12)" leading="" trailing=" " raw_val="go" val="go"/>
                          <NullNode start="(532, 13)" end="(532, 22)">
                            <IdentNode start="(532, 13)" end="(532, 15)" leading="" trailing=" " raw_val="as" val="as"/>
                            <IdentNode start="(532, 16)" end="(532, 18)" leading="" trailing=" " raw_val="bs" val="bs"/>
                            <OtherNode start="(532, 19)" end="(532, 22)" kind="«term#[_,]»">
                              <AtomNode start="(532, 19)" end="(532, 21)" leading="" trailing="" val="#["/>
                              <NullNode/>
                              <AtomNode start="(532, 21)" end="(532, 22)" leading="" trailing="" val="]"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(532, 22)" end="(532, 23)" leading="" trailing="" val=")"/>
                      </OtherNode>
                      <AtomNode start="(532, 23)" end="(532, 24)" leading="" trailing="" val="."/>
                      <IdentNode start="(532, 24)" end="(532, 28)" leading="" trailing="&#10;&#10;" raw_val="symm" val="symm" full_name="Eq.symm" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(534, 1)" end="(534, 33)" comment="## Ranges and enumeration -/">
      <AtomNode start="(534, 1)" end="(534, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(534, 5)" end="(534, 33)" leading="" trailing="&#10;&#10;" val="## Ranges and enumeration -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(536, 1)" end="(536, 18)" comment="### zipIdx -/">
      <AtomNode start="(536, 1)" end="(536, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(536, 5)" end="(536, 18)" leading="" trailing="&#10;&#10;&#10;" val="### zipIdx -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(539, 1)" end="(550, 76)" name="zipIdxTR" full_name="List.zipIdxTR">
      <CommandDeclmodifiersNode start="(539, 1)" end="(547, 3)">
        <NullNode start="(539, 1)" end="(547, 3)">
          <CommandDoccommentNode start="(539, 1)" end="(547, 3)" comment="Pairs each element of a list with its index, optionally starting from an index other than `0`.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.zipIdx` that's used at runtime.&#10;&#10;Examples:&#10;* `[a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]`&#10;* `[a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]`&#10;-/">
            <AtomNode start="(539, 1)" end="(539, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(540, 1)" end="(547, 3)" leading="" trailing="&#10;" val="Pairs each element of a list with its index, optionally starting from an index other than `0`.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.zipIdx` that's used at runtime.&#10;&#10;Examples:&#10;* `[a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]`&#10;* `[a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]`&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(548, 1)" end="(550, 76)" name="zipIdxTR">
        <AtomNode start="(548, 1)" end="(548, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(548, 5)" end="(548, 13)">
          <IdentNode start="(548, 5)" end="(548, 13)" leading="" trailing=" " raw_val="zipIdxTR" val="zipIdxTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(548, 14)" end="(548, 58)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(548, 14)" end="(548, 41)">
            <TermExplicitbinderNode start="(548, 14)" end="(548, 26)">
              <AtomNode start="(548, 14)" end="(548, 15)" leading="" trailing="" val="("/>
              <NullNode start="(548, 15)" end="(548, 16)">
                <IdentNode start="(548, 15)" end="(548, 16)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(548, 17)" end="(548, 25)">
                <AtomNode start="(548, 17)" end="(548, 18)" leading="" trailing=" " val=":"/>
                <OtherNode start="(548, 19)" end="(548, 25)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(548, 19)" end="(548, 23)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(548, 24)" end="(548, 25)">
                    <IdentNode start="(548, 24)" end="(548, 25)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(548, 25)" end="(548, 26)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(548, 27)" end="(548, 41)">
              <AtomNode start="(548, 27)" end="(548, 28)" leading="" trailing="" val="("/>
              <NullNode start="(548, 28)" end="(548, 29)">
                <IdentNode start="(548, 28)" end="(548, 29)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(548, 30)" end="(548, 35)">
                <AtomNode start="(548, 30)" end="(548, 31)" leading="" trailing=" " val=":"/>
                <IdentNode start="(548, 32)" end="(548, 35)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode start="(548, 36)" end="(548, 40)">
                <OtherNode start="(548, 36)" end="(548, 40)" kind="Lean.Parser.Term.binderDefault">
                  <AtomNode start="(548, 36)" end="(548, 38)" leading="" trailing=" " val=":="/>
                  <OtherNode start="(548, 39)" end="(548, 40)" kind="num">
                    <AtomNode start="(548, 39)" end="(548, 40)" leading="" trailing="" val="0"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(548, 40)" end="(548, 41)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(548, 42)" end="(548, 58)">
            <TermTypespecNode start="(548, 42)" end="(548, 58)">
              <AtomNode start="(548, 42)" end="(548, 43)" leading="" trailing=" " val=":"/>
              <OtherNode start="(548, 44)" end="(548, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(548, 44)" end="(548, 48)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(548, 49)" end="(548, 58)">
                  <OtherNode start="(548, 49)" end="(548, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(548, 49)" end="(548, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(548, 50)" end="(548, 57)" kind="«term_×_»">
                      <IdentNode start="(548, 50)" end="(548, 51)" leading="" trailing=" " raw_val="α" val="α"/>
                      <AtomNode start="(548, 52)" end="(548, 53)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(548, 54)" end="(548, 57)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(548, 57)" end="(548, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(548, 59)" end="(550, 76)">
          <AtomNode start="(548, 59)" end="(548, 61)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(549, 3)" end="(550, 76)" kind="Lean.Parser.Term.let">
            <AtomNode start="(549, 3)" end="(549, 6)" leading="" trailing=" " val="let"/>
            <OtherNode start="(549, 7)" end="(549, 22)" kind="Lean.Parser.Term.letDecl">
              <OtherNode start="(549, 7)" end="(549, 22)" kind="Lean.Parser.Term.letIdDecl">
                <IdentNode start="(549, 7)" end="(549, 9)" leading="" trailing=" " raw_val="as" val="as"/>
                <NullNode/>
                <NullNode/>
                <AtomNode start="(549, 10)" end="(549, 12)" leading="" trailing=" " val=":="/>
                <IdentNode start="(549, 13)" end="(549, 22)" leading="" trailing="&#10;  " raw_val="l.toArray" val="l.toArray"/>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(550, 3)" end="(550, 76)" kind="Lean.Parser.Term.proj">
              <OtherNode start="(550, 3)" end="(550, 74)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(550, 3)" end="(550, 4)" leading="" trailing="" val="("/>
                <OtherNode start="(550, 4)" end="(550, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(550, 4)" end="(550, 12)" leading="" trailing=" " raw_val="as.foldr" val="as.foldr"/>
                  <NullNode start="(550, 13)" end="(550, 73)">
                    <OtherNode start="(550, 13)" end="(550, 55)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(550, 13)" end="(550, 14)" leading="" trailing="" val="("/>
                      <OtherNode start="(550, 14)" end="(550, 54)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(550, 14)" end="(550, 17)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(550, 18)" end="(550, 54)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(550, 18)" end="(550, 28)">
                            <IdentNode start="(550, 18)" end="(550, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(550, 20)" end="(550, 28)" kind="Lean.Parser.Term.tuple">
                              <AtomNode start="(550, 20)" end="(550, 21)" leading="" trailing="" val="("/>
                              <NullNode start="(550, 21)" end="(550, 27)">
                                <IdentNode start="(550, 21)" end="(550, 22)" leading="" trailing="" raw_val="n" val="n"/>
                                <AtomNode start="(550, 22)" end="(550, 23)" leading="" trailing=" " val=","/>
                                <NullNode start="(550, 24)" end="(550, 27)">
                                  <IdentNode start="(550, 24)" end="(550, 27)" leading="" trailing="" raw_val="acc" val="acc"/>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(550, 27)" end="(550, 28)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(550, 29)" end="(550, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(550, 32)" end="(550, 54)" kind="Lean.Parser.Term.tuple">
                            <AtomNode start="(550, 32)" end="(550, 33)" leading="" trailing="" val="("/>
                            <NullNode start="(550, 33)" end="(550, 53)">
                              <OtherNode start="(550, 33)" end="(550, 36)" kind="«term_-_»">
                                <IdentNode start="(550, 33)" end="(550, 34)" leading="" trailing="" raw_val="n" val="n"/>
                                <AtomNode start="(550, 34)" end="(550, 35)" leading="" trailing="" val="-"/>
                                <OtherNode start="(550, 35)" end="(550, 36)" kind="num">
                                  <AtomNode start="(550, 35)" end="(550, 36)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(550, 36)" end="(550, 37)" leading="" trailing=" " val=","/>
                              <NullNode start="(550, 38)" end="(550, 53)">
                                <OtherNode start="(550, 38)" end="(550, 53)" kind="«term_::_»">
                                  <OtherNode start="(550, 38)" end="(550, 46)" kind="Lean.Parser.Term.tuple">
                                    <AtomNode start="(550, 38)" end="(550, 39)" leading="" trailing="" val="("/>
                                    <NullNode start="(550, 39)" end="(550, 45)">
                                      <IdentNode start="(550, 39)" end="(550, 40)" leading="" trailing="" raw_val="a" val="a"/>
                                      <AtomNode start="(550, 40)" end="(550, 41)" leading="" trailing=" " val=","/>
                                      <NullNode start="(550, 42)" end="(550, 45)">
                                        <OtherNode start="(550, 42)" end="(550, 45)" kind="«term_-_»">
                                          <IdentNode start="(550, 42)" end="(550, 43)" leading="" trailing="" raw_val="n" val="n"/>
                                          <AtomNode start="(550, 43)" end="(550, 44)" leading="" trailing="" val="-"/>
                                          <OtherNode start="(550, 44)" end="(550, 45)" kind="num">
                                            <AtomNode start="(550, 44)" end="(550, 45)" leading="" trailing="" val="1"/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(550, 45)" end="(550, 46)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(550, 47)" end="(550, 49)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(550, 50)" end="(550, 53)" leading="" trailing="" raw_val="acc" val="acc"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(550, 53)" end="(550, 54)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(550, 54)" end="(550, 55)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(550, 56)" end="(550, 73)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(550, 56)" end="(550, 57)" leading="" trailing="" val="("/>
                      <NullNode start="(550, 57)" end="(550, 72)">
                        <OtherNode start="(550, 57)" end="(550, 68)" kind="«term_+_»">
                          <IdentNode start="(550, 57)" end="(550, 58)" leading="" trailing=" " raw_val="n" val="n"/>
                          <AtomNode start="(550, 59)" end="(550, 60)" leading="" trailing=" " val="+"/>
                          <IdentNode start="(550, 61)" end="(550, 68)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                        </OtherNode>
                        <AtomNode start="(550, 68)" end="(550, 69)" leading="" trailing=" " val=","/>
                        <NullNode start="(550, 70)" end="(550, 72)">
                          <OtherNode start="(550, 70)" end="(550, 72)" kind="«term[_]»">
                            <AtomNode start="(550, 70)" end="(550, 71)" leading="" trailing="" val="["/>
                            <NullNode/>
                            <AtomNode start="(550, 71)" end="(550, 72)" leading="" trailing="" val="]"/>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(550, 72)" end="(550, 73)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(550, 73)" end="(550, 74)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(550, 74)" end="(550, 75)" leading="" trailing="" val="."/>
              <OtherNode start="(550, 75)" end="(550, 76)" kind="fieldIdx">
                <AtomNode start="(550, 75)" end="(550, 76)" leading="" trailing="&#10;&#10;" val="2"/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(552, 1)" end="(561, 23)" name="zipIdx_eq_zipIdxTR" full_name="List.zipIdx_eq_zipIdxTR">
      <CommandDeclmodifiersNode start="(552, 1)" end="(552, 9)">
        <NullNode/>
        <NullNode start="(552, 1)" end="(552, 9)">
          <OtherNode start="(552, 1)" end="(552, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(552, 1)" end="(552, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(552, 3)" end="(552, 8)">
              <OtherNode start="(552, 3)" end="(552, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(552, 3)" end="(552, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(552, 3)" end="(552, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(552, 8)" end="(552, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(552, 10)" end="(561, 23)" name="zipIdx_eq_zipIdxTR" full_name="List.zipIdx_eq_zipIdxTR" _is_private_decl="False">
        <AtomNode start="(552, 10)" end="(552, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(552, 18)" end="(552, 36)">
          <IdentNode start="(552, 18)" end="(552, 36)" leading="" trailing=" " raw_val="zipIdx_eq_zipIdxTR" val="zipIdx_eq_zipIdxTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(552, 37)" end="(552, 58)">
          <NullNode/>
          <TermTypespecNode start="(552, 37)" end="(552, 58)">
            <AtomNode start="(552, 37)" end="(552, 38)" leading="" trailing=" " val=":"/>
            <OtherNode start="(552, 39)" end="(552, 58)" kind="«term_=_»">
              <OtherNode start="(552, 39)" end="(552, 46)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(552, 39)" end="(552, 40)" leading="" trailing="" val="@"/>
                <IdentNode start="(552, 40)" end="(552, 46)" leading="" trailing=" " raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(552, 47)" end="(552, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(552, 49)" end="(552, 58)" kind="Lean.Parser.Term.explicit">
                <AtomNode start="(552, 49)" end="(552, 50)" leading="" trailing="" val="@"/>
                <IdentNode start="(552, 50)" end="(552, 58)" leading="" trailing=" " raw_val="zipIdxTR" val="zipIdxTR" full_name="List.zipIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(548, 5)" def_end="(548, 13)"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(552, 59)" end="(561, 23)">
          <AtomNode start="(552, 59)" end="(552, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(552, 62)" end="(561, 23)">
            <AtomNode start="(552, 62)" end="(552, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(553, 3)" end="(561, 23)">
              <TacticTacticseq1IndentedNode start="(553, 3)" end="(561, 23)">
                <NullNode start="(553, 3)" end="(561, 23)">
                  <OtherNode start="(553, 3)" end="(553, 15)" kind="tacticFunext___" state_before="⊢ @zipIdx = @zipIdxTR" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;⊢ l.zipIdx n = l.zipIdxTR n" tactic="funext α l n">
                    <AtomNode start="(553, 3)" end="(553, 9)" leading="" trailing=" " val="funext"/>
                    <NullNode start="(553, 10)" end="(553, 15)">
                      <IdentNode start="(553, 10)" end="(553, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                      <IdentNode start="(553, 12)" end="(553, 13)" leading="" trailing=" " raw_val="l" val="l"/>
                      <IdentNode start="(553, 14)" end="(553, 15)" leading="" trailing="" raw_val="n" val="n"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(553, 15)" end="(553, 16)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(553, 17)" end="(553, 51)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;⊢ l.zipIdx n = l.zipIdxTR n" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;⊢ l.zipIdx n = (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (a, x.fst - 1) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" tactic="simp only [zipIdxTR, size_toArray]">
                    <AtomNode start="(553, 17)" end="(553, 21)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(553, 22)" end="(553, 26)">
                      <AtomNode start="(553, 22)" end="(553, 26)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(553, 27)" end="(553, 51)">
                      <AtomNode start="(553, 27)" end="(553, 28)" leading="" trailing="" val="["/>
                      <NullNode start="(553, 28)" end="(553, 50)">
                        <OtherNode start="(553, 28)" end="(553, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(553, 28)" end="(553, 36)" leading="" trailing="" raw_val="zipIdxTR" val="zipIdxTR" full_name="List.zipIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(548, 5)" def_end="(548, 13)"/>
                        </OtherNode>
                        <AtomNode start="(553, 36)" end="(553, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(553, 38)" end="(553, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(553, 38)" end="(553, 50)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(553, 50)" end="(553, 51)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(554, 3)" end="(554, 58)" kind="Lean.Parser.Tactic.tacticLet_" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;⊢ l.zipIdx n = (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (a, x.fst - 1) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;⊢ l.zipIdx n = (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (a, x.fst - 1) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" tactic="let f := fun (a : α) (n, acc) =&amp;gt; (n-1, (a, n-1) :: acc)">
                    <AtomNode start="(554, 3)" end="(554, 6)" leading="" trailing=" " val="let"/>
                    <OtherNode start="(554, 7)" end="(554, 58)" kind="Lean.Parser.Term.letDecl">
                      <OtherNode start="(554, 7)" end="(554, 58)" kind="Lean.Parser.Term.letIdDecl">
                        <IdentNode start="(554, 7)" end="(554, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(554, 9)" end="(554, 11)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(554, 12)" end="(554, 58)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(554, 12)" end="(554, 15)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(554, 16)" end="(554, 58)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(554, 16)" end="(554, 32)">
                              <OtherNode start="(554, 16)" end="(554, 23)" kind="Lean.Parser.Term.typeAscription">
                                <AtomNode start="(554, 16)" end="(554, 17)" leading="" trailing="" val="("/>
                                <IdentNode start="(554, 17)" end="(554, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                                <AtomNode start="(554, 19)" end="(554, 20)" leading="" trailing=" " val=":"/>
                                <NullNode start="(554, 21)" end="(554, 22)">
                                  <IdentNode start="(554, 21)" end="(554, 22)" leading="" trailing="" raw_val="α" val="α"/>
                                </NullNode>
                                <AtomNode start="(554, 22)" end="(554, 23)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                              <OtherNode start="(554, 24)" end="(554, 32)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(554, 24)" end="(554, 25)" leading="" trailing="" val="("/>
                                <NullNode start="(554, 25)" end="(554, 31)">
                                  <IdentNode start="(554, 25)" end="(554, 26)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(554, 26)" end="(554, 27)" leading="" trailing=" " val=","/>
                                  <NullNode start="(554, 28)" end="(554, 31)">
                                    <IdentNode start="(554, 28)" end="(554, 31)" leading="" trailing="" raw_val="acc" val="acc"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(554, 31)" end="(554, 32)" leading="" trailing=" " val=")"/>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(554, 33)" end="(554, 35)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(554, 36)" end="(554, 58)" kind="Lean.Parser.Term.tuple">
                              <AtomNode start="(554, 36)" end="(554, 37)" leading="" trailing="" val="("/>
                              <NullNode start="(554, 37)" end="(554, 57)">
                                <OtherNode start="(554, 37)" end="(554, 40)" kind="«term_-_»">
                                  <IdentNode start="(554, 37)" end="(554, 38)" leading="" trailing="" raw_val="n" val="n"/>
                                  <AtomNode start="(554, 38)" end="(554, 39)" leading="" trailing="" val="-"/>
                                  <OtherNode start="(554, 39)" end="(554, 40)" kind="num">
                                    <AtomNode start="(554, 39)" end="(554, 40)" leading="" trailing="" val="1"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(554, 40)" end="(554, 41)" leading="" trailing=" " val=","/>
                                <NullNode start="(554, 42)" end="(554, 57)">
                                  <OtherNode start="(554, 42)" end="(554, 57)" kind="«term_::_»">
                                    <OtherNode start="(554, 42)" end="(554, 50)" kind="Lean.Parser.Term.tuple">
                                      <AtomNode start="(554, 42)" end="(554, 43)" leading="" trailing="" val="("/>
                                      <NullNode start="(554, 43)" end="(554, 49)">
                                        <IdentNode start="(554, 43)" end="(554, 44)" leading="" trailing="" raw_val="a" val="a"/>
                                        <AtomNode start="(554, 44)" end="(554, 45)" leading="" trailing=" " val=","/>
                                        <NullNode start="(554, 46)" end="(554, 49)">
                                          <OtherNode start="(554, 46)" end="(554, 49)" kind="«term_-_»">
                                            <IdentNode start="(554, 46)" end="(554, 47)" leading="" trailing="" raw_val="n" val="n"/>
                                            <AtomNode start="(554, 47)" end="(554, 48)" leading="" trailing="" val="-"/>
                                            <OtherNode start="(554, 48)" end="(554, 49)" kind="num">
                                              <AtomNode start="(554, 48)" end="(554, 49)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(554, 49)" end="(554, 50)" leading="" trailing=" " val=")"/>
                                    </OtherNode>
                                    <AtomNode start="(554, 51)" end="(554, 53)" leading="" trailing=" " val="::"/>
                                    <IdentNode start="(554, 54)" end="(554, 57)" leading="" trailing="" raw_val="acc" val="acc"/>
                                  </OtherNode>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(554, 57)" end="(554, 58)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(555, 3)" end="(559, 23)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(555, 3)" end="(555, 6)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(555, 7)" end="(555, 10)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(555, 11)" end="(559, 23)" kind="Lean.Parser.Term.letRecDecls">
                      <NullNode start="(555, 11)" end="(559, 23)">
                        <OtherNode start="(555, 11)" end="(559, 23)" kind="Lean.Parser.Term.letRecDecl">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(555, 11)" end="(559, 23)" kind="Lean.Parser.Term.letDecl">
                            <OtherNode start="(555, 11)" end="(559, 23)" kind="Lean.Parser.Term.letEqnsDecl">
                              <IdentNode start="(555, 11)" end="(555, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                              <NullNode/>
                              <NullNode start="(555, 14)" end="(555, 69)">
                                <TermTypespecNode start="(555, 14)" end="(555, 69)">
                                  <AtomNode start="(555, 14)" end="(555, 15)" leading="" trailing=" " val=":"/>
                                  <OtherNode start="(555, 16)" end="(555, 69)" kind="Lean.Parser.Term.forall">
                                    <AtomNode start="(555, 16)" end="(555, 17)" leading="" trailing=" " val="∀"/>
                                    <NullNode start="(555, 18)" end="(555, 21)">
                                      <IdentNode start="(555, 18)" end="(555, 19)" leading="" trailing=" " raw_val="l" val="l"/>
                                      <IdentNode start="(555, 20)" end="(555, 21)" leading="" trailing="" raw_val="i" val="i"/>
                                    </NullNode>
                                    <NullNode/>
                                    <AtomNode start="(555, 21)" end="(555, 22)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(555, 23)" end="(555, 69)" kind="«term_=_»">
                                      <OtherNode start="(555, 23)" end="(555, 51)" kind="Lean.Parser.Term.app">
                                        <IdentNode start="(555, 23)" end="(555, 30)" leading="" trailing=" " raw_val="l.foldr" val="l.foldr"/>
                                        <NullNode start="(555, 31)" end="(555, 51)">
                                          <IdentNode start="(555, 31)" end="(555, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                                          <OtherNode start="(555, 33)" end="(555, 51)" kind="Lean.Parser.Term.tuple">
                                            <AtomNode start="(555, 33)" end="(555, 34)" leading="" trailing="" val="("/>
                                            <NullNode start="(555, 34)" end="(555, 50)">
                                              <OtherNode start="(555, 34)" end="(555, 46)" kind="«term_+_»">
                                                <IdentNode start="(555, 34)" end="(555, 35)" leading="" trailing=" " raw_val="i" val="i"/>
                                                <AtomNode start="(555, 36)" end="(555, 37)" leading="" trailing=" " val="+"/>
                                                <IdentNode start="(555, 38)" end="(555, 46)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                                              </OtherNode>
                                              <AtomNode start="(555, 46)" end="(555, 47)" leading="" trailing=" " val=","/>
                                              <NullNode start="(555, 48)" end="(555, 50)">
                                                <OtherNode start="(555, 48)" end="(555, 50)" kind="«term[_]»">
                                                  <AtomNode start="(555, 48)" end="(555, 49)" leading="" trailing="" val="["/>
                                                  <NullNode/>
                                                  <AtomNode start="(555, 49)" end="(555, 50)" leading="" trailing="" val="]"/>
                                                </OtherNode>
                                              </NullNode>
                                            </NullNode>
                                            <AtomNode start="(555, 50)" end="(555, 51)" leading="" trailing=" " val=")"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(555, 52)" end="(555, 53)" leading="" trailing=" " val="="/>
                                      <OtherNode start="(555, 54)" end="(555, 69)" kind="Lean.Parser.Term.tuple">
                                        <AtomNode start="(555, 54)" end="(555, 55)" leading="" trailing="" val="("/>
                                        <NullNode start="(555, 55)" end="(555, 68)">
                                          <IdentNode start="(555, 55)" end="(555, 56)" leading="" trailing="" raw_val="i" val="i"/>
                                          <AtomNode start="(555, 56)" end="(555, 57)" leading="" trailing=" " val=","/>
                                          <NullNode start="(555, 58)" end="(555, 68)">
                                            <OtherNode start="(555, 58)" end="(555, 68)" kind="Lean.Parser.Term.app">
                                              <IdentNode start="(555, 58)" end="(555, 64)" leading="" trailing=" " raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                              <NullNode start="(555, 65)" end="(555, 68)">
                                                <IdentNode start="(555, 65)" end="(555, 66)" leading="" trailing=" " raw_val="l" val="l"/>
                                                <IdentNode start="(555, 67)" end="(555, 68)" leading="" trailing="" raw_val="i" val="i"/>
                                              </NullNode>
                                            </OtherNode>
                                          </NullNode>
                                        </NullNode>
                                        <AtomNode start="(555, 68)" end="(555, 69)" leading="" trailing="&#10;    " val=")"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </OtherNode>
                                </TermTypespecNode>
                              </NullNode>
                              <OtherNode start="(556, 5)" end="(559, 23)" kind="Lean.Parser.Term.matchAlts">
                                <NullNode start="(556, 5)" end="(559, 23)">
                                  <OtherNode start="(556, 5)" end="(556, 19)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(556, 5)" end="(556, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(556, 7)" end="(556, 12)">
                                      <NullNode start="(556, 7)" end="(556, 12)">
                                        <OtherNode start="(556, 7)" end="(556, 9)" kind="«term[_]»">
                                          <AtomNode start="(556, 7)" end="(556, 8)" leading="" trailing="" val="["/>
                                          <NullNode/>
                                          <AtomNode start="(556, 8)" end="(556, 9)" leading="" trailing="" val="]"/>
                                        </OtherNode>
                                        <AtomNode start="(556, 9)" end="(556, 10)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(556, 11)" end="(556, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(556, 13)" end="(556, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <IdentNode start="(556, 16)" end="(556, 19)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </OtherNode>
                                  <OtherNode start="(557, 5)" end="(559, 23)" kind="Lean.Parser.Term.matchAlt">
                                    <AtomNode start="(557, 5)" end="(557, 6)" leading="" trailing=" " val="|"/>
                                    <NullNode start="(557, 7)" end="(557, 15)">
                                      <NullNode start="(557, 7)" end="(557, 15)">
                                        <OtherNode start="(557, 7)" end="(557, 12)" kind="«term_::_»">
                                          <IdentNode start="(557, 7)" end="(557, 8)" leading="" trailing="" raw_val="a" val="a"/>
                                          <AtomNode start="(557, 8)" end="(557, 10)" leading="" trailing="" val="::"/>
                                          <IdentNode start="(557, 10)" end="(557, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                        </OtherNode>
                                        <AtomNode start="(557, 12)" end="(557, 13)" leading="" trailing=" " val=","/>
                                        <IdentNode start="(557, 14)" end="(557, 15)" leading="" trailing=" " raw_val="n" val="n"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(557, 16)" end="(557, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                    <TermBytacticNode start="(557, 19)" end="(559, 23)">
                                      <AtomNode start="(557, 19)" end="(557, 21)" leading="" trailing="&#10;      " val="by"/>
                                      <TacticTacticseqNode start="(558, 7)" end="(559, 23)">
                                        <TacticTacticseq1IndentedNode start="(558, 7)" end="(559, 23)">
                                          <NullNode start="(558, 7)" end="(559, 23)">
                                            <OtherNode start="(558, 7)" end="(558, 88)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;l : List α&#10;n✝ : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;a : α&#10;as : List α&#10;n : Nat&#10;⊢ foldr f (n + (a :: as).length, []) (a :: as) = (n, (a :: as).zipIdx n)" state_after="α : Type u_1&#10;l : List α&#10;n✝ : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;a : α&#10;as : List α&#10;n : Nat&#10;⊢ f a (n.succ, as.zipIdx n.succ) = (n, (a :: as).zipIdx n)" tactic="rw [← show _ + as.length = n + (a::as).length from Nat.succ_add .., foldr, go as]">
                                              <AtomNode start="(558, 7)" end="(558, 9)" leading="" trailing=" " val="rw"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <OtherNode start="(558, 10)" end="(558, 88)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                <AtomNode start="(558, 10)" end="(558, 11)" leading="" trailing="" val="["/>
                                                <NullNode start="(558, 11)" end="(558, 87)">
                                                  <OtherNode start="(558, 11)" end="(558, 73)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode start="(558, 11)" end="(558, 12)">
                                                      <OtherNode start="(558, 11)" end="(558, 12)" kind="patternIgnore">
                                                        <OtherNode start="(558, 11)" end="(558, 12)" kind="token.«← »">
                                                          <AtomNode start="(558, 11)" end="(558, 12)" leading="" trailing=" " val="←"/>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                    <OtherNode start="(558, 13)" end="(558, 73)" kind="Lean.Parser.Term.show">
                                                      <AtomNode start="(558, 13)" end="(558, 17)" leading="" trailing=" " val="show"/>
                                                      <OtherNode start="(558, 18)" end="(558, 52)" kind="«term_=_»">
                                                        <OtherNode start="(558, 18)" end="(558, 31)" kind="«term_+_»">
                                                          <TermHoleNode start="(558, 18)" end="(558, 19)">
                                                            <AtomNode start="(558, 18)" end="(558, 19)" leading="" trailing=" " val="_"/>
                                                          </TermHoleNode>
                                                          <AtomNode start="(558, 20)" end="(558, 21)" leading="" trailing=" " val="+"/>
                                                          <IdentNode start="(558, 22)" end="(558, 31)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                                                        </OtherNode>
                                                        <AtomNode start="(558, 32)" end="(558, 33)" leading="" trailing=" " val="="/>
                                                        <OtherNode start="(558, 34)" end="(558, 52)" kind="«term_+_»">
                                                          <IdentNode start="(558, 34)" end="(558, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                                                          <AtomNode start="(558, 36)" end="(558, 37)" leading="" trailing=" " val="+"/>
                                                          <OtherNode start="(558, 38)" end="(558, 52)" kind="Lean.Parser.Term.proj">
                                                            <OtherNode start="(558, 38)" end="(558, 45)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(558, 38)" end="(558, 39)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(558, 39)" end="(558, 44)" kind="«term_::_»">
                                                            <IdentNode start="(558, 39)" end="(558, 40)" leading="" trailing="" raw_val="a" val="a"/>
                                                            <AtomNode start="(558, 40)" end="(558, 42)" leading="" trailing="" val="::"/>
                                                            <IdentNode start="(558, 42)" end="(558, 44)" leading="" trailing="" raw_val="as" val="as"/>
                                                            </OtherNode>
                                                            <AtomNode start="(558, 44)" end="(558, 45)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            <AtomNode start="(558, 45)" end="(558, 46)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(558, 46)" end="(558, 52)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                      <OtherNode start="(558, 53)" end="(558, 73)" kind="Lean.Parser.Term.fromTerm">
                                                        <AtomNode start="(558, 53)" end="(558, 57)" leading="" trailing=" " val="from"/>
                                                        <OtherNode start="(558, 58)" end="(558, 73)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(558, 58)" end="(558, 70)" leading="" trailing=" " raw_val="Nat.succ_add" val="Nat.succ_add" full_name="Nat.succ_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                          <NullNode start="(558, 71)" end="(558, 73)">
                                                            <OtherNode start="(558, 71)" end="(558, 73)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(558, 71)" end="(558, 73)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                  <AtomNode start="(558, 73)" end="(558, 74)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(558, 75)" end="(558, 80)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <IdentNode start="(558, 75)" end="(558, 80)" leading="" trailing="" raw_val="foldr" val="foldr" full_name="List.foldr" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(558, 80)" end="(558, 81)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(558, 82)" end="(558, 87)" kind="Lean.Parser.Tactic.rwRule">
                                                    <NullNode/>
                                                    <OtherNode start="(558, 82)" end="(558, 87)" kind="Lean.Parser.Term.app">
                                                      <IdentNode start="(558, 82)" end="(558, 84)" leading="" trailing=" " raw_val="go" val="go"/>
                                                      <NullNode start="(558, 85)" end="(558, 87)">
                                                        <IdentNode start="(558, 85)" end="(558, 87)" leading="" trailing="" raw_val="as" val="as"/>
                                                      </NullNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(558, 87)" end="(558, 88)" leading="" trailing="&#10;      " val="]"/>
                                              </OtherNode>
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <OtherNode start="(559, 7)" end="(559, 23)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;l : List α&#10;n✝ : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;a : α&#10;as : List α&#10;n : Nat&#10;⊢ f a (n.succ, as.zipIdx n.succ) = (n, (a :: as).zipIdx n)" state_after="no goals" tactic="simp [zipIdx, f]">
                                              <AtomNode start="(559, 7)" end="(559, 11)" leading="" trailing=" " val="simp"/>
                                              <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <NullNode/>
                                              <NullNode start="(559, 12)" end="(559, 23)">
                                                <AtomNode start="(559, 12)" end="(559, 13)" leading="" trailing="" val="["/>
                                                <NullNode start="(559, 13)" end="(559, 22)">
                                                  <OtherNode start="(559, 13)" end="(559, 19)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(559, 13)" end="(559, 19)" leading="" trailing="" raw_val="zipIdx" val="zipIdx" full_name="List.zipIdx" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                  </OtherNode>
                                                  <AtomNode start="(559, 19)" end="(559, 20)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(559, 21)" end="(559, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(559, 21)" end="(559, 22)" leading="" trailing="" raw_val="f" val="f"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(559, 22)" end="(559, 23)" leading="" trailing="&#10;  " val="]"/>
                                              </NullNode>
                                              <NullNode/>
                                            </OtherNode>
                                          </NullNode>
                                        </TacticTacticseq1IndentedNode>
                                      </TacticTacticseqNode>
                                    </TermBytacticNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <OtherNode kind="Lean.Parser.Termination.suffix">
                            <NullNode/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(560, 3)" end="(560, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;⊢ l.zipIdx n = (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (a, x.fst - 1) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" state_after="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;⊢ l.zipIdx n = (foldr (fun a x =&amp;gt; (x.fst - 1, (a, x.fst - 1) :: x.snd)) (n + l.length, []) l.toArray.toList).snd" tactic="rw [← Array.foldr_toList]">
                    <AtomNode start="(560, 3)" end="(560, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(560, 6)" end="(560, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(560, 6)" end="(560, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(560, 7)" end="(560, 27)">
                        <OtherNode start="(560, 7)" end="(560, 27)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(560, 7)" end="(560, 8)">
                            <OtherNode start="(560, 7)" end="(560, 8)" kind="patternIgnore">
                              <OtherNode start="(560, 7)" end="(560, 8)" kind="token.«← »">
                                <AtomNode start="(560, 7)" end="(560, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(560, 9)" end="(560, 27)" leading="" trailing="" raw_val="Array.foldr_toList" val="Array.foldr_toList" full_name="Array.foldr_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(560, 27)" end="(560, 28)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(561, 3)" end="(561, 23)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;l : List α&#10;n : optParam Nat 0&#10;f : α → Nat × List (α × Nat) → Nat × List (α × Nat) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (a, n - 1) :: acc)&#10;⊢ l.zipIdx n = (foldr (fun a x =&amp;gt; (x.fst - 1, (a, x.fst - 1) :: x.snd)) (n + l.length, []) l.toArray.toList).snd" state_after="no goals" tactic="simp +zetaDelta [go]">
                    <AtomNode start="(561, 3)" end="(561, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode start="(561, 8)" end="(561, 18)" kind="Lean.Parser.Tactic.optConfig">
                      <NullNode start="(561, 8)" end="(561, 18)">
                        <OtherNode start="(561, 8)" end="(561, 18)" kind="Lean.Parser.Tactic.configItem">
                          <OtherNode start="(561, 8)" end="(561, 18)" kind="Lean.Parser.Tactic.posConfigItem">
                            <AtomNode start="(561, 8)" end="(561, 9)" leading="" trailing="" val="+"/>
                            <IdentNode start="(561, 9)" end="(561, 18)" leading="" trailing=" " raw_val="zetaDelta" val="zetaDelta"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(561, 19)" end="(561, 23)">
                      <AtomNode start="(561, 19)" end="(561, 20)" leading="" trailing="" val="["/>
                      <NullNode start="(561, 20)" end="(561, 22)">
                        <OtherNode start="(561, 20)" end="(561, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(561, 20)" end="(561, 22)" leading="" trailing="" raw_val="go" val="go"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(561, 22)" end="(561, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(563, 1)" end="(563, 20)" comment="### enumFrom -/">
      <AtomNode start="(563, 1)" end="(563, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(563, 5)" end="(563, 20)" leading="" trailing="&#10;&#10;" val="### enumFrom -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(565, 1)" end="(569, 76)" name="enumFromTR" full_name="List.enumFromTR">
      <CommandDeclmodifiersNode start="(565, 1)" end="(566, 47)">
        <NullNode start="(565, 1)" end="(565, 50)">
          <CommandDoccommentNode start="(565, 1)" end="(565, 50)" comment="Tail recursive version of `List.enumFrom`. -/">
            <AtomNode start="(565, 1)" end="(565, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(565, 5)" end="(565, 50)" leading="" trailing="&#10;" val="Tail recursive version of `List.enumFrom`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode start="(566, 1)" end="(566, 47)">
          <OtherNode start="(566, 1)" end="(566, 47)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(566, 1)" end="(566, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(566, 3)" end="(566, 46)">
              <OtherNode start="(566, 3)" end="(566, 46)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(566, 3)" end="(566, 46)" kind="Lean.deprecated">
                  <AtomNode start="(566, 3)" end="(566, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(566, 14)" end="(566, 22)">
                    <IdentNode start="(566, 14)" end="(566, 22)" leading="" trailing=" " raw_val="zipIdxTR" val="zipIdxTR" full_name="List.zipIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(548, 5)" def_end="(548, 13)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(566, 23)" end="(566, 46)">
                    <AtomNode start="(566, 23)" end="(566, 24)" leading="" trailing="" val="("/>
                    <AtomNode start="(566, 24)" end="(566, 29)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(566, 30)" end="(566, 32)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(566, 33)" end="(566, 45)" kind="str">
                      <AtomNode start="(566, 33)" end="(566, 45)" leading="" trailing="" val="&amp;quot;2025-01-21&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(566, 45)" end="(566, 46)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(566, 46)" end="(566, 47)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(567, 1)" end="(569, 76)" name="enumFromTR">
        <AtomNode start="(567, 1)" end="(567, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(567, 5)" end="(567, 15)">
          <IdentNode start="(567, 5)" end="(567, 15)" leading="" trailing=" " raw_val="enumFromTR" val="enumFromTR"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode start="(567, 16)" end="(567, 55)" kind="Lean.Parser.Command.optDeclSig">
          <NullNode start="(567, 16)" end="(567, 38)">
            <TermExplicitbinderNode start="(567, 16)" end="(567, 25)">
              <AtomNode start="(567, 16)" end="(567, 17)" leading="" trailing="" val="("/>
              <NullNode start="(567, 17)" end="(567, 18)">
                <IdentNode start="(567, 17)" end="(567, 18)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(567, 19)" end="(567, 24)">
                <AtomNode start="(567, 19)" end="(567, 20)" leading="" trailing=" " val=":"/>
                <IdentNode start="(567, 21)" end="(567, 24)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(567, 24)" end="(567, 25)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(567, 26)" end="(567, 38)">
              <AtomNode start="(567, 26)" end="(567, 27)" leading="" trailing="" val="("/>
              <NullNode start="(567, 27)" end="(567, 28)">
                <IdentNode start="(567, 27)" end="(567, 28)" leading="" trailing=" " raw_val="l" val="l"/>
              </NullNode>
              <NullNode start="(567, 29)" end="(567, 37)">
                <AtomNode start="(567, 29)" end="(567, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(567, 31)" end="(567, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(567, 31)" end="(567, 35)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(567, 36)" end="(567, 37)">
                    <IdentNode start="(567, 36)" end="(567, 37)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(567, 37)" end="(567, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <NullNode start="(567, 39)" end="(567, 55)">
            <TermTypespecNode start="(567, 39)" end="(567, 55)">
              <AtomNode start="(567, 39)" end="(567, 40)" leading="" trailing=" " val=":"/>
              <OtherNode start="(567, 41)" end="(567, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(567, 41)" end="(567, 45)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(567, 46)" end="(567, 55)">
                  <OtherNode start="(567, 46)" end="(567, 55)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(567, 46)" end="(567, 47)" leading="" trailing="" val="("/>
                    <OtherNode start="(567, 47)" end="(567, 54)" kind="«term_×_»">
                      <IdentNode start="(567, 47)" end="(567, 50)" leading="" trailing=" " raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(567, 51)" end="(567, 52)" leading="" trailing=" " val="×"/>
                      <IdentNode start="(567, 53)" end="(567, 54)" leading="" trailing="" raw_val="α" val="α"/>
                    </OtherNode>
                    <AtomNode start="(567, 54)" end="(567, 55)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </TermTypespecNode>
          </NullNode>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(567, 56)" end="(569, 76)">
          <AtomNode start="(567, 56)" end="(567, 58)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(568, 3)" end="(569, 76)" kind="Lean.Parser.Term.let">
            <AtomNode start="(568, 3)" end="(568, 6)" leading="" trailing=" " val="let"/>
            <OtherNode start="(568, 7)" end="(568, 22)" kind="Lean.Parser.Term.letDecl">
              <OtherNode start="(568, 7)" end="(568, 22)" kind="Lean.Parser.Term.letIdDecl">
                <IdentNode start="(568, 7)" end="(568, 9)" leading="" trailing=" " raw_val="as" val="as"/>
                <NullNode/>
                <NullNode/>
                <AtomNode start="(568, 10)" end="(568, 12)" leading="" trailing=" " val=":="/>
                <IdentNode start="(568, 13)" end="(568, 22)" leading="" trailing="&#10;  " raw_val="l.toArray" val="l.toArray"/>
              </OtherNode>
            </OtherNode>
            <NullNode/>
            <OtherNode start="(569, 3)" end="(569, 76)" kind="Lean.Parser.Term.proj">
              <OtherNode start="(569, 3)" end="(569, 74)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(569, 3)" end="(569, 4)" leading="" trailing="" val="("/>
                <OtherNode start="(569, 4)" end="(569, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(569, 4)" end="(569, 12)" leading="" trailing=" " raw_val="as.foldr" val="as.foldr"/>
                  <NullNode start="(569, 13)" end="(569, 73)">
                    <OtherNode start="(569, 13)" end="(569, 55)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(569, 13)" end="(569, 14)" leading="" trailing="" val="("/>
                      <OtherNode start="(569, 14)" end="(569, 54)" kind="Lean.Parser.Term.fun">
                        <AtomNode start="(569, 14)" end="(569, 17)" leading="" trailing=" " val="fun"/>
                        <OtherNode start="(569, 18)" end="(569, 54)" kind="Lean.Parser.Term.basicFun">
                          <NullNode start="(569, 18)" end="(569, 28)">
                            <IdentNode start="(569, 18)" end="(569, 19)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(569, 20)" end="(569, 28)" kind="Lean.Parser.Term.tuple">
                              <AtomNode start="(569, 20)" end="(569, 21)" leading="" trailing="" val="("/>
                              <NullNode start="(569, 21)" end="(569, 27)">
                                <IdentNode start="(569, 21)" end="(569, 22)" leading="" trailing="" raw_val="n" val="n"/>
                                <AtomNode start="(569, 22)" end="(569, 23)" leading="" trailing=" " val=","/>
                                <NullNode start="(569, 24)" end="(569, 27)">
                                  <IdentNode start="(569, 24)" end="(569, 27)" leading="" trailing="" raw_val="acc" val="acc"/>
                                </NullNode>
                              </NullNode>
                              <AtomNode start="(569, 27)" end="(569, 28)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(569, 29)" end="(569, 31)" leading="" trailing=" " val="=&amp;gt;"/>
                          <OtherNode start="(569, 32)" end="(569, 54)" kind="Lean.Parser.Term.tuple">
                            <AtomNode start="(569, 32)" end="(569, 33)" leading="" trailing="" val="("/>
                            <NullNode start="(569, 33)" end="(569, 53)">
                              <OtherNode start="(569, 33)" end="(569, 36)" kind="«term_-_»">
                                <IdentNode start="(569, 33)" end="(569, 34)" leading="" trailing="" raw_val="n" val="n"/>
                                <AtomNode start="(569, 34)" end="(569, 35)" leading="" trailing="" val="-"/>
                                <OtherNode start="(569, 35)" end="(569, 36)" kind="num">
                                  <AtomNode start="(569, 35)" end="(569, 36)" leading="" trailing="" val="1"/>
                                </OtherNode>
                              </OtherNode>
                              <AtomNode start="(569, 36)" end="(569, 37)" leading="" trailing=" " val=","/>
                              <NullNode start="(569, 38)" end="(569, 53)">
                                <OtherNode start="(569, 38)" end="(569, 53)" kind="«term_::_»">
                                  <OtherNode start="(569, 38)" end="(569, 46)" kind="Lean.Parser.Term.tuple">
                                    <AtomNode start="(569, 38)" end="(569, 39)" leading="" trailing="" val="("/>
                                    <NullNode start="(569, 39)" end="(569, 45)">
                                      <OtherNode start="(569, 39)" end="(569, 42)" kind="«term_-_»">
                                        <IdentNode start="(569, 39)" end="(569, 40)" leading="" trailing="" raw_val="n" val="n"/>
                                        <AtomNode start="(569, 40)" end="(569, 41)" leading="" trailing="" val="-"/>
                                        <OtherNode start="(569, 41)" end="(569, 42)" kind="num">
                                          <AtomNode start="(569, 41)" end="(569, 42)" leading="" trailing="" val="1"/>
                                        </OtherNode>
                                      </OtherNode>
                                      <AtomNode start="(569, 42)" end="(569, 43)" leading="" trailing=" " val=","/>
                                      <NullNode start="(569, 44)" end="(569, 45)">
                                        <IdentNode start="(569, 44)" end="(569, 45)" leading="" trailing="" raw_val="a" val="a"/>
                                      </NullNode>
                                    </NullNode>
                                    <AtomNode start="(569, 45)" end="(569, 46)" leading="" trailing=" " val=")"/>
                                  </OtherNode>
                                  <AtomNode start="(569, 47)" end="(569, 49)" leading="" trailing=" " val="::"/>
                                  <IdentNode start="(569, 50)" end="(569, 53)" leading="" trailing="" raw_val="acc" val="acc"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(569, 53)" end="(569, 54)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(569, 54)" end="(569, 55)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(569, 56)" end="(569, 73)" kind="Lean.Parser.Term.tuple">
                      <AtomNode start="(569, 56)" end="(569, 57)" leading="" trailing="" val="("/>
                      <NullNode start="(569, 57)" end="(569, 72)">
                        <OtherNode start="(569, 57)" end="(569, 68)" kind="«term_+_»">
                          <IdentNode start="(569, 57)" end="(569, 58)" leading="" trailing=" " raw_val="n" val="n"/>
                          <AtomNode start="(569, 59)" end="(569, 60)" leading="" trailing=" " val="+"/>
                          <IdentNode start="(569, 61)" end="(569, 68)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                        </OtherNode>
                        <AtomNode start="(569, 68)" end="(569, 69)" leading="" trailing=" " val=","/>
                        <NullNode start="(569, 70)" end="(569, 72)">
                          <OtherNode start="(569, 70)" end="(569, 72)" kind="«term[_]»">
                            <AtomNode start="(569, 70)" end="(569, 71)" leading="" trailing="" val="["/>
                            <NullNode/>
                            <AtomNode start="(569, 71)" end="(569, 72)" leading="" trailing="" val="]"/>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(569, 72)" end="(569, 73)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(569, 73)" end="(569, 74)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(569, 74)" end="(569, 75)" leading="" trailing="" val="."/>
              <OtherNode start="(569, 75)" end="(569, 76)" kind="fieldIdx">
                <AtomNode start="(569, 75)" end="(569, 76)" leading="" trailing="&#10;&#10;" val="2"/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <OtherNode start="(571, 1)" end="(582, 23)" kind="Lean.Parser.Command.in">
      <OtherNode start="(571, 1)" end="(571, 35)" kind="Lean.Parser.Command.set_option">
        <AtomNode start="(571, 1)" end="(571, 11)" leading="" trailing=" " val="set_option"/>
        <IdentNode start="(571, 12)" end="(571, 29)" leading="" trailing=" " raw_val="linter.deprecated" val="linter.deprecated"/>
        <NullNode/>
        <AtomNode start="(571, 30)" end="(571, 35)" leading="" trailing=" " val="false"/>
      </OtherNode>
      <AtomNode start="(571, 36)" end="(571, 38)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(572, 1)" end="(582, 23)" name="enumFrom_eq_enumFromTR" full_name="List.enumFrom_eq_enumFromTR">
        <CommandDeclmodifiersNode start="(572, 1)" end="(572, 64)">
          <NullNode/>
          <NullNode start="(572, 1)" end="(572, 64)">
            <OtherNode start="(572, 1)" end="(572, 64)" kind="Lean.Parser.Term.attributes">
              <AtomNode start="(572, 1)" end="(572, 3)" leading="" trailing="" val="@["/>
              <NullNode start="(572, 3)" end="(572, 63)">
                <OtherNode start="(572, 3)" end="(572, 56)" kind="Lean.Parser.Term.attrInstance">
                  <TermAttrkindNode>
                    <NullNode/>
                  </TermAttrkindNode>
                  <OtherNode start="(572, 3)" end="(572, 56)" kind="Lean.deprecated">
                    <AtomNode start="(572, 3)" end="(572, 13)" leading="" trailing=" " val="deprecated"/>
                    <NullNode start="(572, 14)" end="(572, 32)">
                      <IdentNode start="(572, 14)" end="(572, 32)" leading="" trailing=" " raw_val="zipIdx_eq_zipIdxTR" val="zipIdx_eq_zipIdxTR" full_name="List.zipIdx_eq_zipIdxTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(552, 18)" def_end="(552, 36)"/>
                    </NullNode>
                    <NullNode/>
                    <NullNode start="(572, 33)" end="(572, 56)">
                      <AtomNode start="(572, 33)" end="(572, 34)" leading="" trailing="" val="("/>
                      <AtomNode start="(572, 34)" end="(572, 39)" leading="" trailing=" " val="since"/>
                      <AtomNode start="(572, 40)" end="(572, 42)" leading="" trailing=" " val=":="/>
                      <OtherNode start="(572, 43)" end="(572, 55)" kind="str">
                        <AtomNode start="(572, 43)" end="(572, 55)" leading="" trailing="" val="&amp;quot;2025-01-21&amp;quot;"/>
                      </OtherNode>
                      <AtomNode start="(572, 55)" end="(572, 56)" leading="" trailing="" val=")"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(572, 56)" end="(572, 57)" leading="" trailing=" " val=","/>
                <OtherNode start="(572, 58)" end="(572, 63)" kind="Lean.Parser.Term.attrInstance">
                  <TermAttrkindNode>
                    <NullNode/>
                  </TermAttrkindNode>
                  <OtherNode start="(572, 58)" end="(572, 63)" kind="Lean.Parser.Attr.simple">
                    <IdentNode start="(572, 58)" end="(572, 63)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(572, 63)" end="(572, 64)" leading="" trailing="&#10;" val="]"/>
            </OtherNode>
          </NullNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandTheoremNode start="(573, 1)" end="(582, 23)" name="enumFrom_eq_enumFromTR" full_name="List.enumFrom_eq_enumFromTR" _is_private_decl="False">
          <AtomNode start="(573, 1)" end="(573, 8)" leading="" trailing=" " val="theorem"/>
          <CommandDeclidNode start="(573, 9)" end="(573, 31)">
            <IdentNode start="(573, 9)" end="(573, 31)" leading="" trailing=" " raw_val="enumFrom_eq_enumFromTR" val="enumFrom_eq_enumFromTR"/>
            <NullNode/>
          </CommandDeclidNode>
          <CommandDeclsigNode start="(573, 32)" end="(573, 57)">
            <NullNode/>
            <TermTypespecNode start="(573, 32)" end="(573, 57)">
              <AtomNode start="(573, 32)" end="(573, 33)" leading="" trailing=" " val=":"/>
              <OtherNode start="(573, 34)" end="(573, 57)" kind="«term_=_»">
                <OtherNode start="(573, 34)" end="(573, 43)" kind="Lean.Parser.Term.explicit">
                  <AtomNode start="(573, 34)" end="(573, 35)" leading="" trailing="" val="@"/>
                  <IdentNode start="(573, 35)" end="(573, 43)" leading="" trailing=" " raw_val="enumFrom" val="enumFrom" full_name="List.enumFrom" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <AtomNode start="(573, 44)" end="(573, 45)" leading="" trailing=" " val="="/>
                <OtherNode start="(573, 46)" end="(573, 57)" kind="Lean.Parser.Term.explicit">
                  <AtomNode start="(573, 46)" end="(573, 47)" leading="" trailing="" val="@"/>
                  <IdentNode start="(573, 47)" end="(573, 57)" leading="" trailing=" " raw_val="enumFromTR" val="enumFromTR" full_name="List.enumFromTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(567, 5)" def_end="(567, 15)"/>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </CommandDeclsigNode>
          <CommandDeclvalsimpleNode start="(573, 58)" end="(582, 23)">
            <AtomNode start="(573, 58)" end="(573, 60)" leading="" trailing=" " val=":="/>
            <TermBytacticNode start="(573, 61)" end="(582, 23)">
              <AtomNode start="(573, 61)" end="(573, 63)" leading="" trailing="&#10;  " val="by"/>
              <TacticTacticseqNode start="(574, 3)" end="(582, 23)">
                <TacticTacticseq1IndentedNode start="(574, 3)" end="(582, 23)">
                  <NullNode start="(574, 3)" end="(582, 23)">
                    <OtherNode start="(574, 3)" end="(574, 15)" kind="tacticFunext___" state_before="⊢ @enumFrom = @enumFromTR" state_after="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;⊢ enumFrom n l = enumFromTR n l" tactic="funext α n l">
                      <AtomNode start="(574, 3)" end="(574, 9)" leading="" trailing=" " val="funext"/>
                      <NullNode start="(574, 10)" end="(574, 15)">
                        <IdentNode start="(574, 10)" end="(574, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                        <IdentNode start="(574, 12)" end="(574, 13)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(574, 14)" end="(574, 15)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(574, 15)" end="(574, 16)" leading="" trailing=" " val=";"/>
                    <OtherNode start="(574, 17)" end="(574, 53)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;⊢ enumFrom n l = enumFromTR n l" state_after="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;⊢ enumFrom n l =&#10;    (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (x.fst - 1, a) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" tactic="simp only [enumFromTR, size_toArray]">
                      <AtomNode start="(574, 17)" end="(574, 21)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode start="(574, 22)" end="(574, 26)">
                        <AtomNode start="(574, 22)" end="(574, 26)" leading="" trailing=" " val="only"/>
                      </NullNode>
                      <NullNode start="(574, 27)" end="(574, 53)">
                        <AtomNode start="(574, 27)" end="(574, 28)" leading="" trailing="" val="["/>
                        <NullNode start="(574, 28)" end="(574, 52)">
                          <OtherNode start="(574, 28)" end="(574, 38)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(574, 28)" end="(574, 38)" leading="" trailing="" raw_val="enumFromTR" val="enumFromTR" full_name="List.enumFromTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(567, 5)" def_end="(567, 15)"/>
                          </OtherNode>
                          <AtomNode start="(574, 38)" end="(574, 39)" leading="" trailing=" " val=","/>
                          <OtherNode start="(574, 40)" end="(574, 52)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(574, 40)" end="(574, 52)" leading="" trailing="" raw_val="size_toArray" val="size_toArray" full_name="List.size_toArray" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(574, 52)" end="(574, 53)" leading="" trailing="&#10;  " val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(575, 3)" end="(575, 58)" kind="Lean.Parser.Tactic.tacticLet_" state_before="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;⊢ enumFrom n l =&#10;    (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (x.fst - 1, a) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" state_after="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;⊢ enumFrom n l =&#10;    (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (x.fst - 1, a) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" tactic="let f := fun (a : α) (n, acc) =&amp;gt; (n-1, (n-1, a) :: acc)">
                      <AtomNode start="(575, 3)" end="(575, 6)" leading="" trailing=" " val="let"/>
                      <OtherNode start="(575, 7)" end="(575, 58)" kind="Lean.Parser.Term.letDecl">
                        <OtherNode start="(575, 7)" end="(575, 58)" kind="Lean.Parser.Term.letIdDecl">
                          <IdentNode start="(575, 7)" end="(575, 8)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode/>
                          <NullNode/>
                          <AtomNode start="(575, 9)" end="(575, 11)" leading="" trailing=" " val=":="/>
                          <OtherNode start="(575, 12)" end="(575, 58)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(575, 12)" end="(575, 15)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(575, 16)" end="(575, 58)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(575, 16)" end="(575, 32)">
                                <OtherNode start="(575, 16)" end="(575, 23)" kind="Lean.Parser.Term.typeAscription">
                                  <AtomNode start="(575, 16)" end="(575, 17)" leading="" trailing="" val="("/>
                                  <IdentNode start="(575, 17)" end="(575, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                                  <AtomNode start="(575, 19)" end="(575, 20)" leading="" trailing=" " val=":"/>
                                  <NullNode start="(575, 21)" end="(575, 22)">
                                    <IdentNode start="(575, 21)" end="(575, 22)" leading="" trailing="" raw_val="α" val="α"/>
                                  </NullNode>
                                  <AtomNode start="(575, 22)" end="(575, 23)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                                <OtherNode start="(575, 24)" end="(575, 32)" kind="Lean.Parser.Term.tuple">
                                  <AtomNode start="(575, 24)" end="(575, 25)" leading="" trailing="" val="("/>
                                  <NullNode start="(575, 25)" end="(575, 31)">
                                    <IdentNode start="(575, 25)" end="(575, 26)" leading="" trailing="" raw_val="n" val="n"/>
                                    <AtomNode start="(575, 26)" end="(575, 27)" leading="" trailing=" " val=","/>
                                    <NullNode start="(575, 28)" end="(575, 31)">
                                      <IdentNode start="(575, 28)" end="(575, 31)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </NullNode>
                                  </NullNode>
                                  <AtomNode start="(575, 31)" end="(575, 32)" leading="" trailing=" " val=")"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(575, 33)" end="(575, 35)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(575, 36)" end="(575, 58)" kind="Lean.Parser.Term.tuple">
                                <AtomNode start="(575, 36)" end="(575, 37)" leading="" trailing="" val="("/>
                                <NullNode start="(575, 37)" end="(575, 57)">
                                  <OtherNode start="(575, 37)" end="(575, 40)" kind="«term_-_»">
                                    <IdentNode start="(575, 37)" end="(575, 38)" leading="" trailing="" raw_val="n" val="n"/>
                                    <AtomNode start="(575, 38)" end="(575, 39)" leading="" trailing="" val="-"/>
                                    <OtherNode start="(575, 39)" end="(575, 40)" kind="num">
                                      <AtomNode start="(575, 39)" end="(575, 40)" leading="" trailing="" val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <AtomNode start="(575, 40)" end="(575, 41)" leading="" trailing=" " val=","/>
                                  <NullNode start="(575, 42)" end="(575, 57)">
                                    <OtherNode start="(575, 42)" end="(575, 57)" kind="«term_::_»">
                                      <OtherNode start="(575, 42)" end="(575, 50)" kind="Lean.Parser.Term.tuple">
                                        <AtomNode start="(575, 42)" end="(575, 43)" leading="" trailing="" val="("/>
                                        <NullNode start="(575, 43)" end="(575, 49)">
                                          <OtherNode start="(575, 43)" end="(575, 46)" kind="«term_-_»">
                                            <IdentNode start="(575, 43)" end="(575, 44)" leading="" trailing="" raw_val="n" val="n"/>
                                            <AtomNode start="(575, 44)" end="(575, 45)" leading="" trailing="" val="-"/>
                                            <OtherNode start="(575, 45)" end="(575, 46)" kind="num">
                                              <AtomNode start="(575, 45)" end="(575, 46)" leading="" trailing="" val="1"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(575, 46)" end="(575, 47)" leading="" trailing=" " val=","/>
                                          <NullNode start="(575, 48)" end="(575, 49)">
                                            <IdentNode start="(575, 48)" end="(575, 49)" leading="" trailing="" raw_val="a" val="a"/>
                                          </NullNode>
                                        </NullNode>
                                        <AtomNode start="(575, 49)" end="(575, 50)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                      <AtomNode start="(575, 51)" end="(575, 53)" leading="" trailing=" " val="::"/>
                                      <IdentNode start="(575, 54)" end="(575, 57)" leading="" trailing="" raw_val="acc" val="acc"/>
                                    </OtherNode>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(575, 57)" end="(575, 58)" leading="" trailing="&#10;  " val=")"/>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(576, 3)" end="(580, 25)" kind="Lean.Parser.Tactic.letrec">
                      <AtomNode start="(576, 3)" end="(576, 6)" leading="" trailing=" " val="let"/>
                      <AtomNode start="(576, 7)" end="(576, 10)" leading="" trailing=" " val="rec"/>
                      <OtherNode start="(576, 11)" end="(580, 25)" kind="Lean.Parser.Term.letRecDecls">
                        <NullNode start="(576, 11)" end="(580, 25)">
                          <OtherNode start="(576, 11)" end="(580, 25)" kind="Lean.Parser.Term.letRecDecl">
                            <NullNode/>
                            <NullNode/>
                            <OtherNode start="(576, 11)" end="(580, 25)" kind="Lean.Parser.Term.letDecl">
                              <OtherNode start="(576, 11)" end="(580, 25)" kind="Lean.Parser.Term.letEqnsDecl">
                                <IdentNode start="(576, 11)" end="(576, 13)" leading="" trailing=" " raw_val="go" val="go"/>
                                <NullNode/>
                                <NullNode start="(576, 14)" end="(576, 71)">
                                  <TermTypespecNode start="(576, 14)" end="(576, 71)">
                                    <AtomNode start="(576, 14)" end="(576, 15)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(576, 16)" end="(576, 71)" kind="Lean.Parser.Term.forall">
                                      <AtomNode start="(576, 16)" end="(576, 17)" leading="" trailing=" " val="∀"/>
                                      <NullNode start="(576, 18)" end="(576, 21)">
                                        <IdentNode start="(576, 18)" end="(576, 19)" leading="" trailing=" " raw_val="l" val="l"/>
                                        <IdentNode start="(576, 20)" end="(576, 21)" leading="" trailing="" raw_val="n" val="n"/>
                                      </NullNode>
                                      <NullNode/>
                                      <AtomNode start="(576, 21)" end="(576, 22)" leading="" trailing=" " val=","/>
                                      <OtherNode start="(576, 23)" end="(576, 71)" kind="«term_=_»">
                                        <OtherNode start="(576, 23)" end="(576, 51)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(576, 23)" end="(576, 30)" leading="" trailing=" " raw_val="l.foldr" val="l.foldr"/>
                                          <NullNode start="(576, 31)" end="(576, 51)">
                                            <IdentNode start="(576, 31)" end="(576, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                                            <OtherNode start="(576, 33)" end="(576, 51)" kind="Lean.Parser.Term.tuple">
                                              <AtomNode start="(576, 33)" end="(576, 34)" leading="" trailing="" val="("/>
                                              <NullNode start="(576, 34)" end="(576, 50)">
                                                <OtherNode start="(576, 34)" end="(576, 46)" kind="«term_+_»">
                                                  <IdentNode start="(576, 34)" end="(576, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                                                  <AtomNode start="(576, 36)" end="(576, 37)" leading="" trailing=" " val="+"/>
                                                  <IdentNode start="(576, 38)" end="(576, 46)" leading="" trailing="" raw_val="l.length" val="l.length"/>
                                                </OtherNode>
                                                <AtomNode start="(576, 46)" end="(576, 47)" leading="" trailing=" " val=","/>
                                                <NullNode start="(576, 48)" end="(576, 50)">
                                                  <OtherNode start="(576, 48)" end="(576, 50)" kind="«term[_]»">
                                                    <AtomNode start="(576, 48)" end="(576, 49)" leading="" trailing="" val="["/>
                                                    <NullNode/>
                                                    <AtomNode start="(576, 49)" end="(576, 50)" leading="" trailing="" val="]"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </NullNode>
                                              <AtomNode start="(576, 50)" end="(576, 51)" leading="" trailing=" " val=")"/>
                                            </OtherNode>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(576, 52)" end="(576, 53)" leading="" trailing=" " val="="/>
                                        <OtherNode start="(576, 54)" end="(576, 71)" kind="Lean.Parser.Term.tuple">
                                          <AtomNode start="(576, 54)" end="(576, 55)" leading="" trailing="" val="("/>
                                          <NullNode start="(576, 55)" end="(576, 70)">
                                            <IdentNode start="(576, 55)" end="(576, 56)" leading="" trailing="" raw_val="n" val="n"/>
                                            <AtomNode start="(576, 56)" end="(576, 57)" leading="" trailing=" " val=","/>
                                            <NullNode start="(576, 58)" end="(576, 70)">
                                              <OtherNode start="(576, 58)" end="(576, 70)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(576, 58)" end="(576, 66)" leading="" trailing=" " raw_val="enumFrom" val="enumFrom" full_name="List.enumFrom" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                <NullNode start="(576, 67)" end="(576, 70)">
                                                  <IdentNode start="(576, 67)" end="(576, 68)" leading="" trailing=" " raw_val="n" val="n"/>
                                                  <IdentNode start="(576, 69)" end="(576, 70)" leading="" trailing="" raw_val="l" val="l"/>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                          </NullNode>
                                          <AtomNode start="(576, 70)" end="(576, 71)" leading="" trailing="&#10;    " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <OtherNode start="(577, 5)" end="(580, 25)" kind="Lean.Parser.Term.matchAlts">
                                  <NullNode start="(577, 5)" end="(580, 25)">
                                    <OtherNode start="(577, 5)" end="(577, 19)" kind="Lean.Parser.Term.matchAlt">
                                      <AtomNode start="(577, 5)" end="(577, 6)" leading="" trailing=" " val="|"/>
                                      <NullNode start="(577, 7)" end="(577, 12)">
                                        <NullNode start="(577, 7)" end="(577, 12)">
                                          <OtherNode start="(577, 7)" end="(577, 9)" kind="«term[_]»">
                                            <AtomNode start="(577, 7)" end="(577, 8)" leading="" trailing="" val="["/>
                                            <NullNode/>
                                            <AtomNode start="(577, 8)" end="(577, 9)" leading="" trailing="" val="]"/>
                                          </OtherNode>
                                          <AtomNode start="(577, 9)" end="(577, 10)" leading="" trailing=" " val=","/>
                                          <IdentNode start="(577, 11)" end="(577, 12)" leading="" trailing=" " raw_val="n" val="n"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(577, 13)" end="(577, 15)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <IdentNode start="(577, 16)" end="(577, 19)" leading="" trailing="&#10;    " raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    </OtherNode>
                                    <OtherNode start="(578, 5)" end="(580, 25)" kind="Lean.Parser.Term.matchAlt">
                                      <AtomNode start="(578, 5)" end="(578, 6)" leading="" trailing=" " val="|"/>
                                      <NullNode start="(578, 7)" end="(578, 15)">
                                        <NullNode start="(578, 7)" end="(578, 15)">
                                          <OtherNode start="(578, 7)" end="(578, 12)" kind="«term_::_»">
                                            <IdentNode start="(578, 7)" end="(578, 8)" leading="" trailing="" raw_val="a" val="a"/>
                                            <AtomNode start="(578, 8)" end="(578, 10)" leading="" trailing="" val="::"/>
                                            <IdentNode start="(578, 10)" end="(578, 12)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                          <AtomNode start="(578, 12)" end="(578, 13)" leading="" trailing=" " val=","/>
                                          <IdentNode start="(578, 14)" end="(578, 15)" leading="" trailing=" " raw_val="n" val="n"/>
                                        </NullNode>
                                      </NullNode>
                                      <AtomNode start="(578, 16)" end="(578, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                      <TermBytacticNode start="(578, 19)" end="(580, 25)">
                                        <AtomNode start="(578, 19)" end="(578, 21)" leading="" trailing="&#10;      " val="by"/>
                                        <TacticTacticseqNode start="(579, 7)" end="(580, 25)">
                                          <TacticTacticseq1IndentedNode start="(579, 7)" end="(580, 25)">
                                            <NullNode start="(579, 7)" end="(580, 25)">
                                              <OtherNode start="(579, 7)" end="(579, 88)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;n✝ : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;a : α&#10;as : List α&#10;n : Nat&#10;⊢ foldr f (n + (a :: as).length, []) (a :: as) = (n, enumFrom n (a :: as))" state_after="α : Type u_1&#10;n✝ : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;a : α&#10;as : List α&#10;n : Nat&#10;⊢ f a (n.succ, enumFrom n.succ as) = (n, enumFrom n (a :: as))" tactic="rw [← show _ + as.length = n + (a::as).length from Nat.succ_add .., foldr, go as]">
                                                <AtomNode start="(579, 7)" end="(579, 9)" leading="" trailing=" " val="rw"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <OtherNode start="(579, 10)" end="(579, 88)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                                  <AtomNode start="(579, 10)" end="(579, 11)" leading="" trailing="" val="["/>
                                                  <NullNode start="(579, 11)" end="(579, 87)">
                                                    <OtherNode start="(579, 11)" end="(579, 73)" kind="Lean.Parser.Tactic.rwRule">
                                                      <NullNode start="(579, 11)" end="(579, 12)">
                                                        <OtherNode start="(579, 11)" end="(579, 12)" kind="patternIgnore">
                                                          <OtherNode start="(579, 11)" end="(579, 12)" kind="token.«← »">
                                                            <AtomNode start="(579, 11)" end="(579, 12)" leading="" trailing=" " val="←"/>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                      <OtherNode start="(579, 13)" end="(579, 73)" kind="Lean.Parser.Term.show">
                                                        <AtomNode start="(579, 13)" end="(579, 17)" leading="" trailing=" " val="show"/>
                                                        <OtherNode start="(579, 18)" end="(579, 52)" kind="«term_=_»">
                                                          <OtherNode start="(579, 18)" end="(579, 31)" kind="«term_+_»">
                                                            <TermHoleNode start="(579, 18)" end="(579, 19)">
                                                            <AtomNode start="(579, 18)" end="(579, 19)" leading="" trailing=" " val="_"/>
                                                            </TermHoleNode>
                                                            <AtomNode start="(579, 20)" end="(579, 21)" leading="" trailing=" " val="+"/>
                                                            <IdentNode start="(579, 22)" end="(579, 31)" leading="" trailing=" " raw_val="as.length" val="as.length"/>
                                                          </OtherNode>
                                                          <AtomNode start="(579, 32)" end="(579, 33)" leading="" trailing=" " val="="/>
                                                          <OtherNode start="(579, 34)" end="(579, 52)" kind="«term_+_»">
                                                            <IdentNode start="(579, 34)" end="(579, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                                                            <AtomNode start="(579, 36)" end="(579, 37)" leading="" trailing=" " val="+"/>
                                                            <OtherNode start="(579, 38)" end="(579, 52)" kind="Lean.Parser.Term.proj">
                                                            <OtherNode start="(579, 38)" end="(579, 45)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(579, 38)" end="(579, 39)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(579, 39)" end="(579, 44)" kind="«term_::_»">
                                                            <IdentNode start="(579, 39)" end="(579, 40)" leading="" trailing="" raw_val="a" val="a"/>
                                                            <AtomNode start="(579, 40)" end="(579, 42)" leading="" trailing="" val="::"/>
                                                            <IdentNode start="(579, 42)" end="(579, 44)" leading="" trailing="" raw_val="as" val="as"/>
                                                            </OtherNode>
                                                            <AtomNode start="(579, 44)" end="(579, 45)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            <AtomNode start="(579, 45)" end="(579, 46)" leading="" trailing="" val="."/>
                                                            <IdentNode start="(579, 46)" end="(579, 52)" leading="" trailing=" " raw_val="length" val="length" full_name="List.length" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                                            </OtherNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                        <OtherNode start="(579, 53)" end="(579, 73)" kind="Lean.Parser.Term.fromTerm">
                                                          <AtomNode start="(579, 53)" end="(579, 57)" leading="" trailing=" " val="from"/>
                                                          <OtherNode start="(579, 58)" end="(579, 73)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(579, 58)" end="(579, 70)" leading="" trailing=" " raw_val="Nat.succ_add" val="Nat.succ_add" full_name="Nat.succ_add" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                                                            <NullNode start="(579, 71)" end="(579, 73)">
                                                            <OtherNode start="(579, 71)" end="(579, 73)" kind="Lean.Parser.Term.ellipsis">
                                                            <AtomNode start="(579, 71)" end="(579, 73)" leading="" trailing="" val=".."/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </OtherNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                    <AtomNode start="(579, 73)" end="(579, 74)" leading="" trailing=" " val=","/>
                                                    <OtherNode start="(579, 75)" end="(579, 80)" kind="Lean.Parser.Tactic.rwRule">
                                                      <NullNode/>
                                                      <IdentNode start="(579, 75)" end="(579, 80)" leading="" trailing="" raw_val="foldr" val="foldr" full_name="List.foldr" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                    </OtherNode>
                                                    <AtomNode start="(579, 80)" end="(579, 81)" leading="" trailing=" " val=","/>
                                                    <OtherNode start="(579, 82)" end="(579, 87)" kind="Lean.Parser.Tactic.rwRule">
                                                      <NullNode/>
                                                      <OtherNode start="(579, 82)" end="(579, 87)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(579, 82)" end="(579, 84)" leading="" trailing=" " raw_val="go" val="go"/>
                                                        <NullNode start="(579, 85)" end="(579, 87)">
                                                          <IdentNode start="(579, 85)" end="(579, 87)" leading="" trailing="" raw_val="as" val="as"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(579, 87)" end="(579, 88)" leading="" trailing="&#10;      " val="]"/>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <NullNode/>
                                              <OtherNode start="(580, 7)" end="(580, 25)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n✝ : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;a : α&#10;as : List α&#10;n : Nat&#10;⊢ f a (n.succ, enumFrom n.succ as) = (n, enumFrom n (a :: as))" state_after="no goals" tactic="simp [enumFrom, f]">
                                                <AtomNode start="(580, 7)" end="(580, 11)" leading="" trailing=" " val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode start="(580, 12)" end="(580, 25)">
                                                  <AtomNode start="(580, 12)" end="(580, 13)" leading="" trailing="" val="["/>
                                                  <NullNode start="(580, 13)" end="(580, 24)">
                                                    <OtherNode start="(580, 13)" end="(580, 21)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(580, 13)" end="(580, 21)" leading="" trailing="" raw_val="enumFrom" val="enumFrom" full_name="List.enumFrom" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                    </OtherNode>
                                                    <AtomNode start="(580, 21)" end="(580, 22)" leading="" trailing=" " val=","/>
                                                    <OtherNode start="(580, 23)" end="(580, 24)" kind="Lean.Parser.Tactic.simpLemma">
                                                      <NullNode/>
                                                      <NullNode/>
                                                      <IdentNode start="(580, 23)" end="(580, 24)" leading="" trailing="" raw_val="f" val="f"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                  <AtomNode start="(580, 24)" end="(580, 25)" leading="" trailing="&#10;  " val="]"/>
                                                </NullNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </TermBytacticNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <OtherNode kind="Lean.Parser.Termination.suffix">
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(581, 3)" end="(581, 28)" kind="Lean.Parser.Tactic.rwSeq" state_before="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;⊢ enumFrom n l =&#10;    (Array.foldr (fun a x =&amp;gt; (x.fst - 1, (x.fst - 1, a) :: x.snd)) (n + l.length, []) l.toArray l.length).snd" state_after="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;⊢ enumFrom n l = (foldr (fun a x =&amp;gt; (x.fst - 1, (x.fst - 1, a) :: x.snd)) (n + l.length, []) l.toArray.toList).snd" tactic="rw [← Array.foldr_toList]">
                      <AtomNode start="(581, 3)" end="(581, 5)" leading="" trailing=" " val="rw"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <OtherNode start="(581, 6)" end="(581, 28)" kind="Lean.Parser.Tactic.rwRuleSeq">
                        <AtomNode start="(581, 6)" end="(581, 7)" leading="" trailing="" val="["/>
                        <NullNode start="(581, 7)" end="(581, 27)">
                          <OtherNode start="(581, 7)" end="(581, 27)" kind="Lean.Parser.Tactic.rwRule">
                            <NullNode start="(581, 7)" end="(581, 8)">
                              <OtherNode start="(581, 7)" end="(581, 8)" kind="patternIgnore">
                                <OtherNode start="(581, 7)" end="(581, 8)" kind="token.«← »">
                                  <AtomNode start="(581, 7)" end="(581, 8)" leading="" trailing=" " val="←"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <IdentNode start="(581, 9)" end="(581, 27)" leading="" trailing="" raw_val="Array.foldr_toList" val="Array.foldr_toList" full_name="Array.foldr_toList" mod_name="Init.Data.Array.Bootstrap" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Bootstrap.lean"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(581, 27)" end="(581, 28)" leading="" trailing="&#10;  " val="]"/>
                      </OtherNode>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(582, 3)" end="(582, 23)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;n : Nat&#10;l : List α&#10;f : α → Nat × List (Nat × α) → Nat × List (Nat × α) :=&#10;  fun a x =&amp;gt;&#10;    match x with&#10;    | (n, acc) =&amp;gt; (n - 1, (n - 1, a) :: acc)&#10;⊢ enumFrom n l = (foldr (fun a x =&amp;gt; (x.fst - 1, (x.fst - 1, a) :: x.snd)) (n + l.length, []) l.toArray.toList).snd" state_after="no goals" tactic="simp +zetaDelta [go]">
                      <AtomNode start="(582, 3)" end="(582, 7)" leading="" trailing=" " val="simp"/>
                      <OtherNode start="(582, 8)" end="(582, 18)" kind="Lean.Parser.Tactic.optConfig">
                        <NullNode start="(582, 8)" end="(582, 18)">
                          <OtherNode start="(582, 8)" end="(582, 18)" kind="Lean.Parser.Tactic.configItem">
                            <OtherNode start="(582, 8)" end="(582, 18)" kind="Lean.Parser.Tactic.posConfigItem">
                              <AtomNode start="(582, 8)" end="(582, 9)" leading="" trailing="" val="+"/>
                              <IdentNode start="(582, 9)" end="(582, 18)" leading="" trailing=" " raw_val="zetaDelta" val="zetaDelta"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(582, 19)" end="(582, 23)">
                        <AtomNode start="(582, 19)" end="(582, 20)" leading="" trailing="" val="["/>
                        <NullNode start="(582, 20)" end="(582, 22)">
                          <OtherNode start="(582, 20)" end="(582, 22)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(582, 20)" end="(582, 22)" leading="" trailing="" raw_val="go" val="go"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(582, 22)" end="(582, 23)" leading="" trailing="&#10;&#10;" val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </TermBytacticNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </CommandDeclvalsimpleNode>
        </CommandTheoremNode>
      </CommandDeclarationNode>
    </OtherNode>
    <CommandModuledocNode start="(584, 1)" end="(584, 32)" comment="## Other list operations -/">
      <AtomNode start="(584, 1)" end="(584, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(584, 5)" end="(584, 32)" leading="" trailing="&#10;&#10;" val="## Other list operations -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(586, 1)" end="(586, 23)" comment="### intercalate -/">
      <AtomNode start="(586, 1)" end="(586, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(586, 5)" end="(586, 23)" leading="" trailing="&#10;&#10;" val="### intercalate -/"/>
    </CommandModuledocNode>
    <OtherNode start="(588, 1)" end="(609, 51)" kind="Lean.Parser.Command.in">
      <OtherNode start="(588, 1)" end="(588, 38)" kind="Lean.Parser.Command.set_option">
        <AtomNode start="(588, 1)" end="(588, 11)" leading="" trailing=" " val="set_option"/>
        <IdentNode start="(588, 12)" end="(588, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
        <NullNode/>
        <AtomNode start="(588, 33)" end="(588, 38)" leading="" trailing=" " val="false"/>
      </OtherNode>
      <AtomNode start="(588, 39)" end="(588, 41)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(589, 1)" end="(609, 51)" name="intercalateTR" full_name="List.intercalateTR">
        <CommandDeclmodifiersNode start="(589, 1)" end="(599, 3)">
          <NullNode start="(589, 1)" end="(599, 3)">
            <CommandDoccommentNode start="(589, 1)" end="(599, 3)" comment="Alternates the lists in `xs` with the separator `sep`.&#10;&#10;This is a tail-recursive version of `List.intercalate` used at runtime.&#10;&#10;Examples:&#10;* `List.intercalateTR sep [] = []`&#10;* `List.intercalateTR sep [a] = a`&#10;* `List.intercalateTR sep [a, b] = a ++ sep ++ b`&#10;* `List.intercalateTR sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`&#10;-/">
              <AtomNode start="(589, 1)" end="(589, 4)" leading="" trailing="&#10;" val="/--"/>
              <AtomNode start="(590, 1)" end="(599, 3)" leading="" trailing="&#10;" val="Alternates the lists in `xs` with the separator `sep`.&#10;&#10;This is a tail-recursive version of `List.intercalate` used at runtime.&#10;&#10;Examples:&#10;* `List.intercalateTR sep [] = []`&#10;* `List.intercalateTR sep [a] = a`&#10;* `List.intercalateTR sep [a, b] = a ++ sep ++ b`&#10;* `List.intercalateTR sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`&#10;-/"/>
            </CommandDoccommentNode>
          </NullNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandDefinitionNode start="(600, 1)" end="(609, 51)" name="intercalateTR">
          <AtomNode start="(600, 1)" end="(600, 4)" leading="" trailing=" " val="def"/>
          <CommandDeclidNode start="(600, 5)" end="(600, 18)">
            <IdentNode start="(600, 5)" end="(600, 18)" leading="" trailing=" " raw_val="intercalateTR" val="intercalateTR"/>
            <NullNode/>
          </CommandDeclidNode>
          <OtherNode start="(600, 19)" end="(600, 65)" kind="Lean.Parser.Command.optDeclSig">
            <NullNode start="(600, 19)" end="(600, 33)">
              <TermExplicitbinderNode start="(600, 19)" end="(600, 33)">
                <AtomNode start="(600, 19)" end="(600, 20)" leading="" trailing="" val="("/>
                <NullNode start="(600, 20)" end="(600, 23)">
                  <IdentNode start="(600, 20)" end="(600, 23)" leading="" trailing=" " raw_val="sep" val="sep"/>
                </NullNode>
                <NullNode start="(600, 24)" end="(600, 32)">
                  <AtomNode start="(600, 24)" end="(600, 25)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(600, 26)" end="(600, 32)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(600, 26)" end="(600, 30)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(600, 31)" end="(600, 32)">
                      <IdentNode start="(600, 31)" end="(600, 32)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(600, 32)" end="(600, 33)" leading="" trailing=" " val=")"/>
              </TermExplicitbinderNode>
            </NullNode>
            <NullNode start="(600, 34)" end="(600, 65)">
              <TermTypespecNode start="(600, 34)" end="(600, 65)">
                <AtomNode start="(600, 34)" end="(600, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(600, 36)" end="(600, 65)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(600, 36)" end="(600, 56)">
                    <AtomNode start="(600, 36)" end="(600, 37)" leading="" trailing="" val="("/>
                    <NullNode start="(600, 37)" end="(600, 39)">
                      <IdentNode start="(600, 37)" end="(600, 39)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </NullNode>
                    <NullNode start="(600, 40)" end="(600, 55)">
                      <AtomNode start="(600, 40)" end="(600, 41)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(600, 42)" end="(600, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(600, 42)" end="(600, 46)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(600, 47)" end="(600, 55)">
                          <OtherNode start="(600, 47)" end="(600, 55)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(600, 47)" end="(600, 48)" leading="" trailing="" val="("/>
                            <OtherNode start="(600, 48)" end="(600, 54)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(600, 48)" end="(600, 52)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                              <NullNode start="(600, 53)" end="(600, 54)">
                                <IdentNode start="(600, 53)" end="(600, 54)" leading="" trailing="" raw_val="α" val="α"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(600, 54)" end="(600, 55)" leading="" trailing="" val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(600, 55)" end="(600, 56)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(600, 57)" end="(600, 58)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(600, 59)" end="(600, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(600, 59)" end="(600, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(600, 64)" end="(600, 65)">
                      <IdentNode start="(600, 64)" end="(600, 65)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </TermTypespecNode>
            </NullNode>
          </OtherNode>
          <CommandDeclvaleqnsNode start="(601, 3)" end="(609, 51)">
            <OtherNode start="(601, 3)" end="(609, 51)" kind="Lean.Parser.Term.matchAltsWhereDecls">
              <OtherNode start="(601, 3)" end="(603, 37)" kind="Lean.Parser.Term.matchAlts">
                <NullNode start="(601, 3)" end="(603, 37)">
                  <OtherNode start="(601, 3)" end="(601, 13)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(601, 3)" end="(601, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(601, 5)" end="(601, 7)">
                      <NullNode start="(601, 5)" end="(601, 7)">
                        <OtherNode start="(601, 5)" end="(601, 7)" kind="«term[_]»">
                          <AtomNode start="(601, 5)" end="(601, 6)" leading="" trailing="" val="["/>
                          <NullNode/>
                          <AtomNode start="(601, 6)" end="(601, 7)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(601, 8)" end="(601, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(601, 11)" end="(601, 13)" kind="«term[_]»">
                      <AtomNode start="(601, 11)" end="(601, 12)" leading="" trailing="" val="["/>
                      <NullNode/>
                      <AtomNode start="(601, 12)" end="(601, 13)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(602, 3)" end="(602, 13)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(602, 3)" end="(602, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(602, 5)" end="(602, 8)">
                      <NullNode start="(602, 5)" end="(602, 8)">
                        <OtherNode start="(602, 5)" end="(602, 8)" kind="«term[_]»">
                          <AtomNode start="(602, 5)" end="(602, 6)" leading="" trailing="" val="["/>
                          <NullNode start="(602, 6)" end="(602, 7)">
                            <IdentNode start="(602, 6)" end="(602, 7)" leading="" trailing="" raw_val="x" val="x"/>
                          </NullNode>
                          <AtomNode start="(602, 7)" end="(602, 8)" leading="" trailing=" " val="]"/>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(602, 9)" end="(602, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                    <IdentNode start="(602, 12)" end="(602, 13)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                  </OtherNode>
                  <OtherNode start="(603, 3)" end="(603, 37)" kind="Lean.Parser.Term.matchAlt">
                    <AtomNode start="(603, 3)" end="(603, 4)" leading="" trailing=" " val="|"/>
                    <NullNode start="(603, 5)" end="(603, 10)">
                      <NullNode start="(603, 5)" end="(603, 10)">
                        <OtherNode start="(603, 5)" end="(603, 10)" kind="«term_::_»">
                          <IdentNode start="(603, 5)" end="(603, 6)" leading="" trailing="" raw_val="x" val="x"/>
                          <AtomNode start="(603, 6)" end="(603, 8)" leading="" trailing="" val="::"/>
                          <IdentNode start="(603, 8)" end="(603, 10)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </OtherNode>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(603, 11)" end="(603, 13)" leading="" trailing=" " val="=&amp;gt;"/>
                    <OtherNode start="(603, 14)" end="(603, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(603, 14)" end="(603, 16)" leading="" trailing=" " raw_val="go" val="go"/>
                      <NullNode start="(603, 17)" end="(603, 37)">
                        <IdentNode start="(603, 17)" end="(603, 28)" leading="" trailing=" " raw_val="sep.toArray" val="sep.toArray"/>
                        <IdentNode start="(603, 29)" end="(603, 30)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(603, 31)" end="(603, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <OtherNode start="(603, 34)" end="(603, 37)" kind="«term#[_,]»">
                          <AtomNode start="(603, 34)" end="(603, 36)" leading="" trailing="" val="#["/>
                          <NullNode/>
                          <AtomNode start="(603, 36)" end="(603, 37)" leading="" trailing="&#10;" val="]"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode kind="Lean.Parser.Termination.suffix">
                <NullNode/>
                <NullNode/>
              </OtherNode>
              <NullNode start="(604, 1)" end="(609, 51)">
                <OtherNode start="(604, 1)" end="(609, 51)" kind="Lean.Parser.Term.whereDecls">
                  <AtomNode start="(604, 1)" end="(604, 6)" leading="" trailing="&#10;  " val="where"/>
                  <NullNode start="(605, 3)" end="(609, 51)">
                    <OtherNode start="(605, 3)" end="(609, 51)" kind="Lean.Parser.Term.letRecDecl">
                      <NullNode start="(605, 3)" end="(606, 84)">
                        <CommandDoccommentNode start="(605, 3)" end="(606, 84)" comment="Auxiliary for `intercalateTR`:&#10;  `intercalateTR.go sep x xs acc = acc.toList ++ intercalate sep.toList (x::xs)` -/">
                          <AtomNode start="(605, 3)" end="(605, 6)" leading="" trailing=" " val="/--"/>
                          <AtomNode start="(605, 7)" end="(606, 84)" leading="" trailing="&#10;  " val="Auxiliary for `intercalateTR`:&#10;  `intercalateTR.go sep x xs acc = acc.toList ++ intercalate sep.toList (x::xs)` -/"/>
                        </CommandDoccommentNode>
                      </NullNode>
                      <NullNode/>
                      <OtherNode start="(607, 3)" end="(609, 51)" kind="Lean.Parser.Term.letDecl">
                        <OtherNode start="(607, 3)" end="(609, 51)" kind="Lean.Parser.Term.letEqnsDecl">
                          <IdentNode start="(607, 3)" end="(607, 5)" leading="" trailing=" " raw_val="go" val="go"/>
                          <NullNode start="(607, 6)" end="(607, 21)">
                            <TermExplicitbinderNode start="(607, 6)" end="(607, 21)">
                              <AtomNode start="(607, 6)" end="(607, 7)" leading="" trailing="" val="("/>
                              <NullNode start="(607, 7)" end="(607, 10)">
                                <IdentNode start="(607, 7)" end="(607, 10)" leading="" trailing=" " raw_val="sep" val="sep"/>
                              </NullNode>
                              <NullNode start="(607, 11)" end="(607, 20)">
                                <AtomNode start="(607, 11)" end="(607, 12)" leading="" trailing=" " val=":"/>
                                <OtherNode start="(607, 13)" end="(607, 20)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(607, 13)" end="(607, 18)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(607, 19)" end="(607, 20)">
                                    <IdentNode start="(607, 19)" end="(607, 20)" leading="" trailing="" raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(607, 20)" end="(607, 21)" leading="" trailing=" " val=")"/>
                            </TermExplicitbinderNode>
                          </NullNode>
                          <NullNode start="(607, 22)" end="(607, 65)">
                            <TermTypespecNode start="(607, 22)" end="(607, 65)">
                              <AtomNode start="(607, 22)" end="(607, 23)" leading="" trailing=" " val=":"/>
                              <OtherNode start="(607, 24)" end="(607, 65)" kind="Lean.Parser.Term.arrow">
                                <OtherNode start="(607, 24)" end="(607, 30)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(607, 24)" end="(607, 28)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  <NullNode start="(607, 29)" end="(607, 30)">
                                    <IdentNode start="(607, 29)" end="(607, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(607, 31)" end="(607, 32)" leading="" trailing=" " val="→"/>
                                <OtherNode start="(607, 33)" end="(607, 65)" kind="Lean.Parser.Term.arrow">
                                  <OtherNode start="(607, 33)" end="(607, 46)" kind="Lean.Parser.Term.app">
                                    <IdentNode start="(607, 33)" end="(607, 37)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                    <NullNode start="(607, 38)" end="(607, 46)">
                                      <OtherNode start="(607, 38)" end="(607, 46)" kind="Lean.Parser.Term.paren">
                                        <AtomNode start="(607, 38)" end="(607, 39)" leading="" trailing="" val="("/>
                                        <OtherNode start="(607, 39)" end="(607, 45)" kind="Lean.Parser.Term.app">
                                          <IdentNode start="(607, 39)" end="(607, 43)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                          <NullNode start="(607, 44)" end="(607, 45)">
                                            <IdentNode start="(607, 44)" end="(607, 45)" leading="" trailing="" raw_val="α" val="α"/>
                                          </NullNode>
                                        </OtherNode>
                                        <AtomNode start="(607, 45)" end="(607, 46)" leading="" trailing=" " val=")"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <AtomNode start="(607, 47)" end="(607, 48)" leading="" trailing=" " val="→"/>
                                  <OtherNode start="(607, 49)" end="(607, 65)" kind="Lean.Parser.Term.arrow">
                                    <OtherNode start="(607, 49)" end="(607, 56)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(607, 49)" end="(607, 54)" leading="" trailing=" " raw_val="Array" val="Array" full_name="Array" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(607, 55)" end="(607, 56)">
                                        <IdentNode start="(607, 55)" end="(607, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(607, 57)" end="(607, 58)" leading="" trailing=" " val="→"/>
                                    <OtherNode start="(607, 59)" end="(607, 65)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(607, 59)" end="(607, 63)" leading="" trailing=" " raw_val="List" val="List" full_name="List" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                      <NullNode start="(607, 64)" end="(607, 65)">
                                        <IdentNode start="(607, 64)" end="(607, 65)" leading="" trailing="&#10;  " raw_val="α" val="α"/>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                              </OtherNode>
                            </TermTypespecNode>
                          </NullNode>
                          <OtherNode start="(608, 3)" end="(609, 51)" kind="Lean.Parser.Term.matchAlts">
                            <NullNode start="(608, 3)" end="(609, 51)">
                              <OtherNode start="(608, 3)" end="(608, 37)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(608, 3)" end="(608, 4)" leading="" trailing=" " val="|"/>
                                <NullNode start="(608, 5)" end="(608, 15)">
                                  <NullNode start="(608, 5)" end="(608, 15)">
                                    <IdentNode start="(608, 5)" end="(608, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                    <AtomNode start="(608, 6)" end="(608, 7)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(608, 8)" end="(608, 10)" kind="«term[_]»">
                                      <AtomNode start="(608, 8)" end="(608, 9)" leading="" trailing="" val="["/>
                                      <NullNode/>
                                      <AtomNode start="(608, 9)" end="(608, 10)" leading="" trailing="" val="]"/>
                                    </OtherNode>
                                    <AtomNode start="(608, 10)" end="(608, 11)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(608, 12)" end="(608, 15)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(608, 16)" end="(608, 18)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(608, 19)" end="(608, 37)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(608, 19)" end="(608, 35)" leading="" trailing=" " raw_val="acc.toListAppend" val="acc.toListAppend"/>
                                  <NullNode start="(608, 36)" end="(608, 37)">
                                    <IdentNode start="(608, 36)" end="(608, 37)" leading="" trailing="&#10;  " raw_val="x" val="x"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                              <OtherNode start="(609, 3)" end="(609, 51)" kind="Lean.Parser.Term.matchAlt">
                                <AtomNode start="(609, 3)" end="(609, 4)" leading="" trailing=" " val="|"/>
                                <NullNode start="(609, 5)" end="(609, 18)">
                                  <NullNode start="(609, 5)" end="(609, 18)">
                                    <IdentNode start="(609, 5)" end="(609, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                    <AtomNode start="(609, 6)" end="(609, 7)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(609, 8)" end="(609, 13)" kind="«term_::_»">
                                      <IdentNode start="(609, 8)" end="(609, 9)" leading="" trailing="" raw_val="y" val="y"/>
                                      <AtomNode start="(609, 9)" end="(609, 11)" leading="" trailing="" val="::"/>
                                      <IdentNode start="(609, 11)" end="(609, 13)" leading="" trailing="" raw_val="xs" val="xs"/>
                                    </OtherNode>
                                    <AtomNode start="(609, 13)" end="(609, 14)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(609, 15)" end="(609, 18)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                  </NullNode>
                                </NullNode>
                                <AtomNode start="(609, 19)" end="(609, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                                <OtherNode start="(609, 22)" end="(609, 51)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(609, 22)" end="(609, 24)" leading="" trailing=" " raw_val="go" val="go"/>
                                  <NullNode start="(609, 25)" end="(609, 51)">
                                    <IdentNode start="(609, 25)" end="(609, 28)" leading="" trailing=" " raw_val="sep" val="sep"/>
                                    <IdentNode start="(609, 29)" end="(609, 30)" leading="" trailing=" " raw_val="y" val="y"/>
                                    <IdentNode start="(609, 31)" end="(609, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                    <OtherNode start="(609, 34)" end="(609, 51)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(609, 34)" end="(609, 35)" leading="" trailing="" val="("/>
                                      <OtherNode start="(609, 35)" end="(609, 50)" kind="«term_++_»">
                                        <OtherNode start="(609, 35)" end="(609, 43)" kind="«term_++_»">
                                          <IdentNode start="(609, 35)" end="(609, 38)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                          <AtomNode start="(609, 39)" end="(609, 41)" leading="" trailing=" " val="++"/>
                                          <IdentNode start="(609, 42)" end="(609, 43)" leading="" trailing=" " raw_val="x" val="x"/>
                                        </OtherNode>
                                        <AtomNode start="(609, 44)" end="(609, 46)" leading="" trailing=" " val="++"/>
                                        <IdentNode start="(609, 47)" end="(609, 50)" leading="" trailing="" raw_val="sep" val="sep"/>
                                      </OtherNode>
                                      <AtomNode start="(609, 50)" end="(609, 51)" leading="" trailing="&#10;&#10;" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                      <OtherNode kind="Lean.Parser.Termination.suffix">
                        <NullNode/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </CommandDeclvaleqnsNode>
          <NullNode/>
        </CommandDefinitionNode>
      </CommandDeclarationNode>
    </OtherNode>
    <OtherNode start="(611, 1)" end="(622, 27)" kind="Lean.Parser.Command.in">
      <OtherNode start="(611, 1)" end="(611, 38)" kind="Lean.Parser.Command.set_option">
        <AtomNode start="(611, 1)" end="(611, 11)" leading="" trailing=" " val="set_option"/>
        <IdentNode start="(611, 12)" end="(611, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
        <NullNode/>
        <AtomNode start="(611, 33)" end="(611, 38)" leading="" trailing=" " val="false"/>
      </OtherNode>
      <AtomNode start="(611, 39)" end="(611, 41)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(612, 1)" end="(622, 27)" name="intercalate_eq_intercalateTR" full_name="List.intercalate_eq_intercalateTR">
        <CommandDeclmodifiersNode start="(612, 1)" end="(612, 9)">
          <NullNode/>
          <NullNode start="(612, 1)" end="(612, 9)">
            <OtherNode start="(612, 1)" end="(612, 9)" kind="Lean.Parser.Term.attributes">
              <AtomNode start="(612, 1)" end="(612, 3)" leading="" trailing="" val="@["/>
              <NullNode start="(612, 3)" end="(612, 8)">
                <OtherNode start="(612, 3)" end="(612, 8)" kind="Lean.Parser.Term.attrInstance">
                  <TermAttrkindNode>
                    <NullNode/>
                  </TermAttrkindNode>
                  <OtherNode start="(612, 3)" end="(612, 8)" kind="Lean.Parser.Attr.simple">
                    <IdentNode start="(612, 3)" end="(612, 8)" leading="" trailing="" raw_val="csimp" val="csimp"/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(612, 8)" end="(612, 9)" leading="" trailing=" " val="]"/>
            </OtherNode>
          </NullNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandTheoremNode start="(612, 10)" end="(622, 27)" name="intercalate_eq_intercalateTR" full_name="List.intercalate_eq_intercalateTR" _is_private_decl="False">
          <AtomNode start="(612, 10)" end="(612, 17)" leading="" trailing=" " val="theorem"/>
          <CommandDeclidNode start="(612, 18)" end="(612, 46)">
            <IdentNode start="(612, 18)" end="(612, 46)" leading="" trailing=" " raw_val="intercalate_eq_intercalateTR" val="intercalate_eq_intercalateTR"/>
            <NullNode/>
          </CommandDeclidNode>
          <CommandDeclsigNode start="(612, 47)" end="(612, 78)">
            <NullNode/>
            <TermTypespecNode start="(612, 47)" end="(612, 78)">
              <AtomNode start="(612, 47)" end="(612, 48)" leading="" trailing=" " val=":"/>
              <OtherNode start="(612, 49)" end="(612, 78)" kind="«term_=_»">
                <OtherNode start="(612, 49)" end="(612, 61)" kind="Lean.Parser.Term.explicit">
                  <AtomNode start="(612, 49)" end="(612, 50)" leading="" trailing="" val="@"/>
                  <IdentNode start="(612, 50)" end="(612, 61)" leading="" trailing=" " raw_val="intercalate" val="intercalate" full_name="List.intercalate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                </OtherNode>
                <AtomNode start="(612, 62)" end="(612, 63)" leading="" trailing=" " val="="/>
                <OtherNode start="(612, 64)" end="(612, 78)" kind="Lean.Parser.Term.explicit">
                  <AtomNode start="(612, 64)" end="(612, 65)" leading="" trailing="" val="@"/>
                  <IdentNode start="(612, 65)" end="(612, 78)" leading="" trailing=" " raw_val="intercalateTR" val="intercalateTR" full_name="List.intercalateTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(600, 5)" def_end="(600, 18)"/>
                </OtherNode>
              </OtherNode>
            </TermTypespecNode>
          </CommandDeclsigNode>
          <CommandDeclvalsimpleNode start="(612, 79)" end="(622, 27)">
            <AtomNode start="(612, 79)" end="(612, 81)" leading="" trailing=" " val=":="/>
            <TermBytacticNode start="(612, 82)" end="(622, 27)">
              <AtomNode start="(612, 82)" end="(612, 84)" leading="" trailing="&#10;  " val="by"/>
              <TacticTacticseqNode start="(613, 3)" end="(622, 27)">
                <TacticTacticseq1IndentedNode start="(613, 3)" end="(622, 27)">
                  <NullNode start="(613, 3)" end="(622, 27)">
                    <OtherNode start="(613, 3)" end="(613, 17)" kind="tacticFunext___" state_before="⊢ @intercalate = @intercalateTR" state_after="case h.h.h&#10;α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;⊢ sep.intercalate l = sep.intercalateTR l" tactic="funext α sep l">
                      <AtomNode start="(613, 3)" end="(613, 9)" leading="" trailing=" " val="funext"/>
                      <NullNode start="(613, 10)" end="(613, 17)">
                        <IdentNode start="(613, 10)" end="(613, 11)" leading="" trailing=" " raw_val="α" val="α"/>
                        <IdentNode start="(613, 12)" end="(613, 15)" leading="" trailing=" " raw_val="sep" val="sep"/>
                        <IdentNode start="(613, 16)" end="(613, 17)" leading="" trailing="" raw_val="l" val="l"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(613, 17)" end="(613, 18)" leading="" trailing=" " val=";"/>
                    <OtherNode start="(613, 19)" end="(613, 52)" kind="Lean.Parser.Tactic.simp" state_before="case h.h.h&#10;α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;⊢ sep.intercalate l = sep.intercalateTR l" state_after="case h.h.h&#10;α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;⊢ (intersperse sep l).flatten =&#10;    match l with&#10;    | [] =&amp;gt; []&#10;    | [x] =&amp;gt; x&#10;    | x :: xs =&amp;gt; intercalateTR.go sep.toArray x xs #[]" tactic="simp [intercalate, intercalateTR]">
                      <AtomNode start="(613, 19)" end="(613, 23)" leading="" trailing=" " val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(613, 24)" end="(613, 52)">
                        <AtomNode start="(613, 24)" end="(613, 25)" leading="" trailing="" val="["/>
                        <NullNode start="(613, 25)" end="(613, 51)">
                          <OtherNode start="(613, 25)" end="(613, 36)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(613, 25)" end="(613, 36)" leading="" trailing="" raw_val="intercalate" val="intercalate" full_name="List.intercalate" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                          </OtherNode>
                          <AtomNode start="(613, 36)" end="(613, 37)" leading="" trailing=" " val=","/>
                          <OtherNode start="(613, 38)" end="(613, 51)" kind="Lean.Parser.Tactic.simpLemma">
                            <NullNode/>
                            <NullNode/>
                            <IdentNode start="(613, 38)" end="(613, 51)" leading="" trailing="" raw_val="intercalateTR" val="intercalateTR" full_name="List.intercalateTR" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(600, 5)" def_end="(600, 18)"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(613, 51)" end="(613, 52)" leading="" trailing="&#10;  " val="]"/>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(614, 3)" end="(622, 27)" kind="Lean.Parser.Tactic.match" state_before="case h.h.h&#10;α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;⊢ (intersperse sep l).flatten =&#10;    match l with&#10;    | [] =&amp;gt; []&#10;    | [x] =&amp;gt; x&#10;    | x :: xs =&amp;gt; intercalateTR.go sep.toArray x xs #[]" state_after="no goals" tactic="match l with&#10;| [] =&amp;gt; rfl&#10;| [_] =&amp;gt; simp&#10;| x::y::xs =&amp;gt;&#10;  let rec go {acc x} : ∀ xs,&#10;    intercalateTR.go sep.toArray x xs acc = acc.toList ++ flatten (intersperse sep (x::xs))&#10;  | [] =&amp;gt; by simp [intercalateTR.go]&#10;  | _::_ =&amp;gt; by simp [intercalateTR.go, go]&#10;  simp [intersperse, go]">
                      <AtomNode start="(614, 3)" end="(614, 8)" leading="" trailing=" " val="match"/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(614, 9)" end="(614, 10)">
                        <OtherNode start="(614, 9)" end="(614, 10)" kind="Lean.Parser.Term.matchDiscr">
                          <NullNode/>
                          <IdentNode start="(614, 9)" end="(614, 10)" leading="" trailing=" " raw_val="l" val="l"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(614, 11)" end="(614, 15)" leading="" trailing="&#10;  " val="with"/>
                      <OtherNode start="(615, 3)" end="(622, 27)" kind="Lean.Parser.Term.matchAlts">
                        <NullNode start="(615, 3)" end="(622, 27)">
                          <OtherNode start="(615, 3)" end="(615, 14)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(615, 3)" end="(615, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(615, 5)" end="(615, 7)">
                              <NullNode start="(615, 5)" end="(615, 7)">
                                <OtherNode start="(615, 5)" end="(615, 7)" kind="«term[_]»">
                                  <AtomNode start="(615, 5)" end="(615, 6)" leading="" trailing="" val="["/>
                                  <NullNode/>
                                  <AtomNode start="(615, 6)" end="(615, 7)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(615, 8)" end="(615, 10)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(615, 11)" end="(615, 14)">
                              <TacticTacticseq1IndentedNode start="(615, 11)" end="(615, 14)">
                                <NullNode start="(615, 11)" end="(615, 14)">
                                  <OtherNode start="(615, 11)" end="(615, 14)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;⊢ (intersperse sep []).flatten =&#10;    match [] with&#10;    | [] =&amp;gt; []&#10;    | [x] =&amp;gt; x&#10;    | x :: xs =&amp;gt; intercalateTR.go sep.toArray x xs #[]" state_after="no goals" tactic="rfl">
                                    <AtomNode start="(615, 11)" end="(615, 14)" leading="" trailing="&#10;  " val="rfl"/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <OtherNode start="(616, 3)" end="(616, 16)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(616, 3)" end="(616, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(616, 5)" end="(616, 8)">
                              <NullNode start="(616, 5)" end="(616, 8)">
                                <OtherNode start="(616, 5)" end="(616, 8)" kind="«term[_]»">
                                  <AtomNode start="(616, 5)" end="(616, 6)" leading="" trailing="" val="["/>
                                  <NullNode start="(616, 6)" end="(616, 7)">
                                    <TermHoleNode start="(616, 6)" end="(616, 7)">
                                      <AtomNode start="(616, 6)" end="(616, 7)" leading="" trailing="" val="_"/>
                                    </TermHoleNode>
                                  </NullNode>
                                  <AtomNode start="(616, 7)" end="(616, 8)" leading="" trailing=" " val="]"/>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(616, 9)" end="(616, 11)" leading="" trailing=" " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(616, 12)" end="(616, 16)">
                              <TacticTacticseq1IndentedNode start="(616, 12)" end="(616, 16)">
                                <NullNode start="(616, 12)" end="(616, 16)">
                                  <OtherNode start="(616, 12)" end="(616, 16)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;head✝ : List α&#10;⊢ (intersperse sep [head✝]).flatten =&#10;    match [head✝] with&#10;    | [] =&amp;gt; []&#10;    | [x] =&amp;gt; x&#10;    | x :: xs =&amp;gt; intercalateTR.go sep.toArray x xs #[]" state_after="no goals" tactic="simp">
                                    <AtomNode start="(616, 12)" end="(616, 16)" leading="" trailing="&#10;  " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                          <OtherNode start="(617, 3)" end="(622, 27)" kind="Lean.Parser.Term.matchAlt">
                            <AtomNode start="(617, 3)" end="(617, 4)" leading="" trailing=" " val="|"/>
                            <NullNode start="(617, 5)" end="(617, 13)">
                              <NullNode start="(617, 5)" end="(617, 13)">
                                <OtherNode start="(617, 5)" end="(617, 13)" kind="«term_::_»">
                                  <IdentNode start="(617, 5)" end="(617, 6)" leading="" trailing="" raw_val="x" val="x"/>
                                  <AtomNode start="(617, 6)" end="(617, 8)" leading="" trailing="" val="::"/>
                                  <OtherNode start="(617, 8)" end="(617, 13)" kind="«term_::_»">
                                    <IdentNode start="(617, 8)" end="(617, 9)" leading="" trailing="" raw_val="y" val="y"/>
                                    <AtomNode start="(617, 9)" end="(617, 11)" leading="" trailing="" val="::"/>
                                    <IdentNode start="(617, 11)" end="(617, 13)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                  </OtherNode>
                                </OtherNode>
                              </NullNode>
                            </NullNode>
                            <AtomNode start="(617, 14)" end="(617, 16)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                            <TacticTacticseqNode start="(618, 5)" end="(622, 27)">
                              <TacticTacticseq1IndentedNode start="(618, 5)" end="(622, 27)">
                                <NullNode start="(618, 5)" end="(622, 27)">
                                  <OtherNode start="(618, 5)" end="(621, 45)" kind="Lean.Parser.Tactic.letrec">
                                    <AtomNode start="(618, 5)" end="(618, 8)" leading="" trailing=" " val="let"/>
                                    <AtomNode start="(618, 9)" end="(618, 12)" leading="" trailing=" " val="rec"/>
                                    <OtherNode start="(618, 13)" end="(621, 45)" kind="Lean.Parser.Term.letRecDecls">
                                      <NullNode start="(618, 13)" end="(621, 45)">
                                        <OtherNode start="(618, 13)" end="(621, 45)" kind="Lean.Parser.Term.letRecDecl">
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(618, 13)" end="(621, 45)" kind="Lean.Parser.Term.letDecl">
                                            <OtherNode start="(618, 13)" end="(621, 45)" kind="Lean.Parser.Term.letEqnsDecl">
                                              <IdentNode start="(618, 13)" end="(618, 15)" leading="" trailing=" " raw_val="go" val="go"/>
                                              <NullNode start="(618, 16)" end="(618, 23)">
                                                <OtherNode start="(618, 16)" end="(618, 23)" kind="Lean.Parser.Term.implicitBinder">
                                                  <AtomNode start="(618, 16)" end="(618, 17)" leading="" trailing="" val="{"/>
                                                  <NullNode start="(618, 17)" end="(618, 22)">
                                                    <IdentNode start="(618, 17)" end="(618, 20)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                                    <IdentNode start="(618, 21)" end="(618, 22)" leading="" trailing="" raw_val="x" val="x"/>
                                                  </NullNode>
                                                  <NullNode/>
                                                  <AtomNode start="(618, 22)" end="(618, 23)" leading="" trailing=" " val="}"/>
                                                </OtherNode>
                                              </NullNode>
                                              <NullNode start="(618, 24)" end="(619, 94)">
                                                <TermTypespecNode start="(618, 24)" end="(619, 94)">
                                                  <AtomNode start="(618, 24)" end="(618, 25)" leading="" trailing=" " val=":"/>
                                                  <OtherNode start="(618, 26)" end="(619, 94)" kind="Lean.Parser.Term.forall">
                                                    <AtomNode start="(618, 26)" end="(618, 27)" leading="" trailing=" " val="∀"/>
                                                    <NullNode start="(618, 28)" end="(618, 30)">
                                                      <IdentNode start="(618, 28)" end="(618, 30)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                    </NullNode>
                                                    <NullNode/>
                                                    <AtomNode start="(618, 30)" end="(618, 31)" leading="" trailing="&#10;      " val=","/>
                                                    <OtherNode start="(619, 7)" end="(619, 94)" kind="«term_=_»">
                                                      <OtherNode start="(619, 7)" end="(619, 44)" kind="Lean.Parser.Term.app">
                                                        <IdentNode start="(619, 7)" end="(619, 23)" leading="" trailing=" " raw_val="intercalateTR.go" val="intercalateTR.go" full_name="List.intercalateTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(607, 3)" def_end="(607, 5)"/>
                                                        <NullNode start="(619, 24)" end="(619, 44)">
                                                          <IdentNode start="(619, 24)" end="(619, 35)" leading="" trailing=" " raw_val="sep.toArray" val="sep.toArray"/>
                                                          <IdentNode start="(619, 36)" end="(619, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                                                          <IdentNode start="(619, 38)" end="(619, 40)" leading="" trailing=" " raw_val="xs" val="xs"/>
                                                          <IdentNode start="(619, 41)" end="(619, 44)" leading="" trailing=" " raw_val="acc" val="acc"/>
                                                        </NullNode>
                                                      </OtherNode>
                                                      <AtomNode start="(619, 45)" end="(619, 46)" leading="" trailing=" " val="="/>
                                                      <OtherNode start="(619, 47)" end="(619, 94)" kind="«term_++_»">
                                                        <IdentNode start="(619, 47)" end="(619, 57)" leading="" trailing=" " raw_val="acc.toList" val="acc.toList"/>
                                                        <AtomNode start="(619, 58)" end="(619, 60)" leading="" trailing=" " val="++"/>
                                                        <OtherNode start="(619, 61)" end="(619, 94)" kind="Lean.Parser.Term.app">
                                                          <IdentNode start="(619, 61)" end="(619, 68)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="List.flatten" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                          <NullNode start="(619, 69)" end="(619, 94)">
                                                            <OtherNode start="(619, 69)" end="(619, 94)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(619, 69)" end="(619, 70)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(619, 70)" end="(619, 93)" kind="Lean.Parser.Term.app">
                                                            <IdentNode start="(619, 70)" end="(619, 81)" leading="" trailing=" " raw_val="intersperse" val="intersperse" full_name="List.intersperse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                                            <NullNode start="(619, 82)" end="(619, 93)">
                                                            <IdentNode start="(619, 82)" end="(619, 85)" leading="" trailing=" " raw_val="sep" val="sep"/>
                                                            <OtherNode start="(619, 86)" end="(619, 93)" kind="Lean.Parser.Term.paren">
                                                            <AtomNode start="(619, 86)" end="(619, 87)" leading="" trailing="" val="("/>
                                                            <OtherNode start="(619, 87)" end="(619, 92)" kind="«term_::_»">
                                                            <IdentNode start="(619, 87)" end="(619, 88)" leading="" trailing="" raw_val="x" val="x"/>
                                                            <AtomNode start="(619, 88)" end="(619, 90)" leading="" trailing="" val="::"/>
                                                            <IdentNode start="(619, 90)" end="(619, 92)" leading="" trailing="" raw_val="xs" val="xs"/>
                                                            </OtherNode>
                                                            <AtomNode start="(619, 92)" end="(619, 93)" leading="" trailing="" val=")"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            </OtherNode>
                                                            <AtomNode start="(619, 93)" end="(619, 94)" leading="" trailing="&#10;    " val=")"/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </OtherNode>
                                                      </OtherNode>
                                                    </OtherNode>
                                                  </OtherNode>
                                                </TermTypespecNode>
                                              </NullNode>
                                              <OtherNode start="(620, 5)" end="(621, 45)" kind="Lean.Parser.Term.matchAlts">
                                                <NullNode start="(620, 5)" end="(621, 45)">
                                                  <OtherNode start="(620, 5)" end="(620, 39)" kind="Lean.Parser.Term.matchAlt">
                                                    <AtomNode start="(620, 5)" end="(620, 6)" leading="" trailing=" " val="|"/>
                                                    <NullNode start="(620, 7)" end="(620, 9)">
                                                      <NullNode start="(620, 7)" end="(620, 9)">
                                                        <OtherNode start="(620, 7)" end="(620, 9)" kind="«term[_]»">
                                                          <AtomNode start="(620, 7)" end="(620, 8)" leading="" trailing="" val="["/>
                                                          <NullNode/>
                                                          <AtomNode start="(620, 8)" end="(620, 9)" leading="" trailing=" " val="]"/>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </NullNode>
                                                    <AtomNode start="(620, 10)" end="(620, 12)" leading="" trailing=" " val="=&amp;gt;"/>
                                                    <TermBytacticNode start="(620, 13)" end="(620, 39)">
                                                      <AtomNode start="(620, 13)" end="(620, 15)" leading="" trailing=" " val="by"/>
                                                      <TacticTacticseqNode start="(620, 16)" end="(620, 39)">
                                                        <TacticTacticseq1IndentedNode start="(620, 16)" end="(620, 39)">
                                                          <NullNode start="(620, 16)" end="(620, 39)">
                                                            <OtherNode start="(620, 16)" end="(620, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;x✝ y : List α&#10;xs : List (List α)&#10;acc : Array α&#10;x : List α&#10;⊢ intercalateTR.go sep.toArray x [] acc = acc.toList ++ (intersperse sep [x]).flatten" state_after="no goals" tactic="simp [intercalateTR.go]">
                                                            <AtomNode start="(620, 16)" end="(620, 20)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(620, 21)" end="(620, 39)">
                                                            <AtomNode start="(620, 21)" end="(620, 22)" leading="" trailing="" val="["/>
                                                            <NullNode start="(620, 22)" end="(620, 38)">
                                                            <OtherNode start="(620, 22)" end="(620, 38)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(620, 22)" end="(620, 38)" leading="" trailing="" raw_val="intercalateTR.go" val="intercalateTR.go" full_name="List.intercalateTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(607, 3)" def_end="(607, 5)"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(620, 38)" end="(620, 39)" leading="" trailing="&#10;    " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </TermBytacticNode>
                                                  </OtherNode>
                                                  <OtherNode start="(621, 5)" end="(621, 45)" kind="Lean.Parser.Term.matchAlt">
                                                    <AtomNode start="(621, 5)" end="(621, 6)" leading="" trailing=" " val="|"/>
                                                    <NullNode start="(621, 7)" end="(621, 11)">
                                                      <NullNode start="(621, 7)" end="(621, 11)">
                                                        <OtherNode start="(621, 7)" end="(621, 11)" kind="«term_::_»">
                                                          <TermHoleNode start="(621, 7)" end="(621, 8)">
                                                            <AtomNode start="(621, 7)" end="(621, 8)" leading="" trailing="" val="_"/>
                                                          </TermHoleNode>
                                                          <AtomNode start="(621, 8)" end="(621, 10)" leading="" trailing="" val="::"/>
                                                          <TermHoleNode start="(621, 10)" end="(621, 11)">
                                                            <AtomNode start="(621, 10)" end="(621, 11)" leading="" trailing=" " val="_"/>
                                                          </TermHoleNode>
                                                        </OtherNode>
                                                      </NullNode>
                                                    </NullNode>
                                                    <AtomNode start="(621, 12)" end="(621, 14)" leading="" trailing=" " val="=&amp;gt;"/>
                                                    <TermBytacticNode start="(621, 15)" end="(621, 45)">
                                                      <AtomNode start="(621, 15)" end="(621, 17)" leading="" trailing=" " val="by"/>
                                                      <TacticTacticseqNode start="(621, 18)" end="(621, 45)">
                                                        <TacticTacticseq1IndentedNode start="(621, 18)" end="(621, 45)">
                                                          <NullNode start="(621, 18)" end="(621, 45)">
                                                            <OtherNode start="(621, 18)" end="(621, 45)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;x✝ y : List α&#10;xs : List (List α)&#10;acc : Array α&#10;x head✝ : List α&#10;tail✝ : List (List α)&#10;⊢ intercalateTR.go sep.toArray x (head✝ :: tail✝) acc = acc.toList ++ (intersperse sep (x :: head✝ :: tail✝)).flatten" state_after="no goals" tactic="simp [intercalateTR.go, go]">
                                                            <AtomNode start="(621, 18)" end="(621, 22)" leading="" trailing=" " val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode start="(621, 23)" end="(621, 45)">
                                                            <AtomNode start="(621, 23)" end="(621, 24)" leading="" trailing="" val="["/>
                                                            <NullNode start="(621, 24)" end="(621, 44)">
                                                            <OtherNode start="(621, 24)" end="(621, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(621, 24)" end="(621, 40)" leading="" trailing="" raw_val="intercalateTR.go" val="intercalateTR.go" full_name="List.intercalateTR.go" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean" def_start="(607, 3)" def_end="(607, 5)"/>
                                                            </OtherNode>
                                                            <AtomNode start="(621, 40)" end="(621, 41)" leading="" trailing=" " val=","/>
                                                            <OtherNode start="(621, 42)" end="(621, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <IdentNode start="(621, 42)" end="(621, 44)" leading="" trailing="" raw_val="go" val="go"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                            <AtomNode start="(621, 44)" end="(621, 45)" leading="" trailing="&#10;    " val="]"/>
                                                            </NullNode>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </TermBytacticNode>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </OtherNode>
                                          </OtherNode>
                                          <OtherNode kind="Lean.Parser.Termination.suffix">
                                            <NullNode/>
                                            <NullNode/>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                  </OtherNode>
                                  <NullNode/>
                                  <OtherNode start="(622, 5)" end="(622, 27)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;sep : List α&#10;l : List (List α)&#10;x y : List α&#10;xs : List (List α)&#10;⊢ (intersperse sep (x :: y :: xs)).flatten =&#10;    match x :: y :: xs with&#10;    | [] =&amp;gt; []&#10;    | [x] =&amp;gt; x&#10;    | x :: xs =&amp;gt; intercalateTR.go sep.toArray x xs #[]" state_after="no goals" tactic="simp [intersperse, go]">
                                    <AtomNode start="(622, 5)" end="(622, 9)" leading="" trailing=" " val="simp"/>
                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <NullNode/>
                                    <NullNode start="(622, 10)" end="(622, 27)">
                                      <AtomNode start="(622, 10)" end="(622, 11)" leading="" trailing="" val="["/>
                                      <NullNode start="(622, 11)" end="(622, 26)">
                                        <OtherNode start="(622, 11)" end="(622, 22)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(622, 11)" end="(622, 22)" leading="" trailing="" raw_val="intersperse" val="intersperse" full_name="List.intersperse" mod_name="Init.Data.List.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Basic.lean"/>
                                        </OtherNode>
                                        <AtomNode start="(622, 22)" end="(622, 23)" leading="" trailing=" " val=","/>
                                        <OtherNode start="(622, 24)" end="(622, 26)" kind="Lean.Parser.Tactic.simpLemma">
                                          <NullNode/>
                                          <NullNode/>
                                          <IdentNode start="(622, 24)" end="(622, 26)" leading="" trailing="" raw_val="go" val="go"/>
                                        </OtherNode>
                                      </NullNode>
                                      <AtomNode start="(622, 26)" end="(622, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                                    </NullNode>
                                    <NullNode/>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </TermBytacticNode>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </CommandDeclvalsimpleNode>
        </CommandTheoremNode>
      </CommandDeclarationNode>
    </OtherNode>
    <CommandEndNode start="(624, 1)" end="(624, 9)" name="List">
      <AtomNode start="(624, 1)" end="(624, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(624, 5)" end="(624, 9)">
        <IdentNode start="(624, 5)" end="(624, 9)" leading="" trailing="&#10;" raw_val="List" val="List"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(11, 1)" end="(19, 3)" text="## Tail recursive implementations for `List` definitions.&#10;&#10;Many of the proofs require theorems about `Array`,&#10;so these are in a separate file to minimize imports.&#10;&#10;If you import `Init.Data.List.Basic` but do not import this file,&#10;then at runtime you will get non-tail recursive versions of the following definitions.&#10;-/"/>
    <Comment start="(21, 38)" end="(22, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(22, 39)" end="(24, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(26, 1)" end="(49, 3)" text="## Basic `List` operations.&#10;&#10;The following operations are already tail-recursive, and do not need `@[csimp]` replacements:&#10;`get`, `foldl`, `beq`, `isEqv`, `reverse`, `elem` (and hence `contains`), `drop`, `dropWhile`,&#10;`partition`, `isPrefixOf`, `isPrefixOf?`, `find?`, `findSome?`, `lookup`, `any` (and hence `or`),&#10;`all` (and hence `and`) , `range`, `eraseDups`, `eraseReps`, `span`, `splitBy`.&#10;&#10;The following operations are still missing `@[csimp]` replacements:&#10;`concat`, `zipWithAll`.&#10;&#10;The following operations are not recursive to begin with&#10;(or are defined in terms of recursive primitives):&#10;`isEmpty`, `isSuffixOf`, `isSuffixOf?`, `rotateLeft`, `rotateRight`, `insert`, `zip`, `enum`,&#10;`min?`, `max?`, and `removeAll`.&#10;&#10;The following operations were already given `@[csimp]` replacements in `Init/Data/List/Basic.lean`:&#10;`length`, `map`, `filter`, `replicate`, `leftPad`, `unzip`, `range'`, `iota`, `intersperse`.&#10;&#10;The following operations are given `@[csimp]` replacements below:&#10;`set`, `filterMap`, `foldr`, `append`, `bind`, `join`,&#10;`take`, `takeWhile`, `dropLast`, `replace`, `modify`, `insertIdx`, `erase`, `eraseIdx`, `zipWith`,&#10;`enumFrom`, and `intercalate`.&#10;&#10;-/"/>
    <Comment start="(52, 1)" end="(52, 15)" text="### set -/"/>
    <Comment start="(54, 1)" end="(63, 3)" text="Replaces the value at (zero-based) index `n` in `l` with `a`. If the index is out of bounds, then&#10;the list is returned unmodified.&#10;&#10;This is a tail-recursive version of `List.set` that's used at runtime.&#10;&#10;Examples:&#10;* `[&quot;water&quot;, &quot;coffee&quot;, &quot;soda&quot;, &quot;juice&quot;].set 1 &quot;tea&quot; = [&quot;water&quot;, &quot;tea&quot;, &quot;soda&quot;, &quot;juice&quot;]`&#10;* `[&quot;water&quot;, &quot;coffee&quot;, &quot;soda&quot;, &quot;juice&quot;].set 4 &quot;tea&quot; = [&quot;water&quot;, &quot;coffee&quot;, &quot;soda&quot;, &quot;juice&quot;]`&#10;-/"/>
    <Comment start="(65, 3)" end="(66, 56)" text="Auxiliary for `setTR`: `setTR.go l a xs n acc = acc.toList ++ set xs a`,&#10;  unless `n ≥ l.length` in which case it returns `l` -/"/>
    <Comment start="(81, 1)" end="(81, 21)" text="### filterMap -/"/>
    <Comment start="(84, 1)" end="(98, 3)" text="Applies a function that returns an `Option` to each element of a list, collecting the non-`none`&#10;values.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.filterMap`, used at runtime.&#10;&#10;Example:&#10;```lean example&#10;#eval [1, 2, 5, 2, 7, 7].filterMapTR fun x =&gt;&#10;  if x &gt; 2 then some (2 * x) else none&#10;```&#10;```output&#10;[10, 14, 14]&#10;```&#10;-/"/>
    <Comment start="(100, 3)" end="(100, 85)" text="Auxiliary for `filterMap`: `filterMap.go f l = acc.toList ++ filterMap f l` -/"/>
    <Comment start="(117, 1)" end="(117, 17)" text="### foldr -/"/>
    <Comment start="(119, 1)" end="(129, 3)" text="Folds a function over a list from the right, accumulating a value starting with `init`. The&#10;accumulated value is combined with the each element of the list in reverse order, using `f`.&#10;&#10;`O(|l|)`. This is the tail-recursive replacement for `List.foldr` in runtime code.&#10;&#10;Examples:&#10; * `[a, b, c].foldrTR f init  = f a (f b (f c init))`&#10; * `[1, 2, 3].foldrTR (toString · ++ ·) &quot;&quot; = &quot;123&quot;`&#10; * `[1, 2, 3].foldrTR (s!&quot;({·} {·})&quot;) &quot;!&quot; = &quot;(1 (2 (3 !)))&quot;`&#10;-/"/>
    <Comment start="(135, 1)" end="(135, 20)" text="### flatMap  -/"/>
    <Comment start="(137, 1)" end="(146, 3)" text="Applies a function that returns a list to each element of a list, and concatenates the resulting&#10;lists.&#10;&#10;This is the tail-recursive version of `List.flatMap` that's used at runtime.&#10;&#10;Examples:&#10;* `[2, 3, 2].flatMapTR List.range = [0, 1, 0, 1, 2, 0, 1]`&#10;* `[&quot;red&quot;, &quot;blue&quot;].flatMapTR String.toList = ['r', 'e', 'd', 'b', 'l', 'u', 'e']`&#10;-/"/>
    <Comment start="(148, 3)" end="(148, 78)" text="Auxiliary for `flatMap`: `flatMap.go f as = acc.toList ++ bind f as` -/"/>
    <Comment start="(160, 1)" end="(160, 19)" text="### flatten -/"/>
    <Comment start="(162, 1)" end="(170, 3)" text="Concatenates a list of lists into a single list, preserving the order of the elements.&#10;&#10;`O(|flatten L|)`. This is a tail-recursive version of `List.flatten`, used in runtime code.&#10;&#10;Examples:&#10;* `[[&quot;a&quot;], [&quot;b&quot;, &quot;c&quot;]].flattenTR = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]`&#10;* `[[&quot;a&quot;], [], [&quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]].flattenTR = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]`&#10;-/"/>
    <Comment start="(176, 1)" end="(176, 19)" text="## Sublists -/"/>
    <Comment start="(178, 1)" end="(178, 16)" text="### take -/"/>
    <Comment start="(180, 1)" end="(189, 3)" text="Extracts the first `n` elements of `xs`, or the whole list if `n` is greater than `xs.length`.&#10;&#10;`O(min n |xs|)`. This is a tail-recursive version of `List.take`, used at runtime.&#10;&#10;Examples:&#10;* `[a, b, c, d, e].takeTR 0 = []`&#10;* `[a, b, c, d, e].takeTR 3 = [a, b, c]`&#10;* `[a, b, c, d, e].takeTR 6 = [a, b, c, d, e]`&#10;-/"/>
    <Comment start="(191, 3)" end="(192, 58)" text="Auxiliary for `take`: `take.go l xs n acc = acc.toList ++ take n xs`,&#10;  unless `n ≥ xs.length` in which case it returns `l`. -/"/>
    <Comment start="(209, 1)" end="(209, 21)" text="### takeWhile -/"/>
    <Comment start="(212, 1)" end="(221, 3)" text="Returns the longest initial segment of `xs` for which `p` returns true.&#10;&#10;`O(|xs|)`. This is a tail-recursive version of `List.take`, used at runtime.&#10;&#10;Examples:&#10;* `[7, 6, 4, 8].takeWhileTR (· &gt; 5) = [7, 6]`&#10;* `[7, 6, 6, 5].takeWhileTR (· &gt; 5) = [7, 6, 6]`&#10;* `[7, 6, 6, 8].takeWhileTR (· &gt; 5) = [7, 6, 6, 8]`&#10;-/"/>
    <Comment start="(223, 3)" end="(224, 85)" text="Auxiliary for `takeWhile`: `takeWhile.go p l xs acc = acc.toList ++ takeWhile p xs`,&#10;  unless no element satisfying `p` is found in `xs` in which case it returns `l`. -/"/>
    <Comment start="(242, 1)" end="(242, 20)" text="### dropLast -/"/>
    <Comment start="(244, 1)" end="(253, 3)" text="Removes the last element of the list, if one exists.&#10;&#10;This is a tail-recursive version of `List.dropLast`, used at runtime.&#10;&#10;Examples:&#10;* `[].dropLastTR = []`&#10;* `[&quot;tea&quot;].dropLastTR = []`&#10;* `[&quot;tea&quot;, &quot;coffee&quot;, &quot;juice&quot;].dropLastTR = [&quot;tea&quot;, &quot;coffee&quot;]`&#10;-/"/>
    <Comment start="(259, 1)" end="(259, 27)" text="## Finding elements -/"/>
    <Comment start="(261, 1)" end="(261, 82)" text="Tail recursive implementation of `findRev?`. This is only used at runtime. -/"/>
    <Comment start="(287, 1)" end="(287, 86)" text="Tail recursive implementation of `finSomedRev?`. This is only used at runtime. -/"/>
    <Comment start="(315, 1)" end="(315, 32)" text="## Manipulating elements -/"/>
    <Comment start="(317, 1)" end="(317, 19)" text="### replace -/"/>
    <Comment start="(319, 1)" end="(328, 3)" text="Replaces the first element of the list `l` that is equal to `a` with `b`. If no element is equal to&#10;`a`, then the list is returned unchanged.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.replace` that's used in runtime code.&#10;&#10;Examples:&#10;* `[1, 4, 2, 3, 3, 7].replaceTR 3 6 = [1, 4, 2, 6, 3, 7]`&#10;* `[1, 4, 2, 3, 3, 7].replaceTR 5 6 = [1, 4, 2, 3, 3, 7]`&#10;-/"/>
    <Comment start="(330, 3)" end="(331, 67)" text="Auxiliary for `replace`: `replace.go l b c xs acc = acc.toList ++ replace xs b c`,&#10;  unless `b` is not found in `xs` in which case it returns `l`. -/"/>
    <Comment start="(349, 1)" end="(349, 18)" text="### modify -/"/>
    <Comment start="(351, 1)" end="(360, 3)" text="Replaces the element at the given index, if it exists, with the result of applying `f` to it.&#10;&#10;This is a tail-recursive version of `List.modify`.&#10;&#10;Examples:&#10; * `[1, 2, 3].modifyTR 0 (· * 10) = [10, 2, 3]`&#10; * `[1, 2, 3].modifyTR 2 (· * 10) = [1, 2, 30]`&#10; * `[1, 2, 3].modifyTR 3 (· * 10) = [1, 2, 3]`&#10;-/"/>
    <Comment start="(362, 3)" end="(362, 89)" text="Auxiliary for `modifyTR`: `modifyTR.go f l i acc = acc.toList ++ modify f i l`. -/"/>
    <Comment start="(376, 1)" end="(376, 21)" text="### insertIdx -/"/>
    <Comment start="(378, 1)" end="(392, 3)" text="Inserts an element into a list at the specified index. If the index is greater than the length of&#10;the list, then the list is returned unmodified.&#10;&#10;In other words, the new element is inserted into the list `l` after the first `i` elements of `l`.&#10;&#10;This is a tail-recursive version of `List.insertIdx`, used at runtime.&#10;&#10;Examples:&#10; * `[&quot;tues&quot;, &quot;thur&quot;, &quot;sat&quot;].insertIdxTR 1 &quot;wed&quot; = [&quot;tues&quot;, &quot;wed&quot;, &quot;thur&quot;, &quot;sat&quot;]`&#10; * `[&quot;tues&quot;, &quot;thur&quot;, &quot;sat&quot;].insertIdxTR 2 &quot;wed&quot; = [&quot;tues&quot;, &quot;thur&quot;, &quot;wed&quot;, &quot;sat&quot;]`&#10; * `[&quot;tues&quot;, &quot;thur&quot;, &quot;sat&quot;].insertIdxTR 3 &quot;wed&quot; = [&quot;tues&quot;, &quot;thur&quot;, &quot;sat&quot;, &quot;wed&quot;]`&#10; * `[&quot;tues&quot;, &quot;thur&quot;, &quot;sat&quot;].insertIdxTR 4 &quot;wed&quot; = [&quot;tues&quot;, &quot;thur&quot;, &quot;sat&quot;]`&#10;&#10;-/"/>
    <Comment start="(394, 3)" end="(394, 98)" text="Auxiliary for `insertIdxTR`: `insertIdxTR.go a n l acc = acc.toList ++ insertIdx n a l`. -/"/>
    <Comment start="(407, 1)" end="(407, 17)" text="### erase -/"/>
    <Comment start="(409, 1)" end="(420, 3)" text="Removes the first occurrence of `a` from `l`. If `a` does not occur in `l`, the list is returned&#10;unmodified.&#10;&#10;`O(|l|)`.&#10;&#10;This is a tail-recursive version of `List.erase`, used in runtime code.&#10;&#10;Examples:&#10;* `[1, 5, 3, 2, 5].eraseTR 5 = [1, 3, 2, 5]`&#10;* `[1, 5, 3, 2, 5].eraseTR 6 = [1, 5, 3, 2, 5]`&#10;-/"/>
    <Comment start="(422, 3)" end="(423, 60)" text="Auxiliary for `eraseTR`: `eraseTR.go l a xs acc = acc.toList ++ erase xs a`,&#10;  unless `a` is not present in which case it returns `l` -/"/>
    <Comment start="(440, 1)" end="(450, 3)" text="Removes the first element of a list for which `p` returns `true`. If no element satisfies `p`, then&#10;the list is returned unchanged.&#10;&#10;This is a tail-recursive version of `eraseP`, used at runtime.&#10;&#10;Examples:&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &lt; 2) = [2, 2, 1, 3, 4]`&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &gt; 2) = [2, 1, 2, 1, 4]`&#10;  * `[2, 1, 2, 1, 3, 4].erasePTR (· &gt; 8) = [2, 1, 2, 1, 3, 4]`&#10;-/"/>
    <Comment start="(452, 3)" end="(453, 85)" text="Auxiliary for `erasePTR`: `erasePTR.go p l xs acc = acc.toList ++ eraseP p xs`,&#10;  unless `xs` does not contain any elements satisfying `p`, where it returns `l`. -/"/>
    <Comment start="(468, 1)" end="(468, 20)" text="### eraseIdx -/"/>
    <Comment start="(471, 1)" end="(483, 3)" text="Removes the element at the specified index. If the index is out of bounds, the list is returned&#10;unmodified.&#10;&#10;`O(i)`.&#10;&#10;This is a tail-recursive version of `List.eraseIdx`, used at runtime.&#10;&#10;Examples:&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 0 = [1, 2, 3, 4]`&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 1 = [0, 2, 3, 4]`&#10;* `[0, 1, 2, 3, 4].eraseIdxTR 5 = [0, 1, 2, 3, 4]`&#10;-/"/>
    <Comment start="(485, 3)" end="(486, 60)" text="Auxiliary for `eraseIdxTR`: `eraseIdxTR.go l n xs acc = acc.toList ++ eraseIdx xs a`,&#10;  unless `a` is not present in which case it returns `l` -/"/>
    <Comment start="(505, 1)" end="(505, 18)" text="## Zippers -/"/>
    <Comment start="(507, 1)" end="(507, 19)" text="### zipWith -/"/>
    <Comment start="(509, 1)" end="(520, 3)" text="Applies a function to the corresponding elements of two lists, stopping at the end of the shorter&#10;list.&#10;&#10;`O(min |xs| |ys|)`. This is a tail-recursive version of `List.zipWith` that's used at runtime.&#10;&#10;Examples:&#10;* `[1, 2].zipWithTR (· + ·) [5, 6] = [6, 8]`&#10;* `[1, 2, 3].zipWithTR (· + ·) [5, 6, 10] = [6, 8, 13]`&#10;* `[].zipWithTR (· + ·) [5, 6] = []`&#10;* `[x₁, x₂, x₃].zipWithTR f [y₁, y₂, y₃, y₄] = [f x₁ y₁, f x₂ y₂, f x₃ y₃]`&#10;-/"/>
    <Comment start="(522, 3)" end="(522, 91)" text="Auxiliary for `zipWith`: `zipWith.go f as bs acc = acc.toList ++ zipWith f as bs` -/"/>
    <Comment start="(534, 1)" end="(534, 33)" text="## Ranges and enumeration -/"/>
    <Comment start="(536, 1)" end="(536, 18)" text="### zipIdx -/"/>
    <Comment start="(539, 1)" end="(547, 3)" text="Pairs each element of a list with its index, optionally starting from an index other than `0`.&#10;&#10;`O(|l|)`. This is a tail-recursive version of `List.zipIdx` that's used at runtime.&#10;&#10;Examples:&#10;* `[a, b, c].zipIdxTR = [(a, 0), (b, 1), (c, 2)]`&#10;* `[a, b, c].zipIdxTR 5 = [(a, 5), (b, 6), (c, 7)]`&#10;-/"/>
    <Comment start="(563, 1)" end="(563, 20)" text="### enumFrom -/"/>
    <Comment start="(565, 1)" end="(565, 50)" text="Tail recursive version of `List.enumFrom`. -/"/>
    <Comment start="(584, 1)" end="(584, 32)" text="## Other list operations -/"/>
    <Comment start="(586, 1)" end="(586, 23)" text="### intercalate -/"/>
    <Comment start="(589, 1)" end="(599, 3)" text="Alternates the lists in `xs` with the separator `sep`.&#10;&#10;This is a tail-recursive version of `List.intercalate` used at runtime.&#10;&#10;Examples:&#10;* `List.intercalateTR sep [] = []`&#10;* `List.intercalateTR sep [a] = a`&#10;* `List.intercalateTR sep [a, b] = a ++ sep ++ b`&#10;* `List.intercalateTR sep [a, b, c] = a ++ sep ++ b ++ sep ++ c`&#10;-/"/>
    <Comment start="(605, 3)" end="(606, 84)" text="Auxiliary for `intercalateTR`:&#10;  `intercalateTR.go sep x xs acc = acc.toList ++ intercalate sep.toList (x::xs)` -/"/>
  </Comments>
</TracedFile>
